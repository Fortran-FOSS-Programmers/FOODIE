var tipuesearch = {"pages":[{"text":"FoXy FoXy FoXy, Fortran XML parser for poor people A KISS pure Fortran Library for parsing XML files FoXy is a pure Fortran (KISS) library for modern Fortran projects; FoXy is Fortran 2008+ standard compliant; FoXy is OOP designed; FoXy is a Free, Open Source Project. Compiler Support What is FoXy? | Aims | Status | Documentation | Copyrights What is FoXy? Modern Fortran standards (2003+) have introduced support for a more\nModern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, FoXy is aimed to provide an easy to use module library for parsing (and generating) XML files. Aims Other programming languages have many libraries for XML parsing, Fortran has less options, but some there are: xml-fortran of Arjen Markus; xml-f90 of Alberto Garcia; fox of Andrew Walker; tixi from DLR Simulation and Software Technology. All of the above are great codes, but lack in some points that I would like to have: actively maintained; designed for modern Fortran: OOP designed; exploiting new features of Fortran (e.g. deferred length allocatable characters); recreate a pure Fortran representation of the XML data (e.g. tree structure exploiting); parallel architectures supported (threads/processes safety ensured); extensively tested (strong unit-test regression); comprehensively documented; pure Fortran: no wrapper; no bindings, no ISO_C_BINDING ; be FOSS. In some sense or other, the afore-mentioned Fortran libraries miss somethings. Go to Top Status Done lint baseline code: purge doxygen, format docstrings for FORD; adopt best practice of Rouson ; clean the API: two modules, one main XML file object; parse input string: autoparse tags: autoparse tag's name; autoparse tag's value; autoparse tag's attributes names; autoparse tag's attributes values; lazy find tag value into file (once provided a tag name); parse input file; fix bug on tag's attributes name parsing. Doing implement lazy find tag value attribute into file (once provided a tag name and attribute name). Todo create team of collaborators; profile the parser: almost surely there are performance penalties; Go to Top Documentation Besides this README file the FoXy documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Copyrights FoXy is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FoXy is welcome, feel free to select the license that best matches your soul! Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"","loc":"index.html","title":" FoXy "},{"text":"BeFoR64, Base64 encoding/decoding library for FoRtran poor people. Source Code !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. module befor64 !----------------------------------------------------------------------------------------------------------------------------------- !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. !<{!README-BeFoR64.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. use befor64_pack_data_m ! Library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: is_b64_initialized , b64_init public :: b64_encode , b64_encode_up public :: b64_decode , b64_decode_up public :: pack_data public :: autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_b64_initialized = . false . !< Flag for checking the initialization of the library. character ( 64 ) :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" !< Base64 alphabet. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface b64_encode !< Encode numbers (integer and real) to base64. !< !< This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both !< scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_encode_R16 , b64_encode_R16_a , & #endif b64_encode_R8 , b64_encode_R8_a , & b64_encode_R4 , b64_encode_R4_a , & b64_encode_I8 , b64_encode_I8_a , & b64_encode_I4 , b64_encode_I4_a , & b64_encode_I2 , b64_encode_I2_a , & b64_encode_I1 , b64_encode_I1_a , & b64_encode_string , b64_encode_string_a endinterface interface b64_encode_up !< Encode unlimited polymorphic variable to base64. !< !< This is an interface for encoding both scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_encode_up , b64_encode_up_a endinterface interface b64_decode !< Decode numbers (integer and real) from base64. !< !< This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both !< scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode(code='AAAAAAAA8D8=',n=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_decode_R16 , b64_decode_R16_a , & #endif b64_decode_R8 , b64_decode_R8_a , & b64_decode_R4 , b64_decode_R4_a , & b64_decode_I8 , b64_decode_I8_a , & b64_decode_I4 , b64_decode_I4_a , & b64_decode_I2 , b64_decode_I2_a , & b64_decode_I1 , b64_decode_I1_a , & b64_decode_string , b64_decode_string_a endinterface interface b64_decode_up !< Decode unlimited polymorphic variable from base64. !< !< This is an interface for decoding both scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode_up(code='AAAAAAAA8D8=',up=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',up=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_decode_up , b64_decode_up_a endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16 pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8 pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4 pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8 pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4 pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2 pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1 pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16 elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8 elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4 elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8 elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4 elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2 elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1 elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest endmodule befor64","tags":"","loc":"sourcefile/befor64.f90.html","title":"befor64.F90  FoXy"},{"text":"KISS library for packing heterogeneous data into single (homogeneous) packed one. Source Code !< KISS library for packing heterogeneous data into single (homogeneous) packed one. module befor64_pack_data_m !----------------------------------------------------------------------------------------------------------------------------------- !< KISS library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: pack_data !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface pack_data !< Pack different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```fortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```fortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4 pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2 endmodule befor64_pack_data_m","tags":"","loc":"sourcefile/befor64_pack_data_m.f90.html","title":"befor64_pack_data_m.F90  FoXy"},{"text":"FoXy, Fortran XML parser for poor people Source Code !< FoXy, Fortran XML parser for poor people module foxy !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy, Fortran XML parser for poor people !----------------------------------------------------------------------------------------------------------------------------------- use foxy_xml_file , only : xml_file use foxy_xml_tag , only : xml_tag use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: I1P , I2P , I4P , I8P , R4P , R8P public :: xml_file , xml_tag !----------------------------------------------------------------------------------------------------------------------------------- endmodule foxy","tags":"","loc":"sourcefile/foxy.f90.html","title":"foxy.f90  FoXy"},{"text":"FoXy XML file class. Source Code !< FoXy XML file class. module foxy_xml_file !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy XML file class. !----------------------------------------------------------------------------------------------------------------------------------- use foxy_xml_tag use penf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , public :: xml_file !< XML file class. private integer ( I4P ) :: Nt = 0 !< Number of XML tags. type ( xml_tag ), allocatable :: tag (:) !< XML tags array. contains ! public methods procedure :: free !< Free dynamic memory. final :: finalize !< Free dynamic memory when finalizing. procedure :: parse !< Parse xml data from string or file. procedure :: tag_value !< Return tag value of tag named *tag_name*. procedure :: stringify !< Convert the whole file data into a string. ! private methods procedure , private :: add_tag !< Add tag to self%tag array. procedure , private :: parse_from_string !< Parse xml data from string. endtype xml_file !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % tag )) then call self % tag % free deallocate ( self % tag ) self % Nt = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free subroutine finalize ( file ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( xml_file ), intent ( INOUT ) :: file !< XML file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call file % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize subroutine parse ( self , string , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse xml data from string or file. !< !< @note Self data are free before trying to parse new xml data: all previously parsed data are lost. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), optional , intent ( in ) :: string !< String containing xml data. character ( * ), optional , intent ( in ) :: filename !< File name containing xml data. character ( len = :), allocatable :: source !< String containing xml data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free if ( present ( string )) then call self % parse_from_string ( source_string = string ) elseif ( present ( filename )) then source = load_file_as_stream ( filename = filename , fast_read = . true .) call self % parse_from_string ( source_string = source ) endif return !--------------------------------------------------------------------------------------------------------------------------------- contains endsubroutine parse pure subroutine tag_value ( self , tag_name , tag_val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return tag value of tag named *tag_name*. !< !< @note If there is no value, the *tag_value* string is returned deallocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( in ) :: self !< XML file. character ( * ), intent ( in ) :: tag_name !< Tag name. character ( len = :), allocatable , intent ( inout ) :: tag_val !< Tag value. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( tag_val )) deallocate ( tag_val ) if ( self % Nt > 0 ) then do t = 1 , self % Nt call self % tag ( t )% tag_value ( tag_name = tag_name , tag_val = tag_val ) if ( allocated ( tag_val )) exit enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tag_value pure function stringify ( self ) result ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the whole file data into a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( in ) :: self !< XML file. character ( len = :), allocatable :: string !< Output string containing the whole xml file. character ( len = :), allocatable :: tag_string !< Output string containing the current tag. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = '' if ( self % Nt > 0 ) then do t = 1 , self % Nt - 1 tag_string = self % tag ( t )% stringify () string = string // tag_string // new_line ( 'a' ) enddo tag_string = self % tag ( self % Nt )% stringify () string = string // tag_string endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction stringify ! private methods elemental subroutine add_tag ( self , tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add tag to self%tag array. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. type ( xml_tag ), intent ( in ) :: tag !< XML tag. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % Nt > 0_I4P ) then allocate ( tag_new ( 1 : self % Nt + 1 )) tag_new ( 1 : self % Nt ) = self % tag ( 1 : self % Nt ) tag_new ( self % Nt + 1 ) = tag else allocate ( tag_new ( 1 : 1 )) tag_new ( 1 ) = tag endif call move_alloc ( from = tag_new , to = self % tag ) self % Nt = self % Nt + 1 if ( allocated ( tag_new )) deallocate ( tag_new ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_tag subroutine parse_from_string ( self , source_string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse xml data from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), intent ( in ) :: source_string !< String containing xml data. type ( xml_tag ) :: tag !< Dummy xml tag. integer ( I4P ) :: tstart !< Counter for tracking string parsing. integer ( I4P ) :: tend !< Counter for tracking string parsing. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- tstart = 1 tend = 0 do while ( tstart < len ( source_string )) call tag % free call tag % parse ( source = source_string ( tstart :), tend = tend ) if ( tend == 0 ) exit if ( tag % is_parsed ()) call self % add_tag ( tag ) tstart = tstart + tend enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_from_string ! non TBP function load_file_as_stream ( filename , delimiter_start , delimiter_end , fast_read , iostat , iomsg ) result ( stream ) !--------------------------------------------------------------------------------------------------------------------------------- !< Load file contents and store as single characters stream. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: filename !< File name. character ( * ), optional , intent ( in ) :: delimiter_start !< Delimiter from which start the stream. character ( * ), optional , intent ( in ) :: delimiter_end !< Delimiter to which end the stream. logical , optional , intent ( in ) :: fast_read !< Flag for activating efficient reading with one single read. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: stream !< Output string containing the file data as a single stream. logical :: is_file !< Flag for inquiring the presence of the file. integer ( I4P ) :: unit !< Unit file. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< IO error message. character ( 1 ) :: c1 !< Single character. character ( len = :), allocatable :: string !< Dummy string. logical :: cstart !< Flag for stream capturing trigging. logical :: cend !< Flag for stream capturing trigging. logical :: fast !< Flag for activating efficient reading with one single read. integer ( I4P ) :: filesize !< Size of the file for fast reading. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- fast = . false . ; if ( present ( fast_read )) fast = fast_read ! inquire file existance inquire ( file = adjustl ( trim ( filename )), exist = is_file , iostat = iostatd , iomsg = iomsgd ) if (. not . is_file ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! open file open ( newunit = unit , file = adjustl ( trim ( filename )), access = 'STREAM' , form = 'UNFORMATTED' , iostat = iostatd , iomsg = iomsgd ) if ( iostatd /= 0 ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! loadg data stream = '' if ( present ( delimiter_start ). and . present ( delimiter_end )) then ! load only data inside delimiter_start and delimiter_end string = '' Main_Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_start ( 1 : 1 )) then cstart = . true . string = c1 Start_Read_Loop : do while ( len ( string ) < len ( delimiter_start )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_start , substring = string ) > 0 )) then cstart = . false . exit Start_Read_Loop endif enddo Start_Read_Loop if ( cstart ) then cend = . false . stream = string do while (. not . cend ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_end ( 1 : 1 )) then ! maybe the end string = c1 End_Read_Loop : do while ( len ( string ) < len ( delimiter_end )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_end , substring = string ) > 0 )) then stream = stream // string exit End_Read_Loop elseif ( len ( string ) == len ( delimiter_end )) then cend = . true . stream = stream // string exit Main_Read_Loop endif enddo End_Read_Loop else stream = stream // c1 endif enddo endif endif enddo Main_Read_Loop else ! load all data if ( fast ) then ! load fast inquire ( file = adjustl ( trim ( filename )), size = filesize , iostat = iostatd , iomsg = iomsgd ) if ( iostatd == 0 ) then if ( allocated ( stream )) deallocate ( stream ) allocate ( character ( len = filesize ) :: stream ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) stream endif else ! load slow, one character loop Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 stream = stream // c1 enddo Read_Loop endif endif 10 close ( unit ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endfunction load_file_as_stream endmodule foxy_xml_file","tags":"","loc":"sourcefile/foxy_xml_file.f90.html","title":"foxy_xml_file.f90  FoXy"},{"text":"FoXy XML tag class. Source Code !< FoXy XML tag class. module foxy_xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy XML tag class. !----------------------------------------------------------------------------------------------------------------------------------- use penf use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: xml_tag !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: xml_tag !< XML tag class. !< !< A valid XML tag must have the following syntax for a tag without a value (with only attributes): !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\"/> !<``` !< while a tag with a value must have the following syntax: !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\">Tag_value</Tag_Name> !<``` !< !< It is worth noting that the syntax is case sensitive and that the attributes are optional. Each attribute name must be followed !< by '=\"' without any additional white spaces and its value must be termined by '\"'. Each attribute is separated by a white !< space. If the string member does not contain the tag_name no attributes are parsed. private character ( len = :), allocatable :: tag_name !< Tag name. character ( len = :), allocatable :: tag_val !< Tag value. type ( string ), allocatable :: att_name (:) !< Attributes names. type ( string ), allocatable :: att_val (:) !< Attributes values. contains ! public methods procedure :: free !< Free dynamic memory. final :: finalize !< Free dynamic memory when finalizing. procedure :: parse !< Parse the tag contained into a source string. procedure :: is_parsed !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. procedure :: tag_value !< Return tag value of is sefl (or its nested tags) is named *tag_name*. procedure :: stringify !< Convert the whole tag into a string. generic :: assignment ( = ) => assign_tag !< Assignment operator overloading. ! private methods procedure , private :: alloc_attributes !< Allocate (prepare for filling) dynamic memory of attributes. procedure , private :: get !< Get the tag value and attributes from source. procedure , private :: get_value !< Get the tag value from source after tag_name has been set. procedure , private :: get_attributes !< Get the attributes values from source. procedure , private :: parse_tag_name !< Parse the tag name contained into a string. procedure , private :: parse_attributes_names !< Parse the tag attributes names contained into a string. procedure , private :: search !< Search tag named *tag_name* into a string. procedure , private :: assign_tag !< Assignment between two tags. endtype xml_tag !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % tag_name )) deallocate ( self % tag_name ) if ( allocated ( self % tag_val )) deallocate ( self % tag_val ) if ( allocated ( self % att_name )) then call self % att_name % free deallocate ( self % att_name ) endif if ( allocated ( self % att_val )) then call self % att_val % free deallocate ( self % att_val ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free subroutine finalize ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( xml_tag ), intent ( inout ) :: tag !< XML tag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call tag % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize elemental subroutine parse ( self , source , tstart , tend ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse the tag contained into a source string. !< !< It is assumed that the first tag contained into the source string is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the string. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the string. integer ( I4P ) :: tstartd !< Starting index of tag inside the string. integer ( I4P ) :: tendd !< Ending index of tag inside the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- tstartd = 0 tendd = 0 call self % parse_tag_name ( source = source , tstart = tstartd , tend = tendd ) if ( allocated ( self % tag_name )) then if ( index ( string = source ( tstartd : tendd ), substring = '=' ) > 0 ) call self % parse_attributes_names ( source = source ( tstartd : tendd )) if ( index ( string = source , substring = '</' // self % tag_name // '>' ) > 0 ) & tendd = index ( string = source , substring = '</' // self % tag_name // '>' ) + len ( '</' // self % tag_name // '>' ) - 1 call self % get ( source = source ( tstartd : tendd )) endif if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse elemental function is_parsed ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( in ) :: self !< XML tag. logical :: is_parsed !< Result of check. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_parsed = allocated ( self % tag_name ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_parsed pure subroutine tag_value ( self , tag_name , tag_val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return tag value of is sefl (or its nested tags) is named *tag_name*. !< !< @note If there is no value, the *tag_value* string is returned deallocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: tag_name !< Searched tag name. character ( len = :), allocatable , intent ( inout ) :: tag_val !< Tag value. type ( xml_tag ) :: tag !< Dummy XML tag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( tag_val )) deallocate ( tag_val ) if ( allocated ( self % tag_name )) then if ( self % tag_name == tag_name ) then if ( allocated ( self % tag_val )) tag_val = self % tag_val else if ( allocated ( self % tag_val )) then call tag % search ( tag_name = tag_name , source = self % tag_val ) if ( allocated ( tag % tag_val )) tag_val = tag % tag_val endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tag_value pure function stringify ( self ) result ( stringed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the whole tag into a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: stringed !< Output string containing the whole tag. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- stringed = '' if ( allocated ( self % tag_name )) then stringed = stringed // '<' // self % tag_name if ( allocated ( self % att_name ). and . allocated ( self % att_val )) then if ( size ( self % att_name ) == size ( self % att_val )) then ! consistency check do a = 1 , size ( self % att_name ) if ( self % att_name ( a )% is_allocated (). and . self % att_val ( a )% is_allocated ()) & stringed = stringed // ' ' // self % att_name ( a ) // '=\"' // self % att_val ( a ) // '\"' enddo endif endif if ( allocated ( self % tag_val )) then stringed = stringed // '>' // self % tag_val // '</' // self % tag_name // '>' else stringed = stringed // '/>' endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction stringify ! private methods elemental subroutine alloc_attributes ( self , Na , att_name , att_val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Allocate (prepare for filling) dynamic memory of attributes. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: Na !< Number of attributes. logical , optional , intent ( in ) :: att_name !< Flag for freeing attributes names array. logical , optional , intent ( in ) :: att_val !< Flag for freeing attributes values array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( att_name )) then if ( att_name ) then if ( allocated ( self % att_name )) then call self % att_name % free deallocate ( self % att_name ) endif allocate ( self % att_name ( 1 : Na )) endif endif if ( present ( att_val )) then if ( att_val ) then if ( allocated ( self % att_val )) then call self % att_val % free deallocate ( self % att_val ) endif allocate ( self % att_val ( 1 : Na )) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine alloc_attributes elemental subroutine get ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the tag value and attributes from source after tag_name and att_name have been set. !< !< @note It is worth noting that the leading and trailing white spaces of tag value and attributes are removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % get_value ( source = source ) call self % get_attributes ( source = source ) ! call self%get_nested() return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get elemental subroutine get_value ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the tag value from source after tag_name has been set. !< !< @note It is worth noting that the leading and trailing white spaces of tag value are removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: c1 !< Counter. integer :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then c2 = index ( string = source , substring = '</' // self % tag_name // '>' ) if ( c2 > 0 ) then ! parsing tag value c1 = index ( string = source , substring = '>' ) self % tag_val = trim ( adjustl ( source ( c1 + 1 : c2 - 1 ))) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_value elemental subroutine get_attributes ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the attributes values from source after tag_name and att_name have been set. !< !< @note It is worth noting that the leading and trailing white spaces of attributes values are removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: a !< Counter. integer :: c1 !< Counter. integer :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then if ( allocated ( self % att_name )) then ! parsing attributes call self % alloc_attributes ( att_val = . true ., Na = size ( self % att_name , dim = 1 )) do a = 1 , size ( self % att_name , dim = 1 ) c1 = index ( string = source , substring = self % att_name ( a ) // '=\"' ) + self % att_name ( a )% len () + 2 if ( c1 > self % att_name ( a )% len () + 2 ) then c2 = index ( string = source ( c1 :), substring = '\"' ) if ( c2 > 0 ) then self % att_val ( a ) = trim ( adjustl ( source ( c1 : c1 + c2 - 2 ))) else call self % att_val ( a )% free endif else call self % att_val ( a )% free endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_attributes elemental subroutine parse_tag_name ( self , source , tstart , tend ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse the tag name contained into a string. !< !< It is assumed that the first tag contained into the source is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. integer ( I4P ) :: tstartd !< Starting index of tag inside the source. integer ( I4P ) :: tendd !< Ending index of tag inside the source. character ( len = 1 ) :: c1 !< Dummy string for parsing file. character ( len = :), allocatable :: c2 !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- tstartd = 0 tendd = 0 c = 1 Tag_Search : do while ( c <= len ( source )) c1 = source ( c : c ) if ( c1 == '<' ) then tstartd = c c2 = c1 Tag_Name : do while ( c < len ( source )) c = c + 1 ; c1 = source ( c : c ) c2 = c2 // c1 if ( c1 == '>' ) then tendd = c exit Tag_Name endif enddo Tag_Name s = index ( string = c2 , substring = ' ' ) if ( s > 0 ) then ! there are attributes self % tag_name = c2 ( 2 : s - 1 ) else if ( index ( string = c2 , substring = '/>' ) > 0 ) then ! self closing tag self % tag_name = c2 ( 2 : len ( c2 ) - 2 ) else self % tag_name = c2 ( 2 : len ( c2 ) - 1 ) endif endif exit Tag_Search endif c = c + 1 enddo Tag_Search if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_tag_name elemental subroutine parse_attributes_names ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse the tag attributes names contained into a string. !< !< Valid syntax is: !< + `att1=\"att1 val\" att2=\"att2 val\"...` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. character ( len = :), allocatable :: att !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: Na !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Na = 0 c = 1 Att_Count : do while ( c <= len ( source )) if ( source ( c : c ) == '=' ) Na = Na + 1 c = c + 1 enddo Att_Count if ( Na > 0 ) then call self % alloc_attributes ( att_name = . true ., Na = Na ) c = index ( string = source , substring = ' ' ) att = source ( c :) c = 1 a = 1 Att_Search : do while ( c <= len ( att )) if ( att ( c : c ) == '=' ) then s = max ( 0 , index ( string = att , substring = ' ' )) self % att_name ( a ) = trim ( adjustl ( att ( s + 1 : c - 1 ))) att = att ( c + 1 :) c = 1 a = a + 1 endif c = c + 1 enddo Att_Search endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_attributes_names elemental subroutine search ( self , tag_name , source , tstart , tend ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search tag named *tag_name* into a string and, in case it is found, store into self. !< !< @note If *tag_name* is not found, self is returned empty. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: tag_name !< Searched tag name. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. type ( xml_tag ) :: tag !< Dummy XML tag. integer ( I4P ) :: tstartd !< Starting index of tag inside the source. integer ( I4P ) :: tendd !< Ending index of tag inside the source. logical :: found !< Flag for inquiring search result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free self % tag_name = tag_name tstartd = 1 tendd = 0 found = . false . Tag_Search : do while ((. not . found ). or .( len ( source ( tendd + 1 :)) < len ( self % tag_name ))) call tag % parse ( source = source ( tendd + 1 :), tstart = tstartd , tend = tendd ) if ( tstartd == 0. and . tendd == 0 ) then exit Tag_Search ! no tag found else if ( allocated ( tag % tag_name )) then if ( tag % tag_name == self % tag_name ) then found = . true . endif endif endif enddo Tag_Search if ( found ) then self = tag else call self % free endif if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine search ! assignment (=) elemental subroutine assign_tag ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two tags. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: lhs !< Left hand side. type ( xml_tag ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % tag_name )) lhs % tag_name = rhs % tag_name if ( allocated ( rhs % tag_val )) lhs % tag_val = rhs % tag_val if ( allocated ( rhs % att_name )) then if ( allocated ( lhs % att_name )) deallocate ( lhs % att_name ) ; allocate ( lhs % att_name ( 1 : size ( rhs % att_name ))) do a = 1 , size ( rhs % att_name ) if ( rhs % att_name ( a )% is_allocated ()) lhs % att_name ( a ) = rhs % att_name ( a ) enddo endif if ( allocated ( rhs % att_val )) then if ( allocated ( lhs % att_val )) deallocate ( lhs % att_val ) ; allocate ( lhs % att_val ( 1 : size ( rhs % att_val ))) do a = 1 , size ( rhs % att_val ) if ( rhs % att_val ( a )% is_allocated ()) lhs % att_val ( a ) = rhs % att_val ( a ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_tag endmodule foxy_xml_tag","tags":"","loc":"sourcefile/foxy_xml_tag.f90.html","title":"foxy_xml_tag.f90  FoXy"},{"text":"Portability Environment for Fortran poor people. Source Code !< Portability Environment for Fortran poor people. module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !<{!README-PENF.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90  FoXy"},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Source Code !< StringiFor, Strings Fortran, yet another stringify Fortran module module stringifor !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, Strings Fortran, yet another stringify Fortran module !----------------------------------------------------------------------------------------------------------------------------------- use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P use stringifor_string_t , only : CK , & sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim , & string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! expose StingiFor objects public :: CK public :: string ! expose StingiFor overloaded builtins public :: adjustl , adjustr , count , index , len , len_trim , repeat , scan , trim ! expose StingiFor new procedures public :: read_file , read_lines , write_file , write_lines ! expose PENF kinds public :: I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! builtins overloading interfaces interface adjustl !< Builtin adjustl overloading. module procedure sadjustl_character endinterface adjustl interface adjustr !< Builtin adjustr overloading. module procedure sadjustr_character endinterface adjustr interface count !< Builtin count overloading. module procedure count_substring endinterface interface index !< Builtin index overloading. module procedure sindex_string_string , sindex_string_character , sindex_character_string endinterface index interface len !< Builtin len overloading. module procedure slen endinterface len interface len_trim !< Builtin len_trim overloading. module procedure slen_trim endinterface len_trim interface repeat !< Builtin repeat overloading. module procedure srepeat_string_string endinterface repeat interface scan !< Builtin scan overloading. module procedure sscan_string_string , sscan_string_character , sscan_character_string endinterface scan interface trim !< Builtin trim overloading. module procedure strim endinterface trim !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function count_substring ( string_ , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string_ !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string_ )) return c1 = 1 do c2 = index ( string = string_ ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring subroutine read_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file subroutine read_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines subroutine write_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected-formatted unit. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines subroutine write_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html","title":"stringifor.F90  FoXy"},{"text":"StringiFor, definition of string type. Source Code !< StringiFor, definition of `string` type. module stringifor_string_t !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, definition of `string` type. !----------------------------------------------------------------------------------------------------------------------------------- use befor64 , only : b64_decode , b64_encode use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P , str !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: CK public :: sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim public :: string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. procedure , pass ( self ) :: verify => sverify !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. #endif ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , pass ( self ) :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. ! auxiliary methods procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string ! internal parameters character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len = 1 ), parameter :: SPACE = ' ' !< Space character. character ( kind = CK , len = 1 ), parameter :: TAB = achar ( 9 ) !< Tab character. character ( kind = CK , len = 1 ), parameter :: UIX_DIR_SEP = char ( 47 ) !< Unix/Linux directories separator (/). character ( kind = CK , len = 1 ), parameter :: BACKSLASH = char ( 92 ) !< Backslash character. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl pure function sadjustl_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustl ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl_character elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr pure function sadjustr_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustr ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr_character elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount elemental function sindex_string_string ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_string elemental function sindex_string_character ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_character elemental function sindex_character_string ( string_ , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: string_ !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( substring % raw )) then i = index ( string = string_ , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_character_string elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_string_string elemental function srepeat_character_string ( self , rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_character_string elemental function sscan_string_string ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_string elemental function sscan_string_character ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_character elemental function sscan_character_string ( sstring , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: sstring !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( set % raw )) then i = scan ( string = sstring , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_character_string elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify ! auxiliary methods elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental function insert_character ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_character elemental function insert_string ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_string pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition subroutine read_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file subroutine read_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_eor !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_line subroutine read_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search pure function slice ( self , istart , iend ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data sliced. !< !<### Example !< !<```fortran !< type(string) :: astring        !< A string. !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) ! print \"Brown fox Jumps\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slice elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase elemental function strip ( self , remove_nulls ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unescape double backslashes (or custom escaped character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unescape elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper subroutine write_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file subroutine write_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_line subroutine write_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines ! inquire elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with ! private methods ! assignments elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P ! contatenation operators pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string ! logical operators elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_string elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_character elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw == lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_eq_string elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_string elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_character elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw /= lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ne_string elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_string elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_character elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_lt_string elemental function string_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_string elemental function string_le_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_character elemental function character_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_le_string elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_string elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_character elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ge_string elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_string elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_character elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_gt_string ! IO subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the end of record condition to the ! caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_delimited subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited_listdirected subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted ! miscellanea elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence ! non type-bound-procedures subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_delimiter_mode subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character in the current record. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_this_record subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character, advancing records if necessary. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_any_record subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_decimal_mode endmodule stringifor_string_t","tags":"","loc":"sourcefile/stringifor_string_t.f90.html","title":"stringifor_string_t.F90  FoXy"},{"text":"FoXy test. Source Code !< FoXy test. program parse_file_simple !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' ) write ( unit = xunit ) source close ( unit = xunit ) print \"(A)\" , 'Parsing file' call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram parse_file_simple","tags":"","loc":"sourcefile/parse_file_simple.f90.html","title":"parse_file_simple.f90  FoXy"},{"text":"FoXy test. Source Code !< FoXy test. program parse_string_simple !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'Parsing file' call xfile % parse ( string = source ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram parse_string_simple","tags":"","loc":"sourcefile/parse_string_simple.f90.html","title":"parse_string_simple.f90  FoXy"},{"text":"type, public :: xml_file type~~xml_file~~InheritsGraph type~xml_file xml_file type~xml_tag xml_tag type~xml_tag->type~xml_file tag type~string string type~string->type~xml_tag att_name, att_val Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. XML file class. Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: Nt = 0 Number of XML tags. type( xml_tag ), private, allocatable :: tag (:) XML tags array. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private subroutine finalize (file) Arguments Type Intent Optional Attributes Name type( xml_file ), intent(inout) :: file XML file. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. Description Free dynamic memory. procedure, public :: parse Parse xml data from string or file. private subroutine parse (self, string, filename) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in), optional :: string String containing xml data. character(len=*), intent(in), optional :: filename File name containing xml data. Description Parse xml data from string or file. procedure, public :: tag_value Return tag value of tag named tag_name . private pure subroutine tag_value (self, tag_name, tag_val) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. character(len=*), intent(in) :: tag_name Tag name. character(len=:), intent(inout), allocatable :: tag_val Tag value. Description Return tag value of tag named tag_name . procedure, public :: stringify Convert the whole file data into a string. private pure function stringify (self) result(string) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. Return Value character(len=:),\n  allocatable Output string containing the whole xml file. Description Convert the whole file data into a string. procedure, private :: add_tag Add tag to self%tag array. private elemental subroutine add_tag (self, tag) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag. Description Add tag to self%tag array. procedure, private :: parse_from_string Parse xml data from string. private subroutine parse_from_string (self, source_string) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in) :: source_string String containing xml data. Description Parse xml data from string. Source Code type , public :: xml_file !< XML file class. private integer ( I4P ) :: Nt = 0 !< Number of XML tags. type ( xml_tag ), allocatable :: tag (:) !< XML tags array. contains ! public methods procedure :: free !< Free dynamic memory. final :: finalize !< Free dynamic memory when finalizing. procedure :: parse !< Parse xml data from string or file. procedure :: tag_value !< Return tag value of tag named *tag_name*. procedure :: stringify !< Convert the whole file data into a string. ! private methods procedure , private :: add_tag !< Add tag to self%tag array. procedure , private :: parse_from_string !< Parse xml data from string. endtype xml_file","tags":"","loc":"type/xml_file.html","title":"xml_file  FoXy "},{"text":"type, public :: xml_tag type~~xml_tag~~InheritsGraph type~xml_tag xml_tag type~string string type~string->type~xml_tag att_name, att_val Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. XML tag class. A valid XML tag must have the following syntax for a tag without a value (with only attributes): <Tag_Name att# 1_Name= \"att#1_val\" att# 2_Name= \"att#2_val\" ... att# Nt_Name= \"att#Nt_val\" /> while a tag with a value must have the following syntax: <Tag_Name att# 1_Name= \"att#1_val\" att# 2_Name= \"att#2_val\" ... att# Nt_Name= \"att#Nt_val\" > Tag_value </Tag_Name> It is worth noting that the syntax is case sensitive and that the attributes are optional. Each attribute name must be followed\n by '=\"' without any additional white spaces and its value must be termined by '\"'. Each attribute is separated by a white\n space. If the string member does not contain the tag_name no attributes are parsed. Inherited By type~~xml_tag~~InheritedByGraph type~xml_tag xml_tag type~xml_file xml_file type~xml_tag->type~xml_file tag Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: tag_name Tag name. character(len=:), private, allocatable :: tag_val Tag value. type( string ), private, allocatable :: att_name (:) Attributes names. type( string ), private, allocatable :: att_val (:) Attributes values. Finalization Procedures final :: finalize Free dynamic memory when finalizing. private subroutine finalize (tag) Arguments Type Intent Optional Attributes Name type( xml_tag ), intent(inout) :: tag XML tag. Description Free dynamic memory when finalizing. Type-Bound Procedures procedure, public :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. Description Free dynamic memory. procedure, public :: parse Parse the tag contained into a source string. private elemental subroutine parse (self, source, tstart, tend) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the string. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the string. Description Parse the tag contained into a source string. procedure, public :: is_parsed Check is tag is correctly parsed, i.e. its tag_name is allocated. private elemental function is_parsed (self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value logical Result of check. Description Check is tag is correctly parsed, i.e. its tag_name is allocated. procedure, public :: tag_value Return tag value of is sefl (or its nested tags) is named tag_name . private pure subroutine tag_value (self, tag_name, tag_val) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: tag_name Searched tag name. character(len=:), intent(inout), allocatable :: tag_val Tag value. Description Return tag value of is sefl (or its nested tags) is named tag_name . procedure, public :: stringify Convert the whole tag into a string. private pure function stringify (self) result(stringed) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:),\n  allocatable Output string containing the whole tag. Description Convert the whole tag into a string. generic, public :: assignment(=) => assign_tag Assignment operator overloading. private elemental subroutine assign_tag (lhs, rhs) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs Left hand side. type( xml_tag ), intent(in) :: rhs Right hand side. Description Assignment between two tags. procedure, private :: alloc_attributes Allocate (prepare for filling) dynamic memory of attributes. private elemental subroutine alloc_attributes (self, Na, att_name, att_val) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: Na Number of attributes. logical, intent(in), optional :: att_name Flag for freeing attributes names array. logical, intent(in), optional :: att_val Flag for freeing attributes values array. Description Allocate (prepare for filling) dynamic memory of attributes. procedure, private :: get Get the tag value and attributes from source. private elemental subroutine get (self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Description Get the tag value and attributes from source after tag_name and att_name have been set. procedure, private :: get_value Get the tag value from source after tag_name has been set. private elemental subroutine get_value (self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Description Get the tag value from source after tag_name has been set. procedure, private :: get_attributes Get the attributes values from source. private elemental subroutine get_attributes (self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Description Get the attributes values from source after tag_name and att_name have been set. procedure, private :: parse_tag_name Parse the tag name contained into a string. private elemental subroutine parse_tag_name (self, source, tstart, tend) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. Description Parse the tag name contained into a string. procedure, private :: parse_attributes_names Parse the tag attributes names contained into a string. private elemental subroutine parse_attributes_names (self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. Description Parse the tag attributes names contained into a string. procedure, private :: search Search tag named tag_name into a string. private elemental subroutine search (self, tag_name, source, tstart, tend) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: tag_name Searched tag name. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. Description Search tag named tag_name into a string and, in case it is found, store into self. procedure, private :: assign_tag Assignment between two tags. private elemental subroutine assign_tag (lhs, rhs) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs Left hand side. type( xml_tag ), intent(in) :: rhs Right hand side. Description Assignment between two tags. Source Code type :: xml_tag !< XML tag class. !< !< A valid XML tag must have the following syntax for a tag without a value (with only attributes): !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\"/> !<``` !< while a tag with a value must have the following syntax: !<```xml !<   <Tag_Name att#1_Name=\"att#1_val\" att#2_Name=\"att#2_val\"... att#Nt_Name=\"att#Nt_val\">Tag_value</Tag_Name> !<``` !< !< It is worth noting that the syntax is case sensitive and that the attributes are optional. Each attribute name must be followed !< by '=\"' without any additional white spaces and its value must be termined by '\"'. Each attribute is separated by a white !< space. If the string member does not contain the tag_name no attributes are parsed. private character ( len = :), allocatable :: tag_name !< Tag name. character ( len = :), allocatable :: tag_val !< Tag value. type ( string ), allocatable :: att_name (:) !< Attributes names. type ( string ), allocatable :: att_val (:) !< Attributes values. contains ! public methods procedure :: free !< Free dynamic memory. final :: finalize !< Free dynamic memory when finalizing. procedure :: parse !< Parse the tag contained into a source string. procedure :: is_parsed !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. procedure :: tag_value !< Return tag value of is sefl (or its nested tags) is named *tag_name*. procedure :: stringify !< Convert the whole tag into a string. generic :: assignment ( = ) => assign_tag !< Assignment operator overloading. ! private methods procedure , private :: alloc_attributes !< Allocate (prepare for filling) dynamic memory of attributes. procedure , private :: get !< Get the tag value and attributes from source. procedure , private :: get_value !< Get the tag value from source after tag_name has been set. procedure , private :: get_attributes !< Get the attributes values from source. procedure , private :: parse_tag_name !< Parse the tag name contained into a string. procedure , private :: parse_attributes_names !< Parse the tag attributes names contained into a string. procedure , private :: search !< Search tag named *tag_name* into a string. procedure , private :: assign_tag !< Assignment between two tags. endtype xml_tag","tags":"","loc":"type/xml_tag.html","title":"xml_tag  FoXy "},{"text":"type, public :: string OOP designed string class. Inherited By type~~string~~InheritedByGraph type~string string type~xml_tag xml_tag type~string->type~xml_tag att_name, att_val type~xml_file xml_file type~xml_tag->type~xml_file tag Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. procedure, public, pass(self) :: count => scount Count replacement. private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. generic, public :: index => sindex_string_string , sindex_string_character Index replacement. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, public, pass(self) :: len => slen Len replacement. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. generic, public :: repeat => srepeat_string_string , srepeat_character_string Repeat replacement. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. generic, public :: scan => sscan_string_string , sscan_string_character Scan replacement. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, public, pass(self) :: trim => strim Trim replacement. public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. procedure, public, pass(self) :: verify => sverify Verify replacement. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. procedure, public, pass(self) :: decode Decode string. private elemental function decode (self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. procedure, public, pass(self) :: encode Encode string. private elemental function encode (self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. generic, public :: insert => insert_string , insert_character Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. generic, public :: join => join_strings , join_characters Return a string that is a join of an array of strings or characters. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file Read a file a single string stream. private subroutine read_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. private subroutine read_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. private subroutine read_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. procedure, public, pass(self) :: slice Return the raw characters data sliced. private pure function slice (self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. private elemental function strip (self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P , to_integer_I2P , to_integer_I4P , to_integer_I8P , to_real_R4P , to_real_R8P Cast string to number. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. procedure, public, pass(self) :: write_file Write a single string stream into file. private subroutine write_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. private subroutine write_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. private subroutine write_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string , string_assign_character , string_assign_integer_I1P , string_assign_integer_I2P , string_assign_integer_I4P , string_assign_integer_I8P , string_assign_real_R4P , string_assign_real_R8P Assignment operator overloading. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(==) => string_eq_string , string_eq_character , character_eq_string Equal operator overloading. private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. generic, public :: operator(/=) => string_ne_string , string_ne_character , character_ne_string Not equal operator overloading. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. generic, public :: operator(<) => string_lt_string , string_lt_character , character_lt_string Lower than operator overloading. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. generic, public :: operator(<=) => string_le_string , string_le_character , character_le_string Lower equal than operator overloading. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. generic, public :: operator(>=) => string_ge_string , string_ge_character , character_ge_string Greater equal than operator overloading. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. generic, public :: operator(>) => string_gt_string , string_gt_character , character_gt_string Greater than operator overloading. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. generic, public :: read(formatted) => read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. generic, public :: write(formatted) => write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. generic, public :: read(unformatted) => read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. generic, public :: write(unformatted) => write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: sindex_string_string Index replacement. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, private, pass(self) :: sindex_string_character Index replacement. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. procedure, private, pass(self) :: srepeat_character_string Repeat replacement. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. procedure, private, pass(self) :: sscan_string_string Scan replacement. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, private, pass(self) :: sscan_string_character Scan replacement. public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings Return join string of an array of strings. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). procedure, private, pass(self) :: to_integer_I2P Cast string to integer. private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). procedure, private, pass(self) :: to_integer_I4P Cast string to integer. private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). procedure, private, pass(self) :: to_integer_I8P Cast string to integer. private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). procedure, private, pass(self) :: to_real_R4P Cast string to real. private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). procedure, private, pass(self) :: to_real_R8P Cast string to real. private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, private, pass(self) :: to_real_R16P Cast string to real. private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, private, pass(dtv) :: read_delimited Read a delimited input. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. procedure, private, pass(dtv) :: write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, private, pass(dtv) :: read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. procedure, private, pass(dtv) :: write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Source Code type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. procedure , pass ( self ) :: verify => sverify !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. #endif ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , pass ( self ) :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. ! auxiliary methods procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string","tags":"","loc":"type/string.html","title":"string  FoXy "},{"text":"public subroutine b64_init() Arguments None Description Initialize the BeFoR64 library. Note This procedure must be called before encoding/decoding anything! Called By proc~~b64_init~~CalledByGraph proc~b64_init b64_init proc~autotest autotest proc~autotest->proc~b64_init Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init","tags":"","loc":"proc/b64_init.html","title":"b64_init  FoXy"},{"text":"private pure subroutine encode_bits(bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) +--first octet--+-second octet--+--third octet--+\n |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n +-----------+---+-------+-------+---+-----------+\n |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n +--1.index--+--2.index--+--3.index--+--4.index--+ Note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. Note The number of paddings must be computed outside this procedure, into the calling scope. Warning This procedure is the backend of encoding, thus it must be never called outside the module. Called By proc~~encode_bits~~CalledByGraph proc~encode_bits encode_bits proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r16_a b64_encode_R16_a proc~b64_encode_r16_a->proc~encode_bits proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_i2->proc~encode_bits proc~b64_encode_r16 b64_encode_R16 proc~b64_encode_r16->proc~encode_bits proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_r8->proc~encode_bits proc~b64_encode_string b64_encode_string proc~b64_encode_string->proc~encode_bits proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_r4->proc~encode_bits proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_up->proc~b64_encode_i4 proc~b64_encode_up->proc~b64_encode_i2 proc~b64_encode_up->proc~b64_encode_r8 proc~b64_encode_up->proc~b64_encode_string proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_up->proc~b64_encode_r4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1 interface~b64_encode->proc~b64_encode_i8_a interface~b64_encode->proc~b64_encode_string_a interface~b64_encode->proc~b64_encode_i2_a interface~b64_encode->proc~b64_encode_r8_a interface~b64_encode->proc~b64_encode_i1_a interface~b64_encode->proc~b64_encode_i4 interface~b64_encode->proc~b64_encode_i4_a interface~b64_encode->proc~b64_encode_i2 interface~b64_encode->proc~b64_encode_r8 interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_i8 interface~b64_encode->proc~b64_encode_r4 interface~b64_encode->proc~b64_encode_r4_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_up_a->proc~b64_encode_r4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits","tags":"","loc":"proc/encode_bits.html","title":"encode_bits  FoXy"},{"text":"private pure subroutine decode_bits(code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code QUJD the decoding process must do +-b64 char--+-b64 char--+-b64 char--+-b64 char--+\n |      Q    |      U    |      J    |      D    |\n +-b64 index-+-b64 index-+-b64 index-+-b64 index-+\n !      16   |      20   |      9    |      3    |\n +-6 bits----+-6 bits----+-6 bits----+-6 bits----+\n |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1|\n +-----------+---+-------+-------+---+-----------+\n |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1|\n +-----8 bits----+-----8 bits----+-----8 bits----+ Note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. Warning This procedure is the backend of decoding, thus it must be never called outside the module. Called By proc~~decode_bits~~CalledByGraph proc~decode_bits decode_bits proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r16 b64_decode_R16 proc~b64_decode_r16->proc~decode_bits proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_i1->proc~decode_bits proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_r16_a b64_decode_R16_a proc~b64_decode_r16_a->proc~decode_bits proc~b64_decode_string b64_decode_string proc~b64_decode_string->proc~decode_bits proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i4 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_up->proc~b64_decode_r8 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_up->proc~b64_decode_string interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4 interface~b64_decode->proc~b64_decode_i1_a interface~b64_decode->proc~b64_decode_r4 interface~b64_decode->proc~b64_decode_i4_a interface~b64_decode->proc~b64_decode_r8 interface~b64_decode->proc~b64_decode_i8_a interface~b64_decode->proc~b64_decode_r8_a interface~b64_decode->proc~b64_decode_r4_a interface~b64_decode->proc~b64_decode_i2_a interface~b64_decode->proc~b64_decode_i2 interface~b64_decode->proc~b64_decode_i8 interface~b64_decode->proc~b64_decode_i1 interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits","tags":"","loc":"proc/decode_bits.html","title":"decode_bits  FoXy"},{"text":"public subroutine b64_encode_up(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. Calls proc~~b64_encode_up~~CallsGraph proc~b64_encode_up b64_encode_up proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up->proc~b64_encode_i4 proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up->proc~b64_encode_i2 proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up->proc~b64_encode_r8 proc~b64_encode_string b64_encode_string proc~b64_encode_up->proc~b64_encode_string proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up->proc~b64_encode_r4 proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_string->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up","tags":"","loc":"proc/b64_encode_up.html","title":"b64_encode_up  FoXy"},{"text":"private pure subroutine b64_encode_up_a(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. Calls proc~~b64_encode_up_a~~CallsGraph proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_up_a~~CalledByGraph proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a","tags":"","loc":"proc/b64_encode_up_a.html","title":"b64_encode_up_a  FoXy"},{"text":"public subroutine b64_decode_up(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. Calls proc~~b64_decode_up~~CallsGraph proc~b64_decode_up b64_decode_up proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up->proc~b64_decode_i4 proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up->proc~b64_decode_r8 proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_string b64_decode_string proc~b64_decode_up->proc~b64_decode_string proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_string->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up","tags":"","loc":"proc/b64_decode_up.html","title":"b64_decode_up  FoXy"},{"text":"private subroutine b64_decode_up_a(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Calls proc~~b64_decode_up_a~~CallsGraph proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_up_a~~CalledByGraph proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a","tags":"","loc":"proc/b64_decode_up_a.html","title":"b64_decode_up_a  FoXy"},{"text":"private pure subroutine b64_encode_R16(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). Calls proc~~b64_encode_r16~~CallsGraph proc~b64_encode_r16 b64_encode_R16 proc~encode_bits encode_bits proc~b64_encode_r16->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16","tags":"","loc":"proc/b64_encode_r16.html","title":"b64_encode_R16  FoXy"},{"text":"private pure subroutine b64_encode_R8(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). Calls proc~~b64_encode_r8~~CallsGraph proc~b64_encode_r8 b64_encode_R8 proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8~~CalledByGraph proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8","tags":"","loc":"proc/b64_encode_r8.html","title":"b64_encode_R8  FoXy"},{"text":"private pure subroutine b64_encode_R4(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). Calls proc~~b64_encode_r4~~CallsGraph proc~b64_encode_r4 b64_encode_R4 proc~encode_bits encode_bits proc~b64_encode_r4->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4~~CalledByGraph proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4","tags":"","loc":"proc/b64_encode_r4.html","title":"b64_encode_R4  FoXy"},{"text":"private pure subroutine b64_encode_I8(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). Calls proc~~b64_encode_i8~~CallsGraph proc~b64_encode_i8 b64_encode_I8 proc~encode_bits encode_bits proc~b64_encode_i8->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8~~CalledByGraph proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8","tags":"","loc":"proc/b64_encode_i8.html","title":"b64_encode_I8  FoXy"},{"text":"private pure subroutine b64_encode_I4(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). Calls proc~~b64_encode_i4~~CallsGraph proc~b64_encode_i4 b64_encode_I4 proc~encode_bits encode_bits proc~b64_encode_i4->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4~~CalledByGraph proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4","tags":"","loc":"proc/b64_encode_i4.html","title":"b64_encode_I4  FoXy"},{"text":"private pure subroutine b64_encode_I2(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). Calls proc~~b64_encode_i2~~CallsGraph proc~b64_encode_i2 b64_encode_I2 proc~encode_bits encode_bits proc~b64_encode_i2->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2~~CalledByGraph proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i2 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2","tags":"","loc":"proc/b64_encode_i2.html","title":"b64_encode_I2  FoXy"},{"text":"private pure subroutine b64_encode_I1(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). Calls proc~~b64_encode_i1~~CallsGraph proc~b64_encode_i1 b64_encode_I1 proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1~~CalledByGraph proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i1 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1 proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1","tags":"","loc":"proc/b64_encode_i1.html","title":"b64_encode_I1  FoXy"},{"text":"private pure subroutine b64_encode_string(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. Calls proc~~b64_encode_string~~CallsGraph proc~b64_encode_string b64_encode_string interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string->proc~encode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string~~CalledByGraph proc~b64_encode_string b64_encode_string proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string","tags":"","loc":"proc/b64_encode_string.html","title":"b64_encode_string  FoXy"},{"text":"private pure subroutine b64_encode_R16_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). Calls proc~~b64_encode_r16_a~~CallsGraph proc~b64_encode_r16_a b64_encode_R16_a proc~encode_bits encode_bits proc~b64_encode_r16_a->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a","tags":"","loc":"proc/b64_encode_r16_a.html","title":"b64_encode_R16_a  FoXy"},{"text":"private pure subroutine b64_encode_R8_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). Calls proc~~b64_encode_r8_a~~CallsGraph proc~b64_encode_r8_a b64_encode_R8_a proc~encode_bits encode_bits proc~b64_encode_r8_a->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8_a~~CalledByGraph proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a","tags":"","loc":"proc/b64_encode_r8_a.html","title":"b64_encode_R8_a  FoXy"},{"text":"private pure subroutine b64_encode_R4_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). Calls proc~~b64_encode_r4_a~~CallsGraph proc~b64_encode_r4_a b64_encode_R4_a proc~encode_bits encode_bits proc~b64_encode_r4_a->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4_a~~CalledByGraph proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a","tags":"","loc":"proc/b64_encode_r4_a.html","title":"b64_encode_R4_a  FoXy"},{"text":"private pure subroutine b64_encode_I8_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). Calls proc~~b64_encode_i8_a~~CallsGraph proc~b64_encode_i8_a b64_encode_I8_a proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8_a~~CalledByGraph proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a","tags":"","loc":"proc/b64_encode_i8_a.html","title":"b64_encode_I8_a  FoXy"},{"text":"private pure subroutine b64_encode_I4_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). Calls proc~~b64_encode_i4_a~~CallsGraph proc~b64_encode_i4_a b64_encode_I4_a proc~encode_bits encode_bits proc~b64_encode_i4_a->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4_a~~CalledByGraph proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a","tags":"","loc":"proc/b64_encode_i4_a.html","title":"b64_encode_I4_a  FoXy"},{"text":"private pure subroutine b64_encode_I2_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). Calls proc~~b64_encode_i2_a~~CallsGraph proc~b64_encode_i2_a b64_encode_I2_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2_a~~CalledByGraph proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i2_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a","tags":"","loc":"proc/b64_encode_i2_a.html","title":"b64_encode_I2_a  FoXy"},{"text":"private pure subroutine b64_encode_I1_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). Calls proc~~b64_encode_i1_a~~CallsGraph proc~b64_encode_i1_a b64_encode_I1_a proc~encode_bits encode_bits proc~b64_encode_i1_a->proc~encode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1_a~~CalledByGraph proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i1_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a","tags":"","loc":"proc/b64_encode_i1_a.html","title":"b64_encode_I1_a  FoXy"},{"text":"private pure subroutine b64_encode_string_a(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. Calls proc~~b64_encode_string_a~~CallsGraph proc~b64_encode_string_a b64_encode_string_a interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string_a->proc~encode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string_a~~CalledByGraph proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a","tags":"","loc":"proc/b64_encode_string_a.html","title":"b64_encode_string_a  FoXy"},{"text":"private elemental subroutine b64_decode_R16(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). Calls proc~~b64_decode_r16~~CallsGraph proc~b64_decode_r16 b64_decode_R16 proc~decode_bits decode_bits proc~b64_decode_r16->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16","tags":"","loc":"proc/b64_decode_r16.html","title":"b64_decode_R16  FoXy"},{"text":"private elemental subroutine b64_decode_R8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). Calls proc~~b64_decode_r8~~CallsGraph proc~b64_decode_r8 b64_decode_R8 proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8~~CalledByGraph proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8","tags":"","loc":"proc/b64_decode_r8.html","title":"b64_decode_R8  FoXy"},{"text":"private elemental subroutine b64_decode_R4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). Calls proc~~b64_decode_r4~~CallsGraph proc~b64_decode_r4 b64_decode_R4 proc~decode_bits decode_bits proc~b64_decode_r4->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4~~CalledByGraph proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4","tags":"","loc":"proc/b64_decode_r4.html","title":"b64_decode_R4  FoXy"},{"text":"private elemental subroutine b64_decode_I8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). Calls proc~~b64_decode_i8~~CallsGraph proc~b64_decode_i8 b64_decode_I8 proc~decode_bits decode_bits proc~b64_decode_i8->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8~~CalledByGraph proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8","tags":"","loc":"proc/b64_decode_i8.html","title":"b64_decode_I8  FoXy"},{"text":"private elemental subroutine b64_decode_I4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). Calls proc~~b64_decode_i4~~CallsGraph proc~b64_decode_i4 b64_decode_I4 proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4~~CalledByGraph proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4","tags":"","loc":"proc/b64_decode_i4.html","title":"b64_decode_I4  FoXy"},{"text":"private elemental subroutine b64_decode_I2(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). Calls proc~~b64_decode_i2~~CallsGraph proc~b64_decode_i2 b64_decode_I2 proc~decode_bits decode_bits proc~b64_decode_i2->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2~~CalledByGraph proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i2 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2","tags":"","loc":"proc/b64_decode_i2.html","title":"b64_decode_I2  FoXy"},{"text":"private elemental subroutine b64_decode_I1(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). Calls proc~~b64_decode_i1~~CallsGraph proc~b64_decode_i1 b64_decode_I1 proc~decode_bits decode_bits proc~b64_decode_i1->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1~~CalledByGraph proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i1 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1","tags":"","loc":"proc/b64_decode_i1.html","title":"b64_decode_I1  FoXy"},{"text":"private elemental subroutine b64_decode_string(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. Calls proc~~b64_decode_string~~CallsGraph proc~b64_decode_string b64_decode_string interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string->proc~decode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string~~CalledByGraph proc~b64_decode_string b64_decode_string proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string","tags":"","loc":"proc/b64_decode_string.html","title":"b64_decode_string  FoXy"},{"text":"private pure subroutine b64_decode_R16_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). Calls proc~~b64_decode_r16_a~~CallsGraph proc~b64_decode_r16_a b64_decode_R16_a proc~decode_bits decode_bits proc~b64_decode_r16_a->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a","tags":"","loc":"proc/b64_decode_r16_a.html","title":"b64_decode_R16_a  FoXy"},{"text":"private pure subroutine b64_decode_R8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). Calls proc~~b64_decode_r8_a~~CallsGraph proc~b64_decode_r8_a b64_decode_R8_a proc~decode_bits decode_bits proc~b64_decode_r8_a->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8_a~~CalledByGraph proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a","tags":"","loc":"proc/b64_decode_r8_a.html","title":"b64_decode_R8_a  FoXy"},{"text":"private pure subroutine b64_decode_R4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). Calls proc~~b64_decode_r4_a~~CallsGraph proc~b64_decode_r4_a b64_decode_R4_a proc~decode_bits decode_bits proc~b64_decode_r4_a->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4_a~~CalledByGraph proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a","tags":"","loc":"proc/b64_decode_r4_a.html","title":"b64_decode_R4_a  FoXy"},{"text":"private pure subroutine b64_decode_I8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). Calls proc~~b64_decode_i8_a~~CallsGraph proc~b64_decode_i8_a b64_decode_I8_a proc~decode_bits decode_bits proc~b64_decode_i8_a->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8_a~~CalledByGraph proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a","tags":"","loc":"proc/b64_decode_i8_a.html","title":"b64_decode_I8_a  FoXy"},{"text":"private pure subroutine b64_decode_I4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). Calls proc~~b64_decode_i4_a~~CallsGraph proc~b64_decode_i4_a b64_decode_I4_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4_a~~CalledByGraph proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a","tags":"","loc":"proc/b64_decode_i4_a.html","title":"b64_decode_I4_a  FoXy"},{"text":"private pure subroutine b64_decode_I2_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). Calls proc~~b64_decode_i2_a~~CallsGraph proc~b64_decode_i2_a b64_decode_I2_a proc~decode_bits decode_bits proc~b64_decode_i2_a->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2_a~~CalledByGraph proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i2_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a","tags":"","loc":"proc/b64_decode_i2_a.html","title":"b64_decode_I2_a  FoXy"},{"text":"private pure subroutine b64_decode_I1_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). Calls proc~~b64_decode_i1_a~~CallsGraph proc~b64_decode_i1_a b64_decode_I1_a proc~decode_bits decode_bits proc~b64_decode_i1_a->proc~decode_bits Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1_a~~CalledByGraph proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i1_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a","tags":"","loc":"proc/b64_decode_i1_a.html","title":"b64_decode_I1_a  FoXy"},{"text":"private pure subroutine b64_decode_string_a(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. Calls proc~~b64_decode_string_a~~CallsGraph proc~b64_decode_string_a b64_decode_string_a interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string_a->proc~decode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string_a~~CalledByGraph proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a","tags":"","loc":"proc/b64_decode_string_a.html","title":"b64_decode_string_a  FoXy"},{"text":"public subroutine autotest() Arguments None Description Procedure for autotesting the library functionalities. Note Into the src directory there is a small python script ( validation.py ) that can be used to validate the library\n correctness by a comparison with other widely used tools such as the python builtin module struct . Calls proc~~autotest~~CallsGraph proc~autotest autotest proc~b64_init b64_init proc~autotest->proc~b64_init interface~b64_decode b64_decode proc~autotest->interface~b64_decode interface~b64_encode b64_encode proc~autotest->interface~b64_encode interface~str str proc~autotest->interface~str proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_string_a->interface~byte_size proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_string->interface~byte_size proc~b64_encode_string->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: code64 Base64 code. logical, public :: ok Flag for checking the result of encoding/decoding. real(kind=R8P), public :: scalar_R8 Decoded scalar. real(kind=R4P), public :: scalar_R4 Decoded scalar. integer(kind=I8P), public :: scalar_I8 Decoded scalar. integer(kind=I4P), public :: scalar_I4 Decoded scalar. integer(kind=I2P), public :: scalar_I2 Decoded scalar. integer(kind=I1P), public :: scalar_I1 Decoded scalar. real(kind=R8P), public :: array_R8 (1:2) Decoded array. real(kind=R4P), public :: array_R4 (1:2) Decoded array. integer(kind=I8P), public :: array_I8 (1:4) Decoded array. integer(kind=I4P), public :: array_I4 (1:2) Decoded array. integer(kind=I2P), public :: array_I2 (1:2) Decoded array. integer(kind=I1P), public :: array_I1 (1:2) Decoded array. character(len=5), public :: array_s (1:2) Decoded array. Source Code subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest","tags":"","loc":"proc/autotest.html","title":"autotest  FoXy"},{"text":"public interface b64_encode Encode numbers (integer and real) to base64. This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both\n scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode~~CallsGraph interface~b64_encode b64_encode proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_string->proc~encode_bits proc~b64_encode_string->interface~byte_size proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_encode~~CalledByGraph interface~b64_encode b64_encode proc~autotest autotest proc~autotest->interface~b64_encode proc~encode encode proc~encode->interface~b64_encode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64.","tags":"","loc":"interface/b64_encode.html","title":"b64_encode  FoXy"},{"text":"public interface b64_encode_up Encode unlimited polymorphic variable to base64. This is an interface for encoding both scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode_up~~CallsGraph interface~b64_encode_up b64_encode_up interface~b64_encode_up->interface~b64_encode_up proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64.","tags":"","loc":"interface/b64_encode_up.html","title":"b64_encode_up  FoXy"},{"text":"public interface b64_decode Decode numbers (integer and real) from base64. This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both\n scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode ( code = 'AAAAAAAA8D8=' , n = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode~~CallsGraph interface~b64_decode b64_decode proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_string_a->interface~byte_size proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_decode~~CalledByGraph interface~b64_decode b64_decode proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings.","tags":"","loc":"interface/b64_decode.html","title":"b64_decode  FoXy"},{"text":"public interface b64_decode_up Decode unlimited polymorphic variable from base64. This is an interface for decoding both scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode_up ( code = 'AAAAAAAA8D8=' , up = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode_up ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , up = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode_up~~CallsGraph interface~b64_decode_up b64_decode_up interface~b64_decode_up->interface~b64_decode_up proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64.","tags":"","loc":"interface/b64_decode_up.html","title":"b64_decode_up  FoXy"},{"text":"private pure subroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_r4~~CalledByGraph proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_r4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4","tags":"","loc":"proc/pack_data_r8_r4.html","title":"pack_data_R8_R4  FoXy"},{"text":"private pure subroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i8~~CalledByGraph proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8","tags":"","loc":"proc/pack_data_r8_i8.html","title":"pack_data_R8_I8  FoXy"},{"text":"private pure subroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i4~~CalledByGraph proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4","tags":"","loc":"proc/pack_data_r8_i4.html","title":"pack_data_R8_I4  FoXy"},{"text":"private pure subroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i2~~CalledByGraph proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i2 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2","tags":"","loc":"proc/pack_data_r8_i2.html","title":"pack_data_R8_I2  FoXy"},{"text":"private pure subroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i1~~CalledByGraph proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i1 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1","tags":"","loc":"proc/pack_data_r8_i1.html","title":"pack_data_R8_I1  FoXy"},{"text":"private pure subroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_r8~~CalledByGraph proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_r8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8","tags":"","loc":"proc/pack_data_r4_r8.html","title":"pack_data_R4_R8  FoXy"},{"text":"private pure subroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i8~~CalledByGraph proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8","tags":"","loc":"proc/pack_data_r4_i8.html","title":"pack_data_R4_I8  FoXy"},{"text":"private pure subroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i4~~CalledByGraph proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4","tags":"","loc":"proc/pack_data_r4_i4.html","title":"pack_data_R4_I4  FoXy"},{"text":"private pure subroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i2~~CalledByGraph proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i2 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2","tags":"","loc":"proc/pack_data_r4_i2.html","title":"pack_data_R4_I2  FoXy"},{"text":"private pure subroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i1~~CalledByGraph proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i1 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1","tags":"","loc":"proc/pack_data_r4_i1.html","title":"pack_data_R4_I1  FoXy"},{"text":"private pure subroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r8~~CalledByGraph proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8","tags":"","loc":"proc/pack_data_i8_r8.html","title":"pack_data_I8_R8  FoXy"},{"text":"private pure subroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r4~~CalledByGraph proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4","tags":"","loc":"proc/pack_data_i8_r4.html","title":"pack_data_I8_R4  FoXy"},{"text":"private pure subroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i4~~CalledByGraph proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4","tags":"","loc":"proc/pack_data_i8_i4.html","title":"pack_data_I8_I4  FoXy"},{"text":"private pure subroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i2~~CalledByGraph proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i2 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2","tags":"","loc":"proc/pack_data_i8_i2.html","title":"pack_data_I8_I2  FoXy"},{"text":"private pure subroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i1~~CalledByGraph proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i1 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1","tags":"","loc":"proc/pack_data_i8_i1.html","title":"pack_data_I8_I1  FoXy"},{"text":"private pure subroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r8~~CalledByGraph proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8","tags":"","loc":"proc/pack_data_i4_r8.html","title":"pack_data_I4_R8  FoXy"},{"text":"private pure subroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r4~~CalledByGraph proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4","tags":"","loc":"proc/pack_data_i4_r4.html","title":"pack_data_I4_R4  FoXy"},{"text":"private pure subroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i8~~CalledByGraph proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8","tags":"","loc":"proc/pack_data_i4_i8.html","title":"pack_data_I4_I8  FoXy"},{"text":"private pure subroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i2~~CalledByGraph proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i2 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2","tags":"","loc":"proc/pack_data_i4_i2.html","title":"pack_data_I4_I2  FoXy"},{"text":"private pure subroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i1~~CalledByGraph proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i1 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1","tags":"","loc":"proc/pack_data_i4_i1.html","title":"pack_data_I4_I1  FoXy"},{"text":"private pure subroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r8~~CalledByGraph proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8","tags":"","loc":"proc/pack_data_i2_r8.html","title":"pack_data_I2_R8  FoXy"},{"text":"private pure subroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r4~~CalledByGraph proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4","tags":"","loc":"proc/pack_data_i2_r4.html","title":"pack_data_I2_R4  FoXy"},{"text":"private pure subroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i8~~CalledByGraph proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8","tags":"","loc":"proc/pack_data_i2_i8.html","title":"pack_data_I2_I8  FoXy"},{"text":"private pure subroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i4~~CalledByGraph proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4","tags":"","loc":"proc/pack_data_i2_i4.html","title":"pack_data_I2_I4  FoXy"},{"text":"private pure subroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i1~~CalledByGraph proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i1 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1","tags":"","loc":"proc/pack_data_i2_i1.html","title":"pack_data_I2_I1  FoXy"},{"text":"private pure subroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r8~~CalledByGraph proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8","tags":"","loc":"proc/pack_data_i1_r8.html","title":"pack_data_I1_R8  FoXy"},{"text":"private pure subroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r4~~CalledByGraph proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4","tags":"","loc":"proc/pack_data_i1_r4.html","title":"pack_data_I1_R4  FoXy"},{"text":"private pure subroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i8~~CalledByGraph proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8","tags":"","loc":"proc/pack_data_i1_i8.html","title":"pack_data_I1_I8  FoXy"},{"text":"private pure subroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i4~~CalledByGraph proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4","tags":"","loc":"proc/pack_data_i1_i4.html","title":"pack_data_I1_I4  FoXy"},{"text":"private pure subroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i2~~CalledByGraph proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i2 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2","tags":"","loc":"proc/pack_data_i1_i2.html","title":"pack_data_I1_I2  FoXy"},{"text":"public interface pack_data Pack different kinds of data into single I1P array. This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. Note This procedure exploits the transfer builtin function, that from the standard (2003+) is defined as TRANSFER(SOURCE, MOLD [, SIZE]) . Data object having a physical representation identical to that of SOURCE but with the type\n and type parameters of MOLD . The result is of the same type and type parameters as MOLD .\n If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small as possible such\n that its physical representation is not shorter than that of SOURCE . Presently, the following combinations are available: Arrays-Arrays: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Scalars-Scalars: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Examples of usage Packing two real arrays, one with kind R8P and one with R4P real ( R8P ) :: array_r8 ( 1 : 12 ) real ( R4P ) :: array_r4 ( - 1 : 5 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r8 , a2 = array_r4 , packed = rpack ) Packing two arrays, one real with kind R4P and one integer with I4P real ( R4P ) :: array_r4 ( 2 ) integer ( I4P ) :: array_i4 ( 0 : 2 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r4 , a2 = array_i4 , packed = rpack ) Calls interface~~pack_data~~CallsGraph interface~pack_data pack_data proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data->proc~pack_data_r4_i4 proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data->proc~pack_data_i2_i4 proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data->proc~pack_data_i8_i4 proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data->proc~pack_data_r8_i4 proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data->proc~pack_data_r4_r8 proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data->proc~pack_data_i1_i8 proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data->proc~pack_data_i1_r4 proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data->proc~pack_data_i1_i2 proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data->proc~pack_data_i4_i2 proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data->proc~pack_data_i8_r8 proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data->proc~pack_data_i8_i1 proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data->proc~pack_data_r4_i8 proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data->proc~pack_data_r8_i2 proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data->proc~pack_data_i4_i1 proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data->proc~pack_data_i1_i4 proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data->proc~pack_data_r8_i1 proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data->proc~pack_data_r4_i1 proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data->proc~pack_data_r8_r4 proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data->proc~pack_data_r4_i2 proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data->proc~pack_data_i4_r4 proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data->proc~pack_data_i8_r4 proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data->proc~pack_data_i2_r4 proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data->proc~pack_data_r8_i8 proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data->proc~pack_data_i2_r8 proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data->proc~pack_data_i8_i2 proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data->proc~pack_data_i4_r8 proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data->proc~pack_data_i2_i1 proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data->proc~pack_data_i1_r8 proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data->proc~pack_data_i4_i8 proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data->proc~pack_data_i2_i8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"interface/pack_data.html","title":"pack_data  FoXy"},{"text":"private pure function stringify(self) result(string) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. Return Value character(len=:),\n  allocatable Output string containing the whole xml file. Description Convert the whole file data into a string. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: tag_string Output string containing the current tag. integer(kind=I4P), public :: t Counter. Source Code pure function stringify ( self ) result ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the whole file data into a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( in ) :: self !< XML file. character ( len = :), allocatable :: string !< Output string containing the whole xml file. character ( len = :), allocatable :: tag_string !< Output string containing the current tag. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = '' if ( self % Nt > 0 ) then do t = 1 , self % Nt - 1 tag_string = self % tag ( t )% stringify () string = string // tag_string // new_line ( 'a' ) enddo tag_string = self % tag ( self % Nt )% stringify () string = string // tag_string endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction stringify","tags":"","loc":"proc/stringify.html","title":"stringify  FoXy"},{"text":"private function load_file_as_stream(filename, delimiter_start, delimiter_end, fast_read, iostat, iomsg) result(stream) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename File name. character(len=*), intent(in), optional :: delimiter_start Delimiter from which start the stream. character(len=*), intent(in), optional :: delimiter_end Delimiter to which end the stream. logical, intent(in), optional :: fast_read Flag for activating efficient reading with one single read. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Return Value character(len=:),\n  allocatable Output string containing the file data as a single stream. Description Load file contents and store as single characters stream. Called By proc~~load_file_as_stream~~CalledByGraph proc~load_file_as_stream load_file_as_stream proc~parse parse proc~parse->proc~load_file_as_stream Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_file Flag for inquiring the presence of the file. integer(kind=I4P), public :: unit Unit file. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd IO error message. character(len=1), public :: c1 Single character. character(len=:), public, allocatable :: string Dummy string. logical, public :: cstart Flag for stream capturing trigging. logical, public :: cend Flag for stream capturing trigging. logical, public :: fast Flag for activating efficient reading with one single read. integer(kind=I4P), public :: filesize Size of the file for fast reading. Source Code function load_file_as_stream ( filename , delimiter_start , delimiter_end , fast_read , iostat , iomsg ) result ( stream ) !--------------------------------------------------------------------------------------------------------------------------------- !< Load file contents and store as single characters stream. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: filename !< File name. character ( * ), optional , intent ( in ) :: delimiter_start !< Delimiter from which start the stream. character ( * ), optional , intent ( in ) :: delimiter_end !< Delimiter to which end the stream. logical , optional , intent ( in ) :: fast_read !< Flag for activating efficient reading with one single read. integer ( I4P ), optional , intent ( out ) :: iostat !< IO error. character ( * ), optional , intent ( out ) :: iomsg !< IO error message. character ( len = :), allocatable :: stream !< Output string containing the file data as a single stream. logical :: is_file !< Flag for inquiring the presence of the file. integer ( I4P ) :: unit !< Unit file. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< IO error message. character ( 1 ) :: c1 !< Single character. character ( len = :), allocatable :: string !< Dummy string. logical :: cstart !< Flag for stream capturing trigging. logical :: cend !< Flag for stream capturing trigging. logical :: fast !< Flag for activating efficient reading with one single read. integer ( I4P ) :: filesize !< Size of the file for fast reading. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- fast = . false . ; if ( present ( fast_read )) fast = fast_read ! inquire file existance inquire ( file = adjustl ( trim ( filename )), exist = is_file , iostat = iostatd , iomsg = iomsgd ) if (. not . is_file ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! open file open ( newunit = unit , file = adjustl ( trim ( filename )), access = 'STREAM' , form = 'UNFORMATTED' , iostat = iostatd , iomsg = iomsgd ) if ( iostatd /= 0 ) then if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return endif ! loadg data stream = '' if ( present ( delimiter_start ). and . present ( delimiter_end )) then ! load only data inside delimiter_start and delimiter_end string = '' Main_Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_start ( 1 : 1 )) then cstart = . true . string = c1 Start_Read_Loop : do while ( len ( string ) < len ( delimiter_start )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_start , substring = string ) > 0 )) then cstart = . false . exit Start_Read_Loop endif enddo Start_Read_Loop if ( cstart ) then cend = . false . stream = string do while (. not . cend ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 if ( c1 == delimiter_end ( 1 : 1 )) then ! maybe the end string = c1 End_Read_Loop : do while ( len ( string ) < len ( delimiter_end )) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 string = string // c1 if (. not .( index ( string = delimiter_end , substring = string ) > 0 )) then stream = stream // string exit End_Read_Loop elseif ( len ( string ) == len ( delimiter_end )) then cend = . true . stream = stream // string exit Main_Read_Loop endif enddo End_Read_Loop else stream = stream // c1 endif enddo endif endif enddo Main_Read_Loop else ! load all data if ( fast ) then ! load fast inquire ( file = adjustl ( trim ( filename )), size = filesize , iostat = iostatd , iomsg = iomsgd ) if ( iostatd == 0 ) then if ( allocated ( stream )) deallocate ( stream ) allocate ( character ( len = filesize ) :: stream ) read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) stream endif else ! load slow, one character loop Read_Loop : do read ( unit = unit , iostat = iostatd , iomsg = iomsgd , end = 10 ) c1 stream = stream // c1 enddo Read_Loop endif endif 10 close ( unit ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endfunction load_file_as_stream","tags":"","loc":"proc/load_file_as_stream.html","title":"load_file_as_stream  FoXy"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % tag )) then call self % tag % free deallocate ( self % tag ) self % Nt = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free  FoXy"},{"text":"private subroutine finalize(file) Arguments Type Intent Optional Attributes Name type( xml_file ), intent(inout) :: file XML file. Description Free dynamic memory when finalizing. Source Code subroutine finalize ( file ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( xml_file ), intent ( INOUT ) :: file !< XML file. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call file % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize  FoXy"},{"text":"private subroutine parse(self, string, filename) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in), optional :: string String containing xml data. character(len=*), intent(in), optional :: filename File name containing xml data. Description Parse xml data from string or file. Note Self data are free before trying to parse new xml data: all previously parsed data are lost. Calls proc~~parse~~CallsGraph proc~parse parse proc~load_file_as_stream load_file_as_stream proc~parse->proc~load_file_as_stream Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: source String containing xml data. Source Code subroutine parse ( self , string , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse xml data from string or file. !< !< @note Self data are free before trying to parse new xml data: all previously parsed data are lost. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), optional , intent ( in ) :: string !< String containing xml data. character ( * ), optional , intent ( in ) :: filename !< File name containing xml data. character ( len = :), allocatable :: source !< String containing xml data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free if ( present ( string )) then call self % parse_from_string ( source_string = string ) elseif ( present ( filename )) then source = load_file_as_stream ( filename = filename , fast_read = . true .) call self % parse_from_string ( source_string = source ) endif return !--------------------------------------------------------------------------------------------------------------------------------- contains endsubroutine parse","tags":"","loc":"proc/parse.html","title":"parse  FoXy"},{"text":"private pure subroutine tag_value(self, tag_name, tag_val) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(in) :: self XML file. character(len=*), intent(in) :: tag_name Tag name. character(len=:), intent(inout), allocatable :: tag_val Tag value. Description Return tag value of tag named tag_name . Note If there is no value, the tag_value string is returned deallocated. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: t Counter. Source Code pure subroutine tag_value ( self , tag_name , tag_val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return tag value of tag named *tag_name*. !< !< @note If there is no value, the *tag_value* string is returned deallocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( in ) :: self !< XML file. character ( * ), intent ( in ) :: tag_name !< Tag name. character ( len = :), allocatable , intent ( inout ) :: tag_val !< Tag value. integer ( I4P ) :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( tag_val )) deallocate ( tag_val ) if ( self % Nt > 0 ) then do t = 1 , self % Nt call self % tag ( t )% tag_value ( tag_name = tag_name , tag_val = tag_val ) if ( allocated ( tag_val )) exit enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tag_value","tags":"","loc":"proc/tag_value.html","title":"tag_value  FoXy"},{"text":"private elemental subroutine add_tag(self, tag) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. type( xml_tag ), intent(in) :: tag XML tag. Description Add tag to self%tag array. Variables Type Visibility Attributes Name Initial type( xml_tag ), public, allocatable :: tag_new (:) New (extended) tags array. Source Code elemental subroutine add_tag ( self , tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add tag to self%tag array. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. type ( xml_tag ), intent ( in ) :: tag !< XML tag. type ( xml_tag ), allocatable :: tag_new (:) !< New (extended) tags array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % Nt > 0_I4P ) then allocate ( tag_new ( 1 : self % Nt + 1 )) tag_new ( 1 : self % Nt ) = self % tag ( 1 : self % Nt ) tag_new ( self % Nt + 1 ) = tag else allocate ( tag_new ( 1 : 1 )) tag_new ( 1 ) = tag endif call move_alloc ( from = tag_new , to = self % tag ) self % Nt = self % Nt + 1 if ( allocated ( tag_new )) deallocate ( tag_new ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine add_tag","tags":"","loc":"proc/add_tag.html","title":"add_tag  FoXy"},{"text":"private subroutine parse_from_string(self, source_string) Arguments Type Intent Optional Attributes Name class( xml_file ), intent(inout) :: self XML file. character(len=*), intent(in) :: source_string String containing xml data. Description Parse xml data from string. Variables Type Visibility Attributes Name Initial type( xml_tag ), public :: tag Dummy xml tag. integer(kind=I4P), public :: tstart Counter for tracking string parsing. integer(kind=I4P), public :: tend Counter for tracking string parsing. Source Code subroutine parse_from_string ( self , source_string ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse xml data from string. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_file ), intent ( inout ) :: self !< XML file. character ( * ), intent ( in ) :: source_string !< String containing xml data. type ( xml_tag ) :: tag !< Dummy xml tag. integer ( I4P ) :: tstart !< Counter for tracking string parsing. integer ( I4P ) :: tend !< Counter for tracking string parsing. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- tstart = 1 tend = 0 do while ( tstart < len ( source_string )) call tag % free call tag % parse ( source = source_string ( tstart :), tend = tend ) if ( tend == 0 ) exit if ( tag % is_parsed ()) call self % add_tag ( tag ) tstart = tstart + tend enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_from_string","tags":"","loc":"proc/parse_from_string.html","title":"parse_from_string  FoXy"},{"text":"private elemental function is_parsed(self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value logical Result of check. Description Check is tag is correctly parsed, i.e. its tag_name is allocated. Source Code elemental function is_parsed ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Check is tag is correctly parsed, i.e. its *tag_name* is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( in ) :: self !< XML tag. logical :: is_parsed !< Result of check. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_parsed = allocated ( self % tag_name ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_parsed","tags":"","loc":"proc/is_parsed.html","title":"is_parsed  FoXy"},{"text":"private pure function stringify(self) result(stringed) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. Return Value character(len=:),\n  allocatable Output string containing the whole tag. Description Convert the whole tag into a string. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counters. Source Code pure function stringify ( self ) result ( stringed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert the whole tag into a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( len = :), allocatable :: stringed !< Output string containing the whole tag. integer ( I4P ) :: a !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- stringed = '' if ( allocated ( self % tag_name )) then stringed = stringed // '<' // self % tag_name if ( allocated ( self % att_name ). and . allocated ( self % att_val )) then if ( size ( self % att_name ) == size ( self % att_val )) then ! consistency check do a = 1 , size ( self % att_name ) if ( self % att_name ( a )% is_allocated (). and . self % att_val ( a )% is_allocated ()) & stringed = stringed // ' ' // self % att_name ( a ) // '=\"' // self % att_val ( a ) // '\"' enddo endif endif if ( allocated ( self % tag_val )) then stringed = stringed // '>' // self % tag_val // '</' // self % tag_name // '>' else stringed = stringed // '/>' endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction stringify","tags":"","loc":"proc/stringify~2.html","title":"stringify  FoXy"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % tag_name )) deallocate ( self % tag_name ) if ( allocated ( self % tag_val )) deallocate ( self % tag_val ) if ( allocated ( self % att_name )) then call self % att_name % free deallocate ( self % att_name ) endif if ( allocated ( self % att_val )) then call self % att_val % free deallocate ( self % att_val ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~2.html","title":"free  FoXy"},{"text":"private subroutine finalize(tag) Arguments Type Intent Optional Attributes Name type( xml_tag ), intent(inout) :: tag XML tag. Description Free dynamic memory when finalizing. Source Code subroutine finalize ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory when finalizing. !--------------------------------------------------------------------------------------------------------------------------------- type ( xml_tag ), intent ( inout ) :: tag !< XML tag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call tag % free return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize  FoXy"},{"text":"private elemental subroutine parse(self, source, tstart, tend) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the string. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the string. Description Parse the tag contained into a source string. It is assumed that the first tag contained into the source string is parsed, the others eventually present are omitted.\n Valid syntax are:\n + <tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name> + <tag_name att1=\"att1 val\" att2=\"att2 val\".../> Note Inside the attributes value the symbols < and > are not allowed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: tstartd Starting index of tag inside the string. integer(kind=I4P), public :: tendd Ending index of tag inside the string. Source Code elemental subroutine parse ( self , source , tstart , tend ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse the tag contained into a source string. !< !< It is assumed that the first tag contained into the source string is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the string. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the string. integer ( I4P ) :: tstartd !< Starting index of tag inside the string. integer ( I4P ) :: tendd !< Ending index of tag inside the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- tstartd = 0 tendd = 0 call self % parse_tag_name ( source = source , tstart = tstartd , tend = tendd ) if ( allocated ( self % tag_name )) then if ( index ( string = source ( tstartd : tendd ), substring = '=' ) > 0 ) call self % parse_attributes_names ( source = source ( tstartd : tendd )) if ( index ( string = source , substring = '</' // self % tag_name // '>' ) > 0 ) & tendd = index ( string = source , substring = '</' // self % tag_name // '>' ) + len ( '</' // self % tag_name // '>' ) - 1 call self % get ( source = source ( tstartd : tendd )) endif if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse","tags":"","loc":"proc/parse~2.html","title":"parse  FoXy"},{"text":"private pure subroutine tag_value(self, tag_name, tag_val) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(in) :: self XML tag. character(len=*), intent(in) :: tag_name Searched tag name. character(len=:), intent(inout), allocatable :: tag_val Tag value. Description Return tag value of is sefl (or its nested tags) is named tag_name . Note If there is no value, the tag_value string is returned deallocated. Variables Type Visibility Attributes Name Initial type( xml_tag ), public :: tag Dummy XML tag. Source Code pure subroutine tag_value ( self , tag_name , tag_val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return tag value of is sefl (or its nested tags) is named *tag_name*. !< !< @note If there is no value, the *tag_value* string is returned deallocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( in ) :: self !< XML tag. character ( * ), intent ( in ) :: tag_name !< Searched tag name. character ( len = :), allocatable , intent ( inout ) :: tag_val !< Tag value. type ( xml_tag ) :: tag !< Dummy XML tag. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( tag_val )) deallocate ( tag_val ) if ( allocated ( self % tag_name )) then if ( self % tag_name == tag_name ) then if ( allocated ( self % tag_val )) tag_val = self % tag_val else if ( allocated ( self % tag_val )) then call tag % search ( tag_name = tag_name , source = self % tag_val ) if ( allocated ( tag % tag_val )) tag_val = tag % tag_val endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine tag_value","tags":"","loc":"proc/tag_value~2.html","title":"tag_value  FoXy"},{"text":"private elemental subroutine alloc_attributes(self, Na, att_name, att_val) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. integer(kind=I4P), intent(in) :: Na Number of attributes. logical, intent(in), optional :: att_name Flag for freeing attributes names array. logical, intent(in), optional :: att_val Flag for freeing attributes values array. Description Allocate (prepare for filling) dynamic memory of attributes. Source Code elemental subroutine alloc_attributes ( self , Na , att_name , att_val ) !--------------------------------------------------------------------------------------------------------------------------------- !< Allocate (prepare for filling) dynamic memory of attributes. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. integer ( I4P ), intent ( in ) :: Na !< Number of attributes. logical , optional , intent ( in ) :: att_name !< Flag for freeing attributes names array. logical , optional , intent ( in ) :: att_val !< Flag for freeing attributes values array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( att_name )) then if ( att_name ) then if ( allocated ( self % att_name )) then call self % att_name % free deallocate ( self % att_name ) endif allocate ( self % att_name ( 1 : Na )) endif endif if ( present ( att_val )) then if ( att_val ) then if ( allocated ( self % att_val )) then call self % att_val % free deallocate ( self % att_val ) endif allocate ( self % att_val ( 1 : Na )) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine alloc_attributes","tags":"","loc":"proc/alloc_attributes.html","title":"alloc_attributes  FoXy"},{"text":"private elemental subroutine get(self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Description Get the tag value and attributes from source after tag_name and att_name have been set. Note It is worth noting that the leading and trailing white spaces of tag value and attributes are removed. Source Code elemental subroutine get ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the tag value and attributes from source after tag_name and att_name have been set. !< !< @note It is worth noting that the leading and trailing white spaces of tag value and attributes are removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % get_value ( source = source ) call self % get_attributes ( source = source ) ! call self%get_nested() return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get","tags":"","loc":"proc/get.html","title":"get  FoXy"},{"text":"private elemental subroutine get_value(self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Description Get the tag value from source after tag_name has been set. Note It is worth noting that the leading and trailing white spaces of tag value are removed. Variables Type Visibility Attributes Name Initial integer, public :: c1 Counter. integer, public :: c2 Counter. Source Code elemental subroutine get_value ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the tag value from source after tag_name has been set. !< !< @note It is worth noting that the leading and trailing white spaces of tag value are removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: c1 !< Counter. integer :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then c2 = index ( string = source , substring = '</' // self % tag_name // '>' ) if ( c2 > 0 ) then ! parsing tag value c1 = index ( string = source , substring = '>' ) self % tag_val = trim ( adjustl ( source ( c1 + 1 : c2 - 1 ))) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_value","tags":"","loc":"proc/get_value.html","title":"get_value  FoXy"},{"text":"private elemental subroutine get_attributes(self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing data. Description Get the attributes values from source after tag_name and att_name have been set. Note It is worth noting that the leading and trailing white spaces of attributes values are removed. Variables Type Visibility Attributes Name Initial integer, public :: a Counter. integer, public :: c1 Counter. integer, public :: c2 Counter. Source Code elemental subroutine get_attributes ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the attributes values from source after tag_name and att_name have been set. !< !< @note It is worth noting that the leading and trailing white spaces of attributes values are removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing data. integer :: a !< Counter. integer :: c1 !< Counter. integer :: c2 !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( index ( string = source , substring = '<' // self % tag_name ) > 0 ) then if ( allocated ( self % att_name )) then ! parsing attributes call self % alloc_attributes ( att_val = . true ., Na = size ( self % att_name , dim = 1 )) do a = 1 , size ( self % att_name , dim = 1 ) c1 = index ( string = source , substring = self % att_name ( a ) // '=\"' ) + self % att_name ( a )% len () + 2 if ( c1 > self % att_name ( a )% len () + 2 ) then c2 = index ( string = source ( c1 :), substring = '\"' ) if ( c2 > 0 ) then self % att_val ( a ) = trim ( adjustl ( source ( c1 : c1 + c2 - 2 ))) else call self % att_val ( a )% free endif else call self % att_val ( a )% free endif enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_attributes","tags":"","loc":"proc/get_attributes.html","title":"get_attributes  FoXy"},{"text":"private elemental subroutine parse_tag_name(self, source, tstart, tend) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. Description Parse the tag name contained into a string. It is assumed that the first tag contained into the source is parsed, the others eventually present are omitted.\n Valid syntax are:\n + <tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name> + <tag_name att1=\"att1 val\" att2=\"att2 val\".../> Note Inside the attributes value the symbols < and > are not allowed. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: tstartd Starting index of tag inside the source. integer(kind=I4P), public :: tendd Ending index of tag inside the source. character(len=1), public :: c1 Dummy string for parsing file. character(len=:), public, allocatable :: c2 Dummy string for parsing file. integer(kind=I4P), public :: c Counter. integer(kind=I4P), public :: s Counter. Source Code elemental subroutine parse_tag_name ( self , source , tstart , tend ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse the tag name contained into a string. !< !< It is assumed that the first tag contained into the source is parsed, the others eventually present are omitted. !< Valid syntax are: !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\"...>...</tag_name>` !< + `<tag_name att1=\"att1 val\" att2=\"att2 val\".../>` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. integer ( I4P ) :: tstartd !< Starting index of tag inside the source. integer ( I4P ) :: tendd !< Ending index of tag inside the source. character ( len = 1 ) :: c1 !< Dummy string for parsing file. character ( len = :), allocatable :: c2 !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- tstartd = 0 tendd = 0 c = 1 Tag_Search : do while ( c <= len ( source )) c1 = source ( c : c ) if ( c1 == '<' ) then tstartd = c c2 = c1 Tag_Name : do while ( c < len ( source )) c = c + 1 ; c1 = source ( c : c ) c2 = c2 // c1 if ( c1 == '>' ) then tendd = c exit Tag_Name endif enddo Tag_Name s = index ( string = c2 , substring = ' ' ) if ( s > 0 ) then ! there are attributes self % tag_name = c2 ( 2 : s - 1 ) else if ( index ( string = c2 , substring = '/>' ) > 0 ) then ! self closing tag self % tag_name = c2 ( 2 : len ( c2 ) - 2 ) else self % tag_name = c2 ( 2 : len ( c2 ) - 1 ) endif endif exit Tag_Search endif c = c + 1 enddo Tag_Search if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_tag_name","tags":"","loc":"proc/parse_tag_name.html","title":"parse_tag_name  FoXy"},{"text":"private elemental subroutine parse_attributes_names(self, source) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: source String containing the input. Description Parse the tag attributes names contained into a string. Valid syntax is:\n + att1=\"att1 val\" att2=\"att2 val\"... Note Inside the attributes value the symbols < and > are not allowed. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: att Dummy string for parsing file. integer(kind=I4P), public :: c Counter. integer(kind=I4P), public :: s Counter. integer(kind=I4P), public :: a Counter. integer(kind=I4P), public :: Na Counter. Source Code elemental subroutine parse_attributes_names ( self , source ) !--------------------------------------------------------------------------------------------------------------------------------- !< Parse the tag attributes names contained into a string. !< !< Valid syntax is: !< + `att1=\"att1 val\" att2=\"att2 val\"...` !< @note Inside the attributes value the symbols `<` and `>` are not allowed. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: source !< String containing the input. character ( len = :), allocatable :: att !< Dummy string for parsing file. integer ( I4P ) :: c !< Counter. integer ( I4P ) :: s !< Counter. integer ( I4P ) :: a !< Counter. integer ( I4P ) :: Na !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Na = 0 c = 1 Att_Count : do while ( c <= len ( source )) if ( source ( c : c ) == '=' ) Na = Na + 1 c = c + 1 enddo Att_Count if ( Na > 0 ) then call self % alloc_attributes ( att_name = . true ., Na = Na ) c = index ( string = source , substring = ' ' ) att = source ( c :) c = 1 a = 1 Att_Search : do while ( c <= len ( att )) if ( att ( c : c ) == '=' ) then s = max ( 0 , index ( string = att , substring = ' ' )) self % att_name ( a ) = trim ( adjustl ( att ( s + 1 : c - 1 ))) att = att ( c + 1 :) c = 1 a = a + 1 endif c = c + 1 enddo Att_Search endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine parse_attributes_names","tags":"","loc":"proc/parse_attributes_names.html","title":"parse_attributes_names  FoXy"},{"text":"private elemental subroutine search(self, tag_name, source, tstart, tend) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: self XML tag. character(len=*), intent(in) :: tag_name Searched tag name. character(len=*), intent(in) :: source String containing the input. integer(kind=I4P), intent(out), optional :: tstart Starting index of tag inside the source. integer(kind=I4P), intent(out), optional :: tend Ending index of tag inside the source. Description Search tag named tag_name into a string and, in case it is found, store into self. Note If tag_name is not found, self is returned empty. Variables Type Visibility Attributes Name Initial type( xml_tag ), public :: tag Dummy XML tag. integer(kind=I4P), public :: tstartd Starting index of tag inside the source. integer(kind=I4P), public :: tendd Ending index of tag inside the source. logical, public :: found Flag for inquiring search result. Source Code elemental subroutine search ( self , tag_name , source , tstart , tend ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search tag named *tag_name* into a string and, in case it is found, store into self. !< !< @note If *tag_name* is not found, self is returned empty. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: self !< XML tag. character ( * ), intent ( in ) :: tag_name !< Searched tag name. character ( * ), intent ( in ) :: source !< String containing the input. integer ( I4P ), optional , intent ( out ) :: tstart !< Starting index of tag inside the source. integer ( I4P ), optional , intent ( out ) :: tend !< Ending index of tag inside the source. type ( xml_tag ) :: tag !< Dummy XML tag. integer ( I4P ) :: tstartd !< Starting index of tag inside the source. integer ( I4P ) :: tendd !< Ending index of tag inside the source. logical :: found !< Flag for inquiring search result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % free self % tag_name = tag_name tstartd = 1 tendd = 0 found = . false . Tag_Search : do while ((. not . found ). or .( len ( source ( tendd + 1 :)) < len ( self % tag_name ))) call tag % parse ( source = source ( tendd + 1 :), tstart = tstartd , tend = tendd ) if ( tstartd == 0. and . tendd == 0 ) then exit Tag_Search ! no tag found else if ( allocated ( tag % tag_name )) then if ( tag % tag_name == self % tag_name ) then found = . true . endif endif endif enddo Tag_Search if ( found ) then self = tag else call self % free endif if ( present ( tstart )) tstart = tstartd if ( present ( tend )) tend = tendd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine search","tags":"","loc":"proc/search.html","title":"search  FoXy"},{"text":"private elemental subroutine assign_tag(lhs, rhs) Arguments Type Intent Optional Attributes Name class( xml_tag ), intent(inout) :: lhs Left hand side. type( xml_tag ), intent(in) :: rhs Right hand side. Description Assignment between two tags. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: a Counter. Source Code elemental subroutine assign_tag ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two tags. !--------------------------------------------------------------------------------------------------------------------------------- class ( xml_tag ), intent ( inout ) :: lhs !< Left hand side. type ( xml_tag ), intent ( in ) :: rhs !< Right hand side. integer ( I4P ) :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % tag_name )) lhs % tag_name = rhs % tag_name if ( allocated ( rhs % tag_val )) lhs % tag_val = rhs % tag_val if ( allocated ( rhs % att_name )) then if ( allocated ( lhs % att_name )) deallocate ( lhs % att_name ) ; allocate ( lhs % att_name ( 1 : size ( rhs % att_name ))) do a = 1 , size ( rhs % att_name ) if ( rhs % att_name ( a )% is_allocated ()) lhs % att_name ( a ) = rhs % att_name ( a ) enddo endif if ( allocated ( rhs % att_val )) then if ( allocated ( lhs % att_val )) deallocate ( lhs % att_val ) ; allocate ( lhs % att_val ( 1 : size ( rhs % att_val ))) do a = 1 , size ( rhs % att_val ) if ( rhs % att_val ( a )% is_allocated ()) lhs % att_val ( a ) = rhs % att_val ( a ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_tag","tags":"","loc":"proc/assign_tag.html","title":"assign_tag  FoXy"},{"text":"private elemental function bit_size_R16P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P  FoXy"},{"text":"private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size bit_size interface~bit_size->proc~bit_size_r8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P  FoXy"},{"text":"private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size bit_size interface~bit_size->proc~bit_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P  FoXy"},{"text":"private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size bit_size interface~bit_size->proc~bit_size_chr Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr  FoXy"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P  FoXy"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P  FoXy"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P  FoXy"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P  FoXy"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P  FoXy"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P  FoXy"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P  FoXy"},{"text":"private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr  FoXy"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~~CallsGraph interface~bit_size bit_size proc~bit_size_r8p bit_size_R8P interface~bit_size->proc~bit_size_r8p proc~bit_size_r4p bit_size_R4P interface~bit_size->proc~bit_size_r4p proc~bit_size_chr bit_size_chr interface~bit_size->proc~bit_size_chr Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable.","tags":"","loc":"interface/bit_size.html","title":"bit_size  FoXy"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~byte_size~~CalledByGraph interface~byte_size byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~encode encode proc~encode->interface~b64_encode proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"interface/byte_size.html","title":"byte_size  FoXy"},{"text":"private elemental function strf_R16P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P  FoXy"},{"text":"private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P  FoXy"},{"text":"private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P  FoXy"},{"text":"private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P  FoXy"},{"text":"private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P  FoXy"},{"text":"private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P  FoXy"},{"text":"private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P  FoXy"},{"text":"private elemental function str_R16P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P  FoXy"},{"text":"private elemental function str_R8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P  FoXy"},{"text":"private elemental function str_R4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P  FoXy"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P  FoXy"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P  FoXy"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P  FoXy"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P  FoXy"},{"text":"private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol  FoXy"},{"text":"private pure function str_a_R16P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P  FoXy"},{"text":"private pure function str_a_R8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P  FoXy"},{"text":"private pure function str_a_R4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P  FoXy"},{"text":"private pure function str_a_I8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P  FoXy"},{"text":"private pure function str_a_I4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P  FoXy"},{"text":"private pure function str_a_I2P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P  FoXy"},{"text":"private pure function str_a_I1P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P  FoXy"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P  FoXy"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P  FoXy"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P  FoXy"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P  FoXy"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P  FoXy"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P  FoXy"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P  FoXy"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P  FoXy"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P  FoXy"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P  FoXy"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P  FoXy"},{"text":"private elemental function bstr_R16P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P  FoXy"},{"text":"private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P  FoXy"},{"text":"private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P  FoXy"},{"text":"private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P  FoXy"},{"text":"private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P  FoXy"},{"text":"private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P  FoXy"},{"text":"private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P  FoXy"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P  FoXy"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P  FoXy"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P  FoXy"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P  FoXy"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P  FoXy"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P  FoXy"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P  FoXy"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~autotest autotest proc~autotest->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string.","tags":"","loc":"interface/str.html","title":"str  FoXy"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros.","tags":"","loc":"interface/strz.html","title":"strz  FoXy"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer.","tags":"","loc":"interface/cton.html","title":"cton  FoXy"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits.","tags":"","loc":"interface/bstr.html","title":"bstr  FoXy"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p interface~str str proc~bctoi_i1p->interface~str proc~bctoi_i8p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i4p->interface~str proc~bctor_r4p->interface~str proc~bctoi_i2p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"interface/bcton.html","title":"bcton  FoXy"},{"text":"private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8  FoXy"},{"text":"private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4  FoXy"},{"text":"private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2  FoXy"},{"text":"private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1  FoXy"},{"text":"public subroutine check_endian() Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Calls proc~~check_endian~~CallsGraph proc~check_endian check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function is_little_endian() result(is_little) Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Check if the type of the bit ordering of the running architecture is little endian. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian  FoXy"},{"text":"public subroutine penf_init() Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init  FoXy"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print  FoXy"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit.html","title":"digit  FoXy"},{"text":"private elemental function count_substring(string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. Called By proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: c1 Counters. integer(kind=I4P), public :: c2 Counters. Source Code elemental function count_substring ( string_ , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string_ !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string_ )) return c1 = 1 do c2 = index ( string = string_ ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring","tags":"","loc":"proc/count_substring.html","title":"count_substring  FoXy"},{"text":"public subroutine read_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Calls proc~~read_file~~CallsGraph proc~read_file read_file proc~read_lines read_lines proc~read_file->proc~read_lines Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. logical, public :: does_exist Check if file exist. Source Code subroutine read_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file","tags":"","loc":"proc/read_file.html","title":"read_file  FoXy"},{"text":"public subroutine read_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read lines (records) from a connected-formatted unit. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Called By proc~~read_lines~~CalledByGraph proc~read_lines read_lines proc~read_file read_file proc~read_file->proc~read_lines Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. character(kind=CK,len=1), public :: ch Character storage. integer, public :: l Counter. Source Code subroutine read_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines","tags":"","loc":"proc/read_lines.html","title":"read_lines  FoXy"},{"text":"public subroutine write_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected-formatted unit. Called By proc~~write_lines~~CalledByGraph proc~write_lines write_lines proc~write_file write_file proc~write_file->proc~write_lines Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: l Counter. Source Code subroutine write_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected-formatted unit. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines","tags":"","loc":"proc/write_lines.html","title":"write_lines  FoXy"},{"text":"public subroutine write_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. Calls proc~~write_file~~CallsGraph proc~write_file write_file proc~write_lines write_lines proc~write_file->proc~write_lines Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. Source Code subroutine write_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file","tags":"","loc":"proc/write_file.html","title":"write_file  FoXy"},{"text":"public interface adjustl Builtin adjustl overloading. Calls interface~~adjustl~~CallsGraph interface~adjustl adjustl proc~sadjustl_character sadjustl_character interface~adjustl->proc~sadjustl_character Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output).","tags":"","loc":"interface/adjustl.html","title":"adjustl  FoXy"},{"text":"public interface adjustr Builtin adjustr overloading. Calls interface~~adjustr~~CallsGraph interface~adjustr adjustr proc~sadjustr_character sadjustr_character interface~adjustr->proc~sadjustr_character Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output).","tags":"","loc":"interface/adjustr.html","title":"adjustr  FoXy"},{"text":"public interface count Builtin count overloading. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string.","tags":"","loc":"interface/count.html","title":"count  FoXy"},{"text":"public interface index Builtin index overloading. Calls interface~~index~~CallsGraph interface~index index proc~sindex_string_string sindex_string_string interface~index->proc~sindex_string_string proc~sindex_string_character sindex_string_character interface~index->proc~sindex_string_character proc~sindex_character_string sindex_character_string interface~index->proc~sindex_character_string Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first.","tags":"","loc":"interface/index.html","title":"index  FoXy"},{"text":"public interface len Builtin len overloading. Calls interface~~len~~CallsGraph interface~len len proc~slen slen interface~len->proc~slen Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string.","tags":"","loc":"interface/len.html","title":"len  FoXy"},{"text":"public interface len_trim Builtin len_trim overloading. Calls interface~~len_trim~~CallsGraph interface~len_trim len_trim proc~slen_trim slen_trim interface~len_trim->proc~slen_trim Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks.","tags":"","loc":"interface/len_trim.html","title":"len_trim  FoXy"},{"text":"public interface repeat Builtin repeat overloading. Calls interface~~repeat~~CallsGraph interface~repeat repeat proc~srepeat_string_string srepeat_string_string interface~repeat->proc~srepeat_string_string Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string.","tags":"","loc":"interface/repeat.html","title":"repeat  FoXy"},{"text":"public interface scan Builtin scan overloading. Calls interface~~scan~~CallsGraph interface~scan scan proc~sscan_character_string sscan_character_string interface~scan->proc~sscan_character_string proc~sscan_string_string sscan_string_string interface~scan->proc~sscan_string_string proc~sscan_string_character sscan_string_character interface~scan->proc~sscan_string_character Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set .","tags":"","loc":"interface/scan.html","title":"scan  FoXy"},{"text":"public interface trim Builtin trim overloading. Calls interface~~trim~~CallsGraph interface~trim trim proc~strim strim interface~trim->proc~strim Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces.","tags":"","loc":"interface/trim.html","title":"trim  FoXy"},{"text":"private elemental function sadjustl(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. Source Code elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl","tags":"","loc":"proc/sadjustl.html","title":"sadjustl  FoXy"},{"text":"public pure function sadjustl_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). Called By proc~~sadjustl_character~~CalledByGraph proc~sadjustl_character sadjustl_character interface~adjustl adjustl interface~adjustl->proc~sadjustl_character Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustl_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustl ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl_character","tags":"","loc":"proc/sadjustl_character.html","title":"sadjustl_character  FoXy"},{"text":"private elemental function sadjustr(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. Source Code elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr","tags":"","loc":"proc/sadjustr.html","title":"sadjustr  FoXy"},{"text":"public pure function sadjustr_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). Called By proc~~sadjustr_character~~CalledByGraph proc~sadjustr_character sadjustr_character interface~adjustr adjustr interface~adjustr->proc~sadjustr_character Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustr_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustr ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr_character","tags":"","loc":"proc/sadjustr_character.html","title":"sadjustr_character  FoXy"},{"text":"private elemental function scount(self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. Note If ignore_isolated is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those\n occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a\n right companion). Variables Type Visibility Attributes Name Initial logical, public :: ignore_isolated_ Ignore \"isolated\" occurrences, local variable. integer, public :: c1 Counter. integer, public :: c2 Counter. Source Code elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount","tags":"","loc":"proc/scount.html","title":"scount  FoXy"},{"text":"public elemental function sindex_string_string(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_string_string~~CalledByGraph proc~sindex_string_string sindex_string_string interface~index index interface~index->proc~sindex_string_string Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_string ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_string","tags":"","loc":"proc/sindex_string_string.html","title":"sindex_string_string  FoXy"},{"text":"public elemental function sindex_string_character(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_string_character~~CalledByGraph proc~sindex_string_character sindex_string_character interface~index index interface~index->proc~sindex_string_character Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_character ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_character","tags":"","loc":"proc/sindex_string_character.html","title":"sindex_string_character  FoXy"},{"text":"public elemental function sindex_character_string(string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_character_string~~CalledByGraph proc~sindex_character_string sindex_character_string interface~index index interface~index->proc~sindex_character_string Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_character_string ( string_ , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: string_ !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( substring % raw )) then i = index ( string = string_ , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_character_string","tags":"","loc":"proc/sindex_character_string.html","title":"sindex_character_string  FoXy"},{"text":"public elemental function slen(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. Called By proc~~slen~~CalledByGraph proc~slen slen interface~len len interface~len->proc~slen Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen","tags":"","loc":"proc/slen.html","title":"slen  FoXy"},{"text":"public elemental function slen_trim(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. Called By proc~~slen_trim~~CalledByGraph proc~slen_trim slen_trim interface~len_trim len_trim interface~len_trim->proc~slen_trim Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim","tags":"","loc":"proc/slen_trim.html","title":"slen_trim  FoXy"},{"text":"public elemental function srepeat_string_string(self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. Called By proc~~srepeat_string_string~~CalledByGraph proc~srepeat_string_string srepeat_string_string interface~repeat repeat interface~repeat->proc~srepeat_string_string Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_string_string","tags":"","loc":"proc/srepeat_string_string.html","title":"srepeat_string_string  FoXy"},{"text":"private elemental function srepeat_character_string(self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. Source Code elemental function srepeat_character_string ( self , rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_character_string","tags":"","loc":"proc/srepeat_character_string.html","title":"srepeat_character_string  FoXy"},{"text":"public elemental function sscan_string_string(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_string_string~~CalledByGraph proc~sscan_string_string sscan_string_string interface~scan scan interface~scan->proc~sscan_string_string Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_string ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_string","tags":"","loc":"proc/sscan_string_string.html","title":"sscan_string_string  FoXy"},{"text":"public elemental function sscan_string_character(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_string_character~~CalledByGraph proc~sscan_string_character sscan_string_character interface~scan scan interface~scan->proc~sscan_string_character Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_character ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_character","tags":"","loc":"proc/sscan_string_character.html","title":"sscan_string_character  FoXy"},{"text":"public elemental function sscan_character_string(sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_character_string~~CalledByGraph proc~sscan_character_string sscan_character_string interface~scan scan interface~scan->proc~sscan_character_string Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_character_string ( sstring , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: sstring !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( set % raw )) then i = scan ( string = sstring , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_character_string","tags":"","loc":"proc/sscan_character_string.html","title":"sscan_character_string  FoXy"},{"text":"public elemental function strim(self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Called By proc~~strim~~CalledByGraph proc~strim strim interface~trim trim interface~trim->proc~strim Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim","tags":"","loc":"proc/strim.html","title":"strim  FoXy"},{"text":"private elemental function sverify(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Source Code elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify","tags":"","loc":"proc/sverify.html","title":"sverify  FoXy"},{"text":"private elemental function basedir(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. Example type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(A)' , astring % basedir () // '' ! print \"/bar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. Source Code elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir","tags":"","loc":"proc/basedir.html","title":"basedir  FoXy"},{"text":"private elemental function basename(self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. Optionally, the extension is also stripped if provided or the last one if required, e.g. Example type ( string ) :: astring astring = 'bar/foo.tar.bz2' print '(A)' , astring % basename ( extension = '.tar.bz2' ) // '' ! print \"foo\" print '(A)' , astring % basename ( strip_last_extension = . true .) // '' ! print \"foo.tar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename","tags":"","loc":"proc/basename.html","title":"basename  FoXy"},{"text":"private elemental function camelcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. Note Multiple subsequent separators are collapsed to one occurence. Example ```fortran\n type(string) :: astring\n astring = 'caMeL caSe var'\n print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase","tags":"","loc":"proc/camelcase.html","title":"camelcase  FoXy"},{"text":"private elemental function capitalize(self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize","tags":"","loc":"proc/capitalize.html","title":"capitalize  FoXy"},{"text":"private pure function chars(self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. Source Code pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars","tags":"","loc":"proc/chars.html","title":"chars  FoXy"},{"text":"private elemental function decode(self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. Note Only BASE64 codec is currently available. Example ```fortran\n type(string) :: astring\n astring = 'SG93IGFyZSB5b3U/'\n print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" Calls proc~~decode~~CallsGraph proc~decode decode interface~b64_decode b64_decode proc~decode->interface~b64_decode proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_string_a->interface~byte_size proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: codec_u Encoding codec in upper case string. Source Code elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode","tags":"","loc":"proc/decode.html","title":"decode  FoXy"},{"text":"private elemental function encode(self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. Note Only BASE64 codec is currently available. Example ```fortran\n type(string) :: astring\n astring = 'How are you?'\n print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" Calls proc~~encode~~CallsGraph proc~encode encode interface~b64_encode b64_encode proc~encode->interface~b64_encode proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_string->proc~encode_bits proc~b64_encode_string->interface~byte_size proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode","tags":"","loc":"proc/encode.html","title":"encode  FoXy"},{"text":"private elemental function escape(self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: esc_ Character to escape, local variable. integer, public :: c Character counter. Source Code elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape","tags":"","loc":"proc/escape.html","title":"escape  FoXy"},{"text":"private elemental function extension(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. Variables Type Visibility Attributes Name Initial integer, public :: pos Character position. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension","tags":"","loc":"proc/extension.html","title":"extension  FoXy"},{"text":"private elemental function fill(self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. Variables Type Visibility Attributes Name Initial logical, public :: right_ Fill on the right instead of left, local variable. character(kind=CK,len=1), public :: filling_char_ Filling character (default \"0\"), local variable. Source Code elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill","tags":"","loc":"proc/fill.html","title":"fill  FoXy"},{"text":"private elemental function insert_character(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. Variables Type Visibility Attributes Name Initial integer, public :: safepos Safe position from which insert substring. Source Code elemental function insert_character ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_character","tags":"","loc":"proc/insert_character.html","title":"insert_character  FoXy"},{"text":"private elemental function insert_string(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. Variables Type Visibility Attributes Name Initial integer, public :: safepos Safe position from which insert substring. Source Code elemental function insert_string ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_string","tags":"","loc":"proc/insert_string.html","title":"insert_string  FoXy"},{"text":"private pure function join_strings(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings","tags":"","loc":"proc/join_strings.html","title":"join_strings  FoXy"},{"text":"private pure function join_characters(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters","tags":"","loc":"proc/join_characters.html","title":"join_characters  FoXy"},{"text":"private elemental function lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower","tags":"","loc":"proc/lower.html","title":"lower  FoXy"},{"text":"private pure function partition(self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: c Character counter. Source Code pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition","tags":"","loc":"proc/partition.html","title":"partition  FoXy"},{"text":"private elemental function replace(self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: r Counter. Source Code elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace","tags":"","loc":"proc/replace.html","title":"replace  FoXy"},{"text":"private elemental function reverse(self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. Variables Type Visibility Attributes Name Initial integer, public :: length Length of the string. integer, public :: c Counter. Source Code elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse","tags":"","loc":"proc/reverse.html","title":"reverse  FoXy"},{"text":"private function search(self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. Optionally, returns the indexes of tag start/end, thus this is not an elemental function. Note The tagged record is searched into self if allocated otherwise into in_string if passed or, eventually, into in_character is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are\n zero. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: raw Raw string into which search the tag. integer, public :: istart_ Starting index of tag inside the string, local variable. integer, public :: iend_ Ending index of tag inside the string, local variable. logical, public :: found Flag for inquiring search result. integer, public :: nested_tags Number of nested tags inside tag. integer, public :: t Counter. Source Code function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search","tags":"","loc":"proc/search~2.html","title":"search  FoXy"},{"text":"private pure function slice(self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. Example type ( string ) :: astring !< A string. astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) ! print \"Brown fox Jumps\" Source Code pure function slice ( self , istart , iend ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data sliced. !< !<### Example !< !<```fortran !< type(string) :: astring        !< A string. !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) ! print \"Brown fox Jumps\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slice","tags":"","loc":"proc/slice.html","title":"slice  FoXy"},{"text":"private elemental function snakecase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase","tags":"","loc":"proc/snakecase.html","title":"snakecase  FoXy"},{"text":"private elemental function startcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase","tags":"","loc":"proc/startcase.html","title":"startcase  FoXy"},{"text":"private elemental function strip(self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. Variables Type Visibility Attributes Name Initial integer, public :: c Counter. Source Code elemental function strip ( self , remove_nulls ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip","tags":"","loc":"proc/strip.html","title":"strip  FoXy"},{"text":"private elemental function swapcase(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase","tags":"","loc":"proc/swapcase.html","title":"swapcase  FoXy"},{"text":"private elemental function to_integer_I1P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). Source Code elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P","tags":"","loc":"proc/to_integer_i1p.html","title":"to_integer_I1P  FoXy"},{"text":"private elemental function to_integer_I2P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). Source Code elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P","tags":"","loc":"proc/to_integer_i2p.html","title":"to_integer_I2P  FoXy"},{"text":"private elemental function to_integer_I4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). Source Code elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P","tags":"","loc":"proc/to_integer_i4p.html","title":"to_integer_I4P  FoXy"},{"text":"private elemental function to_integer_I8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). Source Code elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P","tags":"","loc":"proc/to_integer_i8p.html","title":"to_integer_I8P  FoXy"},{"text":"private elemental function to_real_R4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). Source Code elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P","tags":"","loc":"proc/to_real_r4p.html","title":"to_real_R4P  FoXy"},{"text":"private elemental function to_real_R8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). Source Code elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P","tags":"","loc":"proc/to_real_r8p.html","title":"to_real_R8P  FoXy"},{"text":"private elemental function to_real_R16P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). Source Code elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P","tags":"","loc":"proc/to_real_r16p.html","title":"to_real_R16P  FoXy"},{"text":"private elemental function unescape(self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: unesc_ Character to unescape, local variable. integer, public :: c Character counter. Source Code elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unescape double backslashes (or custom escaped character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unescape","tags":"","loc":"proc/unescape.html","title":"unescape  FoXy"},{"text":"private elemental function unique(self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. Note Eventual multiple trailing white space are not reduced to one occurrence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: substring_ Substring, default value. Source Code elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique","tags":"","loc":"proc/unique.html","title":"unique  FoXy"},{"text":"private elemental function upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper","tags":"","loc":"proc/upper.html","title":"upper  FoXy"},{"text":"private elemental function end_with(self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with","tags":"","loc":"proc/end_with.html","title":"end_with  FoXy"},{"text":"private elemental function is_allocated(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. Source Code elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated","tags":"","loc":"proc/is_allocated.html","title":"is_allocated  FoXy"},{"text":"private elemental function is_digit(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit","tags":"","loc":"proc/is_digit.html","title":"is_digit  FoXy"},{"text":"private elemental function is_integer(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. The regular expression is \\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 \\s* [\\+\\-]? \\d+ [eE] \\+? \\d+ \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 F F T F F T T Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer","tags":"","loc":"proc/is_integer.html","title":"is_integer  FoXy"},{"text":"private elemental function is_lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower","tags":"","loc":"proc/is_lower.html","title":"is_lower  FoXy"},{"text":"private elemental function is_number(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). Source Code elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number","tags":"","loc":"proc/is_number.html","title":"is_number  FoXy"},{"text":"private elemental function is_real(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. The regular expression is \\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 S7 S8 \\s* [\\+\\-]? \\d* \\.? \\d* [deDE] [\\+\\-]? \\d* \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 S7 S8 Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. logical, public :: has_leading_digit Check the presence of leading digits. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real","tags":"","loc":"proc/is_real.html","title":"is_real  FoXy"},{"text":"private elemental function is_upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper","tags":"","loc":"proc/is_upper.html","title":"is_upper  FoXy"},{"text":"private elemental function start_with(self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with","tags":"","loc":"proc/start_with.html","title":"start_with  FoXy"},{"text":"private pure function string_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html","title":"string_concat_string  FoXy"},{"text":"private pure function string_concat_character(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html","title":"string_concat_character  FoXy"},{"text":"private pure function character_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html","title":"character_concat_string  FoXy"},{"text":"private elemental function string_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: temporary Temporary concatenated string. Source Code elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html","title":"string_concat_string_string  FoXy"},{"text":"private elemental function string_concat_character_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. Source Code elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html","title":"string_concat_character_string  FoXy"},{"text":"private elemental function character_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). Source Code elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html","title":"character_concat_string_string  FoXy"},{"text":"private elemental function string_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. Source Code elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_string","tags":"","loc":"proc/string_eq_string.html","title":"string_eq_string  FoXy"},{"text":"private elemental function string_eq_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. Source Code elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_character","tags":"","loc":"proc/string_eq_character.html","title":"string_eq_character  FoXy"},{"text":"private elemental function character_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. Source Code elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw == lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_eq_string","tags":"","loc":"proc/character_eq_string.html","title":"character_eq_string  FoXy"},{"text":"private elemental function string_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. Source Code elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_string","tags":"","loc":"proc/string_ne_string.html","title":"string_ne_string  FoXy"},{"text":"private elemental function string_ne_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. Source Code elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_character","tags":"","loc":"proc/string_ne_character.html","title":"string_ne_character  FoXy"},{"text":"private elemental function character_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. Source Code elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw /= lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ne_string","tags":"","loc":"proc/character_ne_string.html","title":"character_ne_string  FoXy"},{"text":"private elemental function string_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. Source Code elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_string","tags":"","loc":"proc/string_lt_string.html","title":"string_lt_string  FoXy"},{"text":"private elemental function string_lt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. Source Code elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_character","tags":"","loc":"proc/string_lt_character.html","title":"string_lt_character  FoXy"},{"text":"private elemental function character_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. Source Code elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_lt_string","tags":"","loc":"proc/character_lt_string.html","title":"character_lt_string  FoXy"},{"text":"private elemental function string_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. Source Code elemental function string_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_string","tags":"","loc":"proc/string_le_string.html","title":"string_le_string  FoXy"},{"text":"private elemental function string_le_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. Source Code elemental function string_le_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_character","tags":"","loc":"proc/string_le_character.html","title":"string_le_character  FoXy"},{"text":"private elemental function character_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. Source Code elemental function character_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_le_string","tags":"","loc":"proc/character_le_string.html","title":"character_le_string  FoXy"},{"text":"private elemental function string_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. Source Code elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_string","tags":"","loc":"proc/string_ge_string.html","title":"string_ge_string  FoXy"},{"text":"private elemental function string_ge_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. Source Code elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_character","tags":"","loc":"proc/string_ge_character.html","title":"string_ge_character  FoXy"},{"text":"private elemental function character_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. Source Code elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ge_string","tags":"","loc":"proc/character_ge_string.html","title":"character_ge_string  FoXy"},{"text":"private elemental function string_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. Source Code elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_string","tags":"","loc":"proc/string_gt_string.html","title":"string_gt_string  FoXy"},{"text":"private elemental function string_gt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. Source Code elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_character","tags":"","loc":"proc/string_gt_character.html","title":"string_gt_character  FoXy"},{"text":"private elemental function character_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. Source Code elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_gt_string","tags":"","loc":"proc/character_gt_string.html","title":"character_gt_string  FoXy"},{"text":"private elemental function replace_one_occurrence(self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: pos Position from which replace old. Source Code elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence","tags":"","loc":"proc/replace_one_occurrence.html","title":"replace_one_occurrence  FoXy"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free~3.html","title":"free  FoXy"},{"text":"private subroutine read_file(self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. logical, public :: does_exist Check if file exist. Source Code subroutine read_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file","tags":"","loc":"proc/read_file~2.html","title":"read_file  FoXy"},{"text":"private subroutine read_line(self, unit, form, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. character(kind=CK,len=:), public, allocatable :: line Line storage. character(kind=CK,len=1), public :: ch Character storage. Source Code subroutine read_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_eor !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_line","tags":"","loc":"proc/read_line.html","title":"read_line  FoXy"},{"text":"private subroutine read_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. The line is read as an ascii stream read until the eor is reached. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. type( string ), public :: lines Lines storage. type( string ), public :: line Line storage. Source Code subroutine read_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines","tags":"","loc":"proc/read_lines~2.html","title":"read_lines  FoXy"},{"text":"private pure subroutine split(self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: No Number of occurrences of sep. integer, public :: t Character counter. type( string ), public :: temporary Temporary storage. type( string ), public, allocatable :: temp_toks (:,:) Temporary tokens substring. Source Code pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split","tags":"","loc":"proc/split.html","title":"split  FoXy"},{"text":"private subroutine write_file(self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. Source Code subroutine write_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file","tags":"","loc":"proc/write_file~2.html","title":"write_file  FoXy"},{"text":"private subroutine write_line(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. Source Code subroutine write_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_line","tags":"","loc":"proc/write_line.html","title":"write_line  FoXy"},{"text":"private subroutine write_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. This method checks if self contains more than one line (records) and writes them as lines (records). Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: lines (:) Lines. integer, public :: l Counter. Source Code subroutine write_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines","tags":"","loc":"proc/write_lines~2.html","title":"write_lines  FoXy"},{"text":"private elemental subroutine string_assign_string(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. Source Code elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html","title":"string_assign_string  FoXy"},{"text":"private elemental subroutine string_assign_character(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. Source Code elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html","title":"string_assign_character  FoXy"},{"text":"private elemental subroutine string_assign_integer_I1P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i1p~~CallsGraph proc~string_assign_integer_i1p string_assign_integer_I1P interface~str str proc~string_assign_integer_i1p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P","tags":"","loc":"proc/string_assign_integer_i1p.html","title":"string_assign_integer_I1P  FoXy"},{"text":"private elemental subroutine string_assign_integer_I2P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i2p~~CallsGraph proc~string_assign_integer_i2p string_assign_integer_I2P interface~str str proc~string_assign_integer_i2p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P","tags":"","loc":"proc/string_assign_integer_i2p.html","title":"string_assign_integer_I2P  FoXy"},{"text":"private elemental subroutine string_assign_integer_I4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i4p~~CallsGraph proc~string_assign_integer_i4p string_assign_integer_I4P interface~str str proc~string_assign_integer_i4p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P","tags":"","loc":"proc/string_assign_integer_i4p.html","title":"string_assign_integer_I4P  FoXy"},{"text":"private elemental subroutine string_assign_integer_I8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i8p~~CallsGraph proc~string_assign_integer_i8p string_assign_integer_I8P interface~str str proc~string_assign_integer_i8p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P","tags":"","loc":"proc/string_assign_integer_i8p.html","title":"string_assign_integer_I8P  FoXy"},{"text":"private elemental subroutine string_assign_real_R4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r4p~~CallsGraph proc~string_assign_real_r4p string_assign_real_R4P interface~str str proc~string_assign_real_r4p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P","tags":"","loc":"proc/string_assign_real_r4p.html","title":"string_assign_real_R4P  FoXy"},{"text":"private elemental subroutine string_assign_real_R8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r8p~~CallsGraph proc~string_assign_real_r8p string_assign_real_R8P interface~str str proc~string_assign_real_r8p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P","tags":"","loc":"proc/string_assign_real_r8p.html","title":"string_assign_real_R8P  FoXy"},{"text":"private elemental subroutine string_assign_real_R16P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r16p~~CallsGraph proc~string_assign_real_r16p string_assign_real_R16P interface~str str proc~string_assign_real_r16p->interface~str proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p->proc~str_i1p proc~str_a_i2p->proc~str_i2p proc~str_a_i8p->proc~str_i8p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_r4p->proc~str_r4p Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P","tags":"","loc":"proc/string_assign_real_r16p.html","title":"string_assign_real_R16P  FoXy"},{"text":"private subroutine read_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Calls proc~~read_formatted~~CallsGraph proc~read_formatted read_formatted proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted->proc~get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. character(kind=CK,len=1), public :: delim String delimiter, if any. character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted","tags":"","loc":"proc/read_formatted.html","title":"read_formatted  FoXy"},{"text":"private subroutine read_delimited(dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. If the closing delimiter is followed by end of record, then we return end of record. Variables Type Visibility Attributes Name Initial character(kind=CK,len=1), public :: ch A character read. logical, public :: was_delim Indicates that the last character read was a delimiter. Source Code subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the end of record condition to the ! caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_delimited","tags":"","loc":"proc/read_delimited.html","title":"read_delimited  FoXy"},{"text":"private subroutine read_undelimited_listdirected(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. If input is terminated by end of record, then this procedure returns an end-of-record condition. Calls proc~~read_undelimited_listdirected~~CallsGraph proc~read_undelimited_listdirected read_undelimited_listdirected proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected->proc~get_decimal_mode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: decimal_point True if DECIMAL=POINT in effect. Source Code subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited_listdirected","tags":"","loc":"proc/read_undelimited_listdirected.html","title":"read_undelimited_listdirected  FoXy"},{"text":"private subroutine read_undelimited(dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the\n file remains at end of record. Variables Type Visibility Attributes Name Initial character(kind=CK,len=1), public :: ch A character read. Source Code subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited","tags":"","loc":"proc/read_undelimited.html","title":"read_undelimited  FoXy"},{"text":"private subroutine write_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. Source Code subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted","tags":"","loc":"proc/write_formatted.html","title":"write_formatted  FoXy"},{"text":"private subroutine read_unformatted(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted","tags":"","loc":"proc/read_unformatted.html","title":"read_unformatted  FoXy"},{"text":"private subroutine write_unformatted(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. Source Code subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted","tags":"","loc":"proc/write_unformatted.html","title":"write_unformatted  FoXy"},{"text":"private subroutine get_delimiter_mode(unit, delim, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=len=1,CK), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Description Get the DELIM changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of NONE is always returned. Variables Type Visibility Attributes Name Initial character(len=10), public :: delim_buffer Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_delimiter_mode","tags":"","loc":"proc/get_delimiter_mode.html","title":"get_delimiter_mode  FoXy"},{"text":"private subroutine get_next_non_blank_character_this_record(unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character in the current record. Called By proc~~get_next_non_blank_character_this_record~~CalledByGraph proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character in the current record. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_this_record","tags":"","loc":"proc/get_next_non_blank_character_this_record.html","title":"get_next_non_blank_character_this_record  FoXy"},{"text":"private subroutine get_next_non_blank_character_any_record(unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character, advancing records if necessary. Calls proc~~get_next_non_blank_character_any_record~~CallsGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_next_non_blank_character_any_record~~CalledByGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character, advancing records if necessary. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_any_record","tags":"","loc":"proc/get_next_non_blank_character_any_record.html","title":"get_next_non_blank_character_any_record  FoXy"},{"text":"private subroutine get_decimal_mode(unit, decimal_point, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the DECIMAL changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the\n actual value in force at the time of the call to this procedure. Called By proc~~get_decimal_mode~~CalledByGraph proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected read_undelimited_listdirected proc~read_undelimited_listdirected->proc~get_decimal_mode Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=5), public :: decimal_buffer Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_decimal_mode","tags":"","loc":"proc/get_decimal_mode.html","title":"get_decimal_mode  FoXy"},{"text":"Uses: penf befor64_pack_data_m module~~befor64~~UsesGraph module~befor64 befor64 module~befor64_pack_data_m befor64_pack_data_m module~befor64_pack_data_m->module~befor64 module~penf penf module~penf->module~befor64 module~penf->module~befor64_pack_data_m module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor64UsesGraph = svgPanZoom('#modulebefor64UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. BeFoR64, Base64 encoding/decoding library for FoRtran poor people. BeFoR64 BeFoR64, Base64 encoding/decoding library for FoRtran poor people BeFoR64 is a pure Fortran (KISS) library for base64 encoding/decoding for modern (2003+) Fortran projects; BeFoR64 is Fortran 2003+ standard compliant; BeFoR64 is a Free, Open Source Project. Table of Contents What is BeFoR64? Main features Copyrights Documentation A Taste of BeFoR64 Issues Compiler Support -brightgreen.svg) -brightgreen.svg) What is BeFoR64? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, BeFoR64 provides an easy to use module library for encoding and decoding Fortran types (binary internal representation) in ascii- base64 -encoded string. Go to Top Main features User-friendly methods for encoding/decoding in base64: encode real/integer scalar variables; decode real/integer scalar variables; encode real/integer array variables; decode real/integer array variables; encode character scalar variables; decode character scalar variables; encode character array variables; decode character array variables; encode unlimited polymorphic scalar variables; decode unlimited polymorphic scalar variables; encode unlimited polymorphic array variables; decode unlimited polymorphic array variables; user-friendly methods for packing heterogeneous data: pack integer/integer (different kinds) scalars; pack integer/integer (different kinds) arrays; pack real/real (different kinds) scalars; pack real/real (different kinds) arrays; pack integer/real scalars; pack integer/real arrays; errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights BeFoR64 is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to BeFoR64 is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the BeFoR64 documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of BeFoR64 Let us assume our goal is encoding a binary integer. It is as simple as use befor64 ... character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) print \"(A)\" , code64 But you are not limited to a simple integer scalar, you can encode real, integer, characters scalar or arrays, and by means of the auxiliary Lib_Pack library also mixed types. See the wiki . Go to Top Used By module~~befor64~~UsedByGraph module~befor64 befor64 module~stringifor_string_t stringifor_string_t module~befor64->module~stringifor_string_t module~stringifor stringifor module~stringifor_string_t->module~stringifor module~foxy_xml_tag foxy_xml_tag module~stringifor->module~foxy_xml_tag module~foxy_xml_file foxy_xml_file module~foxy_xml_tag->module~foxy_xml_file module~foxy foxy module~foxy_xml_tag->module~foxy module~foxy_xml_file->module~foxy program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple var panmodulebefor64UsedByGraph = svgPanZoom('#modulebefor64UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_b64_initialized = .false. Flag for checking the initialization of the library. character(len=64), private :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" Base64 alphabet. Interfaces public interface b64_encode Encode numbers (integer and real) to base64. private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. public interface b64_encode_up Encode unlimited polymorphic variable to base64. public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public interface b64_decode Decode numbers (integer and real) from base64. private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public interface b64_decode_up Decode unlimited polymorphic variable from base64. public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Subroutines public subroutine b64_init () Arguments None Description Initialize the BeFoR64 library. private pure subroutine encode_bits (bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). private pure subroutine decode_bits (code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. public subroutine b64_encode_up (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public subroutine b64_decode_up (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. private pure subroutine b64_encode_R16 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_R16_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. private elemental subroutine b64_decode_R16 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_R16_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public subroutine autotest () Arguments None Description Procedure for autotesting the library functionalities.","tags":"","loc":"module/befor64.html","title":"befor64  FoXy"},{"text":"Uses: penf module~~befor64_pack_data_m~~UsesGraph module~befor64_pack_data_m befor64_pack_data_m module~penf penf module~penf->module~befor64_pack_data_m module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor64_pack_data_mUsesGraph = svgPanZoom('#modulebefor64_pack_data_mUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. KISS library for packing heterogeneous data into single (homogeneous) packed one. Used By module~~befor64_pack_data_m~~UsedByGraph module~befor64_pack_data_m befor64_pack_data_m module~befor64 befor64 module~befor64_pack_data_m->module~befor64 module~stringifor_string_t stringifor_string_t module~befor64->module~stringifor_string_t module~stringifor stringifor module~stringifor_string_t->module~stringifor module~foxy_xml_tag foxy_xml_tag module~stringifor->module~foxy_xml_tag module~foxy_xml_file foxy_xml_file module~foxy_xml_tag->module~foxy_xml_file module~foxy foxy module~foxy_xml_tag->module~foxy module~foxy_xml_file->module~foxy program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple var panmodulebefor64_pack_data_mUsedByGraph = svgPanZoom('#modulebefor64_pack_data_mUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface pack_data Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Subroutines private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"module/befor64_pack_data_m.html","title":"befor64_pack_data_m  FoXy"},{"text":"Uses: foxy_xml_file foxy_xml_tag penf module~~foxy~~UsesGraph module~foxy foxy module~foxy_xml_file foxy_xml_file module~foxy_xml_file->module~foxy module~foxy_xml_tag foxy_xml_tag module~foxy_xml_tag->module~foxy module~foxy_xml_tag->module~foxy_xml_file module~penf penf module~penf->module~foxy module~penf->module~foxy_xml_file module~penf->module~foxy_xml_tag module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor->module~foxy_xml_tag module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulefoxyUsesGraph = svgPanZoom('#modulefoxyUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FoXy, Fortran XML parser for poor people Used By module~~foxy~~UsedByGraph module~foxy foxy program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/foxy.html","title":"foxy  FoXy"},{"text":"Uses: foxy_xml_tag penf module~~foxy_xml_file~~UsesGraph module~foxy_xml_file foxy_xml_file module~foxy_xml_tag foxy_xml_tag module~foxy_xml_tag->module~foxy_xml_file module~penf penf module~penf->module~foxy_xml_file module~penf->module~foxy_xml_tag module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor->module~foxy_xml_tag module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulefoxy_xml_fileUsesGraph = svgPanZoom('#modulefoxy_xml_fileUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FoXy XML file class. Used By module~~foxy_xml_file~~UsedByGraph module~foxy_xml_file foxy_xml_file module~foxy foxy module~foxy_xml_file->module~foxy program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: xml_file Components Type Visibility Attributes Name Initial integer(kind=I4P), private :: Nt = 0 Number of XML tags. type( xml_tag ), private, allocatable :: tag (:) XML tags array. Finalizations Procedures final :: finalize","tags":"","loc":"module/foxy_xml_file.html","title":"foxy_xml_file  FoXy"},{"text":"Uses: penf stringifor module~~foxy_xml_tag~~UsesGraph module~foxy_xml_tag foxy_xml_tag module~stringifor stringifor module~stringifor->module~foxy_xml_tag module~penf penf module~penf->module~foxy_xml_tag module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulefoxy_xml_tagUsesGraph = svgPanZoom('#modulefoxy_xml_tagUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FoXy XML tag class. Used By module~~foxy_xml_tag~~UsedByGraph module~foxy_xml_tag foxy_xml_tag module~foxy_xml_file foxy_xml_file module~foxy_xml_tag->module~foxy_xml_file module~foxy foxy module~foxy_xml_tag->module~foxy module~foxy_xml_file->module~foxy program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: xml_tag Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: tag_name Tag name. character(len=:), private, allocatable :: tag_val Tag value. type( string ), private, allocatable :: att_name (:) Attributes names. type( string ), private, allocatable :: att_val (:) Attributes values. Finalizations Procedures final :: finalize","tags":"","loc":"module/foxy_xml_tag.html","title":"foxy_xml_tag  FoXy"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf penf module~penf_global_parameters_variables->module~penf module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~foxy_xml_tag foxy_xml_tag module~penf->module~foxy_xml_tag module~foxy foxy module~penf->module~foxy module~befor64 befor64 module~penf->module~befor64 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~foxy_xml_file foxy_xml_file module~penf->module~foxy_xml_file module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~penf_stringify->module~penf module~foxy_xml_tag->module~foxy module~foxy_xml_tag->module~foxy_xml_file program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple module~befor64->module~stringifor_string_t module~stringifor->module~foxy_xml_tag module~befor64_pack_data_m->module~befor64 module~foxy_xml_file->module~foxy module~stringifor_string_t->module~stringifor var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables  FoXy"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF bit/byte size functions. Used By module~~penf_b_size~~UsedByGraph module~penf_b_size penf_b_size module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf penf module~penf_b_size->module~penf module~penf_stringify->module~penf module~foxy_xml_tag foxy_xml_tag module~penf->module~foxy_xml_tag module~foxy foxy module~penf->module~foxy module~befor64 befor64 module~penf->module~befor64 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~foxy_xml_file foxy_xml_file module~penf->module~foxy_xml_file module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~foxy_xml_tag->module~foxy module~foxy_xml_tag->module~foxy_xml_file program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple module~befor64->module~stringifor_string_t module~stringifor->module~foxy_xml_tag module~befor64_pack_data_m->module~befor64 module~foxy_xml_file->module~foxy module~stringifor_string_t->module~stringifor var panmodulepenf_b_sizeUsedByGraph = svgPanZoom('#modulepenf_b_sizeUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Functions private elemental function bit_size_R16P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R16P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size  FoXy"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf_stringify iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_global_parameters_variables->module~penf_b_size Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf penf module~penf_stringify->module~penf module~foxy_xml_tag foxy_xml_tag module~penf->module~foxy_xml_tag module~foxy foxy module~penf->module~foxy module~befor64 befor64 module~penf->module~befor64 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~foxy_xml_file foxy_xml_file module~penf->module~foxy_xml_file module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~foxy_xml_tag->module~foxy module~foxy_xml_tag->module~foxy_xml_file program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple module~befor64->module~stringifor_string_t module~stringifor->module~foxy_xml_tag module~befor64_pack_data_m->module~befor64 module~foxy_xml_file->module~foxy module~stringifor_string_t->module~stringifor var panmodulepenf_stringifyUsedByGraph = svgPanZoom('#modulepenf_stringifyUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Functions private elemental function strf_R16P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_R16P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R16P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private function ctor_R16P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. private elemental function bstr_R16P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bctor_R16P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify  FoXy"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Portability Environment for Fortran poor people. PENF PENF, Portability Environment for Fortran poor people A KISS library for exploiting codes portability for modern (2003+) Fortran projects. PENF is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; PENF provides many number-to-string and viceversa facilities; PENF is Fortran 2003+ standard compliant; PENF is a Free, Open Source Project. Table of Contents What is PENF? Main features Copyrights Documentation A Taste of PENF Issues Compiler Support What is PENF? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. PENF module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights PENF is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to PENF is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the PENF documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of PENF To be written. Go to Top Used By module~~penf~~UsedByGraph module~penf penf module~foxy_xml_tag foxy_xml_tag module~penf->module~foxy_xml_tag module~foxy foxy module~penf->module~foxy module~befor64 befor64 module~penf->module~befor64 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~foxy_xml_file foxy_xml_file module~penf->module~foxy_xml_file module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~foxy_xml_tag->module~foxy module~foxy_xml_tag->module~foxy_xml_file program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple module~befor64->module~stringifor_string_t module~stringifor->module~foxy_xml_tag module~befor64_pack_data_m->module~befor64 module~foxy_xml_file->module~foxy module~stringifor_string_t->module~stringifor var panmodulepenfUsedByGraph = svgPanZoom('#modulepenfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Functions private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Subroutines public subroutine check_endian () Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. public subroutine penf_init () Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data.","tags":"","loc":"module/penf.html","title":"penf  FoXy"},{"text":"Uses: penf stringifor_string_t module~~stringifor~~UsesGraph module~stringifor stringifor module~penf penf module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor_string_t->module~stringifor module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 var panmodulestringiforUsesGraph = svgPanZoom('#modulestringiforUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor, Strings Fortran, yet another stringify Fortran module Used By module~~stringifor~~UsedByGraph module~stringifor stringifor module~foxy_xml_tag foxy_xml_tag module~stringifor->module~foxy_xml_tag module~foxy_xml_file foxy_xml_file module~foxy_xml_tag->module~foxy_xml_file module~foxy foxy module~foxy_xml_tag->module~foxy module~foxy_xml_file->module~foxy program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface adjustl Builtin adjustl overloading. public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). public interface adjustr Builtin adjustr overloading. public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). public interface count Builtin count overloading. private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. public interface index Builtin index overloading. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public interface len Builtin len overloading. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. public interface len_trim Builtin len_trim overloading. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. public interface repeat Builtin repeat overloading. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. public interface scan Builtin scan overloading. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public interface trim Builtin trim overloading. public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Functions private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. Subroutines public subroutine read_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. public subroutine read_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read lines (records) from a connected-formatted unit. public subroutine write_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected-formatted unit. public subroutine write_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file.","tags":"","loc":"module/stringifor.html","title":"stringifor  FoXy"},{"text":"Uses: befor64 penf module~~stringifor_string_t~~UsesGraph module~stringifor_string_t stringifor_string_t module~befor64 befor64 module~befor64->module~stringifor_string_t module~penf penf module~penf->module~stringifor_string_t module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64_pack_data_m->module~befor64 module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulestringifor_string_tUsesGraph = svgPanZoom('#modulestringifor_string_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor, definition of string type. Used By module~~stringifor_string_t~~UsedByGraph module~stringifor_string_t stringifor_string_t module~stringifor stringifor module~stringifor_string_t->module~stringifor module~foxy_xml_tag foxy_xml_tag module~stringifor->module~foxy_xml_tag module~foxy_xml_file foxy_xml_file module~foxy_xml_tag->module~foxy_xml_file module~foxy foxy module~foxy_xml_tag->module~foxy module~foxy_xml_file->module~foxy program~parse_file_simple parse_file_simple module~foxy->program~parse_file_simple program~parse_string_simple parse_string_simple module~foxy->program~parse_string_simple var panmodulestringifor_string_tUsedByGraph = svgPanZoom('#modulestringifor_string_tUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Default character kind. character(kind=CK,len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(kind=CK,len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(kind=CK,len=1), private, parameter :: SPACE = ' ' Space character. character(kind=CK,len=1), private, parameter :: TAB = achar(9) Tab character. character(kind=CK,len=1), private, parameter :: UIX_DIR_SEP = char(47) Unix/Linux directories separator (/). character(kind=CK,len=1), private, parameter :: BACKSLASH = char(92) Backslash character. Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. procedure, public, pass(self) :: count => scount Count replacement. generic, public :: index => sindex_string_string, sindex_string_character Index replacement. procedure, public, pass(self) :: len => slen Len replacement. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. generic, public :: repeat => srepeat_string_string, srepeat_character_string Repeat replacement. generic, public :: scan => sscan_string_string, sscan_string_character Scan replacement. procedure, public, pass(self) :: trim => strim Trim replacement. procedure, public, pass(self) :: verify => sverify Verify replacement. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. procedure, public, pass(self) :: decode Decode string. procedure, public, pass(self) :: encode Encode string. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. generic, public :: insert => insert_string, insert_character Insert substring into string at a specified position. generic, public :: join => join_strings, join_characters Return a string that is a join of an array of strings or characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file Read a file a single string stream. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. procedure, public, pass(self) :: slice Return the raw characters data sliced. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P, to_integer_I2P, to_integer_I4P, to_integer_I8P, to_real_R4P, to_real_R8P Cast string to number. procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. procedure, public, pass(self) :: write_file Write a single string stream into file. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string, string_assign_character, string_assign_integer_I1P, string_assign_integer_I2P, string_assign_integer_I4P, string_assign_integer_I8P, string_assign_real_R4P, string_assign_real_R8P Assignment operator overloading. generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string Concatenation operator (string output) overloading. generic, public :: operator(==) => string_eq_string, string_eq_character, character_eq_string Equal operator overloading. generic, public :: operator(/=) => string_ne_string, string_ne_character, character_ne_string Not equal operator overloading. generic, public :: operator(<) => string_lt_string, string_lt_character, character_lt_string Lower than operator overloading. generic, public :: operator(<=) => string_le_string, string_le_character, character_le_string Lower equal than operator overloading. generic, public :: operator(>=) => string_ge_string, string_ge_character, character_ge_string Greater equal than operator overloading. generic, public :: operator(>) => string_gt_string, string_gt_character, character_gt_string Greater than operator overloading. generic, public :: read(formatted) => read_formatted Formatted input. generic, public :: write(formatted) => write_formatted Formatted output. generic, public :: read(unformatted) => read_unformatted Unformatted input. generic, public :: write(unformatted) => write_unformatted Unformatted output. procedure, private, pass(self) :: sindex_string_string Index replacement. procedure, private, pass(self) :: sindex_string_character Index replacement. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. procedure, private, pass(self) :: srepeat_character_string Repeat replacement. procedure, private, pass(self) :: sscan_string_string Scan replacement. procedure, private, pass(self) :: sscan_string_character Scan replacement. procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings Return join string of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. procedure, private, pass(self) :: to_integer_I2P Cast string to integer. procedure, private, pass(self) :: to_integer_I4P Cast string to integer. procedure, private, pass(self) :: to_integer_I8P Cast string to integer. procedure, private, pass(self) :: to_real_R4P Cast string to real. procedure, private, pass(self) :: to_real_R8P Cast string to real. procedure, private, pass(self) :: to_real_R16P Cast string to real. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted Formatted input. procedure, private, pass(dtv) :: read_delimited Read a delimited input. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. procedure, private, pass(dtv) :: write_formatted Formatted output. procedure, private, pass(dtv) :: read_unformatted Unformatted input. procedure, private, pass(dtv) :: write_unformatted Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. Description OOP designed string class. Functions private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. private elemental function decode (self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. private elemental function encode (self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. private pure function slice (self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. private elemental function strip (self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. private subroutine read_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. private subroutine read_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. private subroutine read_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. private subroutine write_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. private subroutine write_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. private subroutine write_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. private subroutine get_delimiter_mode (unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=len=1,CK), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Description Get the DELIM changeable connection mode for the given unit. private subroutine get_next_non_blank_character_this_record (unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character in the current record. private subroutine get_next_non_blank_character_any_record (unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character, advancing records if necessary. private subroutine get_decimal_mode (unit, decimal_point, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the DECIMAL changeable connection mode for the given unit.","tags":"","loc":"module/stringifor_string_t.html","title":"stringifor_string_t  FoXy"},{"text":"Uses: foxy program~~parse_file_simple~~UsesGraph program~parse_file_simple parse_file_simple module~foxy foxy module~foxy->program~parse_file_simple module~foxy_xml_file foxy_xml_file module~foxy_xml_file->module~foxy module~foxy_xml_tag foxy_xml_tag module~foxy_xml_tag->module~foxy module~foxy_xml_tag->module~foxy_xml_file module~penf penf module~penf->module~foxy module~penf->module~foxy_xml_file module~penf->module~foxy_xml_tag module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor->module~foxy_xml_tag module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panprogramparse_file_simpleUsesGraph = svgPanZoom('#programparse_file_simpleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FoXy test. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_file ) :: xfile XML file handler. integer :: xunit XML file unit. logical :: test_passed (1) List of passed tests. Source Code program parse_file_simple !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. integer :: xunit !< XML file unit. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source open ( newunit = xunit , file = 'parse_file_simple.xml' , access = 'STREAM' , form = 'UNFORMATTED' ) write ( unit = xunit ) source close ( unit = xunit ) print \"(A)\" , 'Parsing file' call xfile % parse ( filename = 'parse_file_simple.xml' ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) open ( newunit = xunit , file = 'parse_file_simple.xml' ) close ( unit = xunit , status = 'DELETE' ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram parse_file_simple","tags":"","loc":"program/parse_file_simple.html","title":"parse_file_simple  FoXy"},{"text":"Uses: foxy program~~parse_string_simple~~UsesGraph program~parse_string_simple parse_string_simple module~foxy foxy module~foxy->program~parse_string_simple module~foxy_xml_file foxy_xml_file module~foxy_xml_file->module~foxy module~foxy_xml_tag foxy_xml_tag module~foxy_xml_tag->module~foxy module~foxy_xml_tag->module~foxy_xml_file module~penf penf module~penf->module~foxy module~penf->module~foxy_xml_file module~penf->module~foxy_xml_tag module~stringifor stringifor module~penf->module~stringifor module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~stringifor->module~foxy_xml_tag module~stringifor_string_t->module~stringifor module~befor64->module~stringifor_string_t module~befor64_pack_data_m->module~befor64 module~penf_b_size penf_b_size module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panprogramparse_string_simpleUsesGraph = svgPanZoom('#programparse_string_simpleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help  Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FoXy test. Variables Type Attributes Name Initial character(len=:), allocatable :: source String containing the source XML data. character(len=:), allocatable :: parsed String containing the parsed XML data. type( xml_file ) :: xfile XML file handler. logical :: test_passed (1) List of passed tests. Source Code program parse_string_simple !----------------------------------------------------------------------------------------------------------------------------------- !< FoXy test. !----------------------------------------------------------------------------------------------------------------------------------- use foxy , only : xml_file !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none character ( len = :), allocatable :: source !< String containing the source XML data. character ( len = :), allocatable :: parsed !< String containing the parsed XML data. type ( xml_file ) :: xfile !< XML file handler. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . print \"(A)\" , 'Input XML data:' source = '<first x=\"1\" y=\"c\" z=\"2\">lorem ipsum...</first>' // new_line ( 'a' ) // & '<second a1=\"2\"/>' // new_line ( 'a' ) // & '<third>bye</third>' // new_line ( 'a' ) // & '<fourth a=\"3\">bye bye Mrs. Robinson</fourth>' // new_line ( 'a' ) // & '<fift>' // new_line ( 'a' ) // & '  <nested level=\"1\">I am supported! Nested tag at level 1</nested>' // new_line ( 'a' ) // & '  <nested2 level=\"1\">' // new_line ( 'a' ) // & '    <nested3 level=\"2\">Nested tag at level 2</nested3>' // new_line ( 'a' ) // & '  </nested2>' // new_line ( 'a' ) // & '</fift>' print \"(A)\" , source print \"(A)\" , 'Parsing file' call xfile % parse ( string = source ) print \"(A)\" , 'Parsed data' parsed = xfile % stringify () print \"(A)\" , parsed test_passed ( 1 ) = trim ( source ) == trim ( parsed ) print \"(A,L1)\" , 'Is parsed data correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram parse_string_simple","tags":"","loc":"program/parse_string_simple.html","title":"parse_string_simple  FoXy"}]}