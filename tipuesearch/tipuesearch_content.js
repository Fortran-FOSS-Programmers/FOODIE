var tipuesearch = {"pages":[{"text":"FOODiE FOODiE FOODiE, Fortran Object oriented Ordinary Differential Equations integration library FOODiE is a pure Fortran (KISS) library for integrating Ordinary Differential Equations (ODE); FOODiE is Fortran 2003+ standard compliant; FOODiE is OOP designed; FOODiE is a Free, Open Source Project. Table of Contents What is FOODiE? Main features Status Copyrights Documentation What is FOODiE? Modern Fortran standards (2003+) have introduced support for Object Oriented Programming. Exploiting new features like Abstract Data Type (ADT) is now possible to develop a KISS library for integrating Ordinary Differential Equations on ADT making the development of new numerical schemes faster, easier and clearer. Go to Top Main features FOODiE is aimed to be a KISS-pure-Fortran library for integrating Ordinary Differential Equations (ODE), it being: Pure Fortran implementation; KISS and user-friendly: simple API, presently based on the Rouson's Abstract Data Type Pattern [1]; easy building and porting on heterogeneous architectures; comprehensive: explicit Euler scheme, 1st order accurate; explicit Runge-Kutta schemes: TVD or SSP schemes, see [2]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages, 2nd order accurate; 3 stages, 3rd order accurate; 4 stages; 5 stages, 4th order accurate; implicit Runge-Kutta schemes; low-storage explicit schemes, see [2,3,3]; Leapfrog, 2nd order accurate: Robert-Asselin filter, for stability and leapfrog, 1st order accurate; Robert-Asselin-Williams filter, for stability and leapfrog, 3rd order accurate; Adams-Bashforth variants of 2nd and 3rd order accurate; efficient: high scalability on parallel architectures: support for shared memory multi/many cores architecture; support for distributed memory cluster; support for GPGPU/accelerators device; Tests-Driven Developed (TDD): well documented: clear documentation of schemes implementations; complete API reference; comprehensive wiki: collaborative developed; FOSS licensed; Any feature request is welcome. Bibliography [1] Scientific Software Design: The Object-Oriented Way , Rouson, Damian and Xia, Jim and Xu, Xiaofeng, 2011, ISBN 9780521888134, Cambridge University Press, New York, NY, USA. [2] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. [3] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [4] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, June 1994. Go to Top Status FOODiE project is young, but developed with love. A bunch of integrators have been implemented using the Rouson's Abstract Data Type Pattern and test with complex problems, but the library API is not stable. Nevertheless, FOODiE is already proven to be able to integrate a wide range of different ODE problems, from pure ODEs (Lorenz and inertial oscillations equations) to complex PDEs (Burgers and Euler equations), see the documentation. We are searching for Fortraners enthusiast joining our team. Copyrights FOODiE is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FOODiE is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FOODiE documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"","loc":"index.html","title":" FOODiE "},{"text":"Source Code module foodie !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODiE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODiE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< !<+ *forward explicit Euler* scheme, a 1st order accurate scheme; !<+ *TVD or SSP Runge-Kutta* class schemes: !<    + TVD(1,1): 1 stage, 1st order scheme, namely the forward explicit Euler one; !<    + SSP(2,2): 2 stages, 2nd order scheme; !<    + SSP(3,3): 3 stages, 3rd order scheme; !<    + SSP(5,4): 5 stages, 4th order scheme; !< !<### Usage !< !< FOODiE schemes must be applied to only subclass extensions of the abstract class *type_integrand*. !< !< To use FOODiE you must: !< !<#### extend type_integrand abstract class provided by FOODiE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODiE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: output                                          !< Extract Lorenz field. !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !< endtype lorenz !<``` !< !<#### use one of the provided FOODiE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : euler_explicit_integrator !< use type_lorenz, only : lorenz !< type(euler_explicit_integrator) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use type_integrand , only : integrand use foodie_integrator_euler_explicit , only : euler_explicit_integrator use foodie_integrator_tvd_runge_kutta , only : tvd_runge_kutta_integrator use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand public :: euler_explicit_integrator public :: tvd_runge_kutta_integrator public :: adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. Source Code !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. module foodie_integrator_adams_bashforth !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is: !< !<  U&#94;{n+s} = U&#94;{n+s-1} +\\Delta t \\left[ \\sum_{i=1}&#94;{n+s}{ b_i \\cdot R(t&#94;{n+i-1}, U&#94;{n+i-1}) } \\right]  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients \\b define the actual scheme, that is selected accordingly to the number of !< **steps** used. !< !< Currently the following schemes are available: !<##### 1 step, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !< The *b* coefficient is: !< b = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  !< !<##### 2 steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 3 steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_bashforth_integrator !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. !< !< @note The integrator must be created or initialized (initialize the *b* coeficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , field , dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: dt !< Time step. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps field = field + field % t ( n = s ) * ( dt * self % b ( s )) enddo call field % update_previous_steps return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth.f90.html","title":"foodie_integrator_adams_bashforth.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Source Code !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_explicit_integrator !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine integrate ( field , dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field + field % t () * dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. Source Code !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. module foodie_integrator_tvd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< The class of integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax (see Butcher, J.C., *Coefficients for the study of !< Runge-Kutta integration processes*, J. Austral. Math. Soc., Vol. 3, pages: 185--201, 1963). !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !< |                 |                   |                   |            |                    | !< |-----------------|-------------------|-------------------|------------|--------------------| !< | \\gamma&#94;1    | \\alpha&#94;{1,1}  | \\alpha&#94;{1,2}  | \\cdots | \\alpha&#94;{1,Ns}  | !< | \\gamma&#94;2    | \\alpha&#94;{2,1}  | \\alpha&#94;{2,2}  | \\cdots | \\alpha&#94;{2,Ns}  | !< | \\vdots      | \\vdots        | \\vdots        | \\ddots | \\vdots         | !< | \\gamma&#94;{Ns} | \\alpha&#94;{Ns,1} | \\alpha&#94;{Ns,2} | \\cdots | \\alpha&#94;{Ns,Ns} | !< |                 | \\beta&#94;1       | \\beta&#94;2       | \\cdots | \\beta&#94;{Ns}     | !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !< |                 |                   |                   |            |                    | !< |-----------------|-------------------|-------------------|------------|--------------------| !< | \\gamma&#94;1    |       0       |       0       | \\cdots |         0      | !< | \\gamma&#94;2    | \\alpha&#94;{2,1}  | \\alpha&#94;{2,2}  | \\cdots | \\alpha&#94;{2,Ns}  | !< | \\vdots      | \\vdots        | \\vdots        | \\ddots | \\vdots         | !< | \\gamma&#94;{Ns} | \\alpha&#94;{Ns,1} | \\alpha&#94;{Ns,2} | \\cdots |         0      | !< |                 | \\beta&#94;1       | \\beta&#94;2       | \\cdots | \\beta&#94;{Ns}     | !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !< \\beta = \\left[1\\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0 \\end{array}} \\right] !< \\gamma = \\left[0\\right] !< !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm. See *High Order Strong Stability Preserving Time !< Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, !< pp. 251-289. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2}&\\frac{1}{2} \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0\\\\ 1&0 \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\end{array}} \\right] !< !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm. See *High Order Strong Stability Preserving Time !< Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, !< pp. 251-289. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{6}&\\frac{1}{6}&\\frac{1}{3}  \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0&0\\\\ 1&0&0\\\\ \\frac{1}{4}&\\frac{1}{4}&0 \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\\\ \\frac{1}{2} \\end{array}} \\right] !< !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm. See *High Order Strong Stability Preserving Time !< Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, !< pp. 251-289. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} 0.14681187618661&0.24848290924556&0.10425883036650&0.27443890091960& !< 0.22600748319395 \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} !< 0&0&0&0&0 \\\\ 0.39175222700392&0&0&0&0 \\\\ 0.21766909633821&0.36841059262959&0&0&0 \\\\ 0.08269208670950& !< 0.13995850206999&0.25189177424738&0&0 \\\\ 0.06796628370320&0.11503469844438&0.20703489864929&0.54497475021237&0 !< \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0\\\\0.39175222700392\\\\0.58607968896780\\\\0.47454236302687\\\\0.93501063100924 !<           \\end{array}} \\right] !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: tvd_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator interface tvd_runge_kutta_integrator !< Overload tvd_runge_kutta_integrator name with the constructor function *create*. module procedure create endinterface tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function create ( stages ) result ( rk ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. type ( tvd_runge_kutta_integrator ) :: rk !< Actual RK integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk % init ( stages = stages ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction create ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , field , stage , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , size ( stage ) stage ( s ) = field do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , size ( stage ) field = field + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_tvd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_tvd_runge_kutta.f90.html","title":"foodie_integrator_tvd_runge_kutta.f90 – FOODiE"},{"text":"Define the abstract type integrand for building FOODiE ODE integrators. Source Code !< Define the abstract type *integrand* for building FOODiE ODE integrators. module type_integrand !----------------------------------------------------------------------------------------------------------------------------------- !< Define the abstract type *integrand* for building FOODiE ODE integrators. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: integrand !< Abstract type for building FOODiE ODE integrators. contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. procedure ( update_previous_steps ), pass ( self ), deferred , public :: update_previous_steps !< Time derivative, residuals. ! operators procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand oprator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< Integrand = real. ! operators overloading generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading = assignament. endtype integrand abstract interface !< Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). pure function time_derivative ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative function of integrand class, i.e. the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , I_P class ( integrand ), intent ( IN ) :: self !< Integrand field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Result of the time derivative function of integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction time_derivative pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update the previous time steps (of integrand field) for multi-step(level) ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: self !< Integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps pure function integrand_op_real ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator integrand.op.real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction integrand_op_real pure function real_op_integrand ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator real.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_op_integrand pure function symmetric_operator ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric type operator integrand.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction symmetric_operator pure subroutine assignment_integrand ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric assignment integrand = integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_integrand pure subroutine assignment_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric assignment integrand = real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_real endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule type_integrand","tags":"","loc":"sourcefile/type_integrand.f90.html","title":"type_integrand.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Burgers equation. Source Code !< Test FOODiE with the integration of Burgers equation. program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results\" , & \"burgers --solver runge-kutta -r \" , & \"burgers --solver adams-bashforth\" , & \"burgers --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( field = domain , dt = dt ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = domain , dt = dt ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_burgers","tags":"","loc":"sourcefile/burgers.f90.html","title":"burgers.f90 – FOODiE"},{"text":"Define Burgers field that is a concrete extension of the abstract integrand type. Source Code !< Define Burgers field that is a concrete extension of the abstract integrand type. module type_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Define Burgers field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: burgers !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODiE integrand class. private integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: state !< Solution vector, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous steps solution vector, [1:Ni,1:steps]. contains ! public methods ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivate, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers oprator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers oprator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! operators overloading generic , public :: operator ( - ) => sub ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % state )) deallocate ( self % state ) ; allocate ( self % state ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % state = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt pure function dBurgers_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. type ( burgers ), allocatable :: delta !< Delta state used as temporary variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary variables allocate ( burgers :: delta ) delta % Ni = self % Ni delta % steps = self % steps delta % h = self % h delta % nu = self % nu delta % state = self % state if ( allocated ( self % previous )) delta % previous = self % previous ! Burgers residuals delta = self % xx ( n = n ) * self % nu delta = delta - self * self % x ( n = n ) call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % state endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps ! operators overloading pure function burgers_multiply_burgers ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( burgers ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) select type ( rhs ) class is ( burgers ) local_product % Ni = lhs % Ni local_product % steps = lhs % steps local_product % h = lhs % h local_product % nu = lhs % nu local_product % state = lhs % state * rhs % state if ( allocated ( lhs % previous )) local_product % previous = lhs % previous endselect call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers pure function burgers_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( burgers ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % Ni = lhs % Ni local_product % steps = lhs % steps local_product % h = lhs % h local_product % nu = lhs % nu local_product % state = lhs % state * rhs if ( allocated ( lhs % previous )) local_product % previous = lhs % previous call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real pure function real_multiply_burgers ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( burgers ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % Ni = rhs % Ni local_product % steps = rhs % steps local_product % h = rhs % h local_product % nu = rhs % nu local_product % state = rhs % state * lhs if ( allocated ( rhs % previous )) local_product % previous = rhs % previous call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers pure function add_burgers ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( burgers ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_sum ) select type ( rhs ) class is ( burgers ) local_sum % Ni = lhs % Ni local_sum % steps = lhs % steps local_sum % h = lhs % h local_sum % nu = lhs % nu local_sum % state = lhs % state + rhs % state if ( allocated ( lhs % previous )) local_sum % previous = lhs % previous endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers pure function sub_burgers ( lhs , rhs ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sub !< Subtraction. type ( burgers ), allocatable :: local_sub !< Temporary subtraction. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_sub ) select type ( rhs ) class is ( burgers ) local_sub % Ni = lhs % Ni local_sub % steps = lhs % steps local_sub % h = lhs % h local_sub % nu = lhs % nu local_sub % state = lhs % state - rhs % state if ( allocated ( lhs % previous )) local_sub % previous = lhs % previous endselect call move_alloc ( local_sub , sub ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers pure subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % state )) lhs % state = rhs % state if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers pure subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real ! private methods pure function dBurgers_dx ( self , n ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the first order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer , optional , intent ( IN ) :: n !< Time level. type ( burgers ), allocatable :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. integer :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( derivative ) derivative % Ni = self % Ni derivative % steps = self % steps derivative % h = self % h derivative % nu = self % nu derivative % state = self % state if ( allocated ( self % previous )) derivative % previous = self % previous if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n do i = 2 , self % Ni - 1 derivative % state ( i ) = ( self % previous ( i + 1 , dn ) - self % previous ( i - 1 , dn )) / ( 2._R_P * self % h ) enddo derivative % state ( 1 ) = ( self % previous ( 2 , dn ) - self % previous ( self % Ni , dn )) / ( 2._R_P * self % h ) derivative % state ( self % Ni ) = ( self % previous ( 1 , dn ) - self % previous ( self % Ni - 1 , dn )) / ( 2._R_P * self % h ) else ! self%previous should not be used, use directly self%state do i = 2 , self % Ni - 1 derivative % state ( i ) = ( self % state ( i + 1 ) - self % state ( i - 1 )) / ( 2._R_P * self % h ) enddo derivative % state ( 1 ) = ( self % state ( 2 ) - self % state ( self % Ni )) / ( 2._R_P * self % h ) derivative % state ( self % Ni ) = ( self % state ( 1 ) - self % state ( self % Ni - 1 )) / ( 2._R_P * self % h ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction pure function d2Burgers_dx2 ( self , n ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the second order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer , optional , intent ( IN ) :: n !< Time level. type ( burgers ), allocatable :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. integer :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( derivative ) derivative % Ni = self % Ni derivative % steps = self % steps derivative % h = self % h derivative % nu = self % nu derivative % state = self % state if ( allocated ( self % previous )) derivative % previous = self % previous if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n do i = 2 , self % Ni - 1 derivative % state ( i ) = ( self % previous ( i + 1 , dn ) - 2._R_P * self % previous ( i , dn ) + self % previous ( i - 1 , dn )) / ( self % h ** 2 ) enddo derivative % state ( 1 ) = ( self % previous ( 2 , dn ) - 2._R_P * self % previous ( 1 , dn ) + self % previous ( self % Ni , dn )) / ( self % h ** 2 ) derivative % state ( self % Ni ) = ( self % previous ( 1 , dn ) - 2._R_P * self % previous ( self % Ni , dn ) + self % previous ( self % Ni - 1 , dn )) / & ( self % h ** 2 ) else ! self%previous should not be used, use directly self%state do i = 2 , self % Ni - 1 derivative % state ( i ) = ( self % state ( i + 1 ) - 2._R_P * self % state ( i ) + self % state ( i - 1 )) / ( self % h ** 2 ) enddo derivative % state ( 1 ) = ( self % state ( 2 ) - 2._R_P * self % state ( 1 ) + self % state ( self % Ni )) / ( self % h ** 2 ) derivative % state ( self % Ni ) = ( self % state ( 1 ) - 2._R_P * self % state ( self % Ni ) + self % state ( self % Ni - 1 )) / ( self % h ** 2 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction endmodule type_burgers","tags":"","loc":"sourcefile/type_burgers.f90.html","title":"type_burgers.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Euler 1D PDEs system. Source Code !< Test FOODiE with the integration of Euler 1D PDEs system. program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.15_R_P !< Final time. integer ( I_P ), parameter :: Ni = 100 !< Number of grid cells. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. real ( R_P ) :: Dx = 1._R_P / Ni !< Space step discretization. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ) :: initial_state ( 1 : Np , 1 : Ni ) !< Initial state of primitive variables. real ( R_P ) :: x ( 1 : Ni ) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results\" , & \"euler-1D --solver runge-kutta -r \" , & \"euler-1D --solver adams-bashforth\" , & \"euler-1D --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler-time_serie.dat' , & t = t ) do while ( t < t_final ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( field = domain , dt = dt ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: ord !< Space order. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) rk_integrator = tvd_runge_kutta_integrator ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-rk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) rk_integrator = tvd_runge_kutta_integrator ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) step = 1 do while ( t < t_final ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = domain , dt = dt ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_euler_1D","tags":"","loc":"sourcefile/euler-1d.f90.html","title":"euler-1D.f90 – FOODiE"},{"text":"Define Euler 1D field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D field that is a concrete extension of the abstract integrand type. module type_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODiE integrand class. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative  variables are organized as an array of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Conservative (state) variables [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Conservative variables of previous time steps [:,:,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! public methods ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivate, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. ! operators overloading procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler oprator. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt pure function dEuler_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: dn !< Time level, dummy variable. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables if ( self % steps >= 2 ) then ! self%previous should be used, multi-step time integration dn = self % steps ; if ( present ( n )) dn = n do i = 1 , Ni P (:, i ) = self % conservative2primitive ( previous (:, i , dn )) enddo else ! self%U should be used, single-step time integration do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo endif call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps ! operators overloading pure function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler pure function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real pure function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler pure function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler pure subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler pure subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i , j , f , v !< Counters. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i , s !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i , s !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D","tags":"","loc":"sourcefile/type_euler-1d.f90.html","title":"type_euler-1D.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Lorenz equations. Source Code !< Test FOODiE with the integration of Lorenz equations. program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results\" , & \"lorenz --solver runge-kutta -r \" , & \"lorenz --solver adams-bashforth\" , & \"lorenz --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' , & filename = 'lorenz_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = attractor , dt = dt ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_lorenz","tags":"","loc":"sourcefile/lorenz.f90.html","title":"lorenz.f90 – FOODiE"},{"text":"Define Lorenz field that is a concrete extension of the abstract integrand type. Source Code !< Define Lorenz field that is a concrete extension of the abstract integrand type. module type_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Define Lorenz field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: state !< Solution vector, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous steps solution vector, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Intial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % state )) deallocate ( self % state ) ; allocate ( self % state ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % state = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function dLorenz_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. type ( lorenz ), allocatable :: delta !< Delta state used as temporary variables. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary delta allocate ( delta ) delta % dims = self % dims delta % steps = self % steps delta % state = self % state if ( allocated ( self % previous )) delta % previous = self % previous delta % sigma = self % sigma delta % rho = self % rho delta % beta = self % beta ! Lorenz equations if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n delta % state ( 1 ) = self % sigma * ( self % previous ( 2 , dn ) - self % previous ( 1 , dn )) delta % state ( 2 ) = self % previous ( 1 , dn ) * ( self % rho - self % previous ( 3 , dn )) - self % previous ( 2 , dn ) delta % state ( 3 ) = self % previous ( 1 , dn ) * self % previous ( 2 , dn ) - self % beta * self % previous ( 3 , dn ) else ! self%previous should not be used, use directly self%state delta % state ( 1 ) = self % sigma * ( self % state ( 2 ) - self % state ( 1 )) delta % state ( 2 ) = self % state ( 1 ) * ( self % rho - self % state ( 3 )) - self % state ( 2 ) delta % state ( 3 ) = self % state ( 1 ) * self % state ( 2 ) - self % beta * self % state ( 3 ) endif call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % state endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps pure function lorenz_multiply_lorenz ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) select type ( rhs ) class is ( lorenz ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs % state if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % sigma = lhs % sigma local_product % rho = lhs % rho local_product % beta = lhs % beta endselect call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz pure function lorenz_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % sigma = lhs % sigma local_product % rho = lhs % rho local_product % beta = lhs % beta call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real pure function real_multiply_lorenz ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = rhs % dims local_product % steps = rhs % steps local_product % state = rhs % state * lhs if ( allocated ( rhs % previous )) local_product % previous = rhs % previous local_product % sigma = rhs % sigma local_product % rho = rhs % rho local_product % beta = rhs % beta call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz pure function add_lorenz ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( lorenz ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: local_sum ) select type ( rhs ) class is ( lorenz ) local_sum % dims = lhs % dims local_sum % steps = lhs % steps local_sum % state = lhs % state + rhs % state if ( allocated ( lhs % previous )) local_sum % previous = lhs % previous local_sum % sigma = lhs % sigma local_sum % rho = lhs % rho local_sum % beta = lhs % beta endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz pure subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % state )) lhs % state = rhs % state if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz pure subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real endmodule type_lorenz","tags":"","loc":"sourcefile/type_lorenz.f90.html","title":"type_lorenz.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Oscillation equations. Source Code !< Test FOODiE with the integration of Oscillation equations. program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_oscillation , only : oscillation use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( oscillation ) :: attractor !< Oscillation field. integer , parameter :: num_steps = 1 e4 !< Maximum time steps. integer , parameter :: space_dimension = 2 !< Space dimensions. real ( R_P ), parameter :: f = 1 e - 4_R_P !< Frequency. real ( R_P ), parameter :: dt = 10 0._R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 0._R_P , 1._R_P ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results\" , & \"oscillation --solver runge-kutta -r \" , & \"oscillation --solver adams-bashforth\" , & \"oscillation --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Oscillation equations select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 2 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' ! initialize field call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integrations, explicit Euler' , & filename = 'oscillation_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'oscillation_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 3 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , f = f , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = attractor , dt = dt ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit ' // 'Adams-Bashforth ' // & trim ( str (. true ., s )) // ' steps' , & filename = 'oscillation_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_oscillation","tags":"","loc":"sourcefile/oscillation.f90.html","title":"oscillation.f90 – FOODiE"},{"text":"Define Oscillation field that is a concrete extension of the abstract integrand type. Source Code !< Define Oscillation field that is a concrete extension of the abstract integrand type. module type_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Define Oscillation field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: oscillation !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODiE integrand class. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: state !< Solution vector, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous steps solution vector, [1:dims,1:steps]. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. procedure , pass ( lhs ), public :: assign_real => oscillation_assign_real !< Oscillation = real. endtype oscillation !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init ( self , initial_state , f , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Intial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: f !< Frequency. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % state )) deallocate ( self % state ) ; allocate ( self % state ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % state = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % f = f return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function dOscillation_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. type ( oscillation ), allocatable :: delta !< Delta state used as temporary variables. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary delta allocate ( delta ) delta % dims = self % dims delta % steps = self % steps delta % state = self % state if ( allocated ( self % previous )) delta % previous = self % previous delta % f = self % f ! Oscillation equations if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n delta % state ( 1 ) = - self % f * self % previous ( 2 , dn ) delta % state ( 2 ) = self % f * self % previous ( 1 , dn ) else ! self%previous should not be used, use directly self%state delta % state ( 1 ) = - self % f * self % state ( 2 ) delta % state ( 2 ) = self % f * self % state ( 1 ) endif call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % state endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps pure function oscillation_multiply_oscillation ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( oscillation ), allocatable :: local_product !< Temporary product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) select type ( rhs ) class is ( oscillation ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs % state if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % f = lhs % f endselect call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation pure function oscillation_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( oscillation ), allocatable :: local_product !< Temporary product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % f = lhs % f call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real pure function real_multiply_oscillation ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( oscillation ), allocatable :: local_product !< Temporary product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = rhs % dims local_product % steps = rhs % steps local_product % state = rhs % state * lhs if ( allocated ( rhs % previous )) local_product % previous = rhs % previous local_product % f = rhs % f call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation pure function add_oscillation ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( oscillation ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: local_sum ) select type ( rhs ) class is ( oscillation ) local_sum % dims = lhs % dims local_sum % steps = lhs % steps local_sum % state = lhs % state + rhs % state if ( allocated ( lhs % previous )) local_sum % previous = lhs % previous local_sum % f = lhs % f endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation pure subroutine oscillation_assign_oscillation ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % state )) lhs % state = rhs % state if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % f = rhs % f endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation pure subroutine oscillation_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_real endmodule type_oscillation","tags":"","loc":"sourcefile/type_oscillation.f90.html","title":"type_oscillation.f90 – FOODiE"},{"text":"type, public :: adams_bashforth_integrator FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. Note The integrator must be created or initialized (initialize the b coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destoy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, field, dt) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: dt Time step. Description Integrate field with Adams-Bashforth class scheme. Source Code type :: adams_bashforth_integrator !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. !< !< @note The integrator must be created or initialized (initialize the *b* coeficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_integrator","tags":"","loc":"type/adams_bashforth_integrator.html","title":"adams_bashforth_integrator – FOODiE "},{"text":"type, public :: euler_explicit_integrator FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Note The integrator can be used directly without any initialization. Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. private subroutine integrate (field, dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: dt Time step. Description Integrate field with explicit Euler scheme, 1st order. Source Code type :: euler_explicit_integrator !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator","tags":"","loc":"type/euler_explicit_integrator.html","title":"euler_explicit_integrator – FOODiE "},{"text":"type, public :: tvd_runge_kutta_integrator FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Constructor public interface tvd_runge_kutta_integrator Overload tvd_runge_kutta_integrator name with the constructor function create . private elementalfunction create (stages) result(rk) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type( tvd_runge_kutta_integrator ) Actual RK integrator. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, field, stage, Dt) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODiE "},{"text":"type, public, abstract :: integrand Abstract type for building FOODiE ODE integrators. Type-Bound Procedures procedure( time_derivative ), public, pass(self), deferred :: t Time derivative, residuals. purefunction time_derivative (self, n) result(dState_dt) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. procedure( update_previous_steps ), public, pass(self), deferred :: update_previous_steps Time derivative, residuals. puresubroutine update_previous_steps (self) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: self Integrand field. Description Update the previous time steps (of integrand field) for multi-step(level) ODE solvers. procedure( symmetric_operator ), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. purefunction symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( integrand_op_real ), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. purefunction integrand_op_real (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. procedure( real_op_integrand ), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. purefunction real_op_integrand (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: add Integrand + integrand oprator. purefunction symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( assignment_integrand ), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. puresubroutine assignment_integrand (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. procedure( assignment_real ), public, pass(lhs), deferred :: assign_real Integrand = real. puresubroutine assignment_real (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real. generic, public :: operator(+) => add Overloading + operator. pass(lhs) deferred add () Arguments None Description Integrand + integrand oprator. generic, public :: operator(*) => integrand_multiply_integrand , real_multiply_integrand , integrand_multiply_real Overloading * operator. pass(lhs) deferred integrand_multiply_integrand () Arguments None Description Integrand * integrand operator. pass(rhs) deferred real_multiply_integrand () Arguments None Description Real * integrand operator. pass(lhs) deferred integrand_multiply_real () Arguments None Description Integrand * real operator. generic, public :: assignment(=) => assign_integrand , assign_real Overloading = assignament. pass(lhs) deferred assign_integrand () Arguments None Description Integrand = integrand. pass(lhs) deferred assign_real () Arguments None Description Integrand = real. Source Code type , abstract :: integrand !< Abstract type for building FOODiE ODE integrators. contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. procedure ( update_previous_steps ), pass ( self ), deferred , public :: update_previous_steps !< Time derivative, residuals. ! operators procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand oprator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< Integrand = real. ! operators overloading generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading = assignament. endtype integrand","tags":"","loc":"type/integrand.html","title":"integrand – FOODiE "},{"text":"type, public, extends(integrand) :: burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Burgers equations field. It is a FOODiE integrand class. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: state Solution vector, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous steps solution vector, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. procedure, public, pass(self) :: output Extract Burgers field. private function output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivate, residuals function. private purefunction dBurgers_dt (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. Description Update previous time steps. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. private purefunction burgers_multiply_burgers (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Burgers field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. private purefunction burgers_multiply_real (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Burgers field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. private purefunction real_multiply_burgers (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Burgers field. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers oprator. private purefunction add_burgers (lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Burgers fields. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers oprator. private purefunction sub_burgers (lhs, rhs) result(sub) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Subtraction. Description Subtract two Burgers fields. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. private puresubroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. private puresubroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. generic, public :: operator(-) => sub pass(lhs) sub () Arguments None Description Burgers - Burgers oprator. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. private purefunction dBurgers_dx (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ),\n  allocatable Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. private purefunction d2Burgers_dx2 (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ),\n  allocatable Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Source Code type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODiE integrand class. private integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: state !< Solution vector, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous steps solution vector, [1:Ni,1:steps]. contains ! public methods ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivate, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers oprator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers oprator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! operators overloading generic , public :: operator ( - ) => sub ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers","tags":"","loc":"type/burgers.html","title":"burgers – FOODiE "},{"text":"type, public, extends(integrand) :: euler_1D Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D PDEs system field. It is a FOODiE integrand class. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative  variables are organized as an array of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Conservative (state) variables [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Conservative variables of previous time steps [:,:,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type(euler_1D), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivate, residuals function. private purefunction dEuler_dt (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. Description Update previous time steps. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private purefunction euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private purefunction euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private purefunction real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class(euler_1D), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler oprator. private purefunction add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private puresubroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private puresubroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private puresubroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODiE integrand class. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative  variables are organized as an array of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Conservative (state) variables [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Conservative variables of previous time steps [:,:,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! public methods ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivate, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. ! operators overloading procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler oprator. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D","tags":"","loc":"type/euler_1d.html","title":"euler_1D – FOODiE "},{"text":"type, public, extends(integrand) :: lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Lorenz equations field. It is a FOODiE integrand class. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: state Solution vector, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous steps solution vector, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. procedure, public, pass(self) :: output Extract Lorenz field. private function output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. procedure, public, pass(self) :: t => dLorenz_dt Time derivate, resiuduals function. private purefunction dLorenz_dt (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. Description Update previous time steps. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * lorenz operator. private purefunction lorenz_multiply_lorenz (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a lorenz field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. private purefunction lorenz_multiply_real (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Lorenz field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. private purefunction real_multiply_lorenz (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Lorenz field. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz oprator. private purefunction add_lorenz (lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Lorenz fields. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. private puresubroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. private puresubroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: state !< Solution vector, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous steps solution vector, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz","tags":"","loc":"type/lorenz.html","title":"lorenz – FOODiE "},{"text":"type, public, extends(integrand) :: oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Oscillation equations field. It is a FOODiE integrand class. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: state Solution vector, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous steps solution vector, [1:dims,1:steps]. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, f, steps) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Oscillation field. procedure, public, pass(self) :: output Extract Oscillation field. private function output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. private purefunction dOscillation_dt (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. Description Update previous time steps. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. private purefunction oscillation_multiply_oscillation (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a oscillation field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. private purefunction oscillation_multiply_real (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Oscillation field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. private purefunction real_multiply_oscillation (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Oscillation field. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. private purefunction add_oscillation (lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Oscillation fields. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. private puresubroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. procedure, public, pass(lhs) :: assign_real => oscillation_assign_real Oscillation = real. private puresubroutine oscillation_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Oscillation field. Source Code type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODiE integrand class. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: state !< Solution vector, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous steps solution vector, [1:dims,1:steps]. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. procedure , pass ( lhs ), public :: assign_real => oscillation_assign_real !< Oscillation = real. endtype oscillation","tags":"","loc":"type/oscillation.html","title":"oscillation – FOODiE "},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private puresubroutine update_previous_steps(self) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: self Integrand field. Description Update the previous time steps (of integrand field) for multi-step(level) ODE solvers.","tags":"","loc":"interface/update_previous_steps.html","title":"update_previous_steps – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private puresubroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private puresubroutine assignment_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real.","tags":"","loc":"interface/assignment_real.html","title":"assignment_real – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction time_derivative(self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction integrand_op_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real.","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction real_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand.","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FOODiE"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FOODiE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destoy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOODiE"},{"text":"private subroutine integrate(self, field, dt) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: dt Time step. Description Integrate field with Adams-Bashforth class scheme. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , field , dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: dt !< Time step. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps field = field + field % t ( n = s ) * ( dt * self % b ( s )) enddo call field % update_previous_steps return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FOODiE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FOODiE"},{"text":"private subroutine integrate(field, dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: dt Time step. Description Integrate field with explicit Euler scheme, 1st order. Source Code subroutine integrate ( field , dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field + field % t () * dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – FOODiE"},{"text":"private elementalfunction create(stages) result(rk) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type( tvd_runge_kutta_integrator ) Actual RK integrator. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function create ( stages ) result ( rk ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. type ( tvd_runge_kutta_integrator ) :: rk !< Actual RK integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk % init ( stages = stages ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction create","tags":"","loc":"proc/create.html","title":"create – FOODiE"},{"text":"private elementalsubroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~2.html","title":"init – FOODiE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FOODiE"},{"text":"private subroutine integrate(self, field, stage, Dt) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , field , stage , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , size ( stage ) stage ( s ) = field do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , size ( stage ) field = field + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – FOODiE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize – FOODiE"},{"text":"public interface tvd_runge_kutta_integrator Overload tvd_runge_kutta_integrator name with the constructor function create . Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elementalfunction create (stages) result(rk) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type( tvd_runge_kutta_integrator ) Actual RK integrator. Description Create the actual RK integrator: initialize the Butcher' table coefficients.","tags":"","loc":"interface/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODiE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, parameter :: pi = 4._R_P*atan(1._R_P) Pi greek. integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~3.html","title":"init – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results.html","title":"save_results – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( field = domain , dt = dt ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler.html","title":"test_euler – FOODiE"},{"text":"subroutine test_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk","tags":"","loc":"proc/test_rk.html","title":"test_rk – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s AB steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = domain , dt = dt ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab.html","title":"test_ab – FOODiE"},{"text":"private function output(self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. Source Code function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output.html","title":"output – FOODiE"},{"text":"private purefunction compute_dt(self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. Source Code pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – FOODiE"},{"text":"private purefunction dBurgers_dt(self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. Variables Type Visibility Attributes Name Initial type( burgers ), public, allocatable :: delta Delta state used as temporary variables. Source Code pure function dBurgers_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. type ( burgers ), allocatable :: delta !< Delta state used as temporary variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary variables allocate ( burgers :: delta ) delta % Ni = self % Ni delta % steps = self % steps delta % h = self % h delta % nu = self % nu delta % state = self % state if ( allocated ( self % previous )) delta % previous = self % previous ! Burgers residuals delta = self % xx ( n = n ) * self % nu delta = delta - self * self % x ( n = n ) call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt","tags":"","loc":"proc/dburgers_dt.html","title":"dBurgers_dt – FOODiE"},{"text":"private purefunction burgers_multiply_burgers(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Burgers field by another one. Variables Type Visibility Attributes Name Initial type( burgers ), public, allocatable :: local_product Temporary produtc. Source Code pure function burgers_multiply_burgers ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( burgers ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) select type ( rhs ) class is ( burgers ) local_product % Ni = lhs % Ni local_product % steps = lhs % steps local_product % h = lhs % h local_product % nu = lhs % nu local_product % state = lhs % state * rhs % state if ( allocated ( lhs % previous )) local_product % previous = lhs % previous endselect call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers","tags":"","loc":"proc/burgers_multiply_burgers.html","title":"burgers_multiply_burgers – FOODiE"},{"text":"private purefunction burgers_multiply_real(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Burgers field by a real scalar. Variables Type Visibility Attributes Name Initial type( burgers ), public, allocatable :: local_product Temporary produtc. Source Code pure function burgers_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( burgers ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % Ni = lhs % Ni local_product % steps = lhs % steps local_product % h = lhs % h local_product % nu = lhs % nu local_product % state = lhs % state * rhs if ( allocated ( lhs % previous )) local_product % previous = lhs % previous call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real","tags":"","loc":"proc/burgers_multiply_real.html","title":"burgers_multiply_real – FOODiE"},{"text":"private purefunction real_multiply_burgers(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Burgers field. Variables Type Visibility Attributes Name Initial type( burgers ), public, allocatable :: local_product Temporary produtc. Source Code pure function real_multiply_burgers ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( burgers ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % Ni = rhs % Ni local_product % steps = rhs % steps local_product % h = rhs % h local_product % nu = rhs % nu local_product % state = rhs % state * lhs if ( allocated ( rhs % previous )) local_product % previous = rhs % previous call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers","tags":"","loc":"proc/real_multiply_burgers.html","title":"real_multiply_burgers – FOODiE"},{"text":"private purefunction add_burgers(lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Burgers fields. Variables Type Visibility Attributes Name Initial type( burgers ), public, allocatable :: local_sum Temporary sum. Source Code pure function add_burgers ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( burgers ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_sum ) select type ( rhs ) class is ( burgers ) local_sum % Ni = lhs % Ni local_sum % steps = lhs % steps local_sum % h = lhs % h local_sum % nu = lhs % nu local_sum % state = lhs % state + rhs % state if ( allocated ( lhs % previous )) local_sum % previous = lhs % previous endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers","tags":"","loc":"proc/add_burgers.html","title":"add_burgers – FOODiE"},{"text":"private purefunction sub_burgers(lhs, rhs) result(sub) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Subtraction. Description Subtract two Burgers fields. Variables Type Visibility Attributes Name Initial type( burgers ), public, allocatable :: local_sub Temporary subtraction. Source Code pure function sub_burgers ( lhs , rhs ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sub !< Subtraction. type ( burgers ), allocatable :: local_sub !< Temporary subtraction. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_sub ) select type ( rhs ) class is ( burgers ) local_sub % Ni = lhs % Ni local_sub % steps = lhs % steps local_sub % h = lhs % h local_sub % nu = lhs % nu local_sub % state = lhs % state - rhs % state if ( allocated ( lhs % previous )) local_sub % previous = lhs % previous endselect call move_alloc ( local_sub , sub ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers","tags":"","loc":"proc/sub_burgers.html","title":"sub_burgers – FOODiE"},{"text":"private purefunction dBurgers_dx(self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ),\n  allocatable Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. integer, public :: dn Time level, dummy variable.","tags":"","loc":"proc/dburgers_dx.html","title":"dBurgers_dx – FOODiE"},{"text":"private purefunction d2Burgers_dx2(self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ),\n  allocatable Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. integer, public :: dn Time level, dummy variable.","tags":"","loc":"proc/d2burgers_dx2.html","title":"d2Burgers_dx2 – FOODiE"},{"text":"private subroutine init(self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % state )) deallocate ( self % state ) ; allocate ( self % state ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % state = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~4.html","title":"init – FOODiE"},{"text":"private puresubroutine update_previous_steps(self) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % state endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps.html","title":"update_previous_steps – FOODiE"},{"text":"private puresubroutine burgers_assign_burgers(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. Source Code pure subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % state )) lhs % state = rhs % state if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers","tags":"","loc":"proc/burgers_assign_burgers.html","title":"burgers_assign_burgers – FOODiE"},{"text":"private puresubroutine burgers_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. Source Code pure subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real","tags":"","loc":"proc/burgers_assign_real.html","title":"burgers_assign_real – FOODiE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~5.html","title":"init – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~2.html","title":"save_results – FOODiE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler-time_serie.dat' , & t = t ) do while ( t < t_final ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( field = domain , dt = dt ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~2.html","title":"test_euler – FOODiE"},{"text":"subroutine test_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: ord Space order. Source Code subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: ord !< Space order. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) rk_integrator = tvd_runge_kutta_integrator ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-rk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk","tags":"","loc":"proc/test_rk~2.html","title":"test_rk – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s AB steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) rk_integrator = tvd_runge_kutta_integrator ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) step = 1 do while ( t < t_final ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = domain , dt = dt ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~2.html","title":"test_ab – FOODiE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~2.html","title":"output – FOODiE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~2.html","title":"compute_dt – FOODiE"},{"text":"private purefunction dEuler_dt(self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: dn Time level, dummy variable. integer(kind=I_P), public :: i Counter. Source Code pure function dEuler_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: dn !< Time level, dummy variable. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables if ( self % steps >= 2 ) then ! self%previous should be used, multi-step time integration dn = self % steps ; if ( present ( n )) dn = n do i = 1 , Ni P (:, i ) = self % conservative2primitive ( previous (:, i , dn )) enddo else ! self%U should be used, single-step time integration do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo endif call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – FOODiE"},{"text":"private purefunction euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Source Code pure function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – FOODiE"},{"text":"private purefunction euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Source Code pure function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – FOODiE"},{"text":"private purefunction real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class(euler_1D), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Source Code pure function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – FOODiE"},{"text":"private purefunction add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Source Code pure function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – FOODiE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative.html","title":"primitive2conservative – FOODiE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive.html","title":"conservative2primitive – FOODiE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p.html","title":"p – FOODiE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r.html","title":"r – FOODiE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a.html","title":"a – FOODiE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e.html","title":"E – FOODiE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h.html","title":"H – FOODiE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: s Steps counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~6.html","title":"init – FOODiE"},{"text":"private puresubroutine destroy(self) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FOODiE"},{"text":"private puresubroutine update_previous_steps(self) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~2.html","title":"update_previous_steps – FOODiE"},{"text":"private puresubroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code pure subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – FOODiE"},{"text":"private puresubroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Source Code pure subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – FOODiE"},{"text":"private puresubroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – FOODiE"},{"text":"private puresubroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i integer(kind=I_P), public :: j integer(kind=I_P), public :: f integer(kind=I_P), public :: v Counters. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i , j , f , v !< Counters. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i , s !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i , s !< Counters. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states.html","title":"reconstruct_interfaces_states – FOODiE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver.html","title":"riemann_solver – FOODiE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type(euler_1D), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~3.html","title":"finalize – FOODiE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states.html","title":"compute_inter_states – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: s Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~3.html","title":"save_results – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~3.html","title":"test_euler – FOODiE"},{"text":"subroutine test_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' , & filename = 'lorenz_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk","tags":"","loc":"proc/test_rk~3.html","title":"test_rk – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer(kind=I_P), public :: s AB steps counter. integer, public :: step Time steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = attractor , dt = dt ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~3.html","title":"test_ab – FOODiE"},{"text":"private function output(self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. Source Code function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~3.html","title":"output – FOODiE"},{"text":"private purefunction dLorenz_dt(self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: delta Delta state used as temporary variables. integer(kind=I_P), public :: dn Time level, dummy variable. Source Code pure function dLorenz_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. type ( lorenz ), allocatable :: delta !< Delta state used as temporary variables. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary delta allocate ( delta ) delta % dims = self % dims delta % steps = self % steps delta % state = self % state if ( allocated ( self % previous )) delta % previous = self % previous delta % sigma = self % sigma delta % rho = self % rho delta % beta = self % beta ! Lorenz equations if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n delta % state ( 1 ) = self % sigma * ( self % previous ( 2 , dn ) - self % previous ( 1 , dn )) delta % state ( 2 ) = self % previous ( 1 , dn ) * ( self % rho - self % previous ( 3 , dn )) - self % previous ( 2 , dn ) delta % state ( 3 ) = self % previous ( 1 , dn ) * self % previous ( 2 , dn ) - self % beta * self % previous ( 3 , dn ) else ! self%previous should not be used, use directly self%state delta % state ( 1 ) = self % sigma * ( self % state ( 2 ) - self % state ( 1 )) delta % state ( 2 ) = self % state ( 1 ) * ( self % rho - self % state ( 3 )) - self % state ( 2 ) delta % state ( 3 ) = self % state ( 1 ) * self % state ( 2 ) - self % beta * self % state ( 3 ) endif call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt","tags":"","loc":"proc/dlorenz_dt.html","title":"dLorenz_dt – FOODiE"},{"text":"private purefunction lorenz_multiply_lorenz(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a lorenz field by another one. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: local_product Temporary produtc. Source Code pure function lorenz_multiply_lorenz ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) select type ( rhs ) class is ( lorenz ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs % state if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % sigma = lhs % sigma local_product % rho = lhs % rho local_product % beta = lhs % beta endselect call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz","tags":"","loc":"proc/lorenz_multiply_lorenz.html","title":"lorenz_multiply_lorenz – FOODiE"},{"text":"private purefunction lorenz_multiply_real(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Lorenz field by a real scalar. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: local_product Temporary produtc. Source Code pure function lorenz_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % sigma = lhs % sigma local_product % rho = lhs % rho local_product % beta = lhs % beta call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real","tags":"","loc":"proc/lorenz_multiply_real.html","title":"lorenz_multiply_real – FOODiE"},{"text":"private purefunction real_multiply_lorenz(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Lorenz field. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: local_product Temporary produtc. Source Code pure function real_multiply_lorenz ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = rhs % dims local_product % steps = rhs % steps local_product % state = rhs % state * lhs if ( allocated ( rhs % previous )) local_product % previous = rhs % previous local_product % sigma = rhs % sigma local_product % rho = rhs % rho local_product % beta = rhs % beta call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz","tags":"","loc":"proc/real_multiply_lorenz.html","title":"real_multiply_lorenz – FOODiE"},{"text":"private purefunction add_lorenz(lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Lorenz fields. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: local_sum Temporary sum. Source Code pure function add_lorenz ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( lorenz ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: local_sum ) select type ( rhs ) class is ( lorenz ) local_sum % dims = lhs % dims local_sum % steps = lhs % steps local_sum % state = lhs % state + rhs % state if ( allocated ( lhs % previous )) local_sum % previous = lhs % previous local_sum % sigma = lhs % sigma local_sum % rho = lhs % rho local_sum % beta = lhs % beta endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz","tags":"","loc":"proc/add_lorenz.html","title":"add_lorenz – FOODiE"},{"text":"private subroutine init(self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Intial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % state )) deallocate ( self % state ) ; allocate ( self % state ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % state = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~7.html","title":"init – FOODiE"},{"text":"private puresubroutine update_previous_steps(self) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % state endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~3.html","title":"update_previous_steps – FOODiE"},{"text":"private puresubroutine lorenz_assign_lorenz(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. Source Code pure subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % state )) lhs % state = rhs % state if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz","tags":"","loc":"proc/lorenz_assign_lorenz.html","title":"lorenz_assign_lorenz – FOODiE"},{"text":"private puresubroutine lorenz_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code pure subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real","tags":"","loc":"proc/lorenz_assign_real.html","title":"lorenz_assign_real – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: s Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 2 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~4.html","title":"save_results – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' ! initialize field call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integrations, explicit Euler' , & filename = 'oscillation_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~4.html","title":"test_euler – FOODiE"},{"text":"subroutine test_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'oscillation_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk","tags":"","loc":"proc/test_rk~4.html","title":"test_rk – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 3 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer(kind=I_P), public :: s AB steps counter. integer, public :: step Time steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 3 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , f = f , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = attractor , dt = dt ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit ' // 'Adams-Bashforth ' // & trim ( str (. true ., s )) // ' steps' , & filename = 'oscillation_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~4.html","title":"test_ab – FOODiE"},{"text":"private function output(self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. Source Code function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~4.html","title":"output – FOODiE"},{"text":"private purefunction dOscillation_dt(self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. Variables Type Visibility Attributes Name Initial type( oscillation ), public, allocatable :: delta Delta state used as temporary variables. integer(kind=I_P), public :: dn Time level, dummy variable. Source Code pure function dOscillation_dt ( self , n ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. type ( oscillation ), allocatable :: delta !< Delta state used as temporary variables. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary delta allocate ( delta ) delta % dims = self % dims delta % steps = self % steps delta % state = self % state if ( allocated ( self % previous )) delta % previous = self % previous delta % f = self % f ! Oscillation equations if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n delta % state ( 1 ) = - self % f * self % previous ( 2 , dn ) delta % state ( 2 ) = self % f * self % previous ( 1 , dn ) else ! self%previous should not be used, use directly self%state delta % state ( 1 ) = - self % f * self % state ( 2 ) delta % state ( 2 ) = self % f * self % state ( 1 ) endif call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt","tags":"","loc":"proc/doscillation_dt.html","title":"dOscillation_dt – FOODiE"},{"text":"private purefunction oscillation_multiply_oscillation(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a oscillation field by another one. Variables Type Visibility Attributes Name Initial type( oscillation ), public, allocatable :: local_product Temporary product. Source Code pure function oscillation_multiply_oscillation ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( oscillation ), allocatable :: local_product !< Temporary product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) select type ( rhs ) class is ( oscillation ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs % state if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % f = lhs % f endselect call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation","tags":"","loc":"proc/oscillation_multiply_oscillation.html","title":"oscillation_multiply_oscillation – FOODiE"},{"text":"private purefunction oscillation_multiply_real(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Oscillation field by a real scalar. Variables Type Visibility Attributes Name Initial type( oscillation ), public, allocatable :: local_product Temporary product. Source Code pure function oscillation_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( oscillation ), allocatable :: local_product !< Temporary product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = lhs % dims local_product % steps = lhs % steps local_product % state = lhs % state * rhs if ( allocated ( lhs % previous )) local_product % previous = lhs % previous local_product % f = lhs % f call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real","tags":"","loc":"proc/oscillation_multiply_real.html","title":"oscillation_multiply_real – FOODiE"},{"text":"private purefunction real_multiply_oscillation(lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Oscillation field. Variables Type Visibility Attributes Name Initial type( oscillation ), public, allocatable :: local_product Temporary product. Source Code pure function real_multiply_oscillation ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( oscillation ), allocatable :: local_product !< Temporary product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % dims = rhs % dims local_product % steps = rhs % steps local_product % state = rhs % state * lhs if ( allocated ( rhs % previous )) local_product % previous = rhs % previous local_product % f = rhs % f call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation","tags":"","loc":"proc/real_multiply_oscillation.html","title":"real_multiply_oscillation – FOODiE"},{"text":"private purefunction add_oscillation(lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Oscillation fields. Variables Type Visibility Attributes Name Initial type( oscillation ), public, allocatable :: local_sum Temporary sum. Source Code pure function add_oscillation ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( oscillation ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: local_sum ) select type ( rhs ) class is ( oscillation ) local_sum % dims = lhs % dims local_sum % steps = lhs % steps local_sum % state = lhs % state + rhs % state if ( allocated ( lhs % previous )) local_sum % previous = lhs % previous local_sum % f = lhs % f endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation","tags":"","loc":"proc/add_oscillation.html","title":"add_oscillation – FOODiE"},{"text":"private subroutine init(self, initial_state, f, steps) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Oscillation field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , f , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Intial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: f !< Frequency. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % state )) deallocate ( self % state ) ; allocate ( self % state ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % state = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % f = f return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~8.html","title":"init – FOODiE"},{"text":"private puresubroutine update_previous_steps(self) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code pure subroutine update_previous_steps ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % state endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~4.html","title":"update_previous_steps – FOODiE"},{"text":"private puresubroutine oscillation_assign_oscillation(lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. Source Code pure subroutine oscillation_assign_oscillation ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % state )) lhs % state = rhs % state if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % f = rhs % f endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation","tags":"","loc":"proc/oscillation_assign_oscillation.html","title":"oscillation_assign_oscillation – FOODiE"},{"text":"private puresubroutine oscillation_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Oscillation field. Source Code pure subroutine oscillation_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_real","tags":"","loc":"proc/oscillation_assign_real.html","title":"oscillation_assign_real – FOODiE"},{"text":"Uses: type_integrand foodie_integrator_euler_explicit foodie_integrator_tvd_runge_kutta foodie_integrator_adams_bashforth Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE, Fortran Object oriented Ordinary Differential Equations integration library. FOODiE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODiE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: forward explicit Euler scheme, a 1st order accurate scheme; TVD or SSP Runge-Kutta class schemes: TVD(1,1): 1 stage, 1st order scheme, namely the forward explicit Euler one; SSP(2,2): 2 stages, 2nd order scheme; SSP(3,3): 3 stages, 3rd order scheme; SSP(5,4): 5 stages, 4th order scheme; Usage FOODiE schemes must be applied to only subclass extensions of the abstract class type_integrand . To use FOODiE you must: extend type_integrand abstract class provided by FOODiE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: output !< Extract Lorenz field. procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz use one of the provided FOODiE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : euler_explicit_integrator use type_lorenz , only : lorenz type ( euler_explicit_integrator ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/foodie.html","title":"foodie – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is:  U&#94;{n+s} = U&#94;{n+s-1} +\\Delta t \\left[ \\sum_{i=1}&#94;{n+s}{ b_i \\cdot R(t&#94;{n+i-1}, U&#94;{n+i-1}) } \\right]  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients \\b define the actual scheme, that is selected accordingly to the number of steps used. Currently the following schemes are available: 1 step, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order.\n The b coefficient is:\n b = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  2 steps This scheme is 2nd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  3 steps This scheme is 3rd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_bashforth_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_bashforth.html","title":"foodie_integrator_adams_bashforth – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: euler_explicit_integrator Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. Description FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Subroutines private subroutine integrate (field, dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: dt Time step. Description Integrate field with explicit Euler scheme, 1st order.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. The class of integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax (see Butcher, J.C., Coefficients for the study of\n Runge-Kutta integration processes , J. Austral. Math. Soc., Vol. 3, pages: 185–201, 1963). Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: \\gamma&#94;1 \\alpha&#94;{1,1} \\alpha&#94;{1,2} \\cdots \\alpha&#94;{1,Ns} \\gamma&#94;2 \\alpha&#94;{2,1} \\alpha&#94;{2,2} \\cdots \\alpha&#94;{2,Ns} \\vdots \\vdots \\vdots \\ddots \\vdots \\gamma&#94;{Ns} \\alpha&#94;{Ns,1} \\alpha&#94;{Ns,2} \\cdots \\alpha&#94;{Ns,Ns} \\beta&#94;1 \\beta&#94;2 \\cdots \\beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: \\gamma&#94;1       0            0      \\cdots         0     \\gamma&#94;2 \\alpha&#94;{2,1} \\alpha&#94;{2,2} \\cdots \\alpha&#94;{2,Ns} \\vdots \\vdots \\vdots \\ddots \\vdots \\gamma&#94;{Ns} \\alpha&#94;{Ns,1} \\alpha&#94;{Ns,2} \\cdots         0      \\beta&#94;1 \\beta&#94;2 \\cdots \\beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order.\n \\beta = \\left[1\\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0 \\end{array}} \\right]\n \\gamma = \\left[0\\right] 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm. See High Order Strong Stability Preserving Time\n Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009,\n pp. 251-289.\n \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2}&\\frac{1}{2} \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0\\\\ 1&0 \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\end{array}} \\right] 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm. See High Order Strong Stability Preserving Time\n Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009,\n pp. 251-289.\n \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{6}&\\frac{1}{6}&\\frac{1}{3}  \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0&0\\\\ 1&0&0\\\\ \\frac{1}{4}&\\frac{1}{4}&0 \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\\\ \\frac{1}{2} \\end{array}} \\right] 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm. See High Order Strong Stability Preserving Time\n Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009,\n pp. 251-289.\n \\beta = \\left[ {\\begin{array}{*{20}{c}} 0.14681187618661&0.24848290924556&0.10425883036650&0.27443890091960&\n 0.22600748319395 \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}}\n 0&0&0&0&0 \\\\ 0.39175222700392&0&0&0&0 \\\\ 0.21766909633821&0.36841059262959&0&0&0 \\\\ 0.08269208670950&\n 0.13995850206999&0.25189177424738&0&0 \\\\ 0.06796628370320&0.11503469844438&0.20703489864929&0.54497475021237&0\n \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0\\\\0.39175222700392\\\\0.58607968896780\\\\0.47454236302687\\\\0.93501063100924\n           \\end{array}} \\right] Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface tvd_runge_kutta_integrator Overload tvd_runge_kutta_integrator name with the constructor function create . private elementalfunction create (stages) result(rk) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type( tvd_runge_kutta_integrator ) Actual RK integrator. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Derived Types type, public :: tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Constructor Overload tvd_runge_kutta_integrator name with the constructor function create . private elemental function create (stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_tvd_runge_kutta.html","title":"foodie_integrator_tvd_runge_kutta – FOODiE"},{"text":"Uses: IR_Precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define the abstract type integrand for building FOODiE ODE integrators. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: self Integrand field. Description Update the previous time steps (of integrand field) for multi-step(level) ODE solvers. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private puresubroutine assignment_integrand (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private puresubroutine assignment_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction time_derivative (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction integrand_op_real (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction real_op_integrand (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private purefunction symmetric_operator (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. Derived Types type, public, abstract :: integrand Type-Bound Procedures procedure(time_derivative), public, pass(self), deferred :: t Time derivative, residuals. procedure(update_previous_steps), public, pass(self), deferred :: update_previous_steps Time derivative, residuals. procedure(symmetric_operator), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. procedure(integrand_op_real), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. procedure(real_op_integrand), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: add Integrand + integrand oprator. procedure(assignment_integrand), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. procedure(assignment_real), public, pass(lhs), deferred :: assign_real Integrand = real. generic, public :: operator(+) => add Overloading + operator. generic, public :: operator(*) => integrand_multiply_integrand, real_multiply_integrand, integrand_multiply_real Overloading * operator. generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. Description Abstract type for building FOODiE ODE integrators.","tags":"","loc":"module/type_integrand.html","title":"type_integrand – FOODiE"},{"text":"Uses: IR_Precision foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Burgers field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: burgers Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: state Solution vector, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous steps solution vector, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Burgers field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivate, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers oprator. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers oprator. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. generic, public :: operator(-) => sub procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. Description Burgers equations field. Functions private function output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. private purefunction compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. private purefunction dBurgers_dt (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. private purefunction burgers_multiply_burgers (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Burgers field by another one. private purefunction burgers_multiply_real (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Burgers field by a real scalar. private purefunction real_multiply_burgers (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Burgers field. private purefunction add_burgers (lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Burgers fields. private purefunction sub_burgers (lhs, rhs) result(sub) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Subtraction. Description Subtract two Burgers fields. private purefunction dBurgers_dx (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ),\n  allocatable Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. private purefunction d2Burgers_dx2 (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ),\n  allocatable Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Subroutines private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. Description Update previous time steps. private puresubroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. private puresubroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field.","tags":"","loc":"module/type_burgers.html","title":"type_burgers – FOODiE"},{"text":"Uses: IR_Precision foodie wenoof Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Conservative (state) variables [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Conservative variables of previous time steps [:,:,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d.html","title":"type_euler_1D – FOODiE"},{"text":"Uses: IR_Precision foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Lorenz field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: lorenz Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: state Solution vector, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous steps solution vector, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Lorenz field. procedure, public, pass(self) :: t => dLorenz_dt Time derivate, resiuduals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * lorenz operator. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz oprator. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. Description Lorenz equations field. Functions private function output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. private purefunction dLorenz_dt (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. private purefunction lorenz_multiply_lorenz (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a lorenz field by another one. private purefunction lorenz_multiply_real (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Lorenz field by a real scalar. private purefunction real_multiply_lorenz (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Lorenz field. private purefunction add_lorenz (lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Lorenz fields. Subroutines private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. Description Update previous time steps. private puresubroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. private puresubroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field.","tags":"","loc":"module/type_lorenz.html","title":"type_lorenz – FOODiE"},{"text":"Uses: IR_Precision foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Oscillation field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: oscillation Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: state Solution vector, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous steps solution vector, [1:dims,1:steps]. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Oscillation field. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. procedure, public, pass(lhs) :: assign_real => oscillation_assign_real Oscillation = real. Description Oscillation equations field. Functions private function output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. private purefunction dOscillation_dt (self, n) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in), optional :: n Time level. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. private purefunction oscillation_multiply_oscillation (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a oscillation field by another one. private purefunction oscillation_multiply_real (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Oscillation field by a real scalar. private purefunction real_multiply_oscillation (lhs, rhs) result(product) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Oscillation field. private purefunction add_oscillation (lhs, rhs) result(sum) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Oscillation fields. Subroutines private subroutine init (self, initial_state, f, steps) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Oscillation field. private puresubroutine update_previous_steps (self) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. Description Update previous time steps. private puresubroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. private puresubroutine oscillation_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Oscillation field.","tags":"","loc":"module/type_oscillation.html","title":"type_oscillation – FOODiE"},{"text":"Uses: IR_Precision type_burgers Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Burgers equation. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( burgers ) :: domain Burgers field domain. real(kind=R_P), parameter :: CFL = 0.1_R_P CFL value. real(kind=R_P), parameter :: t_final = 0.6_R_P Final time. real(kind=R_P), parameter :: nu = 1._R_P Viscosity. integer(kind=I_P), parameter :: Ni = 100 Number of grid nodes. real(kind=R_P) :: h Space step discretization. real(kind=R_P) :: initial_state (1:Ni) Initial state. real(kind=R_P) :: x (1:Ni) Nodes values. real(kind=R_P), allocatable :: final_state (:) Final state. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Source Code program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results\" , & \"burgers --solver runge-kutta -r \" , & \"burgers --solver adams-bashforth\" , & \"burgers --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( field = domain , dt = dt ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) ! integrate field dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = domain , dt = dt ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration at t=0.6, explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_burgers","tags":"","loc":"program/integrate_burgers.html","title":"integrate_burgers – FOODiE"},{"text":"Uses: IR_Precision type_euler_1D Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Euler 1D PDEs system. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type(euler_1D) :: domain Domain of Euler equations. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. real(kind=R_P), parameter :: t_final = 0.15_R_P Final time. integer(kind=I_P), parameter :: Ni = 100 Number of grid cells. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. real(kind=R_P) :: Dx = 1._R_P/Ni Space step discretization. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P) :: initial_state (1:Np,1:Ni) Initial state of primitive variables. real(kind=R_P) :: x (1:Ni) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Source Code program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.15_R_P !< Final time. integer ( I_P ), parameter :: Ni = 100 !< Number of grid cells. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. real ( R_P ) :: Dx = 1._R_P / Ni !< Space step discretization. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ) :: initial_state ( 1 : Np , 1 : Ni ) !< Initial state of primitive variables. real ( R_P ) :: x ( 1 : Ni ) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results\" , & \"euler-1D --solver runge-kutta -r \" , & \"euler-1D --solver adams-bashforth\" , & \"euler-1D --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler-time_serie.dat' , & t = t ) do while ( t < t_final ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( field = domain , dt = dt ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: ord !< Space order. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) rk_integrator = tvd_runge_kutta_integrator ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-rk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) rk_integrator = tvd_runge_kutta_integrator ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) step = 1 do while ( t < t_final ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = domain , dt = dt ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_euler_1D","tags":"","loc":"program/integrate_euler_1d.html","title":"integrate_euler_1D – FOODiE"},{"text":"Uses: IR_Precision type_lorenz Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Lorenz equations. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( lorenz ) :: attractor Lorenz field. integer, parameter :: num_steps = 2000 Maximum time steps. integer, parameter :: space_dimension = 3 Space dimensions. real(kind=R_P), parameter :: sigma = 10._R_P Lorenz' \\sigma. real(kind=R_P), parameter :: rho = 28._R_P Lorenz' \\rho. real(kind=R_P), parameter :: beta = 8._R_P/3._R_P Lorenz' \\beta. real(kind=R_P), parameter :: dt = 0.01_R_P Time step. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [1.,1.,1.] Initial state. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Source Code program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results\" , & \"lorenz --solver runge-kutta -r \" , & \"lorenz --solver adams-bashforth\" , & \"lorenz --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' , & filename = 'lorenz_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = attractor , dt = dt ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_lorenz","tags":"","loc":"program/integrate_lorenz.html","title":"integrate_lorenz – FOODiE"},{"text":"Uses: IR_Precision type_oscillation Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Oscillation equations. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( oscillation ) :: attractor Oscillation field. integer, parameter :: num_steps = 1e4 Maximum time steps. integer, parameter :: space_dimension = 2 Space dimensions. real(kind=R_P), parameter :: f = 1e-4_R_P Frequency. real(kind=R_P), parameter :: dt = 100._R_P Time step. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [0._R_P,1._R_P] Initial state. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Source Code program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_oscillation , only : oscillation use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator , adams_bashforth_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( oscillation ) :: attractor !< Oscillation field. integer , parameter :: num_steps = 1 e4 !< Maximum time steps. integer , parameter :: space_dimension = 2 !< Space dimensions. real ( R_P ), parameter :: f = 1 e - 4_R_P !< Frequency. real ( R_P ), parameter :: dt = 10 0._R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 0._R_P , 1._R_P ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results\" , & \"oscillation --solver runge-kutta -r \" , & \"oscillation --solver adams-bashforth\" , & \"oscillation --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Oscillation equations select case ( trim ( adjustl ( solver ))) case ( 'euler' ) call test_euler () case ( 'runge-kutta' ) call test_rk () case ( 'adams-bashforth' ) call test_ab () case ( 'all' ) call test_euler () call test_rk () call test_ab () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + euler' print \"(A)\" , '  + runge-kutta' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 2 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' ! initialize field call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integrations, explicit Euler' , & filename = 'oscillation_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'oscillation_integration-rk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_rk subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 3 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) ! initialize the AB integrator accordingly to the number of time steps used call ab_integrator % init ( steps = s ) ! initialize the RK integrator used for initial steps of AB integration rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field call attractor % init ( initial_state = initial_state , f = f , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps if ( s > step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) else call ab_integrator % integrate ( field = attractor , dt = dt ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit ' // 'Adams-Bashforth ' // & trim ( str (. true ., s )) // ' steps' , & filename = 'oscillation_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab endprogram integrate_oscillation","tags":"","loc":"program/integrate_oscillation.html","title":"integrate_oscillation – FOODiE"}]}