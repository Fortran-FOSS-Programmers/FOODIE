var tipuesearch = {"pages":[{"text":"FOODIE FOODIE FOODIE, Fortran Object-Oriented Differential-equations Integration Environment FOODIE is a pure Fortran (KISS) library providing an awesome environment for the numerical integration of Differential-equations (ODE, PDE); FOODIE is Fortran 2008+ standard compliant; FOODIE is OOP designed; FOODIE is a Free, Open Source Project. Table of Contents What is FOODIE? Main features Status Copyrights Documentation What is FOODIE? Modern Fortran standards (2003+) have introduced support for Object-Oriented Programming (OOP). Exploiting new features like Abstract Data Type (ADT) is now possible to develop a KISS library providing an awesome environment for the numerical integration of Differential-equations such as Ordinary and Partial Differential Eqautions (ODE, PDE). FOODIE is tailored to the systems arising from the semi-discretization of PDEs, but it is not limited to them. The FOODIE environment allows the (numerical) solution of general, non linear differential equations system of the form: where: U_t = dU/dt ; U is the vector of state variables being a function of the time-like independent variable t ; R is the (vectorial) residual function, it could be a non linear function of the solution U itself; F is the (vectorial) initial conditions function. The FOODIE has two main purposes: for developers devising new schemes for the numerical integrations of differential equations (DE): provide a concise, clear, robust and comprehensive abstract environment by means of which: express the solvers formulae with a very high-level language, it being close as much as possible to their natual mathematical formulations; this ensures: clearness, conciseness and robustness; fast-developing; for clients that must solve a differential equations system: provide a simple, standard API for many built-in DE solvers out-of-the-box, thus allowing: fast-solution of new problems; robustness: the same DE solver is applied to different problems, i.e. cross-validation; Go to Top Main features FOODIE is aimed to be a KISS-pure-Fortran library for integrating Ordinary Differential Equations (ODE), it being: Pure Fortran implementation; KISS and user-friendly: simple API, presently based on the Rouson's Abstract Data Type Pattern [8]; easy building and porting on heterogeneous architectures; comprehensive solvers set out-of-the-box: explicit schemes: Adams-Bashforth schemes see [7, 12]: 1 step, namely the forward explicit Euler scheme, 1st order accurate; 2 to 16 steps, 2nd to 16th accurate, respectively; Euler (forward explicit) scheme, 1st order accurate; Leapfrog , 2nd order accurate: unfiltered leapfrog, 2nd order accurate, mostly unstable, see [4]; Robert-Asselin filtered leapfrog, 1st order accurate, see [4, 5, 6]; Robert-Asselin-Williams filtered leapfrog, 3rd order accurate, see [5, 6]; Linear Multistep Methods, SSP schemes see [16]: 3 steps, 2nd order accurate; 4 steps, 3rd order accurate; 5 steps, 3rd order accurate; Linear Multistep Methods, SSP with Variable Step Size (VSS) schemes see [17]: 2 steps, 2nd order accurate; 3 steps, 2nd order accurate; 3 steps, 3rd order accurate; 4 steps, 3rd order accurate; 5 steps, 3rd order accurate; Linear Multistep Runge-Kutta Methods SSP schemes see [18]: 2 steps, 2 stages, 3rd order accurate; 3 steps, 2 stages, 3rd order accurate; 4 steps, 3 stages, 5th order accurate; 3 steps, 6 stages, 5th order accurate; 3 steps, 5 stages, 6th order accurate; 3 steps, 7 stages, 7th order accurate; 4 steps, 7 stages, 7th order accurate; 4 steps, 5 stages, 8th order accurate; 5 steps, 9 stages, 8th order accurate; 4 steps, 9 stages, 9th order accurate; 3 steps, 20 stages, 10th order accurate; Runge-Kutta schemes: [+] Linear SSP (of any order) schemes, see [16]: generic s-stages of order (s-1)-th; generic s-stages of order s-th; low-storage schemes, see [1, 2, 3]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages; 3 stages; 4 stages; 5 stages, 4th order accurate, 2N registers, see [3]; 6 stages, 4th order accurate, 2N registers, see [9]; 7 stages, 4th order accurate, 2N registers, see [9]; 12 stages, 4th order accurate, 2N registers, see [10]; 13 stages, 4th order accurate, 2N registers, see [10]; 14 stages, 4th order accurate, 2N registers, see [10]; TVD/SSP schemes, see [1]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages, 2nd order accurate; 3 stages, 3rd order accurate; 4 stages; 5 stages, 4th order accurate; embedded (adaptive) schemes: Heun-Euler, 2 stages, 2nd order accurate; Runge-Kutta-Fehlberg, 5 stages, 4th order accurate; Runge-Kutta-Cash-Karp, 6 stages, 5th order accurate, see [13]; Prince-Dormand, 7 stages, 4th order accurate, see [11]; Calvo, 9 stages, 6th order accurate, see [14]; Feagin, 17 stages, 10th order accurate, see [15]; implicit schemes: Runge-Kutta schemes; Adams-Moulton schemes: 0 step, 1st order accurate; 1 step, 2nd accurate; 2 steps, 3rd accurate; 3 steps, 4th accurate; Backward Differentiation Formula schemes: 1 step, namely the backward implicit Euler scheme, 1st order accurate; 2 to 6 steps, 2nd to 6th accurate, respectively; predictor-corrector schemes: Adams-Bashforth-Moulton schemes: 1 step, AB(1)-AM(0), 1st order accurate; 2 steps, AB(2)-AM(1), 2nd accurate; 3 steps, AB(3)-AM(2), 3rd accurate; 4 steps, AB(4)-AM(3), 4th accurate; efficient and non intrusive : FOODIE environment is unaware of any eventual parallel paradigms the clients used, but it is proved to preserve high scalability on parallel architectures such as: OpenMP directive-based codes on shared memory multi/many cores architectures; CoArray Fortran (CAF) based codes for Partitioned Global Address Space (PGAS) programming model; MPI based code on distributed memory clusters; GPGPU/accelerators device enabled codes; Tests-Driven Developed ( TDD ): well documented: clear documentation of schemes implementations, e.g. see Adams-Bashforth API documentation ; complete API reference; comprehensive wiki : collaborative developed on GitHub ; FOSS licensed ; Any feature request is welcome. Bibliography [1] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, pp. 251–289. [2] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [3] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, June 1994. [4] Numerical methods used in atmospheric models , Mesinger F. and A. Arakawa, Global Atmospheric Research Programme (GARP), Technical Report , 1976. [5] A Proposed Modification to the Robert-Asselin Time Filter , Williams, P. D., Mon. Wea. Rev., vol. 137, pp. 2538–2546, 2009, doi: http://dx.doi.org/10.1175/2009MWR2724.1. [6] The RAW filter: An improvement to the Robert-Asselin filter in semi-implicit integrations , Williams, P.D., Monthly Weather Review, vol. 139(6), pages 1996–2007, June 2011. [7] Linear multistep method , wikipedia article . [8] Scientific Software Design: The Object-Oriented Way , Rouson, Damian and Xia, Jim and Xu, Xiaofeng, 2011, ISBN 9780521888134, Cambridge University Press, New York, NY, USA. [9] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [10] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. [11] A family of embedded Runge-Kutta formulae , Dormand, J. R.; Prince, P. J. (1980), , Journal of Computational and Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. [12] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr., G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [13] A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides , J. R. Cash, A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201–222, 1990, doi:10.1145/79505.79507. [14] A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6 , M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics with Applications, Volume 20, Issue 1, 1990, Pages 15–24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. [15] A tenth-order Runge-Kutta method with error estimate , Feagin, T., Proceedings of the IAENG Conf. on Scientific Computing. 2007. [16] Strong Stability Preserving Runge-Kutta and Multistep Time Discretizations , S. Gottlieb, D. Ketcheson, C.W. Shu, 2011, 978-981-4289-26-9, doi:10.1142/7498, World Scientific Publishing Co. Pte. Ltd. [17] Strong Stability Preserving Explicit Linear Multistep Methods with Variable Step Size , Y. Hadjimichael, D. Ketcheson, L. Lóczi, A. Németh, 2016, SIAM J. Numer. Anal., 54(5), 2799–2832.DOI:10.1137/15M101717X. [18] Explicit Strong Stability Preserving Multistep Runge-Kutta Methods , C. Bresten, S. Gottlieb, Z. Grant, D. Higgs, D. Ketcheson, A. Nemeth, Mathematics of Computation, 2016, http://dx.doi.org/10.1090/mcom/3115. Go to Top Status FOODIE project is young, but developed with love. Many integrators have been implemented using the Rouson's Abstract Data Type Pattern and tested with complex problems, but the library API is still in beta testing status. Nevertheless, FOODIE is already proven to be able to integrate a wide range of different ODE problems, from pure ODEs (Lorenz and inertial oscillations equations) to complex PDEs (Burgers and Euler equations), see the documentation. We are searching for Fortraners enthusiast joining our team! Copyrights FOODIE is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FOODIE is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FOODIE documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"","loc":"index.html","title":" FOODIE "},{"text":"FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. This File Depends On sourcefile~~foodie.f90~~EfferentGraph sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodief90EfferentGraph = svgPanZoom('#sourcefilefoodief90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie.f90~~AfferentGraph sourcefile~foodie.f90 foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodief90AfferentGraph = svgPanZoom('#sourcefilefoodief90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie Source Code foodie.f90 Source Code !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. module foodie !< FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< see [FOODIE home page](https://github.com/Fortran-FOSS-Programmers/FOODIE) for more details about available integrators. !< !<### Usage !< !< FOODIE schemes must be applied to only subclass extensions of the abstract class *integrand*. !< !< To use FOODIE you must: !< !<#### extend integrand abstract class provided by FOODIE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand_object) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODIE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !<     ... !< endtype lorenz !<``` !< !<#### use one of the provided FOODIE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : integrator_euler_explicit !< use type_lorenz, only : lorenz !< type(integrator_euler_explicit) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_object , only : integrator_object use foodie_integrator_adams_bashforth , only : integrator_adams_bashforth use foodie_integrator_adams_bashforth_moulton , only : integrator_adams_bashforth_moulton use foodie_integrator_adams_moulton , only : integrator_adams_moulton use foodie_integrator_backward_differentiation_formula , only : integrator_back_df use foodie_integrator_euler_explicit , only : integrator_euler_explicit use foodie_integrator_leapfrog , only : integrator_leapfrog use foodie_integrator_lmm_ssp , only : integrator_lmm_ssp use foodie_integrator_lmm_ssp_vss , only : integrator_lmm_ssp_vss use foodie_integrator_ms_runge_kutta_ssp , only : integrator_ms_runge_kutta_ssp use foodie_integrator_multistage_object , only : integrator_multistage_object use foodie_integrator_multistage_multistep_object , only : integrator_multistage_multistep_object use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_runge_kutta_emd , only : integrator_runge_kutta_emd use foodie_integrator_runge_kutta_low_storage , only : integrator_runge_kutta_ls use foodie_integrator_runge_kutta_lssp , only : integrator_runge_kutta_lssp use foodie_integrator_runge_kutta_ssp , only : integrator_runge_kutta_ssp use penf , only : I_P , R_P implicit none private ! helper procedures public :: foodie_integrator_class_names public :: foodie_integrator_factory public :: foodie_integrator_schemes public :: is_available public :: is_class_available public :: is_scheme_available ! abstract objects public :: integrand_object public :: integrator_object public :: integrator_multistage_object public :: integrator_multistage_multistep_object public :: integrator_multistep_object ! concrete objects public :: integrator_adams_bashforth public :: integrator_adams_bashforth_moulton public :: integrator_adams_moulton public :: integrator_back_df public :: integrator_euler_explicit public :: integrator_leapfrog public :: integrator_lmm_ssp public :: integrator_lmm_ssp_vss public :: integrator_ms_runge_kutta_ssp public :: integrator_runge_kutta_emd public :: integrator_runge_kutta_ls public :: integrator_runge_kutta_lssp public :: integrator_runge_kutta_ssp contains pure function foodie_integrator_class_names () result ( names ) !< Return the list of available intergrator class of schemes names. character ( len = 99 ), allocatable :: names (:) !< Available integrator class names. type ( integrator_adams_bashforth ) :: int_adams_bashforth !< Integrator Adams Bashforth. type ( integrator_adams_bashforth_moulton ) :: int_adams_bashforth_moulton !< Integrator Adams Bashforth Moulton. type ( integrator_adams_moulton ) :: int_adams_moulton !< Integrator Adams Moulton. type ( integrator_back_df ) :: int_back_df !< Integrator back differentiation formula. type ( integrator_euler_explicit ) :: int_euler_explicit !< Integrator euler explicit. type ( integrator_leapfrog ) :: int_leapfrog !< Integrator leapfrog. type ( integrator_lmm_ssp ) :: int_lmm_ssp !< Integrator lmm SSP. type ( integrator_lmm_ssp_vss ) :: int_lmm_ssp_vss !< Integrator lmm SSP VSS. type ( integrator_ms_runge_kutta_ssp ) :: int_ms_runge_kutta_ssp !< Integrator multistep Runge Kutta ssp. type ( integrator_runge_kutta_emd ) :: int_runge_kutta_emd !< Integrator Runge Kutta embdedded. type ( integrator_runge_kutta_ls ) :: int_runge_kutta_ls !< Integrator Runge Kutta low storage. type ( integrator_runge_kutta_lssp ) :: int_runge_kutta_lssp !< Integrator linear Runge Kutta SSP. type ( integrator_runge_kutta_ssp ) :: int_runge_kutta_ssp !< Integrator Runge Kutta SSP. names = [ int_adams_bashforth % class_name ()] names = [ names , int_adams_bashforth_moulton % class_name ()] names = [ names , int_adams_moulton % class_name ()] names = [ names , int_back_df % class_name ()] names = [ names , int_euler_explicit % class_name ()] names = [ names , int_leapfrog % class_name ()] names = [ names , int_lmm_ssp % class_name ()] names = [ names , int_lmm_ssp_vss % class_name ()] names = [ names , int_ms_runge_kutta_ssp % class_name ()] names = [ names , int_runge_kutta_emd % class_name ()] names = [ names , int_runge_kutta_ls % class_name ()] names = [ names , int_runge_kutta_lssp % class_name ()] names = [ names , int_runge_kutta_ssp % class_name ()] endfunction foodie_integrator_class_names subroutine foodie_integrator_factory ( scheme , integrator , stages , tolerance , nu , alpha , iterations , autoupdate , U ) !< Return a concrete instance of [[integrator_object]] given a scheme selection. !< !< This is the FOODIE integrators factory. !< !< @note If an error occurs the error status of [[integrator_object]] is updated. character ( * ), intent ( in ) :: scheme !< Selected integrator given. class ( integrator_object ), allocatable , intent ( out ) :: integrator !< The FOODIE integrator. integer ( I_P ), optional , intent ( in ) :: stages !< Stages of multi-stage methods. real ( R_P ), optional , intent ( in ) :: tolerance !< Tolerance on the local truncation error. real ( R_P ), optional , intent ( in ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( in ) :: alpha !< Robert-Asselin filter coefficient. integer ( I_P ), optional , intent ( in ) :: iterations !< Implicit iterations. logical , optional , intent ( in ) :: autoupdate !< Enable cyclic autoupdate for multistep. class ( integrand_object ), optional , intent ( in ) :: U !< Integrand molding prototype. type ( integrator_adams_bashforth ) :: int_adams_bashforth !< Integrator Adams Bashforth. type ( integrator_adams_bashforth_moulton ) :: int_adams_bashforth_moulton !< Integrator Adams Bashforth Moulton. type ( integrator_adams_moulton ) :: int_adams_moulton !< Integrator Adams Moulton. type ( integrator_back_df ) :: int_back_df !< Integrator back differentiation formula. type ( integrator_euler_explicit ) :: int_euler_explicit !< Integrator euler explicit. type ( integrator_leapfrog ) :: int_leapfrog !< Integrator leapfrog. type ( integrator_lmm_ssp ) :: int_lmm_ssp !< Integrator LMM SSP. type ( integrator_lmm_ssp_vss ) :: int_lmm_ssp_vss !< Integrator LMM SSP VSS. type ( integrator_ms_runge_kutta_ssp ) :: int_ms_runge_kutta_ssp !< Integrator multistep Runge Kutta ssp. type ( integrator_runge_kutta_emd ) :: int_runge_kutta_emd !< Integrator Runge Kutta_embdedded. type ( integrator_runge_kutta_ls ) :: int_runge_kutta_ls !< Integrator Runge Kutta low storage. type ( integrator_runge_kutta_lssp ) :: int_runge_kutta_lssp !< Integrator linear Runge Kutta SSP. type ( integrator_runge_kutta_ssp ) :: int_runge_kutta_ssp !< Integrator Runge Kutta SSP. if ( index ( trim ( adjustl ( scheme )), trim ( int_adams_bashforth_moulton % class_name ())) > 0 ) then allocate ( integrator_adams_bashforth_moulton :: integrator ) select type ( integrator ) type is ( integrator_adams_bashforth_moulton ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_adams_bashforth % class_name ())) > 0 ) then allocate ( integrator_adams_bashforth :: integrator ) select type ( integrator ) type is ( integrator_adams_bashforth ) call integrator % initialize ( scheme = scheme , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_adams_moulton % class_name ())) > 0 ) then allocate ( integrator_adams_moulton :: integrator ) select type ( integrator ) type is ( integrator_adams_moulton ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_back_df % class_name ())) > 0 ) then allocate ( integrator_back_df :: integrator ) select type ( integrator ) type is ( integrator_back_df ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_euler_explicit % class_name ())) > 0 ) then allocate ( integrator_euler_explicit :: integrator ) select type ( integrator ) type is ( integrator_euler_explicit ) call integrator % initialize ( scheme = scheme , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_leapfrog % class_name ())) > 0 ) then allocate ( integrator_leapfrog :: integrator ) select type ( integrator ) type is ( integrator_leapfrog ) call integrator % initialize ( scheme = scheme , nu = nu , alpha = alpha , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_lmm_ssp_vss % class_name ())) > 0 ) then allocate ( integrator_lmm_ssp_vss :: integrator ) select type ( integrator ) type is ( integrator_lmm_ssp_vss ) call integrator % initialize ( scheme = scheme , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_lmm_ssp % class_name ())) > 0 ) then allocate ( integrator_lmm_ssp :: integrator ) select type ( integrator ) type is ( integrator_lmm_ssp ) call integrator % initialize ( scheme = scheme , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_ms_runge_kutta_ssp % class_name ())) > 0 ) then allocate ( integrator_ms_runge_kutta_ssp :: integrator ) select type ( integrator ) type is ( integrator_ms_runge_kutta_ssp ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_emd % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_emd :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_emd ) call integrator % initialize ( scheme = scheme , tolerance = tolerance , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_lssp % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_lssp :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_lssp ) call integrator % initialize ( scheme = scheme , stages = stages , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_ls % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_ls :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_ls ) call integrator % initialize ( scheme = scheme , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_ssp % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_ssp :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_ssp ) call integrator % initialize ( scheme = scheme , U = U ) endselect else write ( stderr , '(A)' ) 'error: \"' // trim ( adjustl ( scheme )) // '\" scheme is unknown!' stop endif endsubroutine foodie_integrator_factory pure function foodie_integrator_schemes ( class_name ) result ( schemes ) !< Return the list of all available intergrator schemes, or only the schemes belonging to the given class name. !< !< @note In the case the class name passed is not available the schemes array is returned not allocated and not warnings are !< given: it is up to the caller to check the status of the schemes array. character ( * ), intent ( in ), optional :: class_name !< Return only the schemes belogn to the given class. character ( len = 99 ), allocatable :: schemes (:) !< Available integrators. type ( integrator_adams_bashforth ) :: int_adams_bashforth !< Integrator Adams Bashforth. type ( integrator_adams_bashforth_moulton ) :: int_adams_bashforth_moulton !< Integrator Adams Bashforth Moulton. type ( integrator_adams_moulton ) :: int_adams_moulton !< Integrator Adams Moulton. type ( integrator_back_df ) :: int_back_df !< Integrator back differentiation formula. type ( integrator_euler_explicit ) :: int_euler_explicit !< Integrator euler explicit. type ( integrator_leapfrog ) :: int_leapfrog !< Integrator leapfrog. type ( integrator_lmm_ssp ) :: int_lmm_ssp !< Integrator lmm SSP. type ( integrator_lmm_ssp_vss ) :: int_lmm_ssp_vss !< Integrator lmm SSP VSS. type ( integrator_ms_runge_kutta_ssp ) :: int_ms_runge_kutta_ssp !< Integrator multistep Runge Kutta ssp. type ( integrator_runge_kutta_emd ) :: int_runge_kutta_emd !< Integrator Runge Kutta embdedded. type ( integrator_runge_kutta_ls ) :: int_runge_kutta_ls !< Integrator Runge Kutta low storage. type ( integrator_runge_kutta_lssp ) :: int_runge_kutta_lssp !< Integrator linear Runge Kutta SSP. type ( integrator_runge_kutta_ssp ) :: int_runge_kutta_ssp !< Integrator Runge Kutta SSP. if ( present ( class_name )) then if ( trim ( int_adams_bashforth % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_adams_bashforth % supported_schemes () elseif ( trim ( int_adams_bashforth_moulton % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_adams_bashforth_moulton % supported_schemes () elseif ( trim ( int_adams_moulton % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_adams_moulton % supported_schemes () elseif ( trim ( int_back_df % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_back_df % supported_schemes () elseif ( trim ( int_euler_explicit % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_euler_explicit % supported_schemes () elseif ( trim ( int_leapfrog % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_leapfrog % supported_schemes () elseif ( trim ( int_lmm_ssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_lmm_ssp % supported_schemes () elseif ( trim ( int_lmm_ssp_vss % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_lmm_ssp_vss % supported_schemes () elseif ( trim ( int_ms_runge_kutta_ssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_ms_runge_kutta_ssp % supported_schemes () elseif ( trim ( int_runge_kutta_emd % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_emd % supported_schemes () elseif ( trim ( int_runge_kutta_ls % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_ls % supported_schemes () elseif ( trim ( int_runge_kutta_lssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_lssp % supported_schemes () elseif ( trim ( int_runge_kutta_ssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_ssp % supported_schemes () endif else schemes = int_adams_bashforth % supported_schemes () schemes = [ schemes , int_adams_bashforth_moulton % supported_schemes ()] schemes = [ schemes , int_adams_moulton % supported_schemes ()] schemes = [ schemes , int_back_df % supported_schemes ()] schemes = [ schemes , int_euler_explicit % supported_schemes ()] schemes = [ schemes , int_leapfrog % supported_schemes ()] schemes = [ schemes , int_lmm_ssp % supported_schemes ()] schemes = [ schemes , int_lmm_ssp_vss % supported_schemes ()] schemes = [ schemes , int_ms_runge_kutta_ssp % supported_schemes ()] schemes = [ schemes , int_runge_kutta_emd % supported_schemes ()] schemes = [ schemes , int_runge_kutta_ls % supported_schemes ()] schemes = [ schemes , int_runge_kutta_lssp % supported_schemes ()] schemes = [ schemes , int_runge_kutta_ssp % supported_schemes ()] endif endfunction foodie_integrator_schemes pure function is_available ( scheme ) !< Return .true. if the given scheme (or class of schemes name) is available in the FOODIE library. character ( * ), intent ( in ) :: scheme !< Selected integrator given. logical :: is_available !< Availability result. is_available = is_class_available ( scheme = scheme ) if ( is_available ) return is_available = is_scheme_available ( scheme = scheme ) if ( is_available ) return endfunction is_available pure function is_class_available ( scheme ) !< Return .true. if the given class of schemes name is available. character ( * ), intent ( in ) :: scheme !< Selected integrator given. logical :: is_class_available !< Availability result. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. integer ( I_P ) :: i !< Counter. integrator_class_names = foodie_integrator_class_names () is_class_available = . false . do i = 1 , size ( integrator_class_names , dim = 1 ) is_class_available = ( trim ( adjustl ( scheme )) == trim ( adjustl ( integrator_class_names ( i )))) if ( is_class_available ) return enddo endfunction is_class_available pure function is_scheme_available ( scheme ) !< Return .true. if the given scheme (class name) is available in the FOODIE library. character ( * ), intent ( in ) :: scheme !< Selected integrator given. logical :: is_scheme_available !< Availability result. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: i !< Counter. integrator_schemes = foodie_integrator_schemes () is_scheme_available = . false . do i = 1 , size ( integrator_schemes , dim = 1 ) is_scheme_available = ( trim ( adjustl ( scheme )) == trim ( adjustl ( integrator_schemes ( i )))) if ( is_scheme_available ) return enddo endfunction is_scheme_available endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – FOODIE"},{"text":"FOODIE error codes list. Files Dependent On This One sourcefile~~foodie_error_codes.f90~~AfferentGraph sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_error_codesf90AfferentGraph = svgPanZoom('#sourcefilefoodie_error_codesf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_error_codes Source Code foodie_error_codes.f90 Source Code !< FOODIE error codes list. module foodie_error_codes !< FOODIE error codes list. use penf , only : I_P implicit none private public :: ERROR_UNSUPPORTED_SCHEME integer ( I_P ), parameter :: ERROR_UNSUPPORTED_SCHEME = 1 !< Error unsupported scheme. endmodule foodie_error_codes","tags":"","loc":"sourcefile/foodie_error_codes.f90.html","title":"foodie_error_codes.f90 – FOODIE"},{"text":"Define the abstract type integrand for building FOODIE ODE integrators. Files Dependent On This One sourcefile~~foodie_integrand_object.f90~~AfferentGraph sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrand_objectf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrand_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrand_object Source Code foodie_integrand_object.f90 Source Code !< Define the abstract type *integrand* for building FOODIE ODE integrators. module foodie_integrand_object !< Define the abstract type *integrand* for building FOODIE ODE integrators. use penf , only : I_P , R_P implicit none private public :: integrand_object type , abstract :: integrand_object !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( integrand_dimension_interface ), pass ( self ), deferred , public :: integrand_dimension !< Return integrand dimension. procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< `||integrand - integrand||` operator. generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. ! + procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_add_integrand !< `+` operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_add_real !< `+ real` operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_add_integrand !< `real +` operator. generic , public :: operator ( + ) => integrand_add_integrand , & integrand_add_real , & real_add_integrand !< Overloading `+` operator. ! * procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< `*` operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< `* real` operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< `real *` operator. procedure ( integrand_op_real_scalar ), pass ( lhs ), deferred , public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure ( real_scalar_op_integrand ), pass ( rhs ), deferred , public :: real_scalar_multiply_integrand !< `real_scalar *` operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & integrand_multiply_real , & real_multiply_integrand , & integrand_multiply_real_scalar , & real_scalar_multiply_integrand !< Overloading `*` operator. ! - procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_sub_integrand !< `-` operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_sub_real !< `- real` operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_sub_integrand !< `real -` operator. generic , public :: operator ( - ) => integrand_sub_integrand , & integrand_sub_real , & real_sub_integrand !< Overloading `-` operator. ! = procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< `=` operator. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< `= real` operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading `=` assignament. ! public methods for fast operational mode, must be overridden procedure , pass ( self ), public :: t_fast !< Time derivative, residuals, fast mode. procedure , pass ( opr ), public :: integrand_add_integrand_fast !< `+` fast operator. generic , public :: add_fast => integrand_add_integrand_fast !< Overloading `add_fast` method. procedure , pass ( opr ), public :: integrand_multiply_integrand_fast !< `*` fast operator. procedure , pass ( opr ), public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. generic , public :: multiply_fast => integrand_multiply_integrand_fast , & integrand_multiply_real_scalar_fast !< Overloading `multiply_fast` method. procedure , pass ( opr ), public :: integrand_subtract_integrand_fast !< `-` fast operator. generic , public :: subtract_fast => integrand_subtract_integrand_fast !< Overloading `subtract_fast` method. endtype integrand_object abstract interface !< Abstract type bound procedures necessary for implementing a concrete extension of [[integrand_object]]. pure function integrand_dimension_interface ( self ) result ( integrand_dimension ) !< Return integrand dimension. import :: integrand_object , I_P class ( integrand_object ), intent ( in ) :: self !< Integrand. integer ( I_P ) :: integrand_dimension !< Integrand dimension. endfunction integrand_dimension_interface function time_derivative ( self , t ) result ( dState_dt ) !< Time derivative function of integrand class, i.e. the residuals function. import :: integrand_object , R_P class ( integrand_object ), intent ( in ) :: self !< Integrand field. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), allocatable :: dState_dt (:) !< Result of the time derivative function of integrand field. endfunction time_derivative ! operators function local_error_operator ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 solution approximations. import :: integrand_object , R_P class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. endfunction local_error_operator pure function integrand_op_real ( lhs , rhs ) result ( operator_result ) !< Asymmetric type operator `integrand.op.real`. import :: integrand_object , R_P class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: operator_result (:) !< Operator result. endfunction integrand_op_real pure function real_op_integrand ( lhs , rhs ) result ( operator_result ) !< Asymmetric type operator `real.op.integrand`. import :: integrand_object , R_P class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: operator_result (:) !< Operator result. endfunction real_op_integrand pure function integrand_op_real_scalar ( lhs , rhs ) result ( operator_result ) !< Asymmetric type operator `integrand.op.real`. import :: integrand_object , R_P class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: operator_result (:) !< Operator result. endfunction integrand_op_real_scalar pure function real_scalar_op_integrand ( lhs , rhs ) result ( operator_result ) !< Asymmetric type operator `real.op.integrand`. import :: integrand_object , R_P real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: operator_result (:) !< Operator result. endfunction real_scalar_op_integrand pure function symmetric_operator ( lhs , rhs ) result ( operator_result ) !< Symmetric type operator integrand.op.integrand. import :: integrand_object , R_P class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: operator_result (:) !< Operator result. endfunction symmetric_operator subroutine assignment_integrand ( lhs , rhs ) !< Symmetric assignment integrand = integrand. import :: integrand_object class ( integrand_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_integrand pure subroutine assignment_real ( lhs , rhs ) !< Symmetric assignment integrand = integrand. import :: integrand_object , R_P class ( integrand_object ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. endsubroutine assignment_real endinterface contains ! fast operators ! time derivative subroutine t_fast ( self , t ) !< Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: self !< Integrand field. real ( R_P ), intent ( in ), optional :: t !< Time. endsubroutine t_fast ! + pure subroutine integrand_add_integrand_fast ( opr , lhs , rhs ) !< `+` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_add_integrand_fast ! * pure subroutine integrand_multiply_integrand_fast ( opr , lhs , rhs ) !< `*` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_multiply_integrand_fast pure subroutine integrand_multiply_real_scalar_fast ( opr , lhs , rhs ) !< `* real_scalar` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_multiply_real_scalar_fast ! - pure subroutine integrand_subtract_integrand_fast ( opr , lhs , rhs ) !< `-` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_subtract_integrand_fast endmodule foodie_integrand_object","tags":"","loc":"sourcefile/foodie_integrand_object.f90.html","title":"foodie_integrand_object.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. This File Depends On sourcefile~~foodie_integrator_adams_bashforth.f90~~EfferentGraph sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_adams_bashforth.f90~~AfferentGraph sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_adams_bashforthf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_adams_bashforthf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_adams_bashforth Source Code foodie_integrator_adams_bashforth.f90 Source Code !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. module foodie_integrator_adams_bashforth !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients *b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[1, 16]*. Note that the scheme using only 1 step reverts !< to Explicit Forward Euler. The formal order of accuracy varies consistently in *[1st, 16th]* order. !< !<#### Bibliography !< [1] *Cowell Type Numerical Integration As Applied to Satellite Orbit Computation*, J. L. Maury Jr., !< G. P. Segal, X-553-69-46, April 1969, [NASA-TM-X-63542](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19690017325.pdf). !< !< [2] *Linear multistep method*, [wikipedia article](https://en.wikipedia.org/wiki/Linear_multistep_method). use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_adams_bashforth character ( len = 99 ), parameter :: class_name_ = 'adams_bashforth' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 16 ) = [ trim ( class_name_ ) // '_1 ' , & trim ( class_name_ ) // '_2 ' , & trim ( class_name_ ) // '_3 ' , & trim ( class_name_ ) // '_4 ' , & trim ( class_name_ ) // '_5 ' , & trim ( class_name_ ) // '_6 ' , & trim ( class_name_ ) // '_7 ' , & trim ( class_name_ ) // '_8 ' , & trim ( class_name_ ) // '_9 ' , & trim ( class_name_ ) // '_10' , & trim ( class_name_ ) // '_11' , & trim ( class_name_ ) // '_12' , & trim ( class_name_ ) // '_13' , & trim ( class_name_ ) // '_14' , & trim ( class_name_ ) // '_15' , & trim ( class_name_ ) // '_16' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistep_object ) :: integrator_adams_bashforth !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: b (:) !< *b* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_adams_bashforth contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_adams_bashforth ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_adams_bashforth ) if ( allocated ( rhs % b )) lhs % b = rhs % b endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth class scheme. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. do s = 1 , self % steps U = U + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % b ( s ))) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth class scheme, fast mode. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. do s = 1 , self % steps self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % b )) deallocate ( self % b ) endsubroutine destroy subroutine initialize ( self , scheme , autoupdate , U , stop_on_fail ) !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'adams_bashforth_1' ) self % steps = 1 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 1.0_R_P case ( 'adams_bashforth_2' ) self % steps = 2 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 1.0_R_P / 2.0_R_P self % b ( 2 ) = 3.0_R_P / 2.0_R_P case ( 'adams_bashforth_3' ) self % steps = 3 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 5.0_R_P / 1 2.0_R_P self % b ( 2 ) = - 1 6.0_R_P / 1 2.0_R_P self % b ( 3 ) = 2 3.0_R_P / 1 2.0_R_P case ( 'adams_bashforth_4' ) self % steps = 4 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 9.0_R_P / 2 4.0_R_P self % b ( 2 ) = 3 7.0_R_P / 2 4.0_R_P self % b ( 3 ) = - 5 9.0_R_P / 2 4.0_R_P self % b ( 4 ) = 5 5.0_R_P / 2 4.0_R_P case ( 'adams_bashforth_5' ) self % steps = 5 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 25 1.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 127 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 261 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = - 277 4.0_R_P / 72 0.0_R_P self % b ( 5 ) = 190 1.0_R_P / 72 0.0_R_P case ( 'adams_bashforth_6' ) self % steps = 6 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 47 5.0_R_P / 144 0.0_R_P self % b ( 2 ) = 287 7.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 729 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 998 2.0_R_P / 144 0.0_R_P self % b ( 5 ) = - 792 3.0_R_P / 144 0.0_R_P self % b ( 6 ) = 427 7.0_R_P / 144 0.0_R_P case ( 'adams_bashforth_7' ) self % steps = 7 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 1908 7.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 13447 2.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 40713 9.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 68825 6.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 70554 9.0_R_P / 6048 0.0_R_P self % b ( 6 ) = - 44728 8.0_R_P / 6048 0.0_R_P self % b ( 7 ) = 19872 1.0_R_P / 6048 0.0_R_P case ( 'adams_bashforth_8' ) self % steps = 8 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 3679 9.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 29576 7.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 104172 3.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 210224 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 266447 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 218387 7.0_R_P / 12096 0.0_R_P self % b ( 7 ) = - 115216 9.0_R_P / 12096 0.0_R_P self % b ( 8 ) = 43424 1.0_R_P / 12096 0.0_R_P case ( 'adams_bashforth_9' ) self % steps = 9 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 107001 7.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 966410 6.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 3883348 6.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 9117264 2.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 13796848 0.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 13985526 2.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 9547678 6.0_R_P / 362880 0.0_R_P self % b ( 8 ) = - 4312520 6.0_R_P / 362880 0.0_R_P self % b ( 9 ) = 1409724 7.0_R_P / 362880 0.0_R_P case ( 'adams_bashforth_10' ) self % steps = 10 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 208275 3.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 2088481 1.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 9430732 0.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 25261822 4.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 44477216 2.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 53836383 8.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 45466177 6.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 26593268 0.0_R_P / 725760 0.0_R_P self % b ( 9 ) = - 10499518 9.0_R_P / 725760 0.0_R_P self % b ( 10 ) = 3027724 7.0_R_P / 725760 0.0_R_P case ( 'adams_bashforth_11' ) self % steps = 11 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 13421126 5.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 147957434 8.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 741790445 1.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 2232963492 0.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 4485716843 4.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 6317620147 2.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 6371637895 8.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 4611302901 6.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 2359106380 5.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = - 827179512 4.0_R_P / 47900160 0.0_R_P self % b ( 11 ) = 213250956 7.0_R_P / 47900160 0.0_R_P case ( 'adams_bashforth_12' ) self % steps = 12 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 26274726 5.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 315864244 5.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 1741024827 1.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 5818910762 7.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 13136586729 0.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 21110357329 8.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 24774163937 4.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 21413935536 6.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 13557935675 7.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 6163322718 5.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = - 1943381016 3.0_R_P / 95800320 0.0_R_P self % b ( 12 ) = 452776639 9.0_R_P / 95800320 0.0_R_P case ( 'adams_bashforth_13' ) self % steps = 13 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 916055108573 4.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 5506097466241 2.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 20232291373837 0.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 50714036972842 5.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 91588338715244 4.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 122644308612940 8.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 123358924494176 4.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 93288454605589 5.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 52492457990515 0.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 21469659100261 2.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = - 6149755279727 4.0_R_P / 261534873600 0.0_R_P self % b ( 13 ) = 1306440652362 7.0_R_P / 261534873600 0.0_R_P case ( 'adams_bashforth_14' ) self % steps = 14 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 138274192962 1.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 1938285359378 7.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 12617497268190 6.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 50558614119643 0.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 139330630715575 5.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 279386960287907 7.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 420455192553452 4.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 482567132348845 2.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 424676735330575 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 285442957179080 5.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 144531335168190 6.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 53724705251566 2.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = - 14097075067962 1.0_R_P / 523069747200 0.0_R_P self % b ( 14 ) = 2751155497687 5.0_R_P / 523069747200 0.0_R_P case ( 'adams_bashforth_15' ) self % steps = 15 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 12259481390411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 85923647668423 1.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 372880725657747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 1120584975351517 9.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 2470450365560772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 4128021633628425 9.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 5324673866064691 2.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 5347102665994050 9.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 4182526993250772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 2529891033708142 9.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 1164363753057747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 396642167021548 1.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = - 96012286640411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 15 ) = 17323349859884 9.0_R_P / 3138418483200 0.0_R_P case ( 'adams_bashforth_16' ) self % steps = 16 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 1608812922937 5.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 25765027591582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 193444319689259 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 903857175273408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 2941791091125181 9.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 7072435158284348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 12993009410423733 1.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 18608754426359664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 21002058891232194 9.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 18746314011290289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 13196319194082858 1.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 7255811707225973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 3060737386052056 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 962209690951533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = - 216156767124884 9.0_R_P / 6276836966400 0.0_R_P self % b ( 16 ) = 36255512642707 3.0_R_P / 6276836966400 0.0_R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize endmodule foodie_integrator_adams_bashforth","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth.f90.html","title":"foodie_integrator_adams_bashforth.f90 – FOODIE"},{"text":"FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. This File Depends On sourcefile~~foodie_integrator_adams_bashforth_moulton.f90~~EfferentGraph sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 var pansourcefilefoodie_integrator_adams_bashforth_moultonf90EfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_adams_bashforth_moultonf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_adams_bashforth_moulton.f90~~AfferentGraph sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_adams_bashforth_moultonf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_adams_bashforth_moultonf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_adams_bashforth_moulton Source Code foodie_integrator_adams_bashforth_moulton.f90 Source Code !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. module foodie_integrator_adams_bashforth_moulton !< FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order !< accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: !< !<##### predictor !<  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  !<##### corrector !<  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  !< !<where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps !<considered for the corrector. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of !< **steps** used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1 !< should hold. !< !< Currently, the following schemes are available: !<##### P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order !< This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order. !< The *b* coefficient is: !< b&#94;p = \\left[b_1\\right] = \\left[1\\right] !< b&#94;c = \\left[b_0\\right] = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n})  !<  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  !< !<##### P=AB(2)-C=AM(1) steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<##### P=AB(3)-C=AM(2) steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !<  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2}) !< -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  !< !<##### P=AB(4)-C=AM(3) steps !< This scheme is 4th order. !< The *b* coefficients are: !< b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right] !< b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] = !<         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2}) !< +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right]  !<  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3}) !< -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  !< !<#### Bibliography !< use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_adams_bashforth , only : integrator_adams_bashforth use foodie_integrator_adams_moulton , only : integrator_adams_moulton use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_adams_bashforth_moulton character ( len = 99 ), parameter :: class_name_ = 'adams_bashforth_moulton' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 16 ) = [ trim ( class_name_ ) // '_1 ' , & trim ( class_name_ ) // '_2 ' , & trim ( class_name_ ) // '_3 ' , & trim ( class_name_ ) // '_4 ' , & trim ( class_name_ ) // '_5 ' , & trim ( class_name_ ) // '_6 ' , & trim ( class_name_ ) // '_7 ' , & trim ( class_name_ ) // '_8 ' , & trim ( class_name_ ) // '_9 ' , & trim ( class_name_ ) // '_10' , & trim ( class_name_ ) // '_11' , & trim ( class_name_ ) // '_12' , & trim ( class_name_ ) // '_13' , & trim ( class_name_ ) // '_14' , & trim ( class_name_ ) // '_15' , & trim ( class_name_ ) // '_16' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistep_object ) :: integrator_adams_bashforth_moulton !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private type ( integrator_adams_bashforth ) :: predictor !< Predictor solver. type ( integrator_adams_moulton ) :: corrector !< Corrector solver. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. procedure , pass ( self ) :: scheme_number !< Return the scheme number in the list of supported schemes. endtype integrator_adams_bashforth_moulton contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_adams_bashforth_moulton ) lhs % steps = rhs % steps lhs % predictor = rhs % predictor lhs % corrector = rhs % corrector endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth-Moulton class scheme. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. integer ( I_P ) :: s !< Step counter. do s = 1 , self % steps self % predictor % previous ( s ) = self % previous ( s ) self % predictor % t ( s ) = self % t ( s ) self % predictor % Dt ( s ) = self % Dt ( s ) enddo do s = 1 , self % steps - 1 self % corrector % previous ( s ) = self % predictor % previous ( s + 1 ) self % corrector % t ( s ) = self % predictor % t ( s + 1 ) self % corrector % Dt ( s ) = self % predictor % Dt ( s + 1 ) enddo call self % predictor % integrate ( U = U , Dt = Dt , t = t ) call self % corrector % integrate ( U = U , Dt = Dt , t = t ) if ( self % autoupdate ) & call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth-Moulton class scheme, fast mode. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. integer ( I_P ) :: s !< Step counter. do s = 1 , self % steps self % predictor % previous ( s ) = self % previous ( s ) enddo self % predictor % t (:) = self % t ( 1 : self % steps ) self % predictor % Dt (:) = self % Dt ( 1 : self % steps ) do s = 1 , self % steps - 1 self % corrector % previous ( s ) = self % previous ( s + 1 ) enddo self % corrector % t (:) = self % t ( 2 : self % steps ) self % corrector % Dt (:) = self % Dt ( 2 : self % steps ) call self % predictor % integrate_fast ( U = U , Dt = Dt , t = t ) call self % corrector % integrate_fast ( U = U , Dt = Dt , t = t ) if ( self % autoupdate ) & call self % update_previous ( U = U , previous = self % previous ( 1 : self % steps ), Dt = Dt , t = t , previous_t = self % t ( 1 : self % steps )) endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep call self % predictor % destroy call self % corrector % destroy endsubroutine destroy subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. character ( len = 99 ), allocatable :: schemes_ab (:) !< Adams-Bashforth schemes. character ( len = 99 ), allocatable :: schemes_am (:) !< Adams-Moulton schemes. integer ( I_P ) :: scheme_number_ !< Scheme number in the list of supported schemes. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) scheme_number_ = self % scheme_number ( scheme = scheme ) schemes_ab = self % predictor % supported_schemes () schemes_am = self % corrector % supported_schemes () self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations call self % predictor % initialize ( scheme = schemes_ab ( scheme_number_ ), U = U , autoupdate = . false .) call self % corrector % initialize ( scheme = schemes_am ( scheme_number_ ), U = U , iterations = self % iterations , autoupdate = . false .) self % steps = self % predictor % steps_number () self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize elemental function scheme_number ( self , scheme ) !< Return the scheme number in the list of supported schemes. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ) :: scheme_number !< Scheme number in the list of supported schemes. integer ( I_P ) :: s !< Counter. scheme_number = 0 do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then scheme_number = s exit endif enddo endfunction scheme_number endmodule foodie_integrator_adams_bashforth_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth_moulton.f90.html","title":"foodie_integrator_adams_bashforth_moulton.f90 – FOODIE"},{"text":"FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. This File Depends On sourcefile~~foodie_integrator_adams_moulton.f90~~EfferentGraph sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_adams_moulton.f90~~AfferentGraph sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_adams_moultonf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_adams_moultonf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_adams_moulton Source Code foodie_integrator_adams_moulton.f90 Source Code !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. module foodie_integrator_adams_moulton !< FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Moulton class scheme implemented is: !< !<  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } + !< b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients *b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[0, 15]*. Note that the scheme using only 1 step reverts !< to Implciti Backwarad Euler. The formal order of accuracy varies consistently in *[1st, 16th]* order. !< !<#### Bibliography !< [1] *Cowell Type Numerical Integration As Applied to Satellite Orbit Computation*, J. L. Maury Jr., !< G. P. Segal, X-553-69-46, April 1969, [NASA-TM-X-63542](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19690017325.pdf). !< !< [2] *Linear multistep method*, [wikipedia article](https://en.wikipedia.org/wiki/Linear_multistep_method). use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_adams_moulton character ( len = 99 ), parameter :: class_name_ = 'adams_moulton' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 16 ) = [ trim ( class_name_ ) // '_0 ' , & trim ( class_name_ ) // '_1 ' , & trim ( class_name_ ) // '_2 ' , & trim ( class_name_ ) // '_3 ' , & trim ( class_name_ ) // '_4 ' , & trim ( class_name_ ) // '_5 ' , & trim ( class_name_ ) // '_6 ' , & trim ( class_name_ ) // '_7 ' , & trim ( class_name_ ) // '_8 ' , & trim ( class_name_ ) // '_9 ' , & trim ( class_name_ ) // '_10' , & trim ( class_name_ ) // '_11' , & trim ( class_name_ ) // '_12' , & trim ( class_name_ ) // '_13' , & trim ( class_name_ ) // '_14' , & trim ( class_name_ ) // '_15' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistep_object ) :: integrator_adams_moulton !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: b (:) !< b coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_adams_moulton contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_adams_moulton ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_adams_moulton ) lhs % steps = rhs % steps if ( allocated ( rhs % b )) lhs % b = rhs % b endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with Adams-Moulton class scheme. class ( integrator_adams_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. if ( self % steps > 0 ) then if ( self % iterations > 0 ) then ! perform fixed point iterations allocate ( delta , mold = U ) delta = self % previous ( self % steps ) do s = 0 , self % steps - 1 delta = delta + ( self % previous ( s + 1 )% t ( t = self % t ( s + 1 )) * ( Dt * self % b ( s ))) enddo do s = 1 , self % iterations U = delta + ( U % t ( t = self % t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps ))) enddo else U = self % previous ( self % steps ) + ( U % t ( t = self % t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps ))) do s = 0 , self % steps - 1 U = U + ( self % previous ( s + 1 )% t ( t = self % t ( s + 1 )) * ( Dt * self % b ( s ))) enddo endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) else U = U + ( U % t ( t = t ) * ( Dt * self % b ( 0 ))) endif endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with Adams-Moulton class scheme, fast mode. class ( integrator_adams_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. if ( self % steps > 0 ) then if ( self % iterations > 0 ) then ! perform fixed point iterations allocate ( delta , mold = U ) delta = self % previous ( self % steps ) do s = 0 , self % steps - 1 self % buffer = self % previous ( s + 1 ) call self % buffer % t_fast ( t = self % t ( s + 1 )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call delta % add_fast ( lhs = delta , rhs = self % buffer ) enddo do s = 1 , self % iterations self % buffer = U call self % buffer % t_fast ( t = self % t ( self % steps ) + Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( self % steps )) call U % add_fast ( lhs = delta , rhs = self % buffer ) enddo else self % buffer = U call self % buffer % t_fast ( t = self % t ( self % steps ) + Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( self % steps )) call U % add_fast ( lhs = self % previous ( self % steps ), rhs = self % buffer ) do s = 0 , self % steps - 1 self % buffer = self % previous ( s + 1 ) call self % buffer % t_fast ( t = self % t ( s + 1 )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) else self % buffer = U call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( 0 )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_adams_moulton ), intent ( INOUT ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % b )) deallocate ( self % b ) endsubroutine destroy subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. class ( integrator_adams_moulton ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'adams_moulton_0' ) self % steps = 0 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 1.0_R_P case ( 'adams_moulton_1' ) self % steps = 1 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 1.0_R_P / 2.0_R_P self % b ( 1 ) = 1.0_R_P / 2.0_R_P case ( 'adams_moulton_2' ) self % steps = 2 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 1.0_R_P / 1 2.0_R_P self % b ( 1 ) = 8.0_R_P / 1 2.0_R_P self % b ( 2 ) = 5.0_R_P / 1 2.0_R_P case ( 'adams_moulton_3' ) self % steps = 3 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 1.0_R_P / 2 4.0_R_P self % b ( 1 ) = - 5.0_R_P / 2 4.0_R_P self % b ( 2 ) = 1 9.0_R_P / 2 4.0_R_P self % b ( 3 ) = 9.0_R_P / 2 4.0_R_P case ( 'adams_moulton_4' ) self % steps = 4 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 1 9.0_R_P / 72 0.0_R_P self % b ( 1 ) = 10 6.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 26 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 64 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = 25 1.0_R_P / 72 0.0_R_P case ( 'adams_moulton_5' ) self % steps = 5 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 2 7.0_R_P / 144 0.0_R_P self % b ( 1 ) = - 17 3.0_R_P / 144 0.0_R_P self % b ( 2 ) = 48 2.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 79 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 142 7.0_R_P / 144 0.0_R_P self % b ( 5 ) = 47 5.0_R_P / 144 0.0_R_P case ( 'adams_moulton_6' ) self % steps = 6 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 86 3.0_R_P / 6048 0.0_R_P self % b ( 1 ) = 631 2.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 2021 1.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 3750 4.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 4646 1.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 6511 2.0_R_P / 6048 0.0_R_P self % b ( 6 ) = 1908 7.0_R_P / 6048 0.0_R_P case ( 'adams_moulton_7' ) self % steps = 7 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 137 5.0_R_P / 12096 0.0_R_P self % b ( 1 ) = - 1135 1.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 4149 9.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 8854 7.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 12313 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 12179 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 13984 9.0_R_P / 12096 0.0_R_P self % b ( 7 ) = 3679 9.0_R_P / 12096 0.0_R_P case ( 'adams_moulton_8' ) self % steps = 8 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 3395 3.0_R_P / 362880 0.0_R_P self % b ( 1 ) = 31287 4.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 129121 4.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 314633 8.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 503312 0.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 559535 8.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 460459 4.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 446709 4.0_R_P / 362880 0.0_R_P self % b ( 8 ) = 107001 7.0_R_P / 362880 0.0_R_P case ( 'adams_moulton_9' ) self % steps = 9 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 5728 1.0_R_P / 725760 0.0_R_P self % b ( 1 ) = - 58343 5.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 268786 4.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 739403 2.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 1351008 2.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 1728364 6.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 1600232 0.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 1127130 4.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 944971 7.0_R_P / 725760 0.0_R_P self % b ( 9 ) = 208275 3.0_R_P / 725760 0.0_R_P case ( 'adams_moulton_10' ) self % steps = 10 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 325043 3.0_R_P / 47900160 0.0_R_P self % b ( 1 ) = 3628487 6.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 18477619 5.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 56745098 4.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 117059704 2.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 171077452 8.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 182331156 6.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 144620508 0.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 89017554 9.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 65618565 2.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = 13421126 5.0_R_P / 47900160 0.0_R_P case ( 'adams_moulton_11' ) self % steps = 11 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 567526 5.0_R_P / 95800320 0.0_R_P self % b ( 1 ) = - 6892878 1.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 38470932 7.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 130597111 5.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 300773941 8.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 496316651 4.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 604352148 6.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 551946058 2.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 382882888 5.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 209249067 3.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 137479921 9.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = 26274726 5.0_R_P / 95800320 0.0_R_P case ( 'adams_moulton_12' ) self % steps = 12 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 1369577909 3.0_R_P / 261534873600 0.0_R_P self % b ( 1 ) = 17984282256 6.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 109209699226 8.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 406332786317 0.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 1034471179498 5.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 1905818565279 6.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 2620434446515 2.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 2734587069843 6.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 2184753803989 5.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 1346577425651 0.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 661642095742 8.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 391755121698 6.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P case ( 'adams_moulton_13' ) self % steps = 13 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 2446657909 3.0_R_P / 523069747200 0.0_R_P self % b ( 1 ) = - 34545708639 5.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 226807881438 6.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 918163560513 4.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 2562025977783 5.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 5217791088266 1.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 8010102102918 0.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 9439333865389 2.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 8618022868956 3.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 6118868013128 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 3392899013361 8.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 1514123508411 0.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 815316796218 1.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = 138274192962 1.0_R_P / 523069747200 0.0_R_P case ( 'adams_moulton_14' ) self % steps = 14 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 13228284012 7.0_R_P / 3138418483200 0.0_R_P self % b ( 1 ) = 199875923633 6.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 1411048096992 7.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 6175942669254 4.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 18750493659793 1.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 41855180460126 4.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 71031283419734 7.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 93460083349094 4.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 96360540082473 3.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 78191161807163 2.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 49954720375483 7.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 25172489460793 6.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 10288514895621 7.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 5077096753486 4.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P case ( 'adams_moulton_15' ) self % steps = 15 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 24020824582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 1 ) = - 386768936759 9.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 2921938428408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 13751571378931 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 45140310893348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 109635523540233 1.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 203934587954664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 296636573026569 9.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 341494172885289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 312945307199358 1.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 228516859834973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 132697866305806 9.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 61274454106533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 23099216372384 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 10514505875707 3.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = 1608812922937 5.0_R_P / 6276836966400 0.0_R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize endmodule foodie_integrator_adams_moulton","tags":"","loc":"sourcefile/foodie_integrator_adams_moulton.f90.html","title":"foodie_integrator_adams_moulton.f90 – FOODIE"},{"text":"FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. This File Depends On sourcefile~~foodie_integrator_backward_differentiation_formula.f90~~EfferentGraph sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 var pansourcefilefoodie_integrator_backward_differentiation_formulaf90EfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_backward_differentiation_formulaf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_backward_differentiation_formula.f90~~AfferentGraph sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_backward_differentiation_formulaf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_backward_differentiation_formulaf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_backward_differentiation_formula Source Code foodie_integrator_backward_differentiation_formula.f90 Source Code !< FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. module foodie_integrator_backward_differentiation_formula !< FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Backward Differentiation Formula class scheme implemented is: !< !<  U&#94;{n+N_s} + \\sum_{s=1}&#94;{N_s} \\alpha_s U&#94;{n+N_s-s} = \\Delta t \\left[ \\beta R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  !< !< where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are implicit. The coefficients \\alpha_s and \\beta define the actual scheme, that is selected accordingly !< to the number of *steps* used. !< !< Currently, the following schemes are available: !< !< | ` Step ` | ` beta `   | ` alpha 1 `  | ` alpha 2 ` | ` alpha 3 `  | ` alpha 4 ` | ` alpha 5 ` | ` alpha 6 ` | !< |----------|------------|--------------|-------------|--------------|-------------|-------------|-------------| !< | ` 1 `    | `  1 `     | ` -1 `       |             |              |             |             |             | !< | ` 2 `    | ` 2/3 `    | ` -4/3 `     | ` 1/3 `     |              |             |             |             | !< | ` 3 `    | ` 6/11 `   | ` -18/11 `   | ` 9/11  `   | ` -2/11 `    |             |             |             | !< | ` 4 `    | ` 12/25 `  | ` -48/25 `   | ` 36/25 `   | ` -16/25 `   | ` 3/25 `    |             |             | !< | ` 5 `    | ` 60/137 ` | ` -300/137 ` | ` 300/137 ` | ` -200/137 ` | ` 75/137 `  | ` -12/137 ` |             | !< | ` 6 `    | ` 60/147 ` | ` -360/147 ` | ` 450/147 ` | ` -400/147 ` | ` 225/147 ` | ` -72/147 ` | ` 10/147 `  | !< !<#### Bibliography !< use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_back_df character ( len = 99 ), parameter :: class_name_ = 'back_df' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 6 ) = [ trim ( class_name_ ) // '_1' , & trim ( class_name_ ) // '_2' , & trim ( class_name_ ) // '_3' , & trim ( class_name_ ) // '_4' , & trim ( class_name_ ) // '_5' , & trim ( class_name_ ) // '_6' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistep_object ) :: integrator_back_df !< FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order !< accurate. !< !< @note The integrator must be created or initialized (initialize the *a* and *b* coefficients) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: a (:) !< \\alpha coefficients. real ( R_P ) :: b = 0.0_R_P !< \\beta coefficient. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_back_df contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_back_df ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_back_df ) lhs % steps = rhs % steps if ( allocated ( rhs % a )) lhs % a = rhs % a lhs % b = rhs % b endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with BDF class scheme. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. allocate ( delta , mold = U ) delta = self % previous ( self % steps ) * ( - self % a ( self % steps )) do s = 1 , self % steps - 1 delta = delta + ( self % previous ( s ) * ( - self % a ( s ))) enddo do s = 1 , self % iterations U = delta + ( U % t ( t = self % t ( self % steps ) + Dt ) * ( Dt * self % b )) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with BDF class scheme. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. allocate ( delta , mold = U ) call delta % multiply_fast ( lhs = self % previous ( self % steps ), rhs =- self % a ( self % steps )) do s = 1 , self % steps - 1 call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs =- self % a ( s )) call delta % add_fast ( lhs = delta , rhs = self % buffer ) enddo do s = 1 , self % iterations self % buffer = U call self % buffer % t_fast ( t = self % t ( self % steps ) + Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ) call U % add_fast ( lhs = delta , rhs = self % buffer ) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % a )) deallocate ( self % a ) self % b = 0.0_R_P endsubroutine destroy subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual BDF integrator: initialize the *alpha* and *beta* coefficients. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'back_df_1' ) self % steps = 1 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = - 1.0_R_P self % b = 1.0_R_P case ( 'back_df_2' ) self % steps = 2 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = 1.0_R_P / 3.0_R_P self % a ( 2 ) = - 4.0_R_P / 3.0_R_P self % b = 2.0_R_P / 3.0_R_P case ( 'back_df_3' ) self % steps = 3 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = - 2.0_R_P / 1 1.0_R_P self % a ( 2 ) = 9.0_R_P / 1 1.0_R_P self % a ( 3 ) = - 1 8.0_R_P / 1 1.0_R_P self % b = 6.0_R_P / 1 1.0_R_P case ( 'back_df_4' ) self % steps = 4 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = 3.0_R_P / 2 5.0_R_P self % a ( 2 ) = - 1 6.0_R_P / 2 5.0_R_P self % a ( 3 ) = 3 6.0_R_P / 2 5.0_R_P self % a ( 4 ) = - 4 8.0_R_P / 2 5.0_R_P self % b = 1 2.0_R_P / 2 5.0_R_P case ( 'back_df_5' ) self % steps = 5 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = - 1 2.0_R_P / 13 7.0_R_P self % a ( 2 ) = 7 5.0_R_P / 13 7.0_R_P self % a ( 3 ) = - 20 0.0_R_P / 13 7.0_R_P self % a ( 4 ) = 30 0.0_R_P / 13 7.0_R_P self % a ( 5 ) = - 30 0.0_R_P / 13 7.0_R_P self % b = 6 0.0_R_P / 13 7.0_R_P case ( 'back_df_6' ) self % steps = 6 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = 1 0.0_R_P / 14 7.0_R_P self % a ( 2 ) = - 7 2.0_R_P / 14 7.0_R_P self % a ( 3 ) = 22 5.0_R_P / 14 7.0_R_P self % a ( 4 ) = - 40 0.0_R_P / 14 7.0_R_P self % a ( 5 ) = 45 0.0_R_P / 14 7.0_R_P self % a ( 6 ) = - 36 0.0_R_P / 14 7.0_R_P self % b = 6 0.0_R_P / 14 7.0_R_P case default endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize endmodule foodie_integrator_backward_differentiation_formula","tags":"","loc":"sourcefile/foodie_integrator_backward_differentiation_formula.f90.html","title":"foodie_integrator_backward_differentiation_formula.f90 – FOODIE"},{"text":"FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. This File Depends On sourcefile~~foodie_integrator_euler_explicit.f90~~EfferentGraph sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_euler_explicit.f90~~AfferentGraph sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_euler_explicitf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_euler_explicitf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_euler_explicit Source Code foodie_integrator_euler_explicit.f90 Source Code !< FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !< FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistage_object , only : integrator_multistage_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_euler_explicit character ( len = 99 ), parameter :: class_name_ = 'euler_explicit' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 1 ) = [ trim ( class_name_ )] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistage_object ) :: integrator_euler_explicit !< FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_euler_explicit contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_euler_explicit ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistage ( rhs = rhs ) endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit Euler scheme, 1st order. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. U = U + ( U % t ( t = t ) * Dt ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit Euler scheme, 1st order, fast mode. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. self % buffer = U call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call U % add_fast ( lhs = U , rhs = self % buffer ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage endsubroutine destroy subroutine initialize ( self , scheme , U , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) self % stages = 0 self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. This File Depends On sourcefile~~foodie_integrator_leapfrog.f90~~EfferentGraph sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_leapfrog.f90~~AfferentGraph sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_leapfrogf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_leapfrogf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_leapfrog Source Code foodie_integrator_leapfrog.f90 Source Code !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. module foodie_integrator_leapfrog !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is: !< !<  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  !< !< Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps: !<  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2})  !<  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha  !<  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1)  !< Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme. !< The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are !< !<  + \\nu=0.01 !<  + \\alpha=0.53 !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. !< !<#### Bibliography !< !< [1] *The integration of a low order spectral form of the primitive meteorological equations*, Robert, A. J., J. Meteor. Soc. !< Japan,vol. 44, pages 237--245, 1966. !< !< [2] *Frequency filter for time integrations*, Asselin, R., Monthly Weather Review, vol. 100, pages 487--490, 1972. !< !< [3] *The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations*, Williams, P.D., Monthly !< Weather Review, vol. 139(6), pages 1996--2007, June 2011. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_leapfrog character ( len = 99 ), parameter :: class_name_ = 'leapfrog' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 2 ) = [ trim ( class_name_ ) // '    ' , & trim ( class_name_ ) // '_raw' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistep_object ) :: integrator_leapfrog !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator must be initialized before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ) :: nu !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha !< Robert-Asselin-Williams filter coefficient. logical :: is_filtered !< Flag to check if the integration if RAW filtered. class ( integrand_object ), allocatable :: filter !< Filter field displacement. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! overridden public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. endtype integrator_leapfrog contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_leapfrog ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_leapfrog ) lhs % nu = rhs % nu lhs % alpha = rhs % alpha lhs % is_filtered = rhs % is_filtered if ( allocated ( lhs % filter )) deallocate ( lhs % filter ) if ( allocated ( rhs % filter )) then allocate ( lhs % filter , mold = rhs % filter ) lhs % filter = rhs % filter endif endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with leapfrog class scheme. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. U = self % previous ( 1 ) + ( self % previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P )) if ( self % is_filtered ) then self % filter = ( self % previous ( 1 ) - ( self % previous ( 2 ) * 2._R_P ) + U ) * self % nu * 0.5_R_P self % previous ( 2 ) = self % previous ( 2 ) + ( self % filter * self % alpha ) U = U + ( self % filter * ( self % alpha - 1._R_P )) endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous ) endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with leapfrog class scheme, fast mode. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. self % buffer = self % previous ( 2 ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * 2._R_P ) call U % add_fast ( lhs = self % previous ( 1 ), rhs = self % buffer ) if ( self % is_filtered ) then call self % buffer % multiply_fast ( lhs = self % previous ( 2 ), rhs = 2._R_P ) call self % buffer % subtract_fast ( lhs = self % previous ( 1 ), rhs = self % buffer ) call self % buffer % add_fast ( lhs = self % buffer , rhs = U ) call self % filter % multiply_fast ( lhs = self % buffer , rhs = self % nu * 0.5_R_P ) call self % buffer % multiply_fast ( lhs = self % filter , rhs = self % alpha ) call self % previous ( 2 )% add_fast ( lhs = self % previous ( 2 ), rhs = self % buffer ) call self % buffer % multiply_fast ( lhs = self % filter , rhs = self % alpha - 1._R_P ) call U % add_fast ( lhs = U , rhs = self % buffer ) endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous ) endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_leapfrog ), intent ( INOUT ) :: self !< Integrator. call self % destroy_multistep self % nu = 0._R_P self % alpha = 0._R_P self % is_filtered = . false . if ( allocated ( self % filter )) deallocate ( self % filter ) endsubroutine destroy subroutine initialize ( self , scheme , nu , alpha , autoupdate , U , stop_on_fail ) !< Create the actual leapfrog integrator: initialize the filter coefficient. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), intent ( in ), optional :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), intent ( in ), optional :: alpha !< Robert-Asselin filter coefficient. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'leapfrog_raw' ) self % nu = 0.01_R_P ; if ( present ( nu )) self % nu = nu self % alpha = 0.53_R_P ; if ( present ( alpha )) self % alpha = alpha self % is_filtered = . true . endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % steps = 2 self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize ! overridden public methods subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistep () . and . self % registers > 0 ) then if ( allocated ( self % Dt )) deallocate ( self % Dt ) allocate ( self % Dt ( 1 : self % registers )) ; self % Dt = 0._R_P if ( allocated ( self % t )) deallocate ( self % t ) allocate ( self % t ( 1 : self % registers )) ; self % t = 0._R_P if ( allocated ( self % previous )) deallocate ( self % previous ) allocate ( self % previous ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % previous ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif if ( self % is_filtered ) then if ( allocated ( self % filter )) deallocate ( self % filter ) allocate ( self % filter , mold = U ) self % filter = U endif endsubroutine allocate_integrand_members endmodule foodie_integrator_leapfrog","tags":"","loc":"sourcefile/foodie_integrator_leapfrog.f90.html","title":"foodie_integrator_leapfrog.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property, from\n 2nd to 3rd order accurate. This File Depends On sourcefile~~foodie_integrator_lmm_ssp.f90~~EfferentGraph sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_lmm_ssp.f90~~AfferentGraph sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_lmm_sspf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_lmm_sspf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_lmm_ssp Source Code foodie_integrator_lmm_ssp.f90 Source Code !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property, from !< 2nd to 3rd order accurate. module foodie_integrator_lmm_ssp !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property, from !< 2nd to 3rd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the LMM-SSP class scheme implemented is: !< !<  U&#94;{n+N_s} = \\sum_{s=1}&#94;{N_s}{\\left[a_s U&#94;{n+s-1} + \\Delta t b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) \\right]}  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients *a,b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[3, 5]*. The formal order of accuracy varies !< consistently in *[2nd, 3rd]* order. !< !<#### Bibliography !< [1] *Strong Stability Preserving Runge-Kutta and Multistep Time Discretizations*, S. Gottlieb, D. Ketcheson, C.W. Shu, !< 2011, 978-981-4289-26-9, doi:10.1142/7498, World Scientific Publishing Co. Pte. Ltd. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_lmm_ssp character ( len = 99 ), parameter :: class_name_ = 'lmm_ssp' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 3 ) = [ trim ( class_name_ ) // '_steps_3_order_2' , & trim ( class_name_ ) // '_steps_4_order_3' , & trim ( class_name_ ) // '_steps_5_order_3' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistep_object ) :: integrator_lmm_ssp !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property, !< from 2nd to 3rd order accurate. !< !< @note The integrator must be initialized before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: a (:) !< *a* coefficients. real ( R_P ), allocatable :: b (:) !< *b* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_lmm_ssp contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_lmm_ssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_lmm_ssp ) lhs % steps = rhs % steps if ( allocated ( rhs % a )) lhs % a = rhs % a if ( allocated ( rhs % b )) lhs % b = rhs % b endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. U = U * 0._R_P do s = 1 , self % steps if ( self % a ( s ) /= 0._R_P ) U = U + ( self % previous ( s ) * self % a ( s )) if ( self % b ( s ) /= 0._R_P ) U = U + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % b ( s ))) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme, fast mode. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. call U % multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % steps if ( self % a ( s ) /= 0._R_P ) then call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs = self % a ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif if ( self % b ( s ) /= 0._R_P ) then self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % a )) deallocate ( self % a ) if ( allocated ( self % b )) deallocate ( self % b ) endsubroutine destroy subroutine initialize ( self , scheme , autoupdate , U , stop_on_fail ) !< Create the actual LMM-SSP integrator: initialize the *a,b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'lmm_ssp_steps_3_order_2' ) self % steps = 3 allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % a ( 1 ) = 1._R_P / 4._R_P self % a ( 2 ) = 0._R_P self % a ( 3 ) = 3._R_P / 4._R_P self % b ( 1 ) = 0._R_P self % b ( 2 ) = 0._R_P self % b ( 3 ) = 3._R_P / 2._R_P case ( 'lmm_ssp_steps_4_order_3' ) self % steps = 4 allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % a ( 1 ) = 1 1._R_P / 2 7._R_P self % a ( 2 ) = 0._R_P self % a ( 3 ) = 0._R_P self % a ( 4 ) = 1 6._R_P / 2 7._R_P self % b ( 1 ) = 1 2._R_P / 2 7._R_P self % b ( 2 ) = 0._R_P self % b ( 3 ) = 0._R_P self % b ( 4 ) = 1 6._R_P / 9._R_P case ( 'lmm_ssp_steps_5_order_3' ) self % steps = 5 allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % a ( 1 ) = 7._R_P / 3 2._R_P self % a ( 2 ) = 0._R_P self % a ( 3 ) = 0._R_P self % a ( 4 ) = 0._R_P self % a ( 5 ) = 2 5._R_P / 3 2._R_P self % b ( 1 ) = 5._R_P / 1 6._R_P self % b ( 2 ) = 0._R_P self % b ( 3 ) = 0._R_P self % b ( 4 ) = 0._R_P self % b ( 5 ) = 2 5._R_P / 1 6._R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize endmodule foodie_integrator_lmm_ssp","tags":"","loc":"sourcefile/foodie_integrator_lmm_ssp.f90.html","title":"foodie_integrator_lmm_ssp.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and\n variable stepsize (VSS), from 2nd to 3rd order accurate. This File Depends On sourcefile~~foodie_integrator_lmm_ssp_vss.f90~~EfferentGraph sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_lmm_ssp_vss.f90~~AfferentGraph sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_lmm_ssp_vssf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_lmm_ssp_vssf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_lmm_ssp_vss Source Code foodie_integrator_lmm_ssp_vss.f90 Source Code !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and !< variable stepsize (VSS), from 2nd to 3rd order accurate. module foodie_integrator_lmm_ssp_vss !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and !< variable stepsize (VSS), from 2nd to 3rd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the LMM-SSP class scheme implemented is: !< !<#### Second order formula !< !<  U&#94;{n+N_s} = \\frac{1}{\\Omega_{N_s-1}&#94;2} U&#94;n + \\frac{\\Omega_{N_s-1}&#94;2 - 1}{\\Omega_{N_s-1}&#94;2} U&#94;{n+N_s-1} + !<    \\frac{\\Omega_{N_s-1} + 1}{\\Omega_{N_s-1}} \\Delta t&#94;{n+N_s} R(U&#94;{n+N_s-1})  !< !<#### Third order formula !< !<  U&#94;{n+N_s} = \\frac{3 \\Omega_{N_s-1} + 2}{\\Omega_{N_s-1}&#94;3} U&#94;n + !<                \\frac{(\\Omega_{N_s-1} + 1)&#94;2(\\Omega_{N_s-1} - 2)}{\\Omega_{N_s-1}&#94;3} U&#94;{n+N_s-1} + !<                \\frac{\\Omega_{N_s-1} + 1}{\\Omega_{N_s-1}&#94;2} \\Delta t&#94;{n+N_s} R(U&#94;n) + !<                \\frac{(\\Omega_{N_s-1} + 1)&#94;2}{\\Omega_{N_s-1}&#94;2} \\Delta t&#94;{n+N_s} R(U&#94;{n+N_s-1})  !< !<where N_s is the number of previous steps considered and !< !<  \\Omega_s = \\sum_{i=1}&#94;s { \\omega_i }\\quad 1 \\leq s \\leq N_s  !<  \\omega_i = \\frac{\\Delta t&#94;{n + s}}{\\Delta t&#94;{n + N_s}}  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. !< !<#### Bibliography !< [1] *Strong Stability Preserving Explicit Linear Multistep Methods with Variable Step Size*, Y. Hadjmichael, D. Ketcheson, !< L. Loczi, A. Nemeth, 2016, SIAM, Vol. 54, N. 5, pp. 2799-2832. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistep_object , only : integrator_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_lmm_ssp_vss character ( len = 99 ), parameter :: class_name_ = 'lmm_ssp_vss' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 5 ) = [ trim ( class_name_ ) // '_steps_2_order_2' , & trim ( class_name_ ) // '_steps_3_order_2' , & trim ( class_name_ ) // '_steps_3_order_3' , & trim ( class_name_ ) // '_steps_4_order_3' , & trim ( class_name_ ) // '_steps_5_order_3' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistep_object ) :: integrator_lmm_ssp_vss !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and !< variable stepsize (VSS), from 2nd to 3rd order accurate. !< !< @note The integrator must be created or initialized before used. private procedure ( integrate_interface ), pointer :: integrate_ => integrate_order_2 !< Integrate integrand field. procedure ( integrate_fast_interface ), pointer :: integrate_fast_ => integrate_order_2_fast !< Integrate integrand field, fast. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! private methods procedure , pass ( self ), private :: integrate_order_2 !< Integrate integrand field by 2nd order formula. procedure , pass ( self ), private :: integrate_order_3 !< Integrate integrand field by 3rd order formula. procedure , pass ( self ), private :: integrate_order_2_fast !< Integrate integrand field by 2nd order formula, fast mode. procedure , pass ( self ), private :: integrate_order_3_fast !< Integrate integrand field by 3rd order formula, fast mode. endtype integrator_lmm_ssp_vss abstract interface !< Abstract interfaces of [[integrator_lmm_ssp_vss]] methods. subroutine integrate_interface ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. import :: integrand_object , integrator_lmm_ssp_vss , R_P class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. endsubroutine integrate_interface subroutine integrate_fast_interface ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. import :: integrand_object , integrator_lmm_ssp_vss , R_P class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. endsubroutine integrate_fast_interface endinterface contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_lmm_ssp_vss ) if ( associated ( rhs % integrate_ )) lhs % integrate_ => rhs % integrate_ endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. call self % integrate_ ( U = U , Dt = Dt , t = t ) endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme, fast mode. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. call self % integrate_fast_ ( U = U , Dt = Dt , t = t ) endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep self % integrate_ => integrate_order_2 endsubroutine destroy subroutine initialize ( self , scheme , autoupdate , U , stop_on_fail ) !< Create the actual LMM-SSP-VSS integrator. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'lmm_ssp_vss_steps_2_order_2' ) self % steps = 2 self % integrate_ => integrate_order_2 self % integrate_fast_ => integrate_order_2_fast case ( 'lmm_ssp_vss_steps_3_order_2' ) self % steps = 3 self % integrate_ => integrate_order_2 self % integrate_fast_ => integrate_order_2_fast case ( 'lmm_ssp_vss_steps_3_order_3' ) self % steps = 3 self % integrate_ => integrate_order_3 self % integrate_fast_ => integrate_order_3_fast case ( 'lmm_ssp_vss_steps_4_order_3' ) self % steps = 4 self % integrate_ => integrate_order_3 self % integrate_fast_ => integrate_order_3_fast case ( 'lmm_ssp_vss_steps_5_order_3' ) self % steps = 5 self % integrate_ => integrate_order_3 self % integrate_fast_ => integrate_order_3_fast endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize ! private methods subroutine integrate_order_2 ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 2nd order class scheme. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. real ( R_P ) :: omega_sq !< Square of omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) omega_sq = omega_ * omega_ U = ( self % previous ( 1 ) * ( 1._R_P / omega_sq )) + ( self % previous ( self % steps ) * (( omega_sq - 1._R_P ) / omega_sq )) + & ( self % previous ( self % steps )% t ( t = self % t ( self % steps )) * ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / omega_ )) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_2 subroutine integrate_order_3 ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 3rd order class scheme. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) U = ( self % previous ( 1 ) * (( 3._R_P * omega_ + 2._R_P ) / omega_ ** 3 )) + & ( self % previous ( self % steps ) * ((( omega_ + 1._R_P ) ** 2 ) * ( omega_ - 2._R_P ) / omega_ ** 3 )) + & ( self % previous ( 1 )% t ( t = self % t ( 1 )) * ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / omega_ ** 2 )) + & ( self % previous ( self % steps )% t ( t = self % t ( self % steps )) * ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) ** 2 / omega_ ** 2 )) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_3 subroutine integrate_order_2_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 2nd order class scheme, fast mode. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. real ( R_P ) :: omega_sq !< Square of omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) omega_sq = omega_ * omega_ call U % multiply_fast ( lhs = self % previous ( 1 ), rhs = 1._R_P / omega_sq ) call self % buffer % multiply_fast ( lhs = self % previous ( self % steps ), rhs = ( omega_sq - 1._R_P ) / omega_sq ) call U % add_fast ( lhs = U , rhs = self % buffer ) self % buffer = self % previous ( self % steps ) call self % buffer % t_fast ( t = self % t ( self % steps )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / omega_ ) call U % add_fast ( lhs = U , rhs = self % buffer ) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_2_fast subroutine integrate_order_3_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 3rd order class scheme, fast mode. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) call U % multiply_fast ( lhs = self % previous ( 1 ), rhs = ( 3._R_P * omega_ + 2._R_P ) / ( omega_ ** 3 )) call self % buffer % multiply_fast ( lhs = self % previous ( self % steps ), rhs = ((( omega_ + 1._R_P ) ** 2 ) * ( omega_ - 2._R_P ) / ( omega_ ** 3 ))) call U % add_fast ( lhs = U , rhs = self % buffer ) self % buffer = self % previous ( 1 ) call self % buffer % t_fast ( t = self % t ( 1 )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / ( omega_ ** 2 )) call U % add_fast ( lhs = U , rhs = self % buffer ) self % buffer = self % previous ( self % steps ) call self % buffer % t_fast ( t = self % t ( self % steps )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) ** 2 / ( omega_ ** 2 ))) call U % add_fast ( lhs = U , rhs = self % buffer ) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_3_fast ! private non TBP pure function dt_ratio ( Dt , s ) result ( ratio ) !< Return `Dt(n+s)/Dt(n+Ns)` ratio. real ( R_P ), intent ( in ) :: Dt (:) !< Time steps. integer ( I_P ), intent ( in ) :: s !< Step index. real ( R_P ) :: ratio !< Time steps ratio. ratio = Dt ( s ) / Dt ( ubound ( Dt , dim = 1 )) endfunction dt_ratio pure function omega ( Dt , s ) !< Return `omega=sum(dt_ratio(i)), i=1, s`. real ( R_P ), intent ( in ) :: Dt (:) !< Time steps. integer ( I_P ), intent ( in ) :: s !< Step index. real ( R_P ) :: omega !< Omega sum. integer ( I_P ) :: i !< Counter. omega = 0._R_P do i = 1 , s omega = omega + dt_Ratio ( Dt = Dt , s = i ) enddo endfunction omega endmodule foodie_integrator_lmm_ssp_vss","tags":"","loc":"sourcefile/foodie_integrator_lmm_ssp_vss.f90.html","title":"foodie_integrator_lmm_ssp_vss.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property, from\n 2nd to 3rd order accurate. This File Depends On sourcefile~~foodie_integrator_ms_runge_kutta_ssp.f90~~EfferentGraph sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 var pansourcefilefoodie_integrator_ms_runge_kutta_sspf90EfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_ms_runge_kutta_sspf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_ms_runge_kutta_ssp.f90~~AfferentGraph sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_ms_runge_kutta_sspf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_ms_runge_kutta_sspf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_ms_runge_kutta_ssp Source Code foodie_integrator_ms_runge_kutta_ssp.f90 Source Code !< FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property, from !< 2nd to 3rd order accurate. module foodie_integrator_ms_runge_kutta_ssp !< FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property, from !< 2nd to 3rd order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the LMM-SSP class scheme implemented is: !< !<  !< \\begin{align} !< y_1&#94;n & = u&#94;n \\\\ !< y_i&#94;n & = \\sum_{l=1}&#94;{k} d_{il} u&#94;{n-k+l} + \\Delta{t}\\sum_{l=1}&#94;{k-1} \\hat{a}_{il} F(u&#94;{n-k+l}) + !<                                             \\Delta{t}\\sum_{j=1}&#94;{i-1} a_{ij} F(y_j&#94;n) \\; \\; \\; \\;  2 \\leq i \\leq s \\\\ !< u&#94;{n+1} & = \\sum_{l=1}&#94;{k} \\theta_l u&#94;{n-k+l} + \\Delta{t}\\sum_{l=1}&#94;{k-1} \\hat{b}_{l} F(u&#94;{n-k+l}) + !<                                                  \\Delta{t}\\sum_{j=1}&#94;s b_j F(y_j&#94;n). !< \\end{align} !<  !< !<where N_s is the number of previous steps considered. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients *a,b* define the actual scheme, that is selected accordingly to the number of !< **steps** used. Currently, the schemes provided have steps number in *[3, 5]*. The formal order of accuracy varies !< consistently in *[2nd, 3rd]* order. !< !<#### Bibliography !< [1] *Explicit Strong Stability Preserving Multistep Runge-Kutta Methods*, C. Bresten, S. Gottlieb, Z. Grant, D. Higgs, !< D. Ketcheson, A. Németh, 2016, Mathematics of Computations, use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistage_multistep_object , only : integrator_multistage_multistep_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_ms_runge_kutta_ssp character ( len = 99 ), parameter :: class_name_ = 'ms_runge_kutta_ssp' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 3 ) = [ trim ( class_name_ ) // '_steps_2_stages_2_order_3' , & trim ( class_name_ ) // '_steps_3_stages_2_order_3' , & trim ( class_name_ ) // '_steps_4_stages_5_order_8' ] !< List of supported !< schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistage_multistep_object ) :: integrator_ms_runge_kutta_ssp !< FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property, !< from 3rd to 8th order accurate. !< !< @note The integrator must be created or initialized (initialize the *A,Ahat,B,Bhat,D,T* coefficients) before used. private real ( R_P ), allocatable :: A (:,:) !< *A* coefficients. real ( R_P ), allocatable :: Ahat (:,:) !< *Ahat* coefficients. real ( R_P ), allocatable :: B (:) !< *B* coefficients. real ( R_P ), allocatable :: Bhat (:) !< *Bhat* coefficients. real ( R_P ), allocatable :: D (:,:) !< *D* coefficients. real ( R_P ), allocatable :: Q (:) !< *T* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_ms_runge_kutta_ssp contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistage_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_ms_runge_kutta_ssp ) if ( allocated ( rhs % A )) lhs % A = rhs % A if ( allocated ( rhs % Ahat )) lhs % Ahat = rhs % Ahat if ( allocated ( rhs % B )) lhs % B = rhs % B if ( allocated ( rhs % Bhat )) lhs % Bhat = rhs % Bhat if ( allocated ( rhs % D )) lhs % D = rhs % D if ( allocated ( rhs % Q )) lhs % Q = rhs % Q endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: k , kk !< Stages counters. integer ( I_P ) :: s !< Steps counter. ! computing stages self % stage ( 1 ) = U do k = 2 , self % stages self % stage ( k ) = U * 0._R_P do s = 1 , self % steps if ( self % D ( k , s ) /= 0._R_P ) self % stage ( k ) = self % stage ( k ) + ( self % previous ( s ) * self % D ( k , s )) enddo do s = 1 , self % steps - 1 if ( self % Ahat ( k , s ) /= 0._R_P ) self % stage ( k ) = self % stage ( k ) + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % Ahat ( k , s ))) enddo do kk = 1 , k - 1 if ( self % A ( k , kk ) /= 0._R_P ) self % stage ( k ) = self % stage ( k ) + ( self % stage ( kk )% t ( t = t ) * ( Dt * self % A ( k , kk ))) enddo enddo ! computing new time step U = U * 0._R_P do s = 1 , self % steps if ( self % Q ( s ) /= 0._R_P ) U = U + ( self % previous ( s ) * self % Q ( s )) enddo do s = 1 , self % steps - 1 if ( self % Bhat ( s ) /= 0._R_P ) U = U + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % Bhat ( s ))) enddo do k = 1 , self % stages if ( self % B ( k ) /= 0._R_P ) U = U + ( self % stage ( k )% t ( t = t ) * ( Dt * self % B ( k ))) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme, fast mode. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: k , kk !< Stages counters. integer ( I_P ) :: s !< Steps counter. ! computing stages self % stage ( 1 ) = U do k = 2 , self % stages call self % stage ( k )% multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % steps if ( self % D ( k , s ) /= 0._R_P ) then call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs = self % D ( k , s )) call self % stage ( k )% add_fast ( lhs = self % stage ( k ), rhs = self % buffer ) endif enddo do s = 1 , self % steps - 1 if ( self % Ahat ( k , s ) /= 0._R_P ) then self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % Ahat ( k , s )) call self % stage ( k )% add_fast ( lhs = self % stage ( k ), rhs = self % buffer ) endif enddo do kk = 1 , k - 1 if ( self % A ( k , kk ) /= 0._R_P ) then self % buffer = self % stage ( kk ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % A ( k , kk )) call self % stage ( k )% add_fast ( lhs = self % stage ( k ), rhs = self % buffer ) endif enddo enddo ! computing new time step U = U * 0._R_P do s = 1 , self % steps if ( self % Q ( s ) /= 0._R_P ) then call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs = self % Q ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo do s = 1 , self % steps - 1 if ( self % Bhat ( s ) /= 0._R_P ) then self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % Bhat ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo do k = 1 , self % stages if ( self % B ( k ) /= 0._R_P ) U = U + ( self % stage ( k )% t ( t = t ) * ( Dt * self % B ( k ))) if ( self % B ( k ) /= 0._R_P ) then self % buffer = self % stage ( k ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % B ( k )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage_multistep if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % Ahat )) deallocate ( self % Ahat ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % Bhat )) deallocate ( self % Bhat ) if ( allocated ( self % D )) deallocate ( self % D ) if ( allocated ( self % Q )) deallocate ( self % Q ) endsubroutine destroy subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual MS-RK-SSP integrator: initialize the *A,Ahat,B,Bhat,D,T* coefficients. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'ms_runge_kutta_ssp_steps_2_stages_2_order_3' ) self % steps = 2 self % stages = 2 allocate ( self % A ( 1 : self % stages , 1 : self % stages )) ; self % A = 0._R_P self % A ( 2 , 1 ) = 0.910683602522959_R_P allocate ( self % Ahat ( 1 : self % stages , 1 : self % steps )) ; self % Ahat = 0._R_P self % Ahat ( 2 , 1 ) = - 1.11985107194706e-19_R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P self % B ( 1 ) = 0.535898384862245_R_P self % B ( 2 ) = 0.803847577293368_R_P allocate ( self % Bhat ( 1 : self % steps )) ; self % Bhat = 0._R_P self % Bhat ( 1 ) = 0.267949192431123_R_P allocate ( self % D ( 1 : self % stages , 1 : self % steps )) ; self % D = 0._R_P self % D ( 2 , 1 ) = 1._R_P / 3._R_P self % D ( 2 , 2 ) = 2._R_P / 3._R_P allocate ( self % Q ( 1 : self % steps )) ; self % Q = 0._R_P self % Q ( 1 ) = 0.607695154586736_R_P self % Q ( 2 ) = 0.392304845413264_R_P case ( 'ms_runge_kutta_ssp_steps_3_stages_2_order_3' ) self % steps = 3 self % stages = 2 allocate ( self % A ( 1 : self % stages , 1 : self % stages )) ; self % A = 0._R_P self % A ( 2 , 1 ) = 0.731058363135786_R_P allocate ( self % Ahat ( 1 : self % stages , 1 : self % steps )) ; self % Ahat = 0._R_P self % Ahat ( 2 , 1 ) = 0.127467809251820_R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P self % B ( 1 ) = 0.618048297723782_R_P self % B ( 2 ) = 0.759677988437936_R_P allocate ( self % Bhat ( 1 : self % steps )) ; self % Bhat = 0._R_P self % Bhat ( 1 ) = 0.246670340394148_R_P allocate ( self % D ( 1 : self % stages , 1 : self % steps )) ; self % D = 0._R_P self % D ( 2 , 1 ) = 0.186433848116852_R_P self % D ( 2 , 2 ) = 1.80945758995975e-24_R_P self % D ( 2 , 3 ) = 0.813566151883148_R_P allocate ( self % Q ( 1 : self % steps )) ; self % Q = 0._R_P self % Q ( 1 ) = 0.312198313277933_R_P self % Q ( 2 ) = 2.58493941422821e-24_R_P self % Q ( 3 ) = 0.687801686722067_R_P case ( 'ms_runge_kutta_ssp_steps_4_stages_5_order_8' ) self % steps = 4 self % stages = 5 allocate ( self % A ( 1 : self % stages , 1 : self % stages )) ; self % A = 0._R_P self % A ( 2 , 1 ) = 0.0112355687952080_R_P self % A ( 3 , 1 ) = 0.782384118905967_R_P self % A ( 4 , 1 ) = 0.0997788285846345_R_P self % A ( 5 , 1 ) = 0.0173871875042219_R_P self % A ( 4 , 2 ) = 0.775239818309315_R_P self % A ( 5 , 2 ) = 0.781995253645396_R_P self % A ( 4 , 3 ) = 0.522304633131092_R_P self % A ( 5 , 3 ) = 0.0817254029032851_R_P self % A ( 5 , 4 ) = 0.654483113500859_R_P allocate ( self % Ahat ( 1 : self % stages , 1 : self % steps )) ; self % Ahat = 0._R_P self % Ahat ( 2 , 1 ) = 0.000422703250336666_R_P self % Ahat ( 3 , 1 ) = 0.0959783036454617_R_P self % Ahat ( 4 , 1 ) = 0.0140562464699573_R_P self % Ahat ( 5 , 1 ) = 0.0519851819388547_R_P self % Ahat ( 2 , 2 ) = 0.259546324808661_R_P self % Ahat ( 3 , 2 ) = 0.382496291927802_R_P self % Ahat ( 4 , 2 ) = 0.195323228972419_R_P self % Ahat ( 5 , 2 ) = 0.435648262830826_R_P self % Ahat ( 2 , 3 ) = 0.752684925098657_R_P self % Ahat ( 3 , 3 ) = 0.563081036068107_R_P self % Ahat ( 4 , 3 ) = 0.209815168854422_R_P self % Ahat ( 5 , 3 ) = 0.151720560507208_R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P self % B ( 1 ) = 0.711472565648602_R_P self % B ( 2 ) = 0.0953138922500395_R_P self % B ( 3 ) = 0.0808915576045876_R_P self % B ( 4 ) = 0.214580109044146_R_P self % B ( 5 ) = 0.351640244526174_R_P allocate ( self % Bhat ( 1 : self % steps )) ; self % Bhat = 0._R_P self % Bhat ( 1 ) = 0.00614782373612238_R_P self % Bhat ( 2 ) = 0.138226341918060_R_P self % Bhat ( 3 ) = 0.541410372692778_R_P allocate ( self % D ( 1 : self % stages , 1 : self % steps )) ; self % D = 0._R_P self % D ( 2 , 1 ) = 0.0273928990974108_R_P self % D ( 3 , 1 ) = 0.283607987548794_R_P self % D ( 4 , 1 ) = 0.0642241421937960_R_P self % D ( 5 , 1 ) = 0.194681462814288_R_P self % D ( 2 , 2 ) = 0.554039201229659_R_P self % D ( 3 , 2 ) = 0.0914454235177934_R_P self % D ( 4 , 2 ) = 0.198601843371796_R_P self % D ( 5 , 2 ) = 0.293086617882372_R_P self % D ( 2 , 3 ) = 0.348927848402249_R_P self % D ( 3 , 3 ) = 0.437897855084625_R_P self % D ( 4 , 3 ) = 0.662266498804591_R_P self % D ( 5 , 3 ) = 0.158740367819382_R_P self % D ( 2 , 4 ) = 0.0696400512706807_R_P self % D ( 3 , 4 ) = 0.187048733848788_R_P self % D ( 4 , 4 ) = 0.0749075156298171_R_P self % D ( 5 , 4 ) = 0.353491551483958_R_P allocate ( self % Q ( 1 : self % steps )) ; self % Q = 0._R_P self % Q ( 1 ) = 0.0273988434707855_R_P self % Q ( 2 ) = 0.286296288278021_R_P self % Q ( 3 ) = 0.484893800452111_R_P self % Q ( 4 ) = 0.201411067799082_R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations self % registers_stages = self % stages self % registers_steps = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize endmodule foodie_integrator_ms_runge_kutta_ssp","tags":"","loc":"sourcefile/foodie_integrator_ms_runge_kutta_ssp.f90.html","title":"foodie_integrator_ms_runge_kutta_ssp.f90 – FOODIE"},{"text":"Define the abstract type integrator_multistage_multistep_object of FOODIE ODE integrators. This File Depends On sourcefile~~foodie_integrator_multistage_multistep_object.f90~~EfferentGraph sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_multistage_multistep_object.f90~~AfferentGraph sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_multistage_multistep_objectf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_multistage_multistep_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_multistage_multistep_object Source Code foodie_integrator_multistage_multistep_object.f90 Source Code !< Define the abstract type [[integrator_multistage_multistep_object]] of FOODIE ODE integrators. module foodie_integrator_multistage_multistep_object !< Define the abstract type [[integrator_multistage_multistep_object]] of FOODIE ODE integrators. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foodie_integrand_object , only : integrand_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_multistage_multistep_object type , extends ( integrator_object ), abstract :: integrator_multistage_multistep_object !< Abstract type of FOODIE ODE integrators of the multistage/multistep family. integer ( I_P ) :: registers_stages !< Number of registers used for stages. integer ( I_P ) :: registers_steps !< Number of registers used for steps. integer ( I_P ) :: stages !< Number of stages. integer ( I_P ) :: steps !< Number of time steps. logical :: autoupdate !< Perform cyclic autoupdate of previous time steps buffers. integer ( I_P ) :: iterations !< Implicit iterations. real ( R_P ), allocatable :: Dt (:) !< Previous time steps. real ( R_P ), allocatable :: t (:) !< Previous times. class ( integrand_object ), allocatable :: previous (:) !< Previous steps. class ( integrand_object ), allocatable :: stage (:) !< Stages. class ( integrand_object ), allocatable :: buffer !< Buffer used for fast integration. contains ! deferred methods procedure ( integrate_interface ), pass ( self ), deferred :: integrate !< Integrate integrand field. procedure ( integrate_fast_interface ), pass ( self ), deferred :: integrate_fast !< Integrate integrand field, fast mode. ! implemented deferred methods of parent procedure , pass ( self ) :: is_multistage !< Return .true. for multistage integrator. procedure , pass ( self ) :: is_multistep !< Return .true. for multistep integrator. procedure , pass ( self ) :: stages_number !< Return number of stages used. procedure , pass ( self ) :: steps_number !< Return number of steps used. ! public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. procedure , pass ( lhs ) :: assign_multistage_multistep !< Assign members of [[integrator_multistage_multistep_object]]. procedure , pass ( self ) :: destroy_multistage_multistep !< Destroy the integrator. procedure , nopass :: update_previous !< Cyclic update previous time steps. endtype integrator_multistage_multistep_object abstract interface !< Abstract interfaces of deferred methods of [[integrator_multistage_multistep_object]]. subroutine integrate_interface ( self , U , Dt , t ) !< Integrate integrand field. import :: integrand_object , integrator_multistage_multistep_object , R_P class ( integrator_multistage_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. endsubroutine integrate_interface subroutine integrate_fast_interface ( self , U , Dt , t ) !< Integrate integrand field, fast mode. import :: integrand_object , integrator_multistage_multistep_object , R_P class ( integrator_multistage_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. endsubroutine integrate_fast_interface endinterface contains ! deferred methods elemental function is_multistage ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistage !< Inquire result. is_multistage = . true . endfunction is_multistage elemental function is_multistep ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistep !< Inquire result. is_multistep = . true . endfunction is_multistep elemental function stages_number ( self ) !< Return number of stages used. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: stages_number !< Number of stages used. stages_number = self % stages endfunction stages_number elemental function steps_number ( self ) !< Return number of steps used. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: steps_number !< Number of steps used. steps_number = self % steps endfunction steps_number ! public methods subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_multistage_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistage () . and . self % registers_stages > 0 ) then if ( allocated ( self % stage )) deallocate ( self % stage ) allocate ( self % stage ( 1 : self % registers_stages ), mold = U ) do s = 1 , self % registers_stages self % stage ( s ) = U enddo endif if ( self % is_multistep () . and . self % registers_steps > 0 ) then if ( allocated ( self % Dt )) deallocate ( self % Dt ) allocate ( self % Dt ( 1 : self % registers_steps )) ; self % Dt = 0._R_P if ( allocated ( self % t )) deallocate ( self % t ) allocate ( self % t ( 1 : self % registers_steps )) ; self % t = 0._R_P if ( allocated ( self % previous )) deallocate ( self % previous ) allocate ( self % previous ( 1 : self % registers_steps ), mold = U ) do s = 1 , self % registers_steps self % previous ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif endsubroutine allocate_integrand_members subroutine assign_multistage_multistep ( lhs , rhs ) !< Assign members of [[integrator_multistage_multistep_object]] and parents. class ( integrator_multistage_multistep_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: s !< Counter. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_multistage_multistep_object ) lhs % registers_stages = rhs % registers_stages lhs % registers_steps = rhs % registers_steps lhs % stages = rhs % stages lhs % steps = rhs % steps lhs % autoupdate = rhs % autoupdate lhs % iterations = rhs % iterations if ( allocated ( lhs % Dt )) deallocate ( lhs % Dt ) if ( allocated ( rhs % Dt )) lhs % Dt = rhs % Dt if ( allocated ( lhs % t )) deallocate ( lhs % t ) if ( allocated ( rhs % t )) lhs % t = rhs % t if ( allocated ( lhs % previous )) deallocate ( lhs % previous ) if ( allocated ( rhs % previous )) then allocate ( lhs % previous ( 1 : lhs % registers_steps ), mold = rhs % previous ) do s = 1 , lhs % registers_steps lhs % previous ( s ) = rhs % previous ( s ) enddo endif if ( allocated ( lhs % stage )) deallocate ( lhs % stage ) if ( allocated ( rhs % stage )) then allocate ( lhs % stage ( 1 : lhs % registers_stages ), mold = rhs % stage ) do s = 1 , lhs % registers_stages lhs % stage ( s ) = rhs % stage ( s ) enddo endif if ( allocated ( lhs % buffer )) deallocate ( lhs % buffer ) if ( allocated ( rhs % buffer )) then allocate ( lhs % buffer , mold = rhs % buffer ) lhs % buffer = rhs % buffer endif endselect endsubroutine assign_multistage_multistep elemental subroutine destroy_multistage_multistep ( self ) !< Destroy the integrator. class ( integrator_multistage_multistep_object ), intent ( inout ) :: self !< Integrator. call self % destroy_abstract self % registers_stages = 0 self % registers_steps = 0 self % stages = 0 self % steps = - 1 self % autoupdate = . false . self % iterations = 0 if ( allocated ( self % Dt )) deallocate ( self % Dt ) if ( allocated ( self % t )) deallocate ( self % t ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % stage )) deallocate ( self % stage ) if ( allocated ( self % buffer )) deallocate ( self % buffer ) endsubroutine destroy_multistage_multistep subroutine update_previous ( U , previous , Dt , t , previous_Dt , previous_t ) !< Cyclic update previous time steps. class ( integrand_object ), intent ( in ) :: U !< Field to be integrated. class ( integrand_object ), intent ( inout ) :: previous ( 1 :) !< Previous time steps solutions of integrand. real ( R_P ), intent ( in ), optional :: Dt !< Time step. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), intent ( inout ), optional :: previous_Dt ( 1 :) !< Time step. real ( R_P ), intent ( inout ), optional :: previous_t ( 1 :) !< Time. integer ( I_P ) :: last_step !< Last step. integer ( I_P ) :: s !< Steps counter. last_step = size ( previous , dim = 1 ) do s = 1 , last_step - 1 previous ( s ) = previous ( s + 1 ) if ( present ( previous_Dt )) previous_Dt ( s ) = previous_Dt ( s + 1 ) if ( present ( previous_t )) previous_t ( s ) = previous_t ( s + 1 ) enddo previous ( last_step ) = U if ( present ( previous_Dt )) previous_Dt ( last_step ) = Dt if ( present ( previous_t )) previous_t ( last_step ) = t + Dt endsubroutine update_previous endmodule foodie_integrator_multistage_multistep_object","tags":"","loc":"sourcefile/foodie_integrator_multistage_multistep_object.f90.html","title":"foodie_integrator_multistage_multistep_object.f90 – FOODIE"},{"text":"Define the abstract type integrator_multistage_object of FOODIE ODE integrators. This File Depends On sourcefile~~foodie_integrator_multistage_object.f90~~EfferentGraph sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_multistage_object.f90~~AfferentGraph sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_multistage_objectf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_multistage_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_multistage_object Source Code foodie_integrator_multistage_object.f90 Source Code !< Define the abstract type [[integrator_multistage_object]] of FOODIE ODE integrators. module foodie_integrator_multistage_object !< Define the abstract type [[integrator_multistage_object]] of FOODIE ODE integrators. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foodie_integrand_object , only : integrand_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_multistage_object type , extends ( integrator_object ), abstract :: integrator_multistage_object !< Abstract type of FOODIE ODE integrators of the multistage family. integer ( I_P ) :: registers !< Number of registers used for stages. integer ( I_P ) :: stages !< Number of stages. class ( integrand_object ), allocatable :: stage (:) !< Stages. class ( integrand_object ), allocatable :: buffer !< Buffer used for fast integration. contains ! deferred methods procedure ( integrate_interface ), pass ( self ), deferred :: integrate !< Integrate integrand field. procedure ( integrate_fast_interface ), pass ( self ), deferred :: integrate_fast !< Integrate integrand field, fast mode. ! implemented deferred methods of parent procedure , pass ( self ) :: is_multistage !< Return .true. for multistage integrator. procedure , pass ( self ) :: is_multistep !< Return .true. for multistep integrator. procedure , pass ( self ) :: stages_number !< Return number of stages used. procedure , pass ( self ) :: steps_number !< Return number of steps used. ! public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. procedure , pass ( lhs ) :: assign_multistage !< Assign members of [[integrator_multistage_object]] and parents. procedure , pass ( self ) :: destroy_multistage !< Destroy the integrator. endtype integrator_multistage_object abstract interface !< Abstract interfaces of deferred methods of [[integrator_multistage_object]]. subroutine integrate_interface ( self , U , Dt , t , new_Dt ) !< Integrate integrand field. import :: integrand_object , integrator_multistage_object , R_P class ( integrator_multistage_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. endsubroutine integrate_interface subroutine integrate_fast_interface ( self , U , Dt , t , new_Dt ) !< Integrate integrand field, fast mode. import :: integrand_object , integrator_multistage_object , R_P class ( integrator_multistage_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. endsubroutine integrate_fast_interface endinterface contains ! deferred methods elemental function is_multistage ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. logical :: is_multistage !< Inquire result. is_multistage = . true . endfunction is_multistage elemental function is_multistep ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. logical :: is_multistep !< Inquire result. is_multistep = . false . endfunction is_multistep elemental function stages_number ( self ) !< Return number of stages used. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: stages_number !< Number of stages used. stages_number = self % stages endfunction stages_number elemental function steps_number ( self ) !< Return number of steps used. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: steps_number !< Number of steps used. steps_number = 0 endfunction steps_number ! public methods subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_multistage_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistage () . and . self % registers > 0 ) then if ( allocated ( self % stage )) deallocate ( self % stage ) allocate ( self % stage ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % stage ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif endsubroutine allocate_integrand_members subroutine assign_multistage ( lhs , rhs ) !< Assign members of [[integrator_multistage_object]] and parents. class ( integrator_multistage_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: s !< Counter. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_multistage_object ) lhs % registers = rhs % registers lhs % stages = rhs % stages if ( allocated ( lhs % stage )) deallocate ( lhs % stage ) if ( allocated ( rhs % stage )) then allocate ( lhs % stage ( 1 : lhs % registers ), mold = rhs % stage ) do s = 1 , lhs % registers lhs % stage ( s ) = rhs % stage ( s ) enddo endif if ( allocated ( lhs % buffer )) deallocate ( lhs % buffer ) if ( allocated ( rhs % buffer )) then allocate ( lhs % buffer , mold = rhs % buffer ) lhs % buffer = rhs % buffer endif endselect endsubroutine assign_multistage elemental subroutine destroy_multistage ( self ) !< Destroy the integrator. class ( integrator_multistage_object ), intent ( inout ) :: self !< Integrator. call self % destroy_abstract self % registers = 0 self % stages = 0 if ( allocated ( self % stage )) deallocate ( self % stage ) if ( allocated ( self % buffer )) deallocate ( self % buffer ) endsubroutine destroy_multistage endmodule foodie_integrator_multistage_object","tags":"","loc":"sourcefile/foodie_integrator_multistage_object.f90.html","title":"foodie_integrator_multistage_object.f90 – FOODIE"},{"text":"Define the abstract type integrator_multistep_object of FOODIE ODE integrators. This File Depends On sourcefile~~foodie_integrator_multistep_object.f90~~EfferentGraph sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_multistep_object.f90~~AfferentGraph sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_multistep_objectf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_multistep_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_multistep_object Source Code foodie_integrator_multistep_object.f90 Source Code !< Define the abstract type [[integrator_multistep_object]] of FOODIE ODE integrators. module foodie_integrator_multistep_object !< Define the abstract type [[integrator_multistep_object]] of FOODIE ODE integrators. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use foodie_integrand_object , only : integrand_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_multistep_object type , extends ( integrator_object ), abstract :: integrator_multistep_object !< Abstract type of FOODIE ODE integrators of the multistep-implicit family. integer ( I_P ) :: registers !< Number of registers used for steps. integer ( I_P ) :: steps !< Number of time steps. logical :: autoupdate !< Perform cyclic autoupdate of previous time steps buffers. integer ( I_P ) :: iterations !< Implicit iterations. real ( R_P ), allocatable :: Dt (:) !< Previous time steps. real ( R_P ), allocatable :: t (:) !< Previous times. class ( integrand_object ), allocatable :: previous (:) !< Previous steps. class ( integrand_object ), allocatable :: buffer !< Buffer used for fast integration. contains ! deferred methods procedure ( integrate_interface ), pass ( self ), deferred :: integrate !< Integrate integrand field. procedure ( integrate_fast_interface ), pass ( self ), deferred :: integrate_fast !< Integrate integrand field, fast mode. ! implemented deferred methods of parent procedure , pass ( self ) :: is_multistage !< Return .true. for multistage integrator. procedure , pass ( self ) :: is_multistep !< Return .true. for multistep integrator. procedure , pass ( self ) :: stages_number !< Return number of stages used. procedure , pass ( self ) :: steps_number !< Return number of steps used. ! public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. procedure , pass ( lhs ) :: assign_multistep !< Assign members of [[integrator_multistep_object]] and parents. procedure , pass ( self ) :: destroy_multistep !< Destroy the integrator. procedure , nopass :: update_previous !< Cyclic update previous time steps. endtype integrator_multistep_object abstract interface !< Abstract interfaces of deferred methods of [[integrator_multistep_object]]. subroutine integrate_interface ( self , U , Dt , t ) !< Integrate integrand field. import :: integrand_object , integrator_multistep_object , R_P class ( integrator_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. endsubroutine integrate_interface subroutine integrate_fast_interface ( self , U , Dt , t ) !< Integrate integrand field, fast mode. import :: integrand_object , integrator_multistep_object , R_P class ( integrator_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. endsubroutine integrate_fast_interface endinterface contains ! deferred methods elemental function is_multistage ( self ) !< Return .true. for multistage integrator. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistage !< Inquire result. is_multistage = . false . endfunction is_multistage elemental function is_multistep ( self ) !< Return .true. for multistage integrator. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistep !< Inquire result. is_multistep = . true . endfunction is_multistep elemental function stages_number ( self ) !< Return number of stages used. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: stages_number !< Number of stages used. stages_number = 0 endfunction stages_number elemental function steps_number ( self ) !< Return number of steps used. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: steps_number !< Number of steps used. steps_number = self % steps endfunction steps_number ! public methods subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistep () . and . self % registers > 0 ) then if ( allocated ( self % Dt )) deallocate ( self % Dt ) allocate ( self % Dt ( 1 : self % registers )) ; self % Dt = 0._R_P if ( allocated ( self % t )) deallocate ( self % t ) allocate ( self % t ( 1 : self % registers )) ; self % t = 0._R_P if ( allocated ( self % previous )) deallocate ( self % previous ) allocate ( self % previous ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % previous ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif endsubroutine allocate_integrand_members subroutine assign_multistep ( lhs , rhs ) !< Assign members of [[integrator_multistep_object]] and parents. class ( integrator_multistep_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: s !< Counter. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_multistep_object ) lhs % registers = rhs % registers lhs % steps = rhs % steps lhs % autoupdate = rhs % autoupdate lhs % iterations = rhs % iterations if ( allocated ( lhs % Dt )) deallocate ( lhs % Dt ) if ( allocated ( rhs % Dt )) lhs % Dt = rhs % Dt if ( allocated ( lhs % t )) deallocate ( lhs % t ) if ( allocated ( rhs % t )) lhs % t = rhs % t if ( allocated ( lhs % previous )) deallocate ( lhs % previous ) if ( allocated ( rhs % previous )) then allocate ( lhs % previous ( 1 : lhs % registers ), mold = rhs % previous ) do s = 1 , lhs % registers lhs % previous ( s ) = rhs % previous ( s ) enddo endif if ( allocated ( lhs % buffer )) deallocate ( lhs % buffer ) if ( allocated ( rhs % buffer )) then allocate ( lhs % buffer , mold = rhs % buffer ) lhs % buffer = rhs % buffer endif endselect endsubroutine assign_multistep elemental subroutine destroy_multistep ( self ) !< Destroy the integrator. class ( integrator_multistep_object ), intent ( inout ) :: self !< Integrator. call self % destroy_abstract self % registers = 0 self % steps = - 1 self % autoupdate = . false . self % iterations = 0 if ( allocated ( self % Dt )) deallocate ( self % Dt ) if ( allocated ( self % t )) deallocate ( self % t ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % buffer )) deallocate ( self % buffer ) endsubroutine destroy_multistep subroutine update_previous ( U , previous , Dt , t , previous_Dt , previous_t ) !< Cyclic update previous time steps. class ( integrand_object ), intent ( in ) :: U !< Field to be integrated. class ( integrand_object ), intent ( inout ) :: previous ( 1 :) !< Previous time steps solutions of integrand. real ( R_P ), intent ( in ), optional :: Dt !< Time step. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), intent ( inout ), optional :: previous_Dt ( 1 :) !< Time step. real ( R_P ), intent ( inout ), optional :: previous_t ( 1 :) !< Time. integer ( I_P ) :: last_step !< Last step. integer ( I_P ) :: s !< Steps counter. last_step = size ( previous , dim = 1 ) do s = 1 , last_step - 1 previous ( s ) = previous ( s + 1 ) if ( present ( previous_Dt )) previous_Dt ( s ) = previous_Dt ( s + 1 ) if ( present ( previous_t )) previous_t ( s ) = previous_t ( s + 1 ) enddo previous ( last_step ) = U if ( present ( previous_Dt )) previous_Dt ( last_step ) = Dt if ( present ( previous_t )) previous_t ( last_step ) = t + Dt endsubroutine update_previous endmodule foodie_integrator_multistep_object","tags":"","loc":"sourcefile/foodie_integrator_multistep_object.f90.html","title":"foodie_integrator_multistep_object.f90 – FOODIE"},{"text":"Define the abstract type integrator_object of FOODIE ODE integrators. Files Dependent On This One sourcefile~~foodie_integrator_object.f90~~AfferentGraph sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_objectf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_object Source Code foodie_integrator_object.f90 Source Code !< Define the abstract type [[integrator_object]] of FOODIE ODE integrators. module foodie_integrator_object !< Define the abstract type [[integrator_object]] of FOODIE ODE integrators. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use penf , only : I_P implicit none private public :: integrator_object type , abstract :: integrator_object !< Abstract type of FOODIE ODE integrators. character ( len = :), allocatable :: description_ !< Informative description of the integrator. integer ( I_P ) :: error = 0 !< Error status code. character ( len = :), allocatable :: error_message !< Error message, hopefully meaningful. contains ! public methods procedure , pass ( lhs ) :: assign_abstract !< Assign ony members of abstract [[integrator_object]] type. procedure , pass ( self ) :: check_error !< Check for error occurrencies. procedure , pass ( self ) :: description !< Return informative integrator description. procedure , pass ( self ) :: destroy_abstract !< Destroy only members of abstract [[integrator_object]] type. procedure , pass ( self ) :: trigger_error !< Trigger an error. ! deferred methods procedure ( class_name_interface ), pass ( self ), deferred :: class_name !< Return the class name of schemes. procedure ( has_fast_mode_interface ), pass ( self ), deferred :: has_fast_mode !< Return .true. if the integrator class !< has *fast mode* integrate. procedure ( assignment_interface ), pass ( lhs ), deferred :: integr_assign_integr !< Operator `=`. procedure ( is_multistagestep_interface ), pass ( self ), deferred :: is_multistage !< Return .true. for multistage integrator. procedure ( is_multistagestep_interface ), pass ( self ), deferred :: is_multistep !< Return .true. for multistep integrator. procedure ( is_supported_interface ), pass ( self ), deferred :: is_supported !< Return .true. if the integrator class !< support the given scheme. procedure ( stagesteps_number_interface ), pass ( self ), deferred :: stages_number !< Return number of stages used. procedure ( stagesteps_number_interface ), pass ( self ), deferred :: steps_number !< Return number of steps used. procedure ( supported_schemes_interface ), pass ( self ), deferred :: supported_schemes !< Return the list of supported schemes. ! operators generic :: assignment ( = ) => integr_assign_integr !< Overload `=`. endtype integrator_object abstract interface !< Abstract interfaces of deferred methods of [[integrator_object]]. pure function class_name_interface ( self ) result ( class_name ) !< Return the class name of schemes. import :: integrator_object class ( integrator_object ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. endfunction class_name_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: integrator_object class ( integrator_object ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface subroutine assignment_interface ( lhs , rhs ) !< Operator `=`. import :: integrator_object class ( integrator_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_interface elemental function has_fast_mode_interface ( self ) result ( has_fast_mode ) !< Return .true. if the integrator class has *fast mode* integrate. import :: integrator_object class ( integrator_object ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. endfunction has_fast_mode_interface elemental function is_multistagestep_interface ( self ) result ( is_multistagestep ) !< Return .true. for multistage or multistep integrator. import :: integrator_object class ( integrator_object ), intent ( in ) :: self !< Integrator. logical :: is_multistagestep !< Inquire result. endfunction is_multistagestep_interface elemental function is_supported_interface ( self , scheme ) result ( is_supported ) !< Return .true. if the integrator class support the given scheme. import :: integrator_object class ( integrator_object ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Queried scheme. logical :: is_supported !< Inquire result. endfunction is_supported_interface elemental function stagesteps_number_interface ( self ) result ( stagesteps_number ) !< Return number of stages/steps used. import :: integrator_object , I_P class ( integrator_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: stagesteps_number !< Inquire result. endfunction stagesteps_number_interface pure function supported_schemes_interface ( self ) result ( schemes ) !< Return the list of supported schemes. import :: integrator_object class ( integrator_object ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. endfunction supported_schemes_interface endinterface contains ! public methods subroutine assign_abstract ( lhs , rhs ) !< Assign ony members of abstract [[integrator_object]] type. class ( integrator_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % description_ )) lhs % description_ = rhs % description_ lhs % error = rhs % error if ( allocated ( rhs % error_message )) lhs % error_message = rhs % error_message endsubroutine assign_abstract subroutine check_error ( self , is_severe ) !< Check for error occurencies. !< !< If `is_severe=.true.` an stop is called. class ( integrator_object ), intent ( in ) :: self !< Integrator. logical , intent ( in ), optional :: is_severe !< Flag to activate severe faliure, namely errors trigger a stop. if ( self % error /= 0 ) then if ( allocated ( self % error_message )) then write ( stderr , '(A)' ) 'error: ' // self % error_message else write ( stderr , '(A)' ) 'error: an obscure error occurred!' endif write ( stderr , '(A,I4)' ) 'error code: ' , self % error if ( present ( is_severe )) then if ( is_severe ) stop endif endif endsubroutine check_error pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrator_object ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix if ( allocated ( self % description_ )) then desc = prefix // self % description_ else desc = prefix // self % class_name () endif endfunction description elemental subroutine destroy_abstract ( self ) !< Destroy only members of abstract [[integrator_object]] type. class ( integrator_object ), intent ( inout ) :: self !< Integrator. if ( allocated ( self % description_ )) deallocate ( self % description_ ) self % error = 0 if ( allocated ( self % error_message )) deallocate ( self % error_message ) endsubroutine destroy_abstract subroutine trigger_error ( self , error , error_message , is_severe ) !< Check for error occurencies. !< !< If `is_severe=.true.` an stop is called. class ( integrator_object ), intent ( inout ) :: self !< Integrator. integer ( I_P ), intent ( in ) :: error !< Error status code. character ( len =* ), intent ( in ), optional :: error_message !< Error message, hopefully meaningful. logical , intent ( in ), optional :: is_severe !< Flag to activate severe faliure, namely errors trigger a stop. self % error = error if ( present ( error_message )) self % error_message = error_message call self % check_error ( is_severe = is_severe ) endsubroutine trigger_error endmodule foodie_integrator_object","tags":"","loc":"sourcefile/foodie_integrator_object.f90.html","title":"foodie_integrator_object.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. This File Depends On sourcefile~~foodie_integrator_runge_kutta_embedded.f90~~EfferentGraph sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 var pansourcefilefoodie_integrator_runge_kutta_embeddedf90EfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_runge_kutta_embeddedf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_runge_kutta_embedded.f90~~AfferentGraph sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_runge_kutta_embeddedf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_runge_kutta_embeddedf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_runge_kutta_emd Source Code foodie_integrator_runge_kutta_embedded.f90 Source Code !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. module foodie_integrator_runge_kutta_emd !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. !< !< The integrators provided have the embedded pairs property allowing for automatic step size control. !< The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s  !<  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  !< !< *p* is the lower accuracy order scheme and *p+1* is the higher one; Ns is the number of stages used and K&#94;s is !< the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the extended Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns} !<             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !< @bug Presently, the 2 stages Heun-Euler seems to not work, **do not use it**. !< !<##### 2 stages, 2th order !< This scheme is due to Heun-Euler. !<``` !<  0  | 0 !<  1  | 1     0 !< ---------------- !<     | 1/2   1/2 !<     | 1      0 !<``` !< !<##### 6 stages, 5th order !< This scheme is due to Cash and Karp, see [3]. !<``` !<  0    | 0 !<  1/5\t | 1/5 !<  3/10 | 3/40\t         9/40 !<  3/5\t | 3/10\t         -9/10\t      6/5 !<  1\t   | -11/54\t       5/2\t        -70/27\t    35/27 !<  7/8\t | 1631/55296    175/512      575/13824   44275/110592     253/4096     0 !< ---------------------------------------------------------------------------------------- !<       | 37/378        0           250/621      125/594          0            512/1771 !<       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 !<``` !< !<##### 7 stages, 4th order !< This scheme is due to Dormand and Prince, see [1]. !<``` !<  0    | 0 !<  1/5  | 1/5 !<  3/10 | 3/40          9/40 !<  4/5  | 44/45        -56/15        32/9 !<  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729 !<  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656 !<  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !< -------------------------------------------------------------------------------------------- !<       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40 !<       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 !<``` !< !<##### 9 stages, 6th order !< This scheme is due to Calvo et al., see [2]. !<``` !<  0                 | 0 !<  2/15              | 2/15 !<  1/5               | 1/20                  3/20 !<  3/10              | 3/40                  0                      9/40 !<  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441 !<  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461 !<  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831 !<  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713 !<  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !< -------------------------------------------------------------------------------------------------------------- !<                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571 !<                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738 !< ...continued... !<  0                 | !<  2/15              | !<  1/5               | !<  3/10              | !<  14/25             | !<  19/25             | 73139862/60170633 !<  35226607/35688279 | -90453121/33722162     111179552/157155827 !<  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625 !<  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !< ----------------------------------------------------------------------------------------------------------------------- !<                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0 !<                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 !<``` !< !<##### 17 stages, 10th order !< This scheme is due to Feagin, see [4]. !<``` !<  0                        |  0 !<  0.1                      |  0.1 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052 !<  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974 !<  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068 !<  0.981074190219795268254  |  0.087900734020668133731  0                        0 !<  0.833333333333333333333  |  0.085970050490246030218  0                        0 !<  0.354017365856802376329  |  0.120930449125333720660  0                        0 !<  0.882527661964732346425  |  0.110854379580391483508  0                        0 !<  0.642615758240322548157  |  0.112054414752879004829  0                        0 !<  0.357384241759677451842  |  0.113976783964185986138  0                        0 !<  0.117472338035267653574  |  0.079831452828019604635  0                        0 !<  0.833333333333333333333  |  0.985115610164857280120  0                        0 !<  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068 !<  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0 !<  0.1                      |  0.1                      0                       -0.157178665799771163367 !<  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.033333333333333333333  0.025                    0.033333333333333333333 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | -0.072954784731363262918 !<  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678 !<  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015 !<  0.882527661964732346425  |  0                        0                       -0.060576148825500558762 !<  0.642615758240322548157  |  0                        0                       -0.144942775902865915672 !<  0.357384241759677451842  |  0                        0                       -0.076881336420335693858 !<  0.117472338035267653574  |  0                        0                       -0.052032968680060307651 !<  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821 !<  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739 !<  0.539357840802981787532  |  0                       -0.777333643644968233538  0 !<  0.1                      |  0                        0                        0 !<  1                        |  0                        0.259111214548322744512 -0.358278966717952089048 !< ------------------------------------------------------------------------------------------------------ !<                           |  0                        0.05                     0 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | -0.059578021181736100156 !<  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577 !<  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236 !<  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555 !<  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727 !<  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904 !<  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653 !<  0.539357840802981787532  | -0.091089566215517606959  0                        0 !<  0.1                      |  0                        0                        0 !<  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.04                     0                        0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | -0.327769124164018874147 !<  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184 !<  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539 !<  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220 !<  0.539357840802981787532  |  0                        0                        0 !<  0.1                      |  0                        0                        0 !<  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169 !< ------------------------------------------------------------------------------------------------------ !<                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | -0.024403640575012745213 !<  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538 !<  0.1                      |  0                        0                        0.157178665799771163367 !<  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675 !< ------------------------------------------------------------------------------------------------------------- !<                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025 !< ...continued... !<  0                        | !<  0.1                      | !<  0.539357840802981787532  | !<  0.809036761204472681298  | !<  0.309036761204472681298  | !<  0.981074190219795268254  | !<  0.833333333333333333333  | !<  0.354017365856802376329  | !<  0.882527661964732346425  | !<  0.642615758240322548157  | !<  0.357384241759677451842  | !<  0.117472338035267653574  | !<  0.833333333333333333333  | !<  0.309036761204472681298  | !<  0.539357840802981787532  | !<  0.1                      | !<  1                        | !< --------------------------------------------------- !<                           | 0.033333333333333333333 !<``` !< !<#### Bibliography !< !< [1] *A family of embedded Runge-Kutta formulae*, Dormand, J. R., Prince, P. J. (1980), Journal of Computational and !< Applied Mathematics 6 (1): 19--26, doi:10.1016/0771-050X(80)90013-3. !< !< [2] *A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6*, M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics !< with Applications, Volume 20, Issue 1, 1990, Pages 15--24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. !< !< [3] *A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides*, J. R. Cash, !< A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201--222, 1990, doi:10.1145/79505.79507. !< !< [4] *A tenth-order Runge-Kutta method with error estimate*, Feagin, T., Proceedings of the IAENG Conf. on Scientific !< Computing. 2007. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistage_object , only : integrator_multistage_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_runge_kutta_emd character ( len = 99 ), parameter :: class_name_ = 'runge_kutta_emd' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 4 ) = [ trim ( class_name_ ) // '_stages_6_order_5  ' , & trim ( class_name_ ) // '_stages_7_order_4  ' , & trim ( class_name_ ) // '_stages_9_order_6  ' , & trim ( class_name_ ) // '_stages_17_order_10' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_emd !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ) :: tolerance !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv !< 1/(p+1) where p is the accuracy order of the lower accurate scheme. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. class ( integrand_object ), allocatable :: U1 !< First U evaluation. class ( integrand_object ), allocatable :: U2 !< Second U evaluation. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! overridden public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. ! private methods procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. endtype integrator_runge_kutta_emd contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_emd ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_emd ) lhs % tolerance = rhs % tolerance lhs % pp1_inv = rhs % pp1_inv lhs % stages = rhs % stages if ( allocated ( rhs % alph )) lhs % alph = rhs % alph if ( allocated ( rhs % beta )) lhs % beta = rhs % beta if ( allocated ( rhs % gamm )) lhs % gamm = rhs % gamm endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. real ( R_P ) :: Dt_ !< Time step, local variable. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. Dt_ = Dt do ! compute stages do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 self % stage ( s ) = self % stage ( s ) + ( self % stage ( ss ) * ( Dt_ * self % alph ( s , ss ))) enddo self % stage ( s ) = self % stage ( s )% t ( t = t + self % gamm ( s ) * Dt_ ) enddo ! compute new time step self % U1 = U self % U2 = U do s = 1 , self % stages self % U1 = self % U1 + ( self % stage ( s ) * ( Dt_ * self % beta ( s , 1 ))) self % U2 = self % U2 + ( self % stage ( s ) * ( Dt_ * self % beta ( s , 2 ))) enddo error = self % U2 . lterror . self % U1 if ( error <= self % tolerance ) exit call self % new_Dt ( error = error , Dt = Dt_ ) enddo U = self % U1 if ( present ( new_Dt )) new_Dt = Dt_ endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit embedded Runge-Kutta scheme, fast mode. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. real ( R_P ) :: Dt_ !< Time step, local variable. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. Dt_ = Dt do ! compute stages do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 call self % buffer % multiply_fast ( lhs = self % stage ( ss ), rhs = Dt_ * self % alph ( s , ss )) call self % stage ( s )% add_fast ( lhs = self % stage ( s ), rhs = self % buffer ) enddo call self % stage ( s )% t_fast ( t = t + self % gamm ( s ) * Dt_ ) enddo ! compute new time step self % U1 = U self % U2 = U do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = Dt_ * self % beta ( s , 1 )) call self % U1 % add_fast ( lhs = self % U1 , rhs = self % buffer ) call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = Dt_ * self % beta ( s , 2 )) call self % U2 % add_fast ( lhs = self % U2 , rhs = self % buffer ) enddo error = self % U2 . lterror . self % U1 if ( error <= self % tolerance ) exit call self % new_Dt ( error = error , Dt = Dt_ ) enddo U = self % U1 if ( present ( new_Dt )) new_Dt = Dt_ endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage self % tolerance = 0._R_P self % pp1_inv = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) endsubroutine destroy subroutine initialize ( self , scheme , U , tolerance , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. real ( R_P ), intent ( in ), optional :: tolerance !< Tolerance on the local truncation error (default 0.01). logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) self % tolerance = 0.01_R_P ; if ( present ( tolerance )) self % tolerance = tolerance select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_emd_stages_2_order_2' ) ! do not use, seems to not work! self % stages = 2 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 'runge_kutta_emd_stages_6_order_5' ) self % stages = 6 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 'runge_kutta_emd_stages_7_order_4' ) self % stages = 7 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 'runge_kutta_emd_stages_9_order_6' ) self % stages = 9 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 'runge_kutta_emd_stages_17_order_10' ) self % stages = 17 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize ! overridden public methods subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistage () . and . self % registers > 0 ) then if ( allocated ( self % stage )) deallocate ( self % stage ) allocate ( self % stage ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % stage ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif if ( allocated ( self % U1 )) deallocate ( self % U1 ) allocate ( self % U1 , mold = U ) self % U1 = U if ( allocated ( self % U2 )) deallocate ( self % U2 ) allocate ( self % U2 , mold = U ) self % U2 = U endsubroutine allocate_integrand_members ! private methods elemental subroutine new_Dt ( self , error , Dt ) !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. real ( R_P ), intent ( in ) :: error !< Local truncation error estimation. real ( R_P ), intent ( inout ) :: Dt !< Time step. if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv endsubroutine new_Dt endmodule foodie_integrator_runge_kutta_emd","tags":"","loc":"sourcefile/foodie_integrator_runge_kutta_embedded.f90.html","title":"foodie_integrator_runge_kutta_embedded.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. This File Depends On sourcefile~~foodie_integrator_runge_kutta_low_storage.f90~~EfferentGraph sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_integrator_runge_kutta_low_storagef90EfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_runge_kutta_low_storagef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_runge_kutta_low_storage.f90~~AfferentGraph sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_runge_kutta_low_storagef90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_runge_kutta_low_storagef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_runge_kutta_low_storage Source Code foodie_integrator_runge_kutta_low_storage.f90 Source Code !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_runge_kutta_low_storage !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the low storage property allowing for an efficient use of the memory. !< Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<\\begin{matrix} !< K_1 = U&#94;n \\\\ !< K_2 = 0 \\\\ !<\\left.\\begin{matrix} !< K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\ !< K_1 = K_1 + B_s K_2 !<\\end{matrix}\\right\\} s=1,2,...N_s\\\\ !<U&#94;{n+1} = K_1 !<\\end{matrix} !< !< where *Ns* is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table !< form. !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<#### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being !< meaningless for a first order scheme. However it is added for safety reason. !< !< | ` Stage ` | ` A ` | ` B ` | ` C ` | !< |-----------|-------|-------|-------| !< | ` 1 `     | ` 0 ` | ` 1 ` | ` 0 ` | !< !<#### 5 stages, SSP, 4th order !< This scheme is a low storage RK(5, 4), based on the *solution 3* proposed in [2]. !< !< | ` Stage ` | ` A `                            | ` B `                            | ` C `                           | !< |-----------|----------------------------------|----------------------------------|---------------------------------| !< | ` 1 `     | `  0                           ` | ` 1432997174477/9575080441755  ` | ` 0                           ` | !< | ` 2 `     | ` -567301805773 /1357537059087 ` | ` 5161836677717/13612068292357 ` | ` 1432997174477/9575080441755 ` | !< | ` 3 `     | ` -2404267990393/2016746695238 ` | ` 1720146321549/2090206949498  ` | ` 2526269341429/6820363962896 ` | !< | ` 4 `     | ` -3550918686646/2091501179385 ` | ` 3134564353537/4481467310338  ` | ` 2006345519317/3224310063776 ` | !< | ` 5 `     | ` -1275806237668/842570457699  ` | ` 2277821191437/14882151754819 ` | ` 2802321613138/2924317926251 ` | !< !< !<#### 6 stages, 4th order !< This scheme is a low storage RK(6, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.122000000000 ` | ` 0              ` | !< | ` 2 `     | ` -0.691750960670 ` | ` 0.477263056358 ` | ` 0.122000000000 ` | !< | ` 3 `     | ` -1.727127405211 ` | ` 0.381941220320 ` | ` 0.269115878630 ` | !< | ` 4 `     | ` -0.694890150986 ` | ` 0.447757195744 ` | ` 0.447717183551 ` | !< | ` 5 `     | ` -1.039942756197 ` | ` 0.498614246822 ` | ` 0.749979795490 ` | !< | ` 6 `     | ` -1.531977447611 ` | ` 0.186648570846 ` | ` 0.898555413085 ` | !< !<#### 7 stages, 4th order !< This scheme is a low storage RK(7, 4), by [3]. !< !< | ` Stage ` | ` A `               | ` B `              | ` C `              | !< |-----------|---------------------|--------------------|--------------------| !< | ` 1 `     | `  0              ` | ` 0.117322146869 ` | ` 0              ` | !< | ` 2 `     | ` -0.647900745934 ` | ` 0.503270262127 ` | ` 0.117322146869 ` | !< | ` 3 `     | ` -2.704760863204 ` | ` 0.233663281658 ` | ` 0.294523230758 ` | !< | ` 4 `     | ` -0.460080550118 ` | ` 0.283419634625 ` | ` 0.305658622131 ` | !< | ` 5 `     | ` -0.500581787785 ` | ` 0.540367414023 ` | ` 0.582864148403 ` | !< | ` 6 `     | ` -1.906532255913 ` | ` 0.371499414620 ` | ` 0.858664273599 ` | !< | ` 7 `     | ` -1.450000000000 ` | ` 0.136670099385 ` | ` 0.868664273599 ` | !< !<#### 12 stages, 4th order !< This scheme is a low storage RK(12, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0650008435125904 ` | ` 0                  ` | !< | ` 2  `    | ` -0.0923311242368072 ` | ` 0.0161459902249842 ` | ` 0.0650008435125904 ` | !< | ` 3  `    | ` -0.9441056581158819 ` | ` 0.5758627178358159 ` | ` 0.0796560563081853 ` | !< | ` 4  `    | ` -4.3271273247576394 ` | ` 0.1649758848361671 ` | ` 0.1620416710085376 ` | !< | ` 5  `    | ` -2.1557771329026072 ` | ` 0.3934619494248182 ` | ` 0.2248877362907778 ` | !< | ` 6  `    | ` -0.9770727190189062 ` | ` 0.0443509641602719 ` | ` 0.2952293985641261 ` | !< | ` 7  `    | ` -0.7581835342571139 ` | ` 0.2074504268408778 ` | ` 0.3318332506149405 ` | !< | ` 8  `    | ` -1.7977525470825499 ` | ` 0.6914247433015102 ` | ` 0.4094724050198658 ` | !< | ` 9  `    | ` -2.6915667972700770 ` | ` 0.3766646883450449 ` | ` 0.6356954475753369 ` | !< | ` 10 `    | ` -4.6466798960268143 ` | ` 0.0757190350155483 ` | ` 0.6806551557645497 ` | !< | ` 11 `    | ` -0.1539613783825189 ` | ` 0.2027862031054088 ` | ` 0.7143773712418350 ` | !< | ` 12 `    | ` -0.5943293901830616 ` | ` 0.2167029365631842 ` | ` 0.9032588871651854 ` | !< !<#### 13 stages, 4th order !< This scheme is a low storage RK(13, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0271990297818803 ` | ` 0                  ` | !< | ` 2  `    | ` -0.6160178650170565 ` | ` 0.1772488819905108 ` | ` 0.0271990297818803 ` | !< | ` 3  `    | ` -0.4449487060774118 ` | ` 0.0378528418949694 ` | ` 0.0952594339119365 ` | !< | ` 4  `    | ` -1.0952033345276178 ` | ` 0.6086431830142991 ` | ` 0.1266450286591127 ` | !< | ` 5  `    | ` -1.2256030785959187 ` | ` 0.2154313974316100 ` | ` 0.1825883045699772 ` | !< | ` 6  `    | ` -0.2740182222332805 ` | ` 0.2066152563885843 ` | ` 0.3737511439063931 ` | !< | ` 7  `    | ` -0.0411952089052647 ` | ` 0.0415864076069797 ` | ` 0.5301279418422206 ` | !< | ` 8  `    | ` -0.1797084899153560 ` | ` 0.0219891884310925 ` | ` 0.5704177433952291 ` | !< | ` 9  `    | ` -1.1771530652064288 ` | ` 0.9893081222650993 ` | ` 0.5885784947099155 ` | !< | ` 10 `    | ` -0.4078831463120878 ` | ` 0.0063199019859826 ` | ` 0.6160769826246714 ` | !< | ` 11 `    | ` -0.8295636426191777 ` | ` 0.3749640721105318 ` | ` 0.6223252334314046 ` | !< | ` 12 `    | ` -4.7895970584252288 ` | ` 1.6080235151003195 ` | ` 0.6897593128753419 ` | !< | ` 13 `    | ` -0.6606671432964504 ` | ` 0.0961209123818189 ` | ` 0.9126827615920843 ` | !< !<#### 14 stages, 4th order !< This scheme is a low storage RK(14, 4), by [4]. !< !< | ` Stage ` | ` A `                   | ` B `                  | ` C `                  | !< |-----------|-------------------------|------------------------|------------------------| !< | ` 1  `    | `  0                  ` | ` 0.0367762454319673 ` | ` 0                  ` | !< | ` 2  `    | ` -0.7188012108672410 ` | ` 0.3136296607553959 ` | ` 0.0367762454319673 ` | !< | ` 3  `    | ` -0.7785331173421570 ` | ` 0.1531848691869027 ` | ` 0.1249685262725025 ` | !< | ` 4  `    | ` -0.0053282796654044 ` | ` 0.0030097086818182 ` | ` 0.2446177702277698 ` | !< | ` 5  `    | ` -0.8552979934029281 ` | ` 0.3326293790646110 ` | ` 0.2476149531070420 ` | !< | ` 6  `    | ` -3.9564138245774565 ` | ` 0.2440251405350864 ` | ` 0.2969311120382472 ` | !< | ` 7  `    | ` -1.5780575380587385 ` | ` 0.3718879239592277 ` | ` 0.3978149645802642 ` | !< | ` 8  `    | ` -2.0837094552574054 ` | ` 0.6204126221582444 ` | ` 0.5270854589440328 ` | !< | ` 9  `    | ` -0.7483334182761610 ` | ` 0.1524043173028741 ` | ` 0.6981269994175695 ` | !< | ` 10 `    | ` -0.7032861106563359 ` | ` 0.0760894927419266 ` | ` 0.8190890835352128 ` | !< | ` 11 `    | `  0.0013917096117681 ` | ` 0.0077604214040978 ` | ` 0.8527059887098624 ` | !< | ` 12 `    | ` -0.0932075369637460 ` | ` 0.0024647284755382 ` | ` 0.8604711817462826 ` | !< | ` 13 `    | ` -0.9514200470875948 ` | ` 0.0780348340049386 ` | ` 0.8627060376969976 ` | !< | ` 14 `    | ` -7.1151571693922548 ` | ` 5.5059777270269628 ` | ` 0.8734213127600976 ` | !< !<#### Bibliography !< !< [1] *Low-Storage Runge-Kutta Schemes*, J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48--56. !< !< [2] *Fourth-Order 2N-Storage Runge-Kutta Schemes*, Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, !< June 1994. !< !< [3] *High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics*, Vasanth Allampalli and !< Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837--3850. !< !< [4] *Efficient low-storage Runge–Kutta schemes with optimized stability regions*, Jens Niegemann and Richard Diehl and Kurt !< Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364--372. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistage_object , only : integrator_multistage_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , I8P , R_P implicit none private public :: integrator_runge_kutta_ls character ( len = 99 ), parameter :: class_name_ = 'runge_kutta_ls' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 7 ) = [ trim ( class_name_ ) // '_stages_1_order_1 ' , & trim ( class_name_ ) // '_stages_5_order_4 ' , & trim ( class_name_ ) // '_stages_6_order_4 ' , & trim ( class_name_ ) // '_stages_7_order_4 ' , & trim ( class_name_ ) // '_stages_12_order_4' , & trim ( class_name_ ) // '_stages_13_order_4' , & trim ( class_name_ ) // '_stages_14_order_4' ] !< List of supported schemes. integer ( I_P ), parameter :: registers = 2 !< Registers used (2N schemes). logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_ls !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. procedure , nopass :: registers_number !< Return the number of registers used. endtype integrator_runge_kutta_ls contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_ls ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_ls ) lhs % stages = rhs % stages if ( allocated ( rhs % A )) lhs % A = rhs % A if ( allocated ( rhs % B )) lhs % B = rhs % B if ( allocated ( rhs % C )) lhs % C = rhs % C endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit low storage Runge-Kutta scheme. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U self % stage ( 2 ) = U * 0._R_P do s = 1 , self % stages self % stage ( 2 ) = ( self % stage ( 2 ) * self % A ( s )) + ( self % stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt ) self % stage ( 1 ) = self % stage ( 1 ) + ( self % stage ( 2 ) * self % B ( s )) enddo U = self % stage ( 1 ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit low storage Runge-Kutta scheme, fast mode. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U call self % stage ( 2 )% multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % stages self % buffer = self % stage ( 1 ) call self % buffer % t_fast ( t = t + self % C ( s ) * Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call self % stage ( 2 )% multiply_fast ( lhs = self % stage ( 2 ), rhs = self % A ( s )) call self % stage ( 2 )% add_fast ( lhs = self % stage ( 2 ), rhs = self % buffer ) call self % buffer % multiply_fast ( lhs = self % stage ( 2 ), rhs = self % B ( s )) call self % stage ( 1 )% add_fast ( lhs = self % stage ( 1 ), rhs = self % buffer ) enddo U = self % stage ( 1 ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) endsubroutine destroy subroutine initialize ( self , scheme , U , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_ls_stages_1_order_1' ) self % stages = 1 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % B ( 1 ) = 1._R_P case ( 'runge_kutta_ls_stages_5_order_4' ) self % stages = 5 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 'runge_kutta_ls_stages_6_order_4' ) self % stages = 6 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 'runge_kutta_ls_stages_7_order_4' ) self % stages = 7 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 'runge_kutta_ls_stages_12_order_4' ) self % stages = 12 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 'runge_kutta_ls_stages_13_order_4' ) self % stages = 13 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 'runge_kutta_ls_stages_14_order_4' ) self % stages = 14 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P endselect self % registers = 2 if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize pure function registers_number () !< Return the number of registers used. integer ( I_P ) :: registers_number !< Number of registers used. registers_number = registers endfunction registers_number endmodule foodie_integrator_runge_kutta_low_storage","tags":"","loc":"sourcefile/foodie_integrator_runge_kutta_low_storage.f90.html","title":"foodie_integrator_runge_kutta_low_storage.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. This File Depends On sourcefile~~foodie_integrator_runge_kutta_lssp.f90~~EfferentGraph sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_runge_kutta_lssp.f90~~AfferentGraph sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_runge_kutta_lsspf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_runge_kutta_lsspf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_runge_kutta_lssp Source Code foodie_integrator_runge_kutta_lssp.f90 Source Code !< FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. module foodie_integrator_runge_kutta_lssp !< FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. !< !< The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the following 2 forms: !< !<#### Ns stages, Ns-1 order !< !<  U&#94;0 = U&#94;n  !<  U&#94;k = U&#94;{k-1} + \\frac{1}{2} \\Delta t R(U&#94;{k-1}) \\quad k=1,..,Ns  !<  U&#94;{Ns} = U&#94;{Ns} + \\frac{1}{2} \\Delta t R(U&#94;{Ns})  !<  U&#94;{n+1} = \\sum_{k=1}&#94;{Ns}\\alpha_k U&#94;k  !< !< where Ns is the number of stages used and U&#94;k is the k&#94;{th} stage. The minimum number of stages is 2. The !< coefficients \\alpha are computed by means of the following recursive algorith: !< !<##### Computation of coefficients !< !<+ allocate coefficients array, `allocate(alpha(1:Ns))`; !<+ initialize the first 2 elements with the coefficients of the two stages first order methods, `alpha(1)=0, alpha(2)=1`; !<+ for `i` in [3,Ns] do: !<  + `alpha(i) = (2 / i) * alpha(i-1)` !<  + for `j` in [i-1,2,-1] do: !<    + `alpha(j) = (2 / (j-1)) * alpha(j-1)` !<  + for `j` in [2,i] do: !<    + `alpha(1) = 1 - alpha(j)` !< !<#### Ns stages, Ns order !< !<  U&#94;0 = U&#94;n  !<  U&#94;k = U&#94;{k-1} + \\Delta t R(U&#94;{k-1}) \\quad k=1,..,Ns  !<  U&#94;{Ns} = U&#94;{Ns} +\\Delta t R(U&#94;{Ns})  !<  U&#94;{n+1} = \\sum_{k=1}&#94;{Ns}\\alpha_k U&#94;k  !< !< where Ns is the number of stages used and U&#94;k is the k&#94;{th} stage. The minimum number of stages is 1. The !< coefficients \\alpha are computed by means of the following recursive algorith: !< !<##### Computation of coefficients !< !<+ allocate coefficients array, `allocate(alpha(1:Ns))`; !<+ initialize the first element with the coefficient of the one stage first order method, `alpha(1)=1`; !<+ for `i` in [2,Ns] do: !<  + `alpha(i) = 1 / i!` !<  + for `j` in [i-1,2,-1] do: !<    + `alpha(j) = (1 / (j-1)) * alpha(j-1)` !<  + for `j` in [2,i] do: !<    + `alpha(1) = 1 - alpha(j)` !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !<#### Bibliography !< !< [2] *Strong Stability Preserving Runge-Kutta and Multistep Time Discretizations*, S. Gottlieb, D. Ketcheson, C.W. Shu, !< 2011, 978-981-4289-26-9, doi:10.1142/7498, World Scientific Publishing Co. Pte. Ltd. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistage_object , only : integrator_multistage_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P , str implicit none private public :: integrator_runge_kutta_lssp character ( len = 99 ), parameter :: class_name_ = 'runge_kutta_lssp' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 2 ) = [ trim ( class_name_ ) // '_stages_s_order_s_1' , & trim ( class_name_ ) // '_stages_s_order_s  ' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_lssp !< FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ), allocatable :: alpha (:) !< \\alpha coefficients. procedure ( integrate_interface ), pointer :: integrate_ => integrate_order_s_1 !< Integrate integrand field. procedure ( integrate_fast_interface ), pointer :: integrate_fast_ => integrate_order_s_1_fast !< Integrate integrand field, fast. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! private methods procedure , pass ( self ), private :: initialize_order_s_1 !< Integrate integrator for (s-1)-th order formula. procedure , pass ( self ), private :: initialize_order_s !< Integrate integrator for s-th order formula. procedure , pass ( self ), private :: integrate_order_s_1 !< Integrate integrand field by (s-1)-th order formula. procedure , pass ( self ), private :: integrate_order_s !< Integrate integrand field by s-th order formula. endtype integrator_runge_kutta_lssp abstract interface !< Abstract interfaces of [[integrator_runge_kutta_lssp]] methods. subroutine integrate_interface ( self , U , Dt , t ) !< Integrate field with Linear SSP Runge-Kutta scheme. import :: integrand_object , integrator_runge_kutta_lssp , R_P class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. endsubroutine integrate_interface subroutine integrate_fast_interface ( self , U , Dt , t ) !< Integrate field with Linear SSP Runge-Kutta scheme, fast mode. import :: integrand_object , integrator_runge_kutta_lssp , R_P class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. endsubroutine integrate_fast_interface endinterface contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_lssp ) lhs % stages = rhs % stages if ( allocated ( rhs % alpha )) lhs % alpha = rhs % alpha endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate integrand field by Linear SSP Runge-Kutta methods. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. call self % integrate_ ( U = U , Dt = Dt , t = t ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate integrand field by Linear SSP Runge-Kutta methods. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. call self % integrate_fast_ ( U = U , Dt = Dt , t = t ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage if ( allocated ( self % alpha )) deallocate ( self % alpha ) self % integrate_ => integrate_order_s_1 endsubroutine destroy subroutine initialize ( self , scheme , U , stages , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. integer ( I_P ), intent ( in ), optional :: stages !< Stages number. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_lssp_stages_s_order_s_1' ) self % integrate_ => integrate_order_s_1 self % integrate_fast_ => integrate_order_s_1_fast self % stages = 2 ; if ( present ( stages )) self % stages = stages if ( self % stages < 2 ) then error stop 'error: the number of stages of \"runge_kutta_lssp_stages_s_order_s_1\" must be >=2' endif allocate ( self % alpha ( 1 : self % stages )) ; self % alpha = 0._R_P call self % initialize_order_s_1 case ( 'runge_kutta_lssp_stages_s_order_s' ) self % integrate_ => integrate_order_s self % integrate_fast_ => integrate_order_s_fast self % stages = 1 ; if ( present ( stages )) self % stages = stages if ( self % stages < 1 ) then error stop 'error: the number of stages of \"runge_kutta_lssp_stages_s_order_s\" must be >=1' endif allocate ( self % alpha ( 1 : self % stages )) ; self % alpha = 0._R_P call self % initialize_order_s endselect self % description_ = trim ( adjustl ( scheme )) // '_stages_' // trim ( str ( self % stages , no_sign = . true .)) self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize ! private methods elemental subroutine initialize_order_s_1 ( self ) !< Initialize integrator for (s-1)-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. associate ( alpha => self % alpha ) alpha ( 1 ) = 0._R_P alpha ( 2 ) = 1._R_P do i = 3 , self % stages alpha ( i ) = 2._R_P / i * alpha ( i - 1 ) do j = i - 1 , 2 , - 1 alpha ( j ) = 2._R_P / ( j - 1 ) * alpha ( j - 1 ) enddo alpha ( 1 ) = 1._R_P do j = 2 , i alpha ( 1 ) = alpha ( 1 ) - alpha ( j ) enddo enddo endassociate endsubroutine initialize_order_s_1 elemental subroutine initialize_order_s ( self ) !< Initialize integrator for s-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. associate ( alpha => self % alpha ) alpha ( 1 ) = 1._R_P do i = 2 , self % stages alpha ( i ) = 1._R_P / product ([( j , j = 1 , i )]) do j = i - 1 , 2 , - 1 alpha ( j ) = 1._R_P / ( j - 1 ) * alpha ( j - 1 ) enddo alpha ( 1 ) = 1._R_P do j = 2 , i alpha ( 1 ) = alpha ( 1 ) - alpha ( j ) enddo enddo endassociate endsubroutine initialize_order_s subroutine integrate_order_s_1 ( self , U , Dt , t ) !< Integrate integrand field by (s-1)-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % stage ( s ) = self % stage ( s - 1 ) + ( self % stage ( s - 1 )% t ( t = t ) * ( Dt * 0.5_R_P )) enddo self % stage ( self % stages ) = self % stage ( self % stages ) + ( self % stage ( self % stages )% t ( t = t ) * ( Dt * 0.5_R_P )) ! computing new time step U = U * 0._R_P do s = 1 , self % stages U = U + ( self % stage ( s ) * self % alpha ( s )) enddo endsubroutine integrate_order_s_1 subroutine integrate_order_s ( self , U , Dt , t ) !< Integrate integrand field by s-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % stage ( s ) = self % stage ( s - 1 ) + ( self % stage ( s - 1 )% t ( t = t ) * Dt ) enddo self % stage ( self % stages ) = self % stage ( self % stages ) + ( self % stage ( self % stages )% t ( t = t ) * Dt ) ! computing new time step U = U * 0._R_P do s = 1 , self % stages U = U + ( self % stage ( s ) * self % alpha ( s )) enddo endsubroutine integrate_order_s subroutine integrate_order_s_1_fast ( self , U , Dt , t ) !< Integrate integrand field by (s-1)-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % buffer = self % stage ( s - 1 ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * 0.5_R_P ) call self % stage ( s )% add_fast ( lhs = self % stage ( s - 1 ), rhs = self % buffer ) enddo self % buffer = self % stage ( self % stages ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * 0.5_R_P ) call self % stage ( self % stages )% add_fast ( lhs = self % stage ( self % stages ), rhs = self % buffer ) ! computing new time step call U % multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = self % alpha ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo endsubroutine integrate_order_s_1_fast subroutine integrate_order_s_fast ( self , U , Dt , t ) !< Integrate integrand field by s-th order formula, fast mode. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % buffer = self % stage ( s - 1 ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call self % stage ( s )% add_fast ( lhs = self % stage ( s - 1 ), rhs = self % buffer ) enddo self % buffer = self % stage ( self % stages ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call self % stage ( self % stages )% add_fast ( lhs = self % stage ( self % stages ), rhs = self % buffer ) ! computing new time step call U % multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = self % alpha ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo endsubroutine integrate_order_s_fast endmodule foodie_integrator_runge_kutta_lssp","tags":"","loc":"sourcefile/foodie_integrator_runge_kutta_lssp.f90.html","title":"foodie_integrator_runge_kutta_lssp.f90 – FOODIE"},{"text":"FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. This File Depends On sourcefile~~foodie_integrator_runge_kutta_ssp.f90~~EfferentGraph sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_integrator_runge_kutta_ssp.f90~~AfferentGraph sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 var pansourcefilefoodie_integrator_runge_kutta_sspf90AfferentGraph = svgPanZoom('#sourcefilefoodie_integrator_runge_kutta_sspf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_integrator_runge_kutta_ssp Source Code foodie_integrator_runge_kutta_ssp.f90 Source Code !< FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_runge_kutta_ssp !< FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !<``` !<  gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns} !<  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns} !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns} !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !<``` !<  gamma&#94;1    | 0                 0                 ...        0 !<  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0 !<  .          | .                 .                 .          . !<  .          | .                 .                  .         . !<  .          | .                 .                   .        . !<  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0 !< ------------|------------------------------------------------------------- !<             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} !<``` !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !<``` !<  0 | 0 !< ---|--- !<    | 1 !<``` !< !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. !<``` !<  0 | 0     0 !<  1 | 1     0 !< ---|----------- !<    | 1/2   1/2 !<``` !< !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. !<``` !<  0   | 0     0     0 !<  1   | 1     0     0 !<  1/2 | 1/4   1/4   0 !< -----|----------------- !<      | 1/6   1/6   1/3 !<``` !< !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. !<``` !<  0                | 0                  0                  0                  0                  0 !<  0.39175222700392 | 0.39175222700392   0                  0                  0                  0 !<  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0 !<  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0 !<  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0 !< ------------------|--------------------------------------------------------------------------------------------- !<                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 !<``` !< !<#### Bibliography !< !< [1] *Coefficients for the study of Runge-Kutta integration processes*, Butcher, J.C., J. Austral. Math. Soc., Vol. 3, !< pages: 185--201, 1963. !< !< [2] *High Order Strong Stability Preserving Time Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of !< Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. use foodie_error_codes , only : ERROR_UNSUPPORTED_SCHEME use foodie_integrand_object , only : integrand_object use foodie_integrator_multistage_object , only : integrator_multistage_object use foodie_integrator_object , only : integrator_object use penf , only : I_P , R_P implicit none private public :: integrator_runge_kutta_ssp character ( len = 99 ), parameter :: class_name_ = 'runge_kutta_ssp' !< Name of the class of schemes. character ( len = 99 ), parameter :: supported_schemes_ ( 1 : 4 ) = [ trim ( class_name_ ) // '_stages_1_order_1' , & trim ( class_name_ ) // '_stages_2_order_2' , & trim ( class_name_ ) // '_stages_3_order_3' , & trim ( class_name_ ) // '_stages_5_order_4' ] !< List of supported schemes. logical , parameter :: has_fast_mode_ = . true . !< Flag to check if integrator provides *fast mode* integrate. type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_ssp !< FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_runge_kutta_ssp contains ! deferred methods pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_ssp ) lhs % stages = rhs % stages if ( allocated ( rhs % alph )) lhs % alph = rhs % alph if ( allocated ( rhs % beta )) lhs % beta = rhs % beta if ( allocated ( rhs % gamm )) lhs % gamm = rhs % gamm endselect endsubroutine integr_assign_integr subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit SSP Runge-Kutta scheme. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. ! computing stages do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 self % stage ( s ) = self % stage ( s ) + ( self % stage ( ss ) * ( Dt * self % alph ( s , ss ))) enddo self % stage ( s ) = self % stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + ( self % stage ( s ) * ( Dt * self % beta ( s ))) enddo if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit SSP Runge-Kutta scheme. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. ! computing stages self % buffer = U do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 call self % buffer % multiply_fast ( lhs = self % stage ( ss ), rhs = Dt * self % alph ( s , ss )) call self % stage ( s )% add_fast ( lhs = self % stage ( s ), rhs = self % buffer ) enddo call self % stage ( s )% t_fast ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = Dt * self % beta ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes ! public methods elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) endsubroutine destroy subroutine initialize ( self , scheme , U , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_ssp_stages_1_order_1' ) self % stages = 1 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 1._R_P case ( 'runge_kutta_ssp_stages_2_order_2' ) self % stages = 2 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 'runge_kutta_ssp_stages_3_order_3' ) self % stages = 3 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 'runge_kutta_ssp_stages_5_order_4' ) self % stages = 5 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize endmodule foodie_integrator_runge_kutta_ssp","tags":"","loc":"sourcefile/foodie_integrator_runge_kutta_ssp.f90.html","title":"foodie_integrator_runge_kutta_ssp.f90 – FOODIE"},{"text":"FOODIE utils: module of (possible) unrelated utilities of FOODIE library. Modules foodie_utils Source Code foodie_utils.f90 Source Code !< FOODIE utils: module of (possible) unrelated utilities of FOODIE library. module foodie_utils !< FOODIE utils: module of (possible) unrelated utilities of FOODIE library. use penf , only : I_P implicit none private public :: is_admissible contains ! public procedures elemental function is_admissible ( n , adm_range ) !< Check if the queried number *n* is admitted by the *admissible* range list *adm_range*. !< !< The admissible range list must be formatted as string containing admissible numbers; valid list are: !<+ `adm_range = '1-5'` => 1, 2, 3, 4, 5 are admissible numbers; !<+ `adm_range = '1,3,5,10-12'` => 1, 3, 5, 10, 11, 12 are admissible numbers; !<+ `adm_range = '1-4,8,21-22'` => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; !< !< You can mix any number of range (`min-max` format) and/or single number (`,` comma separated) entries. integer ( I_P ), intent ( IN ) :: n !< Number queried. character ( * ), intent ( IN ) :: adm_range !< Admissible range string. logical :: is_admissible !< Is true is the number is in *adm_range*. character ( len ( adm_range )), allocatable :: tokens (:) !< Tokens for parsing *adm_range* string. character ( len ( adm_range )), allocatable :: subtokens (:) !< Tokens for parsing *adm_range* string. integer ( I_P ) :: t !< Counter. integer ( I_P ) :: n_parsed ( 1 : 2 ) !< Values parsed from *adm_range*.. is_admissible = . false . call tokenize ( string = adm_range , delimiter = ',' , toks = tokens ) search_me : do t = 1 , size ( tokens ) if ( index ( tokens ( t ), '-' ) > 0 ) then call tokenize ( string = tokens ( t ), delimiter = '-' , toks = subtokens ) read ( subtokens ( 1 ), * ) n_parsed ( 1 ) read ( subtokens ( 2 ), * ) n_parsed ( 2 ) is_admissible = ( n_parsed ( 1 ) <= n . and . n <= n_parsed ( 2 )) else read ( tokens ( t ), * ) n_parsed ( 1 ) is_admissible = ( n_parsed ( 1 ) == n ) endif if ( is_admissible ) exit search_me enddo search_me endfunction is_admissible ! private procedures pure subroutine tokenize ( string , delimiter , toks , Nt ) !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). character ( len =* ), intent ( IN ) :: string !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( string )), allocatable , intent ( OUT ) :: toks (:) !< Tokens. integer ( I_P ), optional , intent ( OUT ) :: Nt !< Number of tokens. character ( len = len ( string )) :: strsub !< Temporary string. integer ( I_P ) :: dlen !< Delimiter length. integer ( I_P ) :: c !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: t !< Counter. ! initialize if ( allocated ( toks )) deallocate ( toks ) strsub = string dlen = len ( delimiter ) if ( dlen > len ( string )) then allocate ( toks ( 1 : 1 )) toks ( 1 ) = char ( 0 ) if ( present ( Nt )) Nt = 1 return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenize do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n endsubroutine tokenize endmodule foodie_utils","tags":"","loc":"sourcefile/foodie_utils.f90.html","title":"foodie_utils.f90 – FOODIE"},{"text":"Test FOODIE with the integration of linear constant coefficients equation. This File Depends On sourcefile~~foodie_test_lcce.f90~~EfferentGraph sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foodie_test_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_test_lccef90EfferentGraph = svgPanZoom('#sourcefilefoodie_test_lccef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foodie_test_lcce Modules foodie_test_lcce_test Source Code foodie_test_lcce.f90 Source Code !< Test FOODIE with the integration of linear constant coefficients equation. module foodie_test_lcce_test !< Linear constant coefficients test handler definition. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use flap , only : command_line_interface use foodie , only : foodie_integrator_class_names , & foodie_integrator_factory , & foodie_integrator_schemes , & integrator_adams_bashforth , & integrator_adams_bashforth_moulton , & integrator_adams_moulton , & integrator_back_df , & integrator_euler_explicit , & integrator_leapfrog , & integrator_lmm_ssp , & integrator_lmm_ssp_vss , & integrator_ms_runge_kutta_ssp , & integrator_object , & integrator_runge_kutta_emd , & integrator_runge_kutta_ls , & integrator_runge_kutta_lssp , & integrator_runge_kutta_ssp , & is_available , is_class_available use foodie_test_integrand_lcce , only : integrand_lcce use penf , only : I_P , R_P , FR_P , str , strz implicit none private public :: lcce_test type :: lcce_test !< Class to handle linear constant coefficients equation test(s). !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error = 0 !< Error handler. character ( 99 ) :: scheme = '' !< Scheme used. logical :: is_fast = . false . !< Flag for activating fast schemes. integer ( I_P ) :: implicit_iterations = 0 !< Number of iterations (implicit solvers). integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. real ( R_P ) :: a = 0._R_P !< *a* coefficient. real ( R_P ) :: b = 0._R_P !< *b* coefficient. real ( R_P ) :: U0 = 0._R_P !< Initial conditions. real ( R_P ) :: final_time = 0.0_R_P !< Final integration time. logical :: results = . false . !< Flag for activating results saving. character ( 99 ) :: output = '' !< Output files basename. logical :: exact_solution = . false . !< Flag for activating exact solution saving. logical :: errors_analysis = . false . !< Flag for activating errors analysis. contains ! public methods procedure , pass ( self ) :: execute !< Execute selected test(s). ! private methods procedure , pass ( self ), private :: initialize !< Initialize test: set Command Line Interface, parse it and check its validity. procedure , pass ( self ), private :: test !< Perform the test. endtype lcce_test contains ! public methods subroutine execute ( self ) !< Execute selected test(s). class ( lcce_test ), intent ( inout ) :: self !< Test. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: s !< Counter. call self % initialize if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if ( is_class_available ( scheme = self % scheme )) then integrator_schemes = foodie_integrator_schemes ( class_name = self % scheme ) elseif ( is_available ( scheme = self % scheme )) then integrator_schemes = [ trim ( adjustl ( self % scheme ))] endif else integrator_schemes = foodie_integrator_schemes () endif do s = 1 , size ( integrator_schemes , dim = 1 ) self % scheme = trim ( integrator_schemes ( s )) call self % test ( scheme = self % scheme ) enddo endsubroutine execute ! private methods subroutine initialize ( self ) !< Initialize test: set Command Line Interface, parse it and check its validity. class ( lcce_test ), intent ( inout ) :: self !< Test. call set_cli call parse_cli contains subroutine set_cli () !< Set Command Line Interface. associate ( cli => self % cli ) call cli % init ( progname = 'foodie_test_lcce' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on linear constant coefficients equation integration' , & examples = [ \"foodie_test_lcce --scheme euler_explicit --save_results  \" , & \"foodie_test_lcce --scheme all -r                         \" ]) call cli % add ( switch = '--scheme' , switch_ab = '-s' , help = 'integrator scheme used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--fast' , help = 'activate fast solvers' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--iterations' , help = 'iterations number for implicit schemes' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--stages' , help = 'stages number' , required = . false ., def = '4' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'time step' , required = . false ., def = '0.01' , act = 'store' ) call cli % add ( switch = '--a' , switch_ab = '-a' , help = '\"a\" coefficient' , required = . false ., def = '-1.0' , act = 'store' ) call cli % add ( switch = '--b' , switch_ab = '-b' , help = '\"b\" coefficient' , required = . false ., def = '0.0' , act = 'store' ) call cli % add ( switch = '--U0' , switch_ab = '-U0' , help = 'initial state' , required = . false ., def = '1.0' , act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'final integration time' , required = . false ., def = '1.0' , act = 'store' ) call cli % add ( switch = '--save_results' , switch_ab = '-r' , help = 'save result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'output files basename' , required = . false ., act = 'store' , def = 'foodie_test_lcce' ) call cli % add ( switch = '--exact_solution' , help = 'save exact solutiion' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--errors_analysis' , help = 'peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) endassociate endsubroutine set_cli subroutine parse_cli () !< Parse Command Line Interface and check its validity. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: i !< Counter. call self % cli % parse ( error = self % error ) call self % cli % get ( switch = '-s' , val = self % scheme , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--fast' , val = self % is_fast , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--iterations' , val = self % implicit_iterations , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--stages' , val = self % stages , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get_varying ( switch = '-Dt' , val = self % Dt , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-a' , val = self % a , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-b' , val = self % b , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-U0' , val = self % U0 , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-tf' , val = self % final_time , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-r' , val = self % results , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--output' , val = self % output , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--exact_solution' , val = self % exact_solution , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--errors_analysis' , val = self % errors_analysis , error = self % error ) ; if ( self % error /= 0 ) stop if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if (. not . is_available ( scheme = self % scheme )) then integrator_class_names = foodie_integrator_class_names () integrator_schemes = foodie_integrator_schemes () print '(A)' , 'Error: the scheme \"' // trim ( adjustl ( self % scheme )) // '\" is unknown!' print '(A)' , 'Supported classes of schemes are:' do i = 1 , size ( integrator_class_names , dim = 1 ) print '(A)' , '  ' // trim ( integrator_class_names ( i )) enddo print '(A)' , 'Supported schemes are:' do i = 1 , size ( integrator_schemes , dim = 1 ) print '(A)' , '  ' // trim ( integrator_schemes ( i )) enddo stop endif endif if (. not . is_dt_valid ()) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str ( self % final_time , . true .) print \"(A)\" , 'Time step: ' // str ( self % Dt , . true .) stop endif if ( self % errors_analysis ) then if (. not .( size ( self % Dt , dim = 1 ) > 1 )) self % errors_analysis = . false . endif endsubroutine parse_cli function is_dt_valid () !< Verify if the selected time step Dt is valid. logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) if (. not . is_dt_valid ) exit enddo endfunction is_dt_valid endsubroutine initialize subroutine test ( self , scheme ) !< Perform the test. class ( lcce_test ), intent ( in ) :: self !< Test. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. real ( R_P ), allocatable :: error (:) !< Error (norm L2) with respect the exact solution. real ( R_P ), allocatable :: order (:) !< Observed order based on subsequent refined solutions. integer ( I_P ) :: last_step !< Last time step computed. integer ( I_P ) :: t !< Counter. print \"(A)\" , trim ( adjustl ( scheme )) allocate ( error ( 1 : size ( self % Dt ))) error = 0.0_R_P if ( self % errors_analysis ) then allocate ( order ( 1 : size ( error , dim = 1 ) - 1 )) order = 0.0_R_P endif do t = 1 , size ( self % Dt , dim = 1 ) call integrate ( scheme = scheme , & a = self % a , & b = self % b , & U0 = self % U0 , & final_time = self % final_time , & Dt = self % Dt ( t ), & iterations = self % implicit_iterations , & stages = self % stages , & is_fast = self % is_fast , & solution = solution , & error = error ( t ), & last_step = last_step ) if ( allocated ( solution )) then print \"(A,G0,A,G0,A,G0)\" , \"  steps: \" , last_step , \" Dt: \" , self % Dt ( t ), \", error: \" , error ( t ) if ( self % errors_analysis . and . t > 1 ) then order ( t - 1 ) = observed_order ( error = error ( t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print \"(A,F7.3)\" , \"    observed order: \" , order ( t - 1 ) endif call save_results ( results = self % results , & output = self % output , & scheme = trim ( adjustl ( scheme )), & a = self % a , & b = self % b , & U0 = self % U0 , & save_exact_solution = self % exact_solution , & solution = solution ( 0 : 1 , 0 : last_step )) endif enddo endsubroutine test ! non type bound procedures subroutine check_scheme_has_fast_mode ( scheme , integrator ) !< Check if a scheme support fast mode integrate. character ( * ), intent ( in ) :: scheme !< Scheme name. class ( integrator_object ), intent ( in ) :: integrator !< Integrator instance. if (. not . integrator % has_fast_mode ()) then write ( stderr , '(A)' ) 'error: ' // trim ( adjustl ( scheme )) // ' has not fast integrate mode!' stop endif endsubroutine check_scheme_has_fast_mode subroutine integrate ( scheme , a , b , U0 , final_time , Dt , iterations , stages , is_fast , solution , error , last_step ) !< Integrate domain by means of the given scheme. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), intent ( in ) :: a !< *a* coefficient. real ( R_P ), intent ( in ) :: b !< *b* coefficient. real ( R_P ), intent ( in ) :: U0 !< Initial state. real ( R_P ), intent ( in ) :: final_time !< Final integration time. real ( R_P ), intent ( in ) :: Dt !< Time step. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. integer ( I_P ), intent ( in ) :: stages !< Number of stages. logical , intent ( in ) :: is_fast !< Activate fast mode integration. real ( R_P ), allocatable , intent ( out ) :: solution (:,:) !< Solution at each time step, X-Y. real ( R_P ), intent ( out ) :: error !< Error (norm L2) with respect the exact solution. integer ( I_P ), intent ( out ) :: last_step !< Last time step computed. class ( integrator_object ), allocatable :: integrator !< The integrator. type ( integrand_lcce ) :: domain !< Linear constant coefficients equation field. type ( integrand_lcce ), allocatable :: previous (:) !< Previous time steps solutions. type ( integrand_lcce ), allocatable :: stage (:) !< Runge-Kutta stages. type ( integrand_lcce ) :: buffer !< Buffer field. type ( integrand_lcce ) :: filter !< Filter displacement. integer :: step !< Time steps counter. integer :: step_offset !< Time steps counter offset for slicing previous data array. real ( R_P ), allocatable :: Dts (:) !< Time steps for variable stepsize. real ( R_P ) :: Dt_a !< Adaptive time step. call domain % initialize ( a = a , b = b , U0 = U0 ) if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : domain % integrand_dimension (), 0 : int ( final_time / Dt ))) solution = 0.0_R_P solution ( 1 :, 0 ) = domain % output () call foodie_integrator_factory ( scheme = scheme , integrator = integrator , stages = stages , tolerance = 1 e2_R_P ) if ( is_fast ) call check_scheme_has_fast_mode ( scheme = trim ( adjustl ( scheme )), integrator = integrator ) if ( integrator % is_multistep ()) allocate ( previous ( 1 : integrator % steps_number ())) if ( integrator % is_multistage ()) allocate ( stage ( 1 : integrator % stages_number ())) select type ( integrator ) type is ( integrator_adams_bashforth ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_bashforth_moulton ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_moulton ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : integrator % steps_number () + 1 )) if ( integrator % steps_number () == 0 ) then step_offset = 1 ! for 0 step-(a convention)-solver offset is 1 else step_offset = integrator % steps_number () ! for >0 step-solver offset is steps endif step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then if ( iterations > 1 ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif else if ( iterations > 1 ) then call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_back_df ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_euler_explicit ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_leapfrog ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( index ( scheme , 'raw' ) > 0 ) then if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step ), filter = filter ) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step ), filter = filter ) endif else if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp_vss ) if ( allocated ( Dts )) deallocate ( Dts ) ; allocate ( Dts ( 1 : integrator % steps_number ())) ; Dts = Dt step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_ms_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & stage = stage , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & stage = stage , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_emd ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 Dt_a = Dt if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt_a , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt_a , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ls ) if ( allocated ( stage )) deallocate ( stage ) ; allocate ( stage ( 1 : integrator % registers_number ())) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_lssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step endselect error = 0._R_P do step = 0 , last_step domain = solution ( 1 :, step ) error = error + ( domain % output () - domain % exact_solution ( t = solution ( 0 , step ))) ** 2 enddo error = sqrt ( error ) endsubroutine integrate subroutine save_results ( results , output , scheme , a , b , U0 , save_exact_solution , solution ) !< Save results (and plots). logical , intent ( in ) :: results !< Flag for activating results saving. character ( * ), intent ( in ) :: output !< Output files basename coming from CLI. character ( * ), intent ( in ) :: scheme !< Selected scheme: must be defined into *solvers*. real ( R_P ), intent ( in ) :: a !< *a* coefficient. real ( R_P ), intent ( in ) :: b !< *b* coefficient. real ( R_P ), intent ( in ) :: U0 !< Initial state. logical , intent ( in ) :: save_exact_solution !< Flag for saving exact solution. real ( R_P ), intent ( in ) :: solution ( 0 :, 0 :) !< Solution at each time step. character ( len = :), allocatable :: title !< Output files title. character ( len = :), allocatable :: basename !< Output files basename. type ( integrand_lcce ) :: lcce !< Linear constant coefficients field. integer ( I_P ) :: rawfile !< Raw file unit for saving results. integer ( I_P ) :: s !< Counter. basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-' // trim ( adjustl ( scheme )) title = 'linear constant coefficients equation integration, solver=' // trim ( adjustl ( scheme )) if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"u\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(2(' // FR_P // ',1X))' ) solution (:, s ) enddo close ( rawfile ) endif if ( save_exact_solution ) then call lcce % initialize ( a = a , b = b , U0 = U0 ) basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-exact_solution' title = 'linear constant coefficients equation integration, solver=exact solution' open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"u\"' write ( rawfile , '(A)' ) 'ZONE T=\"exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(2(' // FR_P // ',1X))' ) solution ( 0 , s ), lcce % exact_solution ( t = solution ( 0 , s )) enddo close ( rawfile ) endif endsubroutine save_results pure function observed_order ( error , Dt ) !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. real ( R_P ), intent ( IN ) :: error ( 1 : 2 ) !< Computed errors. real ( R_P ), intent ( IN ) :: Dt ( 1 : 2 ) !< Time steps used. real ( R_P ) :: observed_order !< Estimation of the order of accuracy. observed_order = log ( error ( 1 ) / error ( 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) endfunction observed_order endmodule foodie_test_lcce_test program foodie_test_lcce !< Test FOODIE with the integration of linear constant coefficients equation. use foodie_test_lcce_test , only : lcce_test implicit none type ( lcce_test ) :: test !< Linear constant coefficients equation test. call test % execute endprogram foodie_test_lcce","tags":"","loc":"sourcefile/foodie_test_lcce.f90.html","title":"foodie_test_lcce.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Oscillation equations. This File Depends On sourcefile~~foodie_test_oscillation.f90~~EfferentGraph sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_test_oscillationf90EfferentGraph = svgPanZoom('#sourcefilefoodie_test_oscillationf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foodie_test_oscillation Modules foodie_test_oscillation_test Source Code foodie_test_oscillation.f90 Source Code !< Test FOODIE with the integration of Oscillation equations. module foodie_test_oscillation_test !< Oscillation test handler definition. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use flap , only : command_line_interface use foodie , only : foodie_integrator_class_names , & foodie_integrator_factory , & foodie_integrator_schemes , & integrator_adams_bashforth , & integrator_adams_bashforth_moulton , & integrator_adams_moulton , & integrator_back_df , & integrator_euler_explicit , & integrator_leapfrog , & integrator_lmm_ssp , & integrator_lmm_ssp_vss , & integrator_ms_runge_kutta_ssp , & integrator_object , & integrator_runge_kutta_emd , & integrator_runge_kutta_ls , & integrator_runge_kutta_lssp , & integrator_runge_kutta_ssp , & is_available , is_class_available use foodie_test_integrand_oscillation , only : integrand_oscillation use penf , only : I_P , R_P , FR_P , str , strz implicit none private public :: oscillation_test type :: oscillation_test !< Class to handle oscillation test(s). !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error = 0 !< Error handler. character ( 99 ) :: scheme = '' !< Scheme used. logical :: is_fast = . false . !< Flag for activating fast schemes. integer ( I_P ) :: implicit_iterations = 0 !< Number of iterations (implicit solvers). integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. real ( R_P ) :: frequency = 0.0_R_P !< Oscillation frequency. real ( R_P ) :: U0 ( 1 : 2 ) = [ 0._R_P , 0._R_P ] !< Initial conditions. real ( R_P ) :: final_time = 0.0_R_P !< Final integration time. logical :: results = . false . !< Flag for activating results saving. character ( 99 ) :: output = '' !< Output files basename. logical :: exact_solution = . false . !< Flag for activating exact solution saving. logical :: errors_analysis = . false . !< Flag for activating errors analysis. contains ! public methods procedure , pass ( self ) :: execute !< Execute selected test(s). ! private methods procedure , pass ( self ), private :: initialize !< Initialize test: set Command Line Interface, parse it and check its validity. procedure , pass ( self ), private :: test !< Perform the test. endtype oscillation_test contains ! public methods subroutine execute ( self ) !< Execute test(s). class ( oscillation_test ), intent ( inout ) :: self !< Test. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: s !< Counter. call self % initialize if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if ( is_class_available ( scheme = self % scheme )) then integrator_schemes = foodie_integrator_schemes ( class_name = self % scheme ) elseif ( is_available ( scheme = self % scheme )) then integrator_schemes = [ trim ( adjustl ( self % scheme ))] endif else integrator_schemes = foodie_integrator_schemes () endif do s = 1 , size ( integrator_schemes , dim = 1 ) self % scheme = trim ( integrator_schemes ( s )) call self % test ( scheme = self % scheme ) enddo endsubroutine execute ! private methods subroutine initialize ( self ) !< Initialize test: set Command Line Interface, parse it and check its validity. class ( oscillation_test ), intent ( inout ) :: self !< Test. call set_cli call parse_cli contains subroutine set_cli () !< Set Command Line Interface. associate ( cli => self % cli ) call cli % init ( progname = 'foodie_test_oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Oscillation equations integration' , & examples = [ \"foodie_test_oscillation --scheme euler_explicit --save_results  \" , & \"foodie_test_oscillation --scheme all -r                         \" ]) call cli % add ( switch = '--scheme' , switch_ab = '-s' , help = 'integrator scheme used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--fast' , help = 'activate fast solvers' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--iterations' , help = 'iterations number for implicit schemes' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--stages' , help = 'stages number' , required = . false ., def = '2' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'time step' , required = . false ., def = '1e2' , act = 'store' ) call cli % add ( switch = '--frequency' , switch_ab = '-f' , help = 'frequency' , required = . false ., def = '1e-4' , act = 'store' ) call cli % add ( switch = '--U0' , switch_ab = '-U0' , nargs = '2' , help = 'initial state' , required = . false ., def = '0.0 1.0' , act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'final integration time' , required = . false ., def = '1e5' , act = 'store' ) call cli % add ( switch = '--save_results' , switch_ab = '-r' , help = 'save result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'output file basename' , required = . false ., act = 'store' , def = 'foodie_test_oscillation' ) call cli % add ( switch = '--exact_solution' , help = 'save exact solutiion' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--errors_analysis' , help = 'peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) endassociate endsubroutine set_cli subroutine parse_cli () !< Parse Command Line Interface and check its validity. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: i !< Counter. call self % cli % parse ( error = self % error ) call self % cli % get ( switch = '-s' , val = self % scheme , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--fast' , val = self % is_fast , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--iterations' , val = self % implicit_iterations , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--stages' , val = self % stages , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get_varying ( switch = '-Dt' , val = self % Dt , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-f' , val = self % frequency , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-U0' , val = self % U0 , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-tf' , val = self % final_time , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-r' , val = self % results , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--output' , val = self % output , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--exact_solution' , val = self % exact_solution , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--errors_analysis' , val = self % errors_analysis , error = self % error ) ; if ( self % error /= 0 ) stop if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if (. not . is_available ( scheme = self % scheme )) then integrator_class_names = foodie_integrator_class_names () integrator_schemes = foodie_integrator_schemes () print '(A)' , 'Error: the scheme \"' // trim ( adjustl ( self % scheme )) // '\" is unknown!' print '(A)' , 'Supported classes of schemes are:' do i = 1 , size ( integrator_class_names , dim = 1 ) print '(A)' , '  ' // trim ( integrator_class_names ( i )) enddo print '(A)' , 'Supported schemes are:' do i = 1 , size ( integrator_schemes , dim = 1 ) print '(A)' , '  ' // trim ( integrator_schemes ( i )) enddo stop endif endif if (. not . is_dt_valid ()) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str ( self % final_time , . true .) print \"(A)\" , 'Time step: ' // str ( self % Dt , . true .) stop endif if ( self % errors_analysis ) then if (. not .( size ( self % Dt , dim = 1 ) > 1 )) self % errors_analysis = . false . endif endsubroutine parse_cli function is_dt_valid () !< Verify if the selected time step Dt is valid. logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) if (. not . is_dt_valid ) exit enddo endfunction is_dt_valid endsubroutine initialize subroutine test ( self , scheme ) !< Perform the test. class ( oscillation_test ), intent ( in ) :: self !< Test. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. real ( R_P ), allocatable :: error (:,:) !< Error (norm L2) with respect the exact solution. real ( R_P ), allocatable :: order (:,:) !< Observed order based on subsequent refined solutions. type ( integrand_oscillation ) :: oscillator !< Molding integrand oscillator. integer ( I_P ) :: last_step !< Last time step computed. integer ( I_P ) :: t !< Counter. print \"(A)\" , trim ( adjustl ( scheme )) allocate ( error ( 1 : oscillator % integrand_dimension (), 1 : size ( self % Dt ))) error = 0.0_R_P if ( self % errors_analysis ) then allocate ( order ( 1 : oscillator % integrand_dimension (), 1 : size ( error , dim = 2 ) - 1 )) order = 0.0_R_P endif do t = 1 , size ( self % Dt , dim = 1 ) call integrate ( scheme = scheme , & frequency = self % frequency , & U0 = self % U0 , & final_time = self % final_time , & Dt = self % Dt ( t ), & iterations = self % implicit_iterations , & stages = self % stages , & is_fast = self % is_fast , & solution = solution , & error = error (:, t ), & last_step = last_step ) if ( allocated ( solution )) then print \"(A,I10,4(A,G10.3))\" , \"    steps: \" , last_step , & \" Dt: \" , self % Dt ( t ), \", f*Dt: \" , self % frequency * self % Dt ( t ), & \", E(x): \" , error ( 1 , t ), \", E(y): \" , error ( 2 , t ) if ( self % errors_analysis . and . t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print \"(A,F10.2,A,F10.2)\" , \"      Observed order, O(x): \" , order ( 1 , t - 1 ), \", O(y): \" , order ( 2 , t - 1 ) endif call save_results ( results = self % results , & output = self % output , & scheme = trim ( adjustl ( scheme )), & frequency = self % frequency , & U0 = self % U0 , & save_exact_solution = self % exact_solution , & solution = solution (:, 0 : last_step )) endif enddo endsubroutine test ! non type bound procedures subroutine check_scheme_has_fast_mode ( scheme , integrator ) !< Check if a scheme support fast mode integrate. character ( * ), intent ( in ) :: scheme !< Scheme name. class ( integrator_object ), intent ( in ) :: integrator !< Integrator instance. if (. not . integrator % has_fast_mode ()) then write ( stderr , '(A)' ) 'error: ' // trim ( adjustl ( scheme )) // ' has not fast integrate mode!' stop endif endsubroutine check_scheme_has_fast_mode subroutine integrate ( scheme , frequency , U0 , final_time , Dt , iterations , stages , is_fast , solution , error , last_step ) !< Integrate domain by means of the given scheme. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( in ) :: U0 ( 1 :) !< Initial state. real ( R_P ), intent ( in ) :: final_time !< Final integration time. real ( R_P ), intent ( in ) :: Dt !< Time step. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. integer ( I_P ), intent ( in ) :: stages !< Number of stages. logical , intent ( in ) :: is_fast !< Activate fast mode integration. real ( R_P ), allocatable , intent ( out ) :: solution (:,:) !< Solution at each time step, X-Y. real ( R_P ), intent ( out ) :: error ( 1 :) !< Error (norm L2) with respect the exact solution. integer ( I_P ), intent ( out ) :: last_step !< Last time step computed. class ( integrator_object ), allocatable :: integrator !< The integrator. type ( integrand_oscillation ) :: domain !< Oscillation field. type ( integrand_oscillation ), allocatable :: previous (:) !< Previous time steps solutions. type ( integrand_oscillation ), allocatable :: stage (:) !< Runge-Kutta stages. type ( integrand_oscillation ) :: buffer !< Buffer oscillation field. type ( integrand_oscillation ) :: filter !< Filter displacement. integer :: step !< Time steps counter. integer :: step_offset !< Time steps counter offset for slicing previous data array. real ( R_P ), allocatable :: Dts (:) !< Time steps for variable stepsize. real ( R_P ) :: Dt_a !< Adaptive time step. call domain % initialize ( U0 = U0 , frequency = frequency ) if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : domain % integrand_dimension (), 0 : int ( final_time / Dt ))) solution = 0.0_R_P solution ( 1 :, 0 ) = domain % output () call foodie_integrator_factory ( scheme = scheme , integrator = integrator , stages = stages , tolerance = 1 e2_R_P ) if ( is_fast ) call check_scheme_has_fast_mode ( scheme = trim ( adjustl ( scheme )), integrator = integrator ) if ( integrator % is_multistep ()) allocate ( previous ( 1 : integrator % steps_number ())) if ( integrator % is_multistage ()) allocate ( stage ( 1 : integrator % stages_number ())) select type ( integrator ) type is ( integrator_adams_bashforth ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_bashforth_moulton ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_moulton ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : integrator % steps_number () + 1 )) if ( integrator % steps_number () == 0 ) then step_offset = 1 ! for 0 step-(a convention)-solver offset is 1 else step_offset = integrator % steps_number () ! for >0 step-solver offset is steps endif step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then if ( iterations > 1 ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif else if ( iterations > 1 ) then call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_back_df ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_euler_explicit ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_leapfrog ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( index ( scheme , 'raw' ) > 0 ) then if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step ), filter = filter ) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step ), filter = filter ) endif else if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp_vss ) if ( allocated ( Dts )) deallocate ( Dts ) ; allocate ( Dts ( 1 : integrator % steps_number ())) ; Dts = Dt step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_ms_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & stage = stage , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & stage = stage , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_emd ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 Dt_a = Dt if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt_a , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt_a , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ls ) if ( allocated ( stage )) deallocate ( stage ) ; allocate ( stage ( 1 : integrator % registers_number ())) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_lssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step endselect error = 0._R_P do step = 0 , last_step domain = solution ( 1 :, step ) error = error + ( domain % output () - domain % exact_solution ( t = solution ( 0 , step ))) ** 2 enddo error = sqrt ( error ) endsubroutine integrate subroutine save_results ( results , output , scheme , frequency , U0 , save_exact_solution , solution ) !< Save results (and plots). logical , intent ( in ) :: results !< Flag for activating results saving. character ( * ), intent ( in ) :: output !< Output files basename coming from CLI. character ( * ), intent ( in ) :: scheme !< Selected scheme: must be defined into *solvers*. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( in ) :: U0 ( 1 :) !< Initial state. logical , intent ( in ) :: save_exact_solution !< Flag for saving exact solution. real ( R_P ), intent ( in ) :: solution ( 0 :, 0 :) !< Solution at each time step. character ( len = :), allocatable :: title !< Output files title. character ( len = :), allocatable :: basename !< Output files basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( integrand_oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: s !< Counter. basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-' // trim ( adjustl ( scheme )) title = 'oscillation equations integration, solver=' // trim ( adjustl ( scheme )) if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution (:, s ), amplitude_phase ( solution ( 1 : 2 , s )) enddo close ( rawfile ) endif if ( save_exact_solution ) then call oscillator % initialize ( U0 = U0 , frequency = frequency ) basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-exact_solution' title = 'linear constant coefficients equation integration, solver=exact solution' open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"u\"' write ( rawfile , '(A)' ) 'ZONE T=\"exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution ( 0 , s ), oscillator % exact_solution ( t = solution ( 0 , s )), & amplitude_phase ( oscillator % exact_solution ( t = solution ( 0 , s ))) enddo close ( rawfile ) endif contains function amplitude_phase ( sol ) result ( ap ) !< Compute amplitude and phase of the solution provided in X-Y domain. real ( R_P ), intent ( in ) :: sol ( 1 :) !< Solution in X-Y domain. real ( R_P ) :: ap ( 1 : 2 ) !< Amplitude and phase solution. ap ( 1 ) = sqrt ( sol ( 1 ) ** 2 + sol ( 2 ) ** 2 ) ap ( 2 ) = atan ( - sol ( 1 ) / sol ( 2 )) endfunction amplitude_phase endsubroutine save_results pure function observed_order ( error , Dt ) !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. real ( R_P ), intent ( in ) :: error ( 1 :, 1 :) !< Computed errors. real ( R_P ), intent ( in ) :: Dt ( 1 :) !< Time steps used. real ( R_P ) :: observed_order ( 1 : size ( error , dim = 1 )) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. do v = 1 , size ( error , dim = 1 ) observed_order ( v ) = log ( error ( v , 1 ) / error ( v , 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) enddo endfunction observed_order endmodule foodie_test_oscillation_test program foodie_test_oscillation !< Test FOODIE with the integration of Oscillation equations. use foodie_test_oscillation_test , only : oscillation_test implicit none type ( oscillation_test ) :: test !< Oscillation test. call test % execute endprogram foodie_test_oscillation","tags":"","loc":"sourcefile/foodie_test_oscillation.f90.html","title":"foodie_test_oscillation.f90 – FOODIE"},{"text":"Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. This File Depends On sourcefile~~euler-1d-caf_no_foodie.f90~~EfferentGraph sourcefile~euler-1d-caf_no_foodie.f90 euler-1D-caf_no_foodie.f90 sourcefile~type_euler-1d-caf_no_foodie.f90 type_euler-1D-caf_no_foodie.f90 sourcefile~type_euler-1d-caf_no_foodie.f90->sourcefile~euler-1d-caf_no_foodie.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs integrate_euler_1D_caf Source Code euler-1D-caf_no_foodie.f90 Source Code !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use IR_Precision , only : R_P , I_P , FR_P , str , strz use pyplot_module , only : pyplot use type_euler_1D_caf_no_foodie , only : euler_1D_caf_nf , tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf_nf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, CAF enabled' , & examples = [ \"euler-1D-caf-no-foodie --results  \" , & \"euler-1D-caf-no-foodie -r -t -v -p\" , & \"euler-1D-caf-no-foodie            \" , & \"euler-1D-caf-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"sourcefile/euler-1d-caf_no_foodie.f90.html","title":"euler-1D-caf_no_foodie.f90 – FOODIE"},{"text":"Define Euler 1D (CAF enabled) field without extending FOODIE integrand. Files Dependent On This One sourcefile~~type_euler-1d-caf_no_foodie.f90~~AfferentGraph sourcefile~type_euler-1d-caf_no_foodie.f90 type_euler-1D-caf_no_foodie.f90 sourcefile~euler-1d-caf_no_foodie.f90 euler-1D-caf_no_foodie.f90 sourcefile~type_euler-1d-caf_no_foodie.f90->sourcefile~euler-1d-caf_no_foodie.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules type_euler_1D_caf_no_foodie Source Code type_euler-1D-caf_no_foodie.f90 Source Code !< Define Euler 1D (CAF enabled) field without extending FOODIE integrand. module type_euler_1D_caf_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (CAF enabled) field without extending FOODIE integrand. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_caf_nf public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_1D_caf_nf !< Euler 1D (CAF enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_caf_nf type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. endtype tvd_runge_kutta_integrator #ifdef CAF real ( R_P ), allocatable :: remote_U (:,:)[:] !< CAF buffer for sharing remote conservative variables. #else real ( R_P ), allocatable :: remote_U (:,:) !< CAF buffer for sharing remote conservative variables. #endif real ( R_P ), allocatable :: U_L (:,:) !< Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real ( R_P ), allocatable :: U_R (:,:) !< Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. !----------------------------------------------------------------------------------------------------------------------------------- contains ! type bound procedures of tvd_runge_kutta_integrator ! public methods elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_caf_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_caf_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk ! type bound procedures of euler_1D_caf_nf ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_caf_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_caf_nf ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_caf_no_foodie","tags":"","loc":"sourcefile/type_euler-1d-caf_no_foodie.f90.html","title":"type_euler-1D-caf_no_foodie.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. This File Depends On sourcefile~~euler-1d-caf.f90~~EfferentGraph sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~euler-1d-caf.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefileeuler1dcaff90EfferentGraph = svgPanZoom('#sourcefileeuler1dcaff90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs integrate_euler_1D_caf Source Code euler-1D-caf.f90 Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str , strz use pyplot_module , only : pyplot use type_euler_1D_caf , only : euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, CAF enabled' , & examples = [ \"euler-1D-caf --results  \" , & \"euler-1D-caf -r -t -v -p\" , & \"euler-1D-caf            \" , & \"euler-1D-caf --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"sourcefile/euler-1d-caf.f90.html","title":"euler-1D-caf.f90 – FOODIE"},{"text":"Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. This File Depends On sourcefile~~type_euler-1d-caf.f90~~EfferentGraph sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-caf.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefiletype_euler1dcaff90EfferentGraph = svgPanZoom('#sourcefiletype_euler1dcaff90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~type_euler-1d-caf.f90~~AfferentGraph sourcefile~type_euler-1d-caf.f90 type_euler-1D-caf.f90 sourcefile~euler-1d-caf.f90 euler-1D-caf.f90 sourcefile~type_euler-1d-caf.f90->sourcefile~euler-1d-caf.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules type_euler_1D_caf Source Code type_euler-1D-caf.f90 Source Code !< Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. module type_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D_caf !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_caf #ifdef CAF real ( R_P ), allocatable :: remote_U (:,:)[:] !< CAF buffer for sharing remote conservative variables. #else real ( R_P ), allocatable :: remote_U (:,:) !< CAF buffer for sharing remote conservative variables. #endif real ( R_P ), allocatable :: U_L (:,:) !< Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real ( R_P ), allocatable :: U_R (:,:) !< Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_caf :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_caf ) dState_dt = self endselect select type ( dState_dt ) class is ( euler_1D_caf ) do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_caf ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = rhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_caf","tags":"","loc":"sourcefile/type_euler-1d-caf.f90.html","title":"type_euler-1D-caf.f90 – FOODIE"},{"text":"Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. This File Depends On sourcefile~~euler-1d-openmp_no_foodie.f90~~EfferentGraph sourcefile~euler-1d-openmp_no_foodie.f90 euler-1D-openmp_no_foodie.f90 sourcefile~type_euler-1d-openmp_no_foodie.f90 type_euler-1D-openmp_no_foodie.f90 sourcefile~type_euler-1d-openmp_no_foodie.f90->sourcefile~euler-1d-openmp_no_foodie.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs integrate_euler_1D_openmp_no_foodie Source Code euler-1D-openmp_no_foodie.f90 Source Code !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. program integrate_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use IR_Precision , only : R_P , I_P , FR_P , str #ifdef OPENMP use OMP_LIB #endif use pyplot_module , only : pyplot use type_euler_1D_openmp_no_foodie , only : euler_1D_omp_nf , tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_omp_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_omp_nf ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, OpenMP enabled' , & examples = [ \"euler-1D-openmp-no-foodie --results  \" , & \"euler-1D-openmp-no-foodie -r -t -v -p\" , & \"euler-1D-openmp-no-foodie            \" , & \"euler-1D-openmp-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp_no_foodie","tags":"","loc":"sourcefile/euler-1d-openmp_no_foodie.f90.html","title":"euler-1D-openmp_no_foodie.f90 – FOODIE"},{"text":"Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. Files Dependent On This One sourcefile~~type_euler-1d-openmp_no_foodie.f90~~AfferentGraph sourcefile~type_euler-1d-openmp_no_foodie.f90 type_euler-1D-openmp_no_foodie.f90 sourcefile~euler-1d-openmp_no_foodie.f90 euler-1D-openmp_no_foodie.f90 sourcefile~type_euler-1d-openmp_no_foodie.f90->sourcefile~euler-1d-openmp_no_foodie.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules type_euler_1D_openmp_no_foodie Source Code type_euler-1D-openmp_no_foodie.f90 Source Code !< Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. module type_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_omp_nf public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_1D_omp_nf !< Euler 1D (OpenMP enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_omp_nf type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! type bound procedures of tvd_runge_kutta_integrator ! public methods elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_omp_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_omp_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk ! type bound procedures of euler_1D_omp_nf ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! private methods function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_omp_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_omp_nf ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_omp_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_openmp_no_foodie","tags":"","loc":"sourcefile/type_euler-1d-openmp_no_foodie.f90.html","title":"type_euler-1D-openmp_no_foodie.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. This File Depends On sourcefile~~euler-1d-openmp.f90~~EfferentGraph sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~euler-1d-openmp.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefileeuler1dopenmpf90EfferentGraph = svgPanZoom('#sourcefileeuler1dopenmpf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs integrate_euler_1D_openmp Source Code euler-1D-openmp.f90 Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str #ifdef OPENMP use OMP_LIB #endif use pyplot_module , only : pyplot use type_euler_1D_openmp , only : euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D-openmp --results  \" , & \"euler-1D-openmp -r -t -v -p\" , & \"euler-1D-openmp            \" , & \"euler-1D-openmp --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads, verbose) omp_threads = omp_get_num_threads () if ( verbose ) print \"(A)\" , ' Thread ' // trim ( str (. true ., omp_get_thread_num ())) // ' of: ' // trim ( str (. true ., omp_threads )) // ' is alive!' !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"sourcefile/euler-1d-openmp.f90.html","title":"euler-1D-openmp.f90 – FOODIE"},{"text":"Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. This File Depends On sourcefile~~type_euler-1d-openmp.f90~~EfferentGraph sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d-openmp.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefiletype_euler1dopenmpf90EfferentGraph = svgPanZoom('#sourcefiletype_euler1dopenmpf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~type_euler-1d-openmp.f90~~AfferentGraph sourcefile~type_euler-1d-openmp.f90 type_euler-1D-openmp.f90 sourcefile~euler-1d-openmp.f90 euler-1D-openmp.f90 sourcefile~type_euler-1d-openmp.f90->sourcefile~euler-1d-openmp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules type_euler_1D_openmp Source Code type_euler-1D-openmp.f90 Source Code !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. module type_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D_openmp ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_openmp","tags":"","loc":"sourcefile/type_euler-1d-openmp.f90.html","title":"type_euler-1D-openmp.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Burgers equation. This File Depends On sourcefile~~burgers.f90~~EfferentGraph sourcefile~burgers.f90 burgers.f90 sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~burgers.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefileburgersf90EfferentGraph = svgPanZoom('#sourcefileburgersf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs integrate_burgers Source Code burgers.f90 Source Code !< Test FOODIE with the integration of Burgers equation. program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_adams_bashforth , & integrator_euler_explicit , & integrator_leapfrog , & integrator_runge_kutta_ls , & integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str use pyplot_module , only : pyplot use type_burgers , only : burgers !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results  \" , & \"burgers --solver ls-runge-kutta -r\" , & \"burgers --solver adams-bashforth  \" , & \"burgers --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"sourcefile/burgers.f90.html","title":"burgers.f90 – FOODIE"},{"text":"Define Burgers field that is a concrete extension of the abstract integrand type. This File Depends On sourcefile~~type_burgers.f90~~EfferentGraph sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~type_burgers.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefiletype_burgersf90EfferentGraph = svgPanZoom('#sourcefiletype_burgersf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~type_burgers.f90~~AfferentGraph sourcefile~type_burgers.f90 type_burgers.f90 sourcefile~burgers.f90 burgers.f90 sourcefile~type_burgers.f90->sourcefile~burgers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules type_burgers Source Code type_burgers.f90 Source Code !< Define Burgers field that is a concrete extension of the abstract integrand type. module type_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Define Burgers field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: burgers !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: local_error => burgers_local_error !< Local error. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dBurgers_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx () * self % nu dState_dt = dState_dt - self * self % x () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function burgers_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 burgers approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_local_error function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real ! private methods function dBurgers_dx ( self ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the first order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - self % U ( i - 1 )) / ( 2._R_P * self % h ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - self % U ( self % Ni )) / ( 2._R_P * self % h ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - self % U ( self % Ni - 1 )) / ( 2._R_P * self % h ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction function d2Burgers_dx2 ( self ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the second order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - 2._R_P * self % U ( i ) + self % U ( i - 1 )) / ( self % h ** 2 ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - 2._R_P * self % U ( 1 ) + self % U ( self % Ni )) / ( self % h ** 2 ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - 2._R_P * self % U ( self % Ni ) + self % U ( self % Ni - 1 )) / ( self % h ** 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction endmodule type_burgers","tags":"","loc":"sourcefile/type_burgers.f90.html","title":"type_burgers.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Euler 1D PDEs system. This File Depends On sourcefile~~euler-1d.f90~~EfferentGraph sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~euler-1d.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefileeuler1df90EfferentGraph = svgPanZoom('#sourcefileeuler1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs integrate_euler_1D Source Code euler-1D.f90 Source Code !< Test FOODIE with the integration of Euler 1D PDEs system. program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_adams_bashforth , & integrator_euler_explicit , & integrator_leapfrog , & integrator_runge_kutta_ls , & integrator_runge_kutta_tvd use penf , only : R_P , I_P , FR_P , str use pyplot_module , only : pyplot use type_euler_1D , only : euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: Ns !< Number of differnt initial gas species. integer ( I_P ) :: Nc !< Number of conservative variables, Nc=Ns+2. integer ( I_P ) :: Np !< Number of primitive variables, Np=Ns+4. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: CFL !< CFL value. real ( R_P ) :: t_final !< Final time. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ), allocatable :: cp0 (:) !< Specific heat at constant pressure [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat at constant volume [1:Ns]. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables [1:Np,1:Ni]. real ( R_P ), allocatable :: xcenter (:) !< Cell center x-abscissa values, [1:Ni]. real ( R_P ), allocatable :: xnode (:) !< Cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: av_xnode (:) !< Average-grid cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: final_state (:,:) !< Final state. real ( R_P ), allocatable :: av_state (:,:) !< Average-grid final state. character ( len = :), allocatable :: variables !< Variables names list. character ( len = :), allocatable :: output !< Output files basename. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. character ( 99 ) :: solver !< Solver used. character ( 99 ) :: problem !< Problem solved. character ( 99 ) :: output_cli !< Output files basename. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: av_Ni !< Average the solution over an average-grid. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results  \" , & \"euler-1D --solver ls-runge-kutta -r\" , & \"euler-1D --solver adams-bashforth  \" , & \"euler-1D --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver' , required = . true ., act = 'store' ) call cli % add ( switch = '--problem' , help = 'Problem solved' , required = . false ., def = 'sod' , act = 'store' , choices = 'sod,smooth' ) call cli % add ( switch = '--Ni' , help = 'Number finite volumes' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--av_Ni' , help = 'Number finite volumes over average the solution' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--solver' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--problem' , val = problem , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--av_Ni' , val = av_Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--results' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--plots' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str ( s ,. true .)) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str ( s ,. true .)) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str ( Ni ,. true .)) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str ( Ni ,. true .)) // ' cells\", I=' // trim ( str ( Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 1 ,. true .)) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str ( Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str ( Ni ,. true .)) // ' to av_Ni: ' // trim ( str ( av_Ni ,. true .)) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str ( Ni ,. true .)) // ' cells averaged over ' // trim ( str ( av_Ni ,. true .)) // & ' cells\", I=' // trim ( str ( av_Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 1 ,. true .)) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str ( av_Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str ( av_Ni ,. true .)) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str ( v ,. true .)) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str ( Ni ,. true .)) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str ( Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 2 ,. true .)) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str ( Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"sourcefile/euler-1d.f90.html","title":"euler-1D.f90 – FOODIE"},{"text":"Define Euler 1D field that is a concrete extension of the abstract integrand type. This File Depends On sourcefile~~type_euler-1d.f90~~EfferentGraph sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~type_euler-1d.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefiletype_euler1df90EfferentGraph = svgPanZoom('#sourcefiletype_euler1df90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~type_euler-1d.f90~~AfferentGraph sourcefile~type_euler-1d.f90 type_euler-1D.f90 sourcefile~euler-1d.f90 euler-1D.f90 sourcefile~type_euler-1d.f90->sourcefile~euler-1d.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules type_euler_1D Source Code type_euler-1D.f90 Source Code !< Define Euler 1D field that is a concrete extension of the abstract integrand type. module type_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use foodie , only : integrand use penf , only : R_P , I_P use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! ADT integrand deferred methods function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: j !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) error = 0._R_P do i = 1 , lhs % Ni do j = 1 , lhs % Nc error = error + ( lhs % U ( j , i ) - rhs % U ( j , i )) ** 2 / lhs % U ( j , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D","tags":"","loc":"sourcefile/type_euler-1d.f90.html","title":"type_euler-1D.f90 – FOODIE"},{"text":"Test FOODIE with the integration of Lorenz equations. This File Depends On sourcefile~~lorenz.f90~~EfferentGraph sourcefile~lorenz.f90 lorenz.f90 sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~lorenz.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilelorenzf90EfferentGraph = svgPanZoom('#sourcefilelorenzf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs integrate_lorenz Source Code lorenz.f90 Source Code !< Test FOODIE with the integration of Lorenz equations. program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_adams_bashforth , & integrator_euler_explicit , & integrator_leapfrog , & integrator_runge_kutta_ls , & integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str use pyplot_module , only : pyplot use type_lorenz , only : lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results  \" , & \"lorenz --solver ls-runge-kutta -r\" , & \"lorenz --solver adams-bashforth  \" , & \"lorenz --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"sourcefile/lorenz.f90.html","title":"lorenz.f90 – FOODIE"},{"text":"Define Lorenz field that is a concrete extension of the abstract integrand type. This File Depends On sourcefile~~type_lorenz.f90~~EfferentGraph sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~type_lorenz.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefiletype_lorenzf90EfferentGraph = svgPanZoom('#sourcefiletype_lorenzf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~type_lorenz.f90~~AfferentGraph sourcefile~type_lorenz.f90 type_lorenz.f90 sourcefile~lorenz.f90 lorenz.f90 sourcefile~type_lorenz.f90->sourcefile~lorenz.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules type_lorenz Source Code type_lorenz.f90 Source Code !< Define Lorenz field that is a concrete extension of the abstract integrand type. module type_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Define Lorenz field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => lorenz_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output ! ADT integrand deferred methods function dLorenz_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function lorenz_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 lorenz approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_local_error function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real endmodule type_lorenz","tags":"","loc":"sourcefile/type_lorenz.f90.html","title":"type_lorenz.f90 – FOODIE"},{"text":"Define integrand_ladvection , the 1D linear advection PDE test field that is a concrete extension of the\n abstract integrand type. This File Depends On sourcefile~~foodie_test_integrand_ladvection.f90~~EfferentGraph sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_test_integrand_ladvectionf90EfferentGraph = svgPanZoom('#sourcefilefoodie_test_integrand_ladvectionf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_test_integrand_ladvection.f90~~AfferentGraph sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_test_integrand_ladvection Source Code foodie_test_integrand_ladvection.f90 Source Code !< Define [[integrand_ladvection]], the 1D linear advection PDE test field that is a concrete extension of the !< abstract integrand type. module foodie_test_integrand_ladvection !< Define [[integrand_ladvection]], the 1D linear advection PDE test field that is a concrete extension of the !< abstract integrand type. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use flap , only : command_line_interface use foodie , only : integrand_object use foodie_test_integrand_tester_object , only : integrand_tester_object use penf , only : FR_P , I_P , R_P , str , strz use wenoof , only : interpolator_object , wenoof_create implicit none private public :: integrand_ladvection type , extends ( integrand_tester_object ) :: integrand_ladvection !< 1D linear advection field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D linear advection field !< The 1D linear advection equation is a conservation law that reads as !< !<\\begin{matrix} !<u_t = R(u)  \\Leftrightarrow u_t = F(u)_x \\\\ !<F(u) = a * u !< !< where `a` is scalar constant coefficient. The PDE must completed with the proper initial and boundary conditions. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). character ( 99 ) :: w_scheme = '' !< WENO Scheme used. integer ( I_P ) :: weno_order = 0 !< WENO reconstruction order. real ( R_P ) :: weno_eps = 0._R_P !< WENO epsilon to avoid division by zero, default value. real ( R_P ) :: CFL = 0._R_P !< CFL value. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Ghost cells number. real ( R_P ) :: length = 0._R_P !< Domain length. real ( R_P ) :: Dx = 0._R_P !< Space step. real ( R_P ) :: a = 0._R_P !< Advection coefficient. real ( R_P ), allocatable :: u (:) !< Integrand (state) variable. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. character ( 99 ) :: initial_state !< Initial state. contains ! auxiliary methods procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step by means of CFL condition. procedure , pass ( self ), public :: compute_dx !< Compute the space step by means of CFL condition. procedure , pass ( self ), public :: output !< Extract integrand state field. ! integrand_tester_object deferred methods procedure , pass ( self ), public :: description !< Return an informative description of the test. procedure , pass ( self ), public :: error !< Return error. procedure , pass ( self ), public :: exact_solution !< Return exact solution. procedure , pass ( self ), public :: export_tecplot !< Export integrand to Tecplot file. procedure , pass ( self ), public :: initialize !< Initialize integrand. procedure , pass ( self ), public :: parse_cli !< Initialize from command line interface. procedure , nopass , public :: set_cli !< Set command line interface. ! integrand_object deferred methods procedure , pass ( self ), public :: integrand_dimension !< Return integrand dimension. procedure , pass ( self ), public :: t => dU_dt !< Time derivative, residuals. ! operators procedure , pass ( lhs ), public :: local_error !<`||integrand_ladvection - integrand_ladvection||` operator. ! + procedure , pass ( lhs ), public :: integrand_add_integrand !< `+` operator. procedure , pass ( lhs ), public :: integrand_add_real !< `+ real` operator. procedure , pass ( rhs ), public :: real_add_integrand !< `real +` operator. ! * procedure , pass ( lhs ), public :: integrand_multiply_integrand !< `*` operator. procedure , pass ( lhs ), public :: integrand_multiply_real !< `* real` operator. procedure , pass ( rhs ), public :: real_multiply_integrand !< `real *` operator. procedure , pass ( lhs ), public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure , pass ( rhs ), public :: real_scalar_multiply_integrand !< `real_scalar *` operator. ! - procedure , pass ( lhs ), public :: integrand_sub_integrand !< `-` operator. procedure , pass ( lhs ), public :: integrand_sub_real !< `- real` operator. procedure , pass ( rhs ), public :: real_sub_integrand !< `real -` operator. ! = procedure , pass ( lhs ), public :: assign_integrand !< `=` operator. procedure , pass ( lhs ), public :: assign_real !< `= real` operator. ! override fast operators ! procedure, pass(self), public :: t_fast                              !< Time derivative, residuals, fast mode. ! procedure, pass(opr),  public :: integrand_add_integrand_fast        !< `+` fast operator. ! procedure, pass(opr),  public :: integrand_multiply_integrand_fast   !< `*` fast operator. ! procedure, pass(opr),  public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. ! procedure, pass(opr),  public :: integrand_subtract_integrand_fast   !< `-` fast operator. ! private methods procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces !< Reconstruct interface states. procedure , pass ( self ), private :: set_sin_wave_initial_state !< Set initial state as a sin wave. procedure , pass ( self ), private :: set_square_wave_initial_state !< Set initial state as a square wave. endtype integrand_ladvection contains ! auxiliary methods subroutine destroy ( self ) !< Destroy field. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. type ( integrand_ladvection ) :: fresh !< Fresh field to reset self. self = fresh endsubroutine destroy pure function compute_dt ( self , final_time , t ) result ( Dt ) !< Compute the current time step by means of CFL condition. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ) :: final_time !< Maximum integration time. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ) :: Dt !< Time step. associate ( a => self % a , Dx => self % Dx , CFL => self % CFL ) Dt = Dx * CFL / abs ( a ) if ( present ( t )) then if (( t + Dt ) > final_time ) Dt = final_time - t endif endassociate endfunction compute_dt pure function compute_dx ( self , Dt ) result ( Dx ) !< Compute the space step step by means of CFL condition. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ) :: Dx !< Space step. associate ( a => self % a , CFL => self % CFL ) Dx = Dt / CFL * abs ( a ) endassociate endfunction compute_dx pure function output ( self ) result ( state ) !< Output the advection field state. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), allocatable :: state (:) !< Advection state state = self % u ( 1 : self % Ni ) endfunction output ! integrand_tester_object deferred methods pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrand_ladvection ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix // 'linear_advection-' // trim ( self % initial_state ) // '-Ni_' // trim ( strz ( self % Ni , 10 )) endfunction description pure function error ( self , t , t0 , U0 ) !< Return error. class ( integrand_ladvection ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: error (:) !< Error. integer ( I_P ) :: i !< Counter. allocate ( error ( 1 : 1 )) error = 0._R_P if ( present ( U0 )) then select type ( U0 ) type is ( integrand_ladvection ) do i = 1 , self % Ni error = error + ( U0 % u ( i ) - self % u ( i )) ** 2 enddo endselect error = self % Dx * sqrt ( error ) endif endfunction error pure function exact_solution ( self , t , t0 , U0 ) result ( exact ) !< Return exact solution. class ( integrand_ladvection ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: exact (:) !< Exact solution. integer ( I_P ) :: offset !< Cells offset. integer ( I_P ) :: i !< Counter. allocate ( exact ( 1 : self % Ni )) if ( present ( U0 )) then select type ( U0 ) type is ( integrand_ladvection ) offset = nint ( mod ( self % a * t , self % length ) / self % Dx ) do i = 1 , self % Ni - offset exact ( i + offset ) = U0 % u ( i ) enddo do i = self % Ni - offset + 1 , self % Ni exact ( i - self % Ni + offset ) = U0 % u ( i ) enddo endselect else exact = self % u ( 1 : self % Ni ) * 0._R_P endif endfunction exact_solution subroutine export_tecplot ( self , file_name , t , scheme , close_file , with_exact_solution , U0 ) !< Export integrand to Tecplot file. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. character ( * ), intent ( in ), optional :: file_name !< File name. real ( R_P ), intent ( in ), optional :: t !< Time. character ( * ), intent ( in ), optional :: scheme !< Scheme used to integrate integrand. logical , intent ( in ), optional :: close_file !< Flag for closing file. logical , intent ( in ), optional :: with_exact_solution !< Flag for export also exact solution. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. logical :: with_exact_solution_ !< Flag for export also exact solution, local variable. logical , save :: is_open = . false . !< Flag for checking if file is open. integer ( I_P ), save :: file_unit !< File unit. real ( R_P ), allocatable :: exact_solution (:) !< Exact solution. integer ( I_P ) :: i !< Counter. if ( present ( close_file )) then if ( close_file . and . is_open ) then close ( unit = file_unit ) is_open = . false . endif else with_exact_solution_ = . false . ; if ( present ( with_exact_solution )) with_exact_solution_ = with_exact_solution if ( present ( file_name )) then if ( is_open ) close ( unit = file_unit ) open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) is_open = . true . write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"x\" \"u\"' endif if ( present ( t ) . and . present ( scheme ) . and . is_open ) then write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // str ( t ) // ' ' // trim ( adjustl ( scheme )) // '\"' do i = 1 , self % Ni write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) self % Dx * i - 0.5_R_P * self % Dx , self % u ( i ) enddo if ( with_exact_solution_ ) then exact_solution = self % exact_solution ( t = t , U0 = U0 ) write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // str ( t ) // ' exact solution\"' do i = 1 , self % Ni write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) self % Dx * i - 0.5_R_P * self % Dx , exact_solution ( i ) enddo endif endif endif endsubroutine export_tecplot subroutine initialize ( self , Dt ) !< Initialize integrand. class ( integrand_ladvection ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. self % Dx = self % compute_dx ( Dt = Dt ) self % Ni = nint ( self % length / self % Dx ) select case ( trim ( adjustl ( self % initial_state ))) case ( 'sin_wave' ) call self % set_sin_wave_initial_state case ( 'square_wave' ) call self % set_square_wave_initial_state endselect endsubroutine initialize subroutine parse_cli ( self , cli ) !< Initialize from command line interface. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call self % destroy call cli % get ( group = 'linear_advection' , switch = '--cfl' , val = self % CFL , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--w-scheme' , val = self % w_scheme , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--weno-order' , val = self % weno_order , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--weno-eps' , val = self % weno_eps , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '-a' , val = self % a , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--length' , val = self % length , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--Ni' , val = self % Ni , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '-is' , val = self % initial_state , error = cli % error ) ; if ( cli % error /= 0 ) stop self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = self % length / self % Ni if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = trim ( adjustl ( self % w_scheme )), & S = self % Ng , & interpolator = self % interpolator , & eps = self % weno_eps ) endsubroutine parse_cli subroutine set_cli ( cli ) !< Set command line interface. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % add_group ( description = 'linear advection test settings' , group = 'linear_advection' ) call cli % add ( group = 'linear_advection' , switch = '--w-scheme' , help = 'WENO scheme' , required = . false ., act = 'store' , & def = 'reconstructor-JS' , choices = 'reconstructor-JS,reconstructor-M-JS,reconstructor-M-Z,reconstructor-Z' ) call cli % add ( group = 'linear_advection' , switch = '--weno-order' , help = 'WENO order' , required = . false ., act = 'store' , def = '1' ) call cli % add ( group = 'linear_advection' , switch = '--weno-eps' , help = 'WENO epsilon parameter' , required = . false ., act = 'store' , & def = '0.000001' ) call cli % add ( group = 'linear_advection' , switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.8' ) call cli % add ( group = 'linear_advection' , switch = '-a' , help = 'advection coefficient' , required = . false ., act = 'store' , def = '1.0' ) call cli % add ( group = 'linear_advection' , switch = '--length' , help = 'domain lenth' , required = . false ., act = 'store' , def = '1.0' ) call cli % add ( group = 'linear_advection' , switch = '--Ni' , help = 'number finite volumes used' , required = . false ., act = 'store' , & def = '100' ) call cli % add ( group = 'linear_advection' , switch = '--initial_state' , switch_ab = '-is' , help = 'initial state' , required = . false ., & act = 'store' , def = 'sin_wave' , choices = 'sin_wave,square_wave' ) endsubroutine set_cli ! integrand_object deferred methods function dU_dt ( self , t ) result ( dState_dt ) !< Time derivative of advection field, the residuals function. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), allocatable :: dState_dt (:) !< Advection field time derivative. real ( R_P ) :: u ( 1 - self % Ng : self % Ni + self % Ng ) !< Conservative variable. real ( R_P ) :: ur ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed conservative variable. real ( R_P ) :: f ( 0 : self % Ni ) !< Flux of conservative variable. integer ( I_P ) :: i !< Counter. do i = 1 , self % Ni u ( i ) = self % u ( i ) enddo call self % impose_boundary_conditions ( u = u ) call self % reconstruct_interfaces ( conservative = u , r_conservative = ur ) do i = 0 , self % Ni call solve_riemann_problem ( state_left = ur ( 2 , i ), state_right = ur ( 1 , i + 1 ), flux = f ( i )) enddo allocate ( dState_dt ( 1 : self % Ni )) do i = 1 , self % Ni dState_dt ( i ) = ( f ( i - 1 ) - f ( i )) / self % Dx enddo contains subroutine solve_riemann_problem ( state_left , state_right , flux ) !< Solver Riemann problem of linear advection by upwinding. real ( R_P ), intent ( in ) :: state_left !< Left state. real ( R_P ), intent ( in ) :: state_right !< right state. real ( R_P ), intent ( out ) :: flux !< Flux of conservative variable. if ( self % a > 0._R_P ) then flux = self % a * state_left else flux = self % a * state_right endif endsubroutine solve_riemann_problem endfunction dU_dt pure function integrand_dimension ( self ) !< return integrand dimension. class ( integrand_ladvection ), intent ( in ) :: self !< integrand. integer ( I_P ) :: integrand_dimension !< integrand dimension. integrand_dimension = self % Ni endfunction integrand_dimension function local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 advection approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%u_i - rhs\\%u_i)&#94;2}{lhs\\%u_i&#94;2} }} }  class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. select type ( rhs ) class is ( integrand_ladvection ) error = 0._R_P do i = 1 , lhs % Ni error = error + ( lhs % u ( i ) - rhs % u ( i )) ** 2 enddo error = sqrt ( error ) endselect endfunction local_error ! + pure function integrand_add_integrand ( lhs , rhs ) result ( opr ) !< `+` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_ladvection ) opr = lhs % u + rhs % u endselect endfunction integrand_add_integrand pure function integrand_add_real ( lhs , rhs ) result ( opr ) !< `+ real` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % u + rhs endfunction integrand_add_real pure function real_add_integrand ( lhs , rhs ) result ( opr ) !< `real +` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_ladvection ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs + rhs % U endfunction real_add_integrand ! * pure function integrand_multiply_integrand ( lhs , rhs ) result ( opr ) !< `*` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_ladvection ) opr = lhs % U * rhs % U endselect endfunction integrand_multiply_integrand pure function integrand_multiply_real ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real pure function real_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. class ( integrand_ladvection ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_multiply_integrand pure function integrand_multiply_real_scalar ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real_scalar pure function real_scalar_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( integrand_ladvection ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_scalar_multiply_integrand ! - pure function integrand_sub_integrand ( lhs , rhs ) result ( opr ) !< `-` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_ladvection ) opr = lhs % U - rhs % U endselect endfunction integrand_sub_integrand pure function integrand_sub_real ( lhs , rhs ) result ( opr ) !< `- real` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U - rhs endfunction integrand_sub_real pure function real_sub_integrand ( lhs , rhs ) result ( opr ) !< `real -` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_ladvection ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs - rhs % U endfunction real_sub_integrand ! = subroutine assign_integrand ( lhs , rhs ) !< `=` operator. class ( integrand_ladvection ), intent ( inout ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( integrand_ladvection ) lhs % w_scheme = rhs % w_scheme lhs % weno_order = rhs % weno_order lhs % weno_eps = rhs % weno_eps lhs % CFL = rhs % CFL lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % length = rhs % length lhs % Dx = rhs % Dx lhs % a = rhs % a if ( allocated ( rhs % u )) then lhs % u = rhs % u else if ( allocated ( lhs % u )) deallocate ( lhs % u ) endif if ( allocated ( rhs % interpolator )) then if ( allocated ( lhs % interpolator )) then call lhs % interpolator % destroy deallocate ( lhs % interpolator ) endif allocate ( lhs % interpolator , mold = rhs % interpolator ) lhs % interpolator = rhs % interpolator else if ( allocated ( lhs % interpolator )) deallocate ( lhs % interpolator ) endif lhs % initial_state = rhs % initial_state endselect endsubroutine assign_integrand pure subroutine assign_real ( lhs , rhs ) !< Assign one real to an advection field. class ( integrand_ladvection ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. lhs % u = rhs endsubroutine assign_real ! private methods pure subroutine impose_boundary_conditions ( self , u ) !< Impose boundary conditions. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( inout ) :: u ( 1 - self % Ng :) !< Conservative variables. integer ( I_P ) :: i !< Space counter. do i = 1 - self % Ng , 0 u ( i ) = u ( self % Ni + i ) enddo do i = self % Ni + 1 , self % Ni + self % Ng u ( i ) = u ( i - self % Ni ) enddo endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces ( self , conservative , r_conservative ) !< Reconstruct interfaces states. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. real ( R_P ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng ) !< Stencils. real ( R_P ) :: CR ( 1 : 2 ) !< Reconstrcuted intrafaces. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 C ( f , j - i ) = conservative ( j ) enddo enddo call self % interpolator % interpolate ( stencil = C (:, :), interpolation = CR (:)) do f = 1 , 2 r_conservative ( f , i ) = CR ( f ) enddo enddo endselect endsubroutine reconstruct_interfaces subroutine set_square_wave_initial_state ( self ) !< Set initial state as a square wave. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. real ( R_P ) :: x !< Cell center x-abscissa values. integer ( I_P ) :: i !< Space counter. if ( allocated ( self % u )) deallocate ( self % u ) ; allocate ( self % u ( 1 : self % Ni )) do i = 1 , self % Ni x = self % Dx * i - 0.5_R_P * self % Dx if ( x < 0.25_R_P ) then self % u ( i ) = 0._R_P elseif ( 0.25_R_P <= x . and . x < 0.75_R_P ) then self % u ( i ) = 1._R_P else self % u ( i ) = 0._R_P endif enddo endsubroutine set_square_wave_initial_state subroutine set_sin_wave_initial_state ( self ) !< Set initial state as a sin wave. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. real ( R_P ) :: x !< Cell center x-abscissa values. real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. if ( allocated ( self % u )) deallocate ( self % u ) ; allocate ( self % u ( 1 : self % Ni )) do i = 1 , self % Ni x = self % Dx * i - 0.5_R_P * self % Dx self % u ( i ) = sin ( x * 2 * pi ) enddo endsubroutine set_sin_wave_initial_state endmodule foodie_test_integrand_ladvection","tags":"","loc":"sourcefile/foodie_test_integrand_ladvection.f90.html","title":"foodie_test_integrand_ladvection.f90 – FOODIE"},{"text":"Define integrand_lcce , the linear constant coefficients equation test field that is a concrete extension of the\n abstract integrand type. This File Depends On sourcefile~~foodie_test_integrand_lcce.f90~~EfferentGraph sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_test_integrand_lccef90EfferentGraph = svgPanZoom('#sourcefilefoodie_test_integrand_lccef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_test_integrand_lcce.f90~~AfferentGraph sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_test_integrand_lcce Source Code foodie_test_integrand_lcce.f90 Source Code !< Define [[integrand_lcce]], the linear constant coefficients equation test field that is a concrete extension of the !< abstract integrand type. module foodie_test_integrand_lcce !< Define [[integrand_lcce]], the linear constant coefficients equation test field that is a concrete extension of the !< abstract integrand type. use flap , only : command_line_interface use foodie , only : integrand_object use foodie_test_integrand_tester_object , only : integrand_tester_object use penf , only : FR_P , R_P , I_P , str implicit none private public :: integrand_lcce type , extends ( integrand_tester_object ) :: integrand_lcce !< The linear constant coefficient equation field. !< !< It is a FOODIE integrand class concrete extension. !< !<### ODE !<The linear constant coefficient equation is a linear pure ODE and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< y !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< a*y + b !< \\end{bmatrix} !<\\end{matrix} !< !<The coefficent *a,b* are constant with a \\ne 0. The exact solution is !< !< U(t) = (U_0 + \\frac{b}{a}) e &#94;{a(t-t_0)} - \\frac{b){a}  !< !< where t_0 is the initial time of integration. !< !<#### Bibliography !< !<[1] *ORDINARY DIFFERENTIAL EQUATIONS*, Gabriel Nagy, 2017. !< private real ( R_P ) :: a = 0._R_P !< *a* constant. real ( R_P ) :: b = 0._R_P !< *b* constant. real ( R_P ) :: U = 0._R_P !< Integrand (state) variable. real ( R_P ) :: U0 = 0._R_P !< Integrand initial state. contains ! auxiliary methods procedure , pass ( self ), public :: output !< Extract integrand state field. ! integrand_tester_object deferred methods procedure , pass ( self ), public :: description !< Return an informative description of the test. procedure , pass ( self ), public :: error !< Return error. procedure , pass ( self ), public :: exact_solution !< Return exact solution. procedure , pass ( self ), public :: export_tecplot !< Export integrand to Tecplot file. procedure , pass ( self ), public :: initialize !< Initialize field. procedure , pass ( self ), public :: parse_cli !< Initialize from command line interface. procedure , nopass , public :: set_cli !< Set command line interface. ! integrand_object deferred methods procedure , pass ( self ), public :: integrand_dimension !< Return integrand dimension. procedure , pass ( self ), public :: t => dU_dt !< Time derivative, residuals. ! operators procedure , pass ( lhs ), public :: local_error !<`||integrand_lcce - integrand_lcce||` operator. ! + procedure , pass ( lhs ), public :: integrand_add_integrand !< `+` operator. procedure , pass ( lhs ), public :: integrand_add_real !< `+ real` operator. procedure , pass ( rhs ), public :: real_add_integrand !< `real +` operator. ! * procedure , pass ( lhs ), public :: integrand_multiply_integrand !< `*` operator. procedure , pass ( lhs ), public :: integrand_multiply_real !< `* real` operator. procedure , pass ( rhs ), public :: real_multiply_integrand !< `real *` operator. procedure , pass ( lhs ), public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure , pass ( rhs ), public :: real_scalar_multiply_integrand !< `real_scalar *` operator. ! - procedure , pass ( lhs ), public :: integrand_sub_integrand !< `-` operator. procedure , pass ( lhs ), public :: integrand_sub_real !< `- real` operator. procedure , pass ( rhs ), public :: real_sub_integrand !< `real -` operator. ! = procedure , pass ( lhs ), public :: assign_integrand !< `=` operator. procedure , pass ( lhs ), public :: assign_real !< `= real` operator. ! override fast operators procedure , pass ( self ), public :: t_fast !< Time derivative, residuals, fast mode. procedure , pass ( opr ), public :: integrand_add_integrand_fast !< `+` fast operator. procedure , pass ( opr ), public :: integrand_multiply_integrand_fast !< `*` fast operator. procedure , pass ( opr ), public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. procedure , pass ( opr ), public :: integrand_subtract_integrand_fast !< `-` fast operator. endtype integrand_lcce contains ! auxiliary methods pure function output ( self ) result ( state ) !< Extract integrand state field. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ) :: state !< State. state = self % U endfunction output ! integrand_tester_object deferred methods pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix // 'linear_constant_coefficients_eq' endfunction description pure function error ( self , t , t0 , U0 ) !< Return error. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: error (:) !< Error. allocate ( error ( 1 : 1 )) error = abs ([ self % U ] - self % exact_solution ( t = t , t0 = t0 )) endfunction error pure function exact_solution ( self , t , t0 , U0 ) result ( exact ) !< Return exact solution. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: exact (:) !< Exact solution. real ( R_P ) :: t0_ !< Initial time, local variable. allocate ( exact ( 1 : 1 )) t0_ = 0._R_P ; if ( present ( t0 )) t0_ = t0 exact ( 1 ) = ( self % U0 + self % b / self % a ) * exp ( self % a * ( t - t0_ )) - self % b / self % a endfunction exact_solution subroutine export_tecplot ( self , file_name , t , scheme , close_file , with_exact_solution , U0 ) !< Export integrand to Tecplot file. class ( integrand_lcce ), intent ( in ) :: self !< Advection field. character ( * ), intent ( in ), optional :: file_name !< File name. real ( R_P ), intent ( in ), optional :: t !< Time. character ( * ), intent ( in ), optional :: scheme !< Scheme used to integrate integrand. logical , intent ( in ), optional :: close_file !< Flag for closing file. logical , intent ( in ), optional :: with_exact_solution !< Flag for export also exact solution. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. logical :: with_exact_solution_ !< Flag for export also exact solution, local variable. logical , save :: is_open = . false . !< Flag for checking if file is open. integer ( I_P ), save :: file_unit !< File unit. if ( present ( close_file )) then if ( close_file . and . is_open ) then close ( unit = file_unit ) is_open = . false . endif else with_exact_solution_ = . false . ; if ( present ( with_exact_solution )) with_exact_solution_ = with_exact_solution if ( present ( file_name )) then if ( is_open ) close ( unit = file_unit ) open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) is_open = . true . if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\" \"x_exact\"' else write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\"' endif endif if ( present ( t ) . and . present ( scheme ) . and . is_open ) then write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(3(' // FR_P // ',1X))' ) t , self % U , self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) t , self % U endif elseif ( present ( t ) . and . is_open ) then if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(3(' // FR_P // ',1X))' ) t , self % U , self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) t , self % U endif endif endif endsubroutine export_tecplot pure subroutine initialize ( self , Dt ) !< Initialize integrand. !< !< Intentionally empty, all is done in `parse_cli` method. class ( integrand_lcce ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. endsubroutine initialize subroutine parse_cli ( self , cli ) !< Initialize from command line interface. class ( integrand_lcce ), intent ( inout ) :: self !< Advection field. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % get ( group = 'lcce' , switch = '-a' , val = self % a , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'lcce' , switch = '-b' , val = self % b , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'lcce' , switch = '-U0' , val = self % U0 , error = cli % error ) ; if ( cli % error /= 0 ) stop self % U = self % U0 endsubroutine parse_cli subroutine set_cli ( cli ) !< Set command line interface. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % add_group ( description = 'linear constant coefficient equation test settings' , group = 'lcce' ) call cli % add ( group = 'lcce' , switch = '-a' , help = '\"a\" coeff of \"a * x + b\" equation' , required = . false ., def = '-1.0' , act = 'store' ) call cli % add ( group = 'lcce' , switch = '-b' , help = '\"b\" coeff of \"a * x + b\" equation' , required = . false ., def = '0.0' , act = 'store' ) call cli % add ( group = 'lcce' , switch = '-U0' , help = 'initial state' , required = . false ., def = '1.0' , act = 'store' ) endsubroutine set_cli ! integrand_object deferred methods pure function integrand_dimension ( self ) !< return integrand dimension. class ( integrand_lcce ), intent ( in ) :: self !< integrand. integer ( I_P ) :: integrand_dimension !< integrand dimension. integrand_dimension = 1 endfunction integrand_dimension pure function dU_dt ( self , t ) result ( dState_dt ) !< Time derivative of field. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), allocatable :: dState_dt (:) !< Integrand time derivative. dState_dt = [ self % a * self % U + self % b ] endfunction dU_dt pure function local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\frac{(lhs\\%U - rhs\\%U)&#94;2}{U&#94;2 } }  class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. select type ( rhs ) class is ( integrand_lcce ) if ( lhs % U /= 0._R_P ) then error = sqrt ((( lhs % U - rhs % U ) ** 2 ) / lhs % U ** 2 ) elseif ( rhs % U /= 0._R_P ) then error = sqrt ((( lhs % U - rhs % U ) ** 2 ) / rhs % U ** 2 ) else error = 0._R_P endif endselect endfunction local_error ! + pure function integrand_add_integrand ( lhs , rhs ) result ( opr ) !< `+` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_lcce ) opr = [ lhs % U + rhs % U ] endselect endfunction integrand_add_integrand pure function integrand_add_real ( lhs , rhs ) result ( opr ) !< `+ real` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U + rhs ( 1 )] endfunction integrand_add_real pure function real_add_integrand ( lhs , rhs ) result ( opr ) !< `real +` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_lcce ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs ( 1 ) + rhs % U ] endfunction real_add_integrand ! * pure function integrand_multiply_integrand ( lhs , rhs ) result ( opr ) !< `*` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_lcce ) opr = [ lhs % U * rhs % U ] endselect endfunction integrand_multiply_integrand pure function integrand_multiply_real ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U * rhs ( 1 )] endfunction integrand_multiply_real pure function real_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. class ( integrand_lcce ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs ( 1 ) * rhs % U ] endfunction real_multiply_integrand pure function integrand_multiply_real_scalar ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U * rhs ] endfunction integrand_multiply_real_scalar pure function real_scalar_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( integrand_lcce ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs * rhs % U ] endfunction real_scalar_multiply_integrand ! - pure function integrand_sub_integrand ( lhs , rhs ) result ( opr ) !< `-` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_lcce ) opr = [ lhs % U - rhs % U ] endselect endfunction integrand_sub_integrand pure function integrand_sub_real ( lhs , rhs ) result ( opr ) !< `- real` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U - rhs ( 1 )] endfunction integrand_sub_real pure function real_sub_integrand ( lhs , rhs ) result ( opr ) !< `real -` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_lcce ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs ( 1 ) - rhs % U ] endfunction real_sub_integrand ! = pure subroutine assign_integrand ( lhs , rhs ) !< `=` operator. class ( integrand_lcce ), intent ( inout ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( integrand_lcce ) lhs % a = rhs % a lhs % b = rhs % b lhs % U = rhs % U lhs % U0 = rhs % U0 endselect endsubroutine assign_integrand pure subroutine assign_real ( lhs , rhs ) !< `= real` operator. class ( integrand_lcce ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. lhs % U = rhs ( 1 ) endsubroutine assign_real ! fast operators ! time derivative subroutine t_fast ( self , t ) !< Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. class ( integrand_lcce ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ), optional :: t !< Time. self % U = self % a * self % U + self % b endsubroutine t_fast ! + pure subroutine integrand_add_integrand_fast ( opr , lhs , rhs ) !< `+` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) select type ( rhs ) class is ( integrand_lcce ) opr % U = lhs % U + rhs % U endselect endselect endsubroutine integrand_add_integrand_fast ! * pure subroutine integrand_multiply_integrand_fast ( opr , lhs , rhs ) !< `*` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) select type ( rhs ) class is ( integrand_lcce ) opr % U = lhs % U * rhs % U endselect endselect endsubroutine integrand_multiply_integrand_fast pure subroutine integrand_multiply_real_scalar_fast ( opr , lhs , rhs ) !< `* real_scalar` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) opr % U = lhs % U * rhs endselect endsubroutine integrand_multiply_real_scalar_fast ! - pure subroutine integrand_subtract_integrand_fast ( opr , lhs , rhs ) !< `-` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) select type ( rhs ) class is ( integrand_lcce ) opr % U = lhs % U - rhs % U endselect endselect endsubroutine integrand_subtract_integrand_fast endmodule foodie_test_integrand_lcce","tags":"","loc":"sourcefile/foodie_test_integrand_lcce.f90.html","title":"foodie_test_integrand_lcce.f90 – FOODIE"},{"text":"Define integrand_oscillation , the Oscillation test field that is a concrete extension of the abstract integrand type. This File Depends On sourcefile~~foodie_test_integrand_oscillation.f90~~EfferentGraph sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_test_integrand_oscillationf90EfferentGraph = svgPanZoom('#sourcefilefoodie_test_integrand_oscillationf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_test_integrand_oscillation.f90~~AfferentGraph sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_test_integrand_oscillation Source Code foodie_test_integrand_oscillation.f90 Source Code !< Define [[integrand_oscillation]], the Oscillation test field that is a concrete extension of the abstract integrand type. module foodie_test_integrand_oscillation !< Define [[integrand_oscillation]], the Oscillation test field that is a concrete extension of the abstract integrand type. use flap , only : command_line_interface use foodie , only : integrand_object use foodie_test_integrand_tester_object , only : integrand_tester_object use penf , only : FR_P , R_P , I_P , str implicit none private public :: integrand_oscillation type , extends ( integrand_tester_object ) :: integrand_oscillation !< The oscillation equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *n=2* elements. private real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). real ( R_P ) :: U0 ( 1 : 2 ) = [ 0._R_P , 0._R_P ] !< Initial state. real ( R_P ) :: U ( 1 : 2 ) = [ 0._R_P , 0._R_P ] !< Integrand (state) variables. contains ! auxiliary methods procedure , pass ( self ), public :: amplitude_phase !< Return amplitude and phase of the oscillation. procedure , pass ( self ), public :: output !< Extract integrand state field. ! integrand_tester_object deferred methods procedure , pass ( self ), public :: description !< Return an informative description of the test. procedure , pass ( self ), public :: error !< Return error. procedure , pass ( self ), public :: exact_solution !< Return exact solution. procedure , pass ( self ), public :: export_tecplot !< Export integrand to Tecplot file. procedure , pass ( self ), public :: initialize !< Initialize field. procedure , pass ( self ), public :: parse_cli !< Initialize from command line interface. procedure , nopass , public :: set_cli !< Set command line interface. ! integrand_object deferred methods procedure , pass ( self ), public :: integrand_dimension !< Return integrand dimension. procedure , pass ( self ), public :: t => dU_dt !< Time derivative, residuals. ! operators procedure , pass ( lhs ), public :: local_error !<`||integrand_oscillation - integrand_oscillation||` operator. ! + procedure , pass ( lhs ), public :: integrand_add_integrand !< `+` operator. procedure , pass ( lhs ), public :: integrand_add_real !< `+ real` operator. procedure , pass ( rhs ), public :: real_add_integrand !< `real +` operator. ! * procedure , pass ( lhs ), public :: integrand_multiply_integrand !< `*` operator. procedure , pass ( lhs ), public :: integrand_multiply_real !< `* real` operator. procedure , pass ( rhs ), public :: real_multiply_integrand !< `real *` operator. procedure , pass ( lhs ), public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure , pass ( rhs ), public :: real_scalar_multiply_integrand !< `real_scalar *` operator. ! - procedure , pass ( lhs ), public :: integrand_sub_integrand !< `-` operator. procedure , pass ( lhs ), public :: integrand_sub_real !< `- real` operator. procedure , pass ( rhs ), public :: real_sub_integrand !< `real -` operator. ! = procedure , pass ( lhs ), public :: assign_integrand !< `=` operator. procedure , pass ( lhs ), public :: assign_real !< `= real` operator. ! override fast operators procedure , pass ( self ), public :: t_fast !< Time derivative, residuals, fast mode. procedure , pass ( opr ), public :: integrand_add_integrand_fast !< `+` fast operator. procedure , pass ( opr ), public :: integrand_multiply_integrand_fast !< `*` fast operator. procedure , pass ( opr ), public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. procedure , pass ( opr ), public :: integrand_subtract_integrand_fast !< `-` fast operator. endtype integrand_oscillation contains ! auxiliary methods function amplitude_phase ( self ) result ( ap ) !< Compute amplitude and phase of the oscillation. class ( integrand_oscillation ), intent ( in ) :: self !< Advection field. real ( R_P ) :: ap ( 1 : 2 ) !< Amplitude and phase. ap ( 1 ) = sqrt ( self % U ( 1 ) ** 2 + self % U ( 2 ) ** 2 ) ap ( 2 ) = atan ( - self % U ( 1 ) / self % U ( 2 )) endfunction amplitude_phase pure function output ( self ) result ( state ) !< Extract integrand state field. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ) :: state ( 1 : 2 ) !< State. state = self % U endfunction output ! integrand_tester_object deferred methods pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix // 'oscillation' endfunction description pure function error ( self , t , t0 , U0 ) !< Return error. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: error (:) !< Error. allocate ( error ( 1 : 2 )) error = abs ( self % U - self % exact_solution ( t = t )) endfunction error pure function exact_solution ( self , t , t0 , U0 ) result ( exact ) !< Return exact solution. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: exact (:) !< Exact solution. exact = [ self % U0 ( 1 ) * cos ( self % f * t ) - self % U0 ( 2 ) * sin ( self % f * t ), & self % U0 ( 1 ) * sin ( self % f * t ) + self % U0 ( 2 ) * cos ( self % f * t )] endfunction exact_solution subroutine export_tecplot ( self , file_name , t , scheme , close_file , with_exact_solution , U0 ) !< Export integrand to Tecplot file. class ( integrand_oscillation ), intent ( in ) :: self !< Advection field. character ( * ), intent ( in ), optional :: file_name !< File name. real ( R_P ), intent ( in ), optional :: t !< Time. character ( * ), intent ( in ), optional :: scheme !< Scheme used to integrate integrand. logical , intent ( in ), optional :: close_file !< Flag for closing file. logical , intent ( in ), optional :: with_exact_solution !< Flag for export also exact solution. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. logical :: with_exact_solution_ !< Flag for export also exact solution, local variable. logical , save :: is_open = . false . !< Flag for checking if file is open. integer ( I_P ), save :: file_unit !< File unit. if ( present ( close_file )) then if ( close_file . and . is_open ) then close ( unit = file_unit ) is_open = . false . endif else with_exact_solution_ = . false . ; if ( present ( with_exact_solution )) with_exact_solution_ = with_exact_solution if ( present ( file_name )) then if ( is_open ) close ( unit = file_unit ) open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) is_open = . true . if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\" \"x_e\" \"y_e\"' else write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\"' endif endif if ( present ( t ) . and . present ( scheme ) . and . is_open ) then write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(7(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase (), self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(5(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase () endif elseif ( present ( t ) . and . is_open ) then if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(7(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase (), self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(5(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase () endif endif endif endsubroutine export_tecplot pure subroutine initialize ( self , Dt ) !< Initialize integrand. !< !< Intentionally empty, all is done in `parse_cli` method. class ( integrand_oscillation ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. endsubroutine initialize subroutine parse_cli ( self , cli ) !< Initialize from command line interface. class ( integrand_oscillation ), intent ( inout ) :: self !< Advection field. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % get ( group = 'oscillation' , switch = '-f' , val = self % f , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'oscillation' , switch = '-U0' , val = self % U0 , error = cli % error ) ; if ( cli % error /= 0 ) stop self % U = self % U0 endsubroutine parse_cli subroutine set_cli ( cli ) !< Set command line interface. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % add_group ( description = 'oscillation test settings' , group = 'oscillation' ) call cli % add ( group = 'oscillation' , switch = '--frequency' , switch_ab = '-f' , help = 'frequency' , required = . false ., def = '1e-4' , & act = 'store' ) call cli % add ( group = 'oscillation' , switch = '--U0' , switch_ab = '-U0' , nargs = '2' , help = 'initial state' , required = . false ., & def = '0.0 1.0' , act = 'store' ) endsubroutine set_cli ! integrand_object deferred methods pure function integrand_dimension ( self ) !< return integrand dimension. class ( integrand_oscillation ), intent ( in ) :: self !< integrand. integer ( I_P ) :: integrand_dimension !< integrand dimension. integrand_dimension = size ( self % U , dim = 1 ) endfunction integrand_dimension pure function dU_dt ( self , t ) result ( dState_dt ) !< Time derivative of integrand_oscillation field. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), allocatable :: dState_dt (:) !< Integrand time derivative. dState_dt = [ - self % f * self % U ( 2 ), & self % f * self % U ( 1 )] endfunction dU_dt pure function local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. select type ( rhs ) class is ( integrand_oscillation ) error = 0._R_P do i = 1 , size ( lhs % U , dim = 1 ) error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect endfunction local_error ! + pure function integrand_add_integrand ( lhs , rhs ) result ( opr ) !< `+` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_oscillation ) opr = lhs % U + rhs % U endselect endfunction integrand_add_integrand pure function integrand_add_real ( lhs , rhs ) result ( opr ) !< `+ real` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U + rhs endfunction integrand_add_real pure function real_add_integrand ( lhs , rhs ) result ( opr ) !< `real +` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_oscillation ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs + rhs % U endfunction real_add_integrand ! * pure function integrand_multiply_integrand ( lhs , rhs ) result ( opr ) !< `*` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_oscillation ) opr = lhs % U * rhs % U endselect endfunction integrand_multiply_integrand pure function integrand_multiply_real ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real pure function real_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. class ( integrand_oscillation ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_multiply_integrand pure function integrand_multiply_real_scalar ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real_scalar pure function real_scalar_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( integrand_oscillation ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_scalar_multiply_integrand ! - pure function integrand_sub_integrand ( lhs , rhs ) result ( opr ) !< `-` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_oscillation ) opr = lhs % U - rhs % U endselect endfunction integrand_sub_integrand pure function integrand_sub_real ( lhs , rhs ) result ( opr ) !< `- real` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U - rhs endfunction integrand_sub_real pure function real_sub_integrand ( lhs , rhs ) result ( opr ) !< `real -` operator. class ( integrand_oscillation ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs - rhs % U endfunction real_sub_integrand ! = pure subroutine assign_integrand ( lhs , rhs ) !< `=` operator. class ( integrand_oscillation ), intent ( inout ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( integrand_oscillation ) lhs % f = rhs % f lhs % U0 = rhs % U0 lhs % U = rhs % U endselect endsubroutine assign_integrand pure subroutine assign_real ( lhs , rhs ) !< `= real` operator. class ( integrand_oscillation ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. lhs % U = rhs endsubroutine assign_real ! fast operators ! time derivative subroutine t_fast ( self , t ) !< Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. class ( integrand_oscillation ), intent ( inout ) :: self !< Oscillation field. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ) :: buffer !< Temporary buffer. buffer = self % U ( 1 ) self % U ( 1 ) = - self % f * self % U ( 2 ) self % U ( 2 ) = self % f * buffer endsubroutine t_fast ! + pure subroutine integrand_add_integrand_fast ( opr , lhs , rhs ) !< `+` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) select type ( rhs ) class is ( integrand_oscillation ) opr % U = lhs % U + rhs % U endselect endselect endsubroutine integrand_add_integrand_fast ! * pure subroutine integrand_multiply_integrand_fast ( opr , lhs , rhs ) !< `*` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) select type ( rhs ) class is ( integrand_oscillation ) opr % U = lhs % U * rhs % U endselect endselect endsubroutine integrand_multiply_integrand_fast pure subroutine integrand_multiply_real_scalar_fast ( opr , lhs , rhs ) !< `* real_scalar` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) opr % U = lhs % U * rhs endselect endsubroutine integrand_multiply_real_scalar_fast ! - pure subroutine integrand_subtract_integrand_fast ( opr , lhs , rhs ) !< `-` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) select type ( rhs ) class is ( integrand_oscillation ) opr % U = lhs % U - rhs % U endselect endselect endsubroutine integrand_subtract_integrand_fast endmodule foodie_test_integrand_oscillation","tags":"","loc":"sourcefile/foodie_test_integrand_oscillation.f90.html","title":"foodie_test_integrand_oscillation.f90 – FOODIE"},{"text":"Define integrand_tester_object , the abstract tester integrand. This File Depends On sourcefile~~foodie_test_integrand_tester_object.f90~~EfferentGraph sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_test_integrand_tester_objectf90EfferentGraph = svgPanZoom('#sourcefilefoodie_test_integrand_tester_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~foodie_test_integrand_tester_object.f90~~AfferentGraph sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_lcce.f90 foodie_test_lcce.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_test_lcce.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_oscillation.f90 foodie_test_oscillation.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_test_oscillation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules foodie_test_integrand_tester_object Source Code foodie_test_integrand_tester_object.f90 Source Code !< Define [[integrand_tester_object]], the abstract tester integrand. module foodie_test_integrand_tester_object !< Define [[integrand_tester_object]], the abstract tester integrand. use flap , only : command_line_interface use foodie , only : integrand_object use penf , only : FR_P , R_P , I_P , str implicit none private public :: integrand_tester_object type , abstract , extends ( integrand_object ) :: integrand_tester_object !< The abstract tester integrand. !< !< This abstract provided some auxiliary methods useful for the tester machinery. contains procedure ( description_interface ), pass ( self ), deferred :: description !< Return an informative description of the test. procedure ( error_interface ), pass ( self ), deferred :: error !< Return error. procedure ( exact_solution_interface ), pass ( self ), deferred :: exact_solution !< Return exact solution. procedure ( export_tecplot_interface ), pass ( self ), deferred :: export_tecplot !< Export integrand to Tecplot file. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize integrand. procedure ( parse_cli_interface ), pass ( self ), deferred :: parse_cli !< Initialize from command line interface. procedure ( set_cli_interface ), nopass , deferred :: set_cli !< Set command line interface. endtype integrand_tester_object abstract interface !< Abstract interfaces of [[integrand_tester_object]] class. pure function description_interface ( self , prefix ) result ( desc ) !< Return informative integrator description. import :: integrand_tester_object class ( integrand_tester_object ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface pure function error_interface ( self , t , t0 , U0 ) result ( error ) !< Return error. import :: integrand_object , integrand_tester_object , R_P class ( integrand_tester_object ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: error (:) !< Error. endfunction error_interface pure function exact_solution_interface ( self , t , t0 , U0 ) result ( exact ) !< Return exact solution. import :: integrand_object , integrand_tester_object , R_P class ( integrand_tester_object ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: exact (:) !< Exact solution. endfunction exact_solution_interface subroutine export_tecplot_interface ( self , file_name , t , scheme , close_file , with_exact_solution , U0 ) !< Export integrand to Tecplot file. import :: integrand_object , integrand_tester_object , R_P class ( integrand_tester_object ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: file_name !< File name. real ( R_P ), intent ( in ), optional :: t !< Time. character ( * ), intent ( in ), optional :: scheme !< Scheme used to integrate integrand. logical , intent ( in ), optional :: close_file !< Flag for closing file. logical , intent ( in ), optional :: with_exact_solution !< Flag for export also exact solution. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. endsubroutine export_tecplot_interface subroutine initialize_interface ( self , Dt ) !< Initialize integrand. import :: integrand_tester_object , R_P class ( integrand_tester_object ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. endsubroutine initialize_interface subroutine parse_cli_interface ( self , cli ) !< Initialize from command line interface. import :: command_line_interface , integrand_tester_object class ( integrand_tester_object ), intent ( inout ) :: self !< Integrand. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. endsubroutine parse_cli_interface subroutine set_cli_interface ( cli ) !< Set command line interface. import :: command_line_interface type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. endsubroutine set_cli_interface endinterface endmodule foodie_test_integrand_tester_object","tags":"","loc":"sourcefile/foodie_test_integrand_tester_object.f90.html","title":"foodie_test_integrand_tester_object.f90 – FOODIE"},{"text":"Tester factory of FOODIE integrators. This File Depends On sourcefile~~foodie_tester.f90~~EfferentGraph sourcefile~foodie_tester.f90 foodie_tester.f90 sourcefile~foodie_test_integrand_lcce.f90 foodie_test_integrand_lcce.f90 sourcefile~foodie_test_integrand_lcce.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90 foodie_test_integrand_tester_object.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~foodie_test_integrand_oscillation.f90 foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie_test_integrand_ladvection.f90 foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_tester_object.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_oscillation.f90->sourcefile~foodie_tester.f90 sourcefile~foodie.f90 foodie.f90 sourcefile~foodie.f90->sourcefile~foodie_tester.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_lcce.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_tester_object.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_oscillation.f90 sourcefile~foodie.f90->sourcefile~foodie_test_integrand_ladvection.f90 sourcefile~foodie_test_integrand_ladvection.f90->sourcefile~foodie_tester.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90 foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_runge_kutta_embedded.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_euler_explicit.f90 foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_euler_explicit.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_moulton.f90 foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90 foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_moulton.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90 foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90 foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90 foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90 foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_multistage_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90 foodie_integrand_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_lmm_ssp.f90 foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90 foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_adams_bashforth.f90 foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90 foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_leapfrog.f90 foodie_integrator_leapfrog.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90 foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_multistep_object.f90 foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrand_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_object.f90 foodie_integrator_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistage_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_multistep_object.f90 sourcefile~foodie_integrator_object.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 sourcefile~foodie_integrator_runge_kutta_lssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_lmm_ssp_vss.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_adams_bashforth.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_adams_bashforth_moulton.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistage_multistep_object.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_integrator_leapfrog.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_backward_differentiation_formula.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_integrator_multistep_object.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_integrator_runge_kutta_low_storage.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90 foodie_error_codes.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_embedded.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_euler_explicit.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_ms_runge_kutta_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_lssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_lmm_ssp_vss.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_adams_bashforth_moulton.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_leapfrog.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_backward_differentiation_formula.f90 sourcefile~foodie_error_codes.f90->sourcefile~foodie_integrator_runge_kutta_low_storage.f90 var pansourcefilefoodie_testerf90EfferentGraph = svgPanZoom('#sourcefilefoodie_testerf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs foodie_tester Modules foodie_test_object Source Code foodie_tester.f90 Source Code !< Tester factory of FOODIE integrators. module foodie_test_object !< Definition of [[test_object]] for FOODIE tester factory. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use flap , only : command_line_interface use foodie , only : foodie_integrator_class_names , & foodie_integrator_factory , & foodie_integrator_schemes , & integrand_object , & integrator_adams_bashforth , & integrator_adams_bashforth_moulton , & integrator_adams_moulton , & integrator_back_df , & integrator_euler_explicit , & integrator_leapfrog , & integrator_lmm_ssp , & integrator_lmm_ssp_vss , & integrator_ms_runge_kutta_ssp , & integrator_multistage_object , & integrator_multistage_multistep_object , & integrator_multistep_object , & integrator_object , & integrator_runge_kutta_emd , & integrator_runge_kutta_ls , & integrator_runge_kutta_lssp , & integrator_runge_kutta_ssp , & is_available , is_class_available use foodie_test_integrand_ladvection , only : integrand_ladvection use foodie_test_integrand_lcce , only : integrand_lcce use foodie_test_integrand_oscillation , only : integrand_oscillation use foodie_test_integrand_tester_object , only : integrand_tester_object use penf , only : I_P , R_P , FR_P , str , strz implicit none private public :: test_object type :: test_object !< Generic FOODIE test object. !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: scheme !< Scheme used. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. logical :: is_fast !< Flag for activating fast schemes. integer ( I_P ) :: implicit_iterations !< Number of iterations (implicit solvers). integer ( I_P ) :: stages !< Number of stages. real ( R_P ) :: final_time !< Final integration time. logical :: save_results !< Flag for activating results saving. character ( 99 ) :: output !< Output files basename. integer ( I_P ) :: save_frequency !< Save frequency. type ( integrand_lcce ) :: lcce_0 !< Initial conditions for linear constant coefficients eq. type ( integrand_ladvection ) :: ladvection_0 !< Initial conditions for linear advection test. type ( integrand_oscillation ) :: oscillation_0 !< Initial conditions for oscillation test. class ( integrand_tester_object ), allocatable :: integrand_0 !< Initial conditions. contains ! public methods procedure , pass ( self ) :: execute !< Execute selected test(s). ! private methods procedure , pass ( self ), private :: initialize !< Initialize test: set Command Line Interface, parse it and check its validity. endtype test_object contains ! public methods subroutine execute ( self ) !< Execute test(s). class ( test_object ), intent ( inout ) :: self !< Test. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. real ( R_P ), allocatable :: error (:,:) !< Error of integrand integration. real ( R_P ), allocatable :: order (:,:) !< Observed order of accuravy. integer ( I_P ) :: s !< Counter. integer ( I_P ) :: t !< Counter. call self % initialize if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if ( is_class_available ( scheme = self % scheme )) then integrator_schemes = foodie_integrator_schemes ( class_name = self % scheme ) elseif ( is_available ( scheme = self % scheme )) then integrator_schemes = [ trim ( adjustl ( self % scheme ))] endif else integrator_schemes = foodie_integrator_schemes () endif allocate ( error ( 1 : size ( self % integrand_0 % error ( t = 0._R_P ), dim = 1 ), 1 : size ( self % Dt , dim = 1 ))) if ( size ( self % Dt , dim = 1 ) > 1 ) allocate ( order ( 1 : size ( error , dim = 1 ), 1 : size ( error , dim = 2 ) - 1 )) do s = 1 , size ( integrator_schemes , dim = 1 ) print '(A)' , trim ( integrator_schemes ( s )) do t = 1 , size ( self % Dt ) call self % integrand_0 % initialize ( Dt = self % Dt ( t )) print '(A)' , self % integrand_0 % description () call integrate ( scheme = trim ( integrator_schemes ( s )), & integrand_0 = self % integrand_0 , & Dt = self % Dt ( t ), & final_time = self % final_time , & iterations = self % implicit_iterations , & stages = self % stages , & is_fast = self % is_fast , & save_results = self % save_results , & output_base_name = trim ( adjustl ( self % output )), & save_frequency = self % save_frequency , & error = error (:, t )) print * , 'Dt = ' , self % Dt ( t ), ', error = ' , error (:, t ) if ( t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print '(A,' // trim ( str ( size ( order , dim = 1 ), no_sign = . true .)) // 'F6.2)' , ' Observed order =' , order (:, t - 1 ) endif enddo enddo endsubroutine execute ! private methods subroutine initialize ( self ) !< Initialize test: set Command Line Interface, parse it and check its validity. class ( test_object ), intent ( inout ) :: self !< Test. call set_cli call parse_cli contains subroutine set_cli () !< Set Command Line Interface. associate ( cli => self % cli ) call cli % init ( progname = 'foodie_tester' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Tester factory of FOODIE integrators' , & examples = [ \"foodie_tester test --scheme euler_explicit --save_results  \" , & \"foodie_tester test --scheme all -r                         \" ]) call cli % add_group ( description = 'general test settings' , group = 'test' ) call cli % add ( group = 'test' , switch = '--scheme' , switch_ab = '-s' , help = 'integrator scheme used' , required = . false ., def = 'all' , & act = 'store' ) call cli % add ( group = 'test' , switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'time step' , required = . false ., & def = '1e2' , act = 'store' ) call cli % add ( group = 'test' , switch = '--fast' , help = 'activate fast solvers' , required = . false ., act = 'store_true' , & def = '.false.' ) call cli % add ( group = 'test' , switch = '--iterations' , help = 'iterations number for implicit schemes' , required = . false ., & act = 'store' , def = '5' ) call cli % add ( group = 'test' , switch = '--stages' , help = 'stages number' , required = . false ., def = '2' , act = 'store' ) call cli % add ( group = 'test' , switch = '--final_time' , switch_ab = '-ft' , help = 'integration time' , required = . false ., def = '1' , & act = 'store' ) call cli % add ( group = 'test' , switch = '--save_results' , switch_ab = '-r' , help = 'save result' , required = . false ., & act = 'store_true' , def = '.false.' ) call cli % add ( group = 'test' , switch = '--output' , help = 'output file basename' , required = . false ., act = 'store' , & def = 'foodie_test' ) call cli % add ( group = 'test' , switch = '--save_frequency' , help = 'save frequency' , required = . false ., act = 'store' , & def = '1' ) endassociate call self % lcce_0 % set_cli ( cli = self % cli ) call self % ladvection_0 % set_cli ( cli = self % cli ) call self % oscillation_0 % set_cli ( cli = self % cli ) endsubroutine set_cli subroutine parse_cli () !< Parse Command Line Interface and check its validity. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. real ( R_P ), allocatable :: initial_state (:) !< Initial integrand state. integer ( I_P ) :: i !< Counter. call self % cli % parse ( error = self % error ) call self % cli % get ( group = 'test' , switch = '-s' , val = self % scheme , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get_varying ( group = 'test' , switch = '-Dt' , val = self % Dt , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--fast' , val = self % is_fast , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--iterations' , val = self % implicit_iterations , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--stages' , val = self % stages , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '-ft' , val = self % final_time , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '-r' , val = self % save_results , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--output' , val = self % output , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--save_frequency' , val = self % save_frequency , error = self % error ) ; if ( self % error /= 0 ) stop call self % lcce_0 % parse_cli ( cli = self % cli ) call self % ladvection_0 % parse_cli ( cli = self % cli ) call self % oscillation_0 % parse_cli ( cli = self % cli ) if ( self % cli % run_command ( 'lcce' )) then allocate ( integrand_lcce :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_lcce ) integrand_0 = self % lcce_0 endselect elseif ( self % cli % run_command ( 'linear_advection' )) then allocate ( integrand_ladvection :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_ladvection ) integrand_0 = self % ladvection_0 endselect elseif ( self % cli % run_command ( 'oscillation' )) then allocate ( integrand_oscillation :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_oscillation ) integrand_0 = self % oscillation_0 endselect else allocate ( integrand_oscillation :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_oscillation ) integrand_0 = self % oscillation_0 endselect endif if (. not . is_dt_valid ()) then write ( stderr , '(A)' ) 'error: the final integration time must be an exact multiple of the time step used' write ( stderr , '(A)' ) '       and time step must respect CFL condition, if any' write ( stderr , '(A)' ) 'Final integration time: ' // str ( self % final_time , . true .) write ( stderr , '(A)' ) 'Time step: ' // str ( self % Dt , . true .) stop endif if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if (. not . is_available ( scheme = self % scheme )) then integrator_class_names = foodie_integrator_class_names () integrator_schemes = foodie_integrator_schemes () write ( stderr , '(A)' ) 'error: the scheme \"' // trim ( adjustl ( self % scheme )) // '\" is unknown!' write ( stderr , '(A)' ) 'Supported classes of schemes are:' do i = 1 , size ( integrator_class_names , dim = 1 ) write ( stderr , '(A)' ) '  ' // trim ( integrator_class_names ( i )) enddo write ( stderr , '(A)' ) 'Supported schemes are:' do i = 1 , size ( integrator_schemes , dim = 1 ) write ( stderr , '(A)' ) '  ' // trim ( integrator_schemes ( i )) enddo stop endif endif endsubroutine parse_cli function is_dt_valid () !< Verify if the selected time step Dt is valid. logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) ! if (is_dt_valid) then !    select type(integrand=>self%integrand_0) !    type is(integrand_ladvection) !       is_dt_valid = is_dt_valid .and. self%Dt(t) <= integrand%Dt(final_time=self%final_time) !       if (.not.is_dt_valid) then !          write(stderr, '(A)') 'error: Dt violates CFL condition, Dt_max = '//str(integrand%Dt(final_time=self%final_time)) !       endif !    endselect ! endif if (. not . is_dt_valid ) exit enddo endfunction is_dt_valid endsubroutine initialize ! non type bound procedures subroutine check_scheme_has_fast_mode ( scheme , integrator ) !< Check if a scheme support fast mode integrate. character ( * ), intent ( in ) :: scheme !< Scheme name. class ( integrator_object ), intent ( in ) :: integrator !< Integrator instance. if (. not . integrator % has_fast_mode ()) then write ( stderr , '(A)' ) 'error: ' // trim ( adjustl ( scheme )) // ' has not fast integrate mode!' stop endif endsubroutine check_scheme_has_fast_mode subroutine integrate ( scheme , integrand_0 , Dt , final_time , iterations , stages , is_fast , save_results , output_base_name , & save_frequency , error ) !< Integrate integrand by means of the given scheme. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_tester_object ), intent ( in ) :: integrand_0 !< Initial conditions. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: final_time !< Final integration time. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. integer ( I_P ), intent ( in ) :: stages !< Number of stages. logical , intent ( in ) :: is_fast !< Activate fast mode integration. logical , intent ( in ) :: save_results !< Save results. character ( * ), intent ( in ) :: output_base_name !< Base name of output results file. integer ( I_P ), intent ( in ) :: save_frequency !< Save frequency. real ( R_P ), intent ( out ) :: error (:) !< Error of integrand integration. real ( R_P ), allocatable :: error_ (:) !< Error of integrand integration. class ( integrand_tester_object ) , allocatable :: integrand !< Integrand. class ( integrator_object ), allocatable :: integrator !< The integrator. real ( R_P ) :: time !< Time. integer ( I_P ) :: step !< Time steps counter. allocate ( integrand , mold = integrand_0 ) ; integrand = integrand_0 call foodie_integrator_factory ( scheme = scheme , integrator = integrator , stages = stages , & tolerance = 1 e2_R_P , iterations = iterations , autoupdate = . true ., U = integrand_0 ) if ( is_fast ) call check_scheme_has_fast_mode ( scheme = trim ( adjustl ( scheme )), integrator = integrator ) step = 0 time = 0._R_P if ( save_results ) call integrand % export_tecplot ( file_name = output_base_name // & integrand % description ( prefix = '-' ) // & integrator % description ( prefix = '-' ) // & '-steps_' // trim ( strz ( int ( final_time / Dt ), 10 )) // '.dat' , & t = time , & scheme = scheme , & with_exact_solution = . true ., & U0 = integrand_0 ) select type ( integrator ) class is ( integrator_multistage_object ) do step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = integrand , Dt = Dt , t = time ) else call integrator % integrate ( U = integrand , Dt = Dt , t = time ) endif time = time + Dt if (( time >= final_time )) exit call integrand_export_tecplot enddo class is ( integrator_multistep_object ) do step = step + 1 if ( integrator % steps_number () >= step ) then time = time + Dt integrator % Dt ( step ) = Dt integrator % t ( step ) = time integrator % previous ( step ) = integrand % exact_solution ( t = time , U0 = integrand_0 ) integrand = integrator % previous ( step ) else if ( is_fast ) then call integrator % integrate_fast ( U = integrand , Dt = Dt , t = time ) else call integrator % integrate ( U = integrand , Dt = Dt , t = time ) endif time = time + Dt endif if (( time >= final_time )) exit call integrand_export_tecplot enddo class is ( integrator_multistage_multistep_object ) do step = step + 1 if ( integrator % steps_number () >= step ) then time = time + Dt integrator % Dt ( step ) = Dt integrator % t ( step ) = time integrator % previous ( step ) = integrand % exact_solution ( t = time , U0 = integrand_0 ) integrand = integrator % previous ( step ) else if ( is_fast ) then call integrator % integrate_fast ( U = integrand , Dt = Dt , t = time ) else call integrator % integrate ( U = integrand , Dt = Dt , t = time ) endif time = time + Dt endif if (( time >= final_time )) exit call integrand_export_tecplot enddo endselect call integrand_close_tecplot error_ = integrand % error ( t = time , U0 = integrand_0 ) error (:) = error_ (:) contains subroutine integrand_close_tecplot !< Close current integrand tecplot file. select type ( integrand ) type is ( integrand_ladvection ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , scheme = scheme ) type is ( integrand_oscillation ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time ) endselect if ( save_results ) call integrand % export_tecplot ( close_file = . true .) endsubroutine integrand_close_tecplot subroutine integrand_export_tecplot !< Export current integrand solution to tecplot file. select type ( integrand ) type is ( integrand_lcce ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , with_exact_solution = . true .) type is ( integrand_ladvection ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , scheme = scheme ) type is ( integrand_oscillation ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , with_exact_solution = . true .) endselect endsubroutine integrand_export_tecplot endsubroutine integrate pure function observed_order ( error , Dt ) !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. real ( R_P ), intent ( in ) :: error ( 1 :, 1 :) !< Computed errors. real ( R_P ), intent ( in ) :: Dt ( 1 :) !< Time steps used. real ( R_P ) :: observed_order ( 1 : size ( error , dim = 1 )) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. do v = 1 , size ( error , dim = 1 ) observed_order ( v ) = log ( error ( v , 1 ) / error ( v , 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) enddo endfunction observed_order endmodule foodie_test_object program foodie_tester !< Tester factory of FOODIE integrators. use foodie_test_object , only : test_object implicit none type ( test_object ) :: test !< FOODIE test. call test % execute endprogram foodie_tester","tags":"","loc":"sourcefile/foodie_tester.f90.html","title":"foodie_tester.f90 – FOODIE"},{"text":"type, public, abstract :: integrand_object Abstract type for building FOODIE ODE integrators. Inherited By type~~integrand_object~~InheritedByGraph type~integrand_object integrand_object type~integrator_euler_explicit integrator_euler_explicit type~integrand_object->type~integrator_euler_explicit buffer, stage type~integrator_back_df integrator_back_df type~integrand_object->type~integrator_back_df buffer, previous type~integrator_runge_kutta_ls integrator_runge_kutta_ls type~integrand_object->type~integrator_runge_kutta_ls buffer, stage type~integrator_adams_moulton integrator_adams_moulton type~integrand_object->type~integrator_adams_moulton buffer, previous type~integrator_runge_kutta_ssp integrator_runge_kutta_ssp type~integrand_object->type~integrator_runge_kutta_ssp buffer, stage type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_multistage_multistep_object integrator_multistage_multistep_object type~integrand_object->type~integrator_multistage_multistep_object buffer, previous, stage type~integrator_adams_bashforth integrator_adams_bashforth type~integrand_object->type~integrator_adams_bashforth buffer, previous type~integrator_ms_runge_kutta_ssp integrator_ms_runge_kutta_ssp type~integrand_object->type~integrator_ms_runge_kutta_ssp buffer, previous, stage type~integrator_lmm_ssp integrator_lmm_ssp type~integrand_object->type~integrator_lmm_ssp buffer, previous type~integrator_adams_bashforth_moulton integrator_adams_bashforth_moulton type~integrand_object->type~integrator_adams_bashforth_moulton buffer, previous type~integrator_leapfrog integrator_leapfrog type~integrand_object->type~integrator_leapfrog buffer, filter, previous type~integrator_runge_kutta_lssp integrator_runge_kutta_lssp type~integrand_object->type~integrator_runge_kutta_lssp buffer, stage type~integrator_lmm_ssp_vss integrator_lmm_ssp_vss type~integrand_object->type~integrator_lmm_ssp_vss buffer, previous type~integrator_multistage_object integrator_multistage_object type~integrand_object->type~integrator_multistage_object buffer, stage type~integrator_runge_kutta_emd integrator_runge_kutta_emd type~integrand_object->type~integrator_runge_kutta_emd U1, U2, buffer, stage type~integrand_tester_object integrand_tester_object type~integrand_object->type~integrand_tester_object type~integrator_adams_moulton->type~integrator_adams_bashforth_moulton corrector type~integrator_multistep_object->type~integrator_back_df type~integrator_multistep_object->type~integrator_adams_moulton type~integrator_multistep_object->type~integrator_adams_bashforth type~integrator_multistep_object->type~integrator_lmm_ssp type~integrator_multistep_object->type~integrator_adams_bashforth_moulton type~integrator_multistep_object->type~integrator_leapfrog type~integrator_multistep_object->type~integrator_lmm_ssp_vss type~integrator_multistage_multistep_object->type~integrator_ms_runge_kutta_ssp type~integrator_adams_bashforth->type~integrator_adams_bashforth_moulton predictor type~integrator_multistage_object->type~integrator_euler_explicit type~integrator_multistage_object->type~integrator_runge_kutta_ls type~integrator_multistage_object->type~integrator_runge_kutta_ssp type~integrator_multistage_object->type~integrator_runge_kutta_lssp type~integrator_multistage_object->type~integrator_runge_kutta_emd type~test_object test_object type~integrand_tester_object->type~test_object integrand_0 type~integrand_ladvection integrand_ladvection type~integrand_tester_object->type~integrand_ladvection type~integrand_lcce integrand_lcce type~integrand_tester_object->type~integrand_lcce type~integrand_oscillation integrand_oscillation type~integrand_tester_object->type~integrand_oscillation type~integrand_ladvection->type~test_object ladvection_0 type~integrand_lcce->type~test_object lcce_0 type~integrand_oscillation->type~test_object oscillation_0 var pantypeintegrand_objectInheritedByGraph = svgPanZoom('#typeintegrand_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables dummy_to_allow_extensions Type-Bound Procedures add_fast assign_integrand assign_real assignment(=) integrand_add_integrand integrand_add_integrand_fast integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_integrand_fast integrand_multiply_real integrand_multiply_real_scalar integrand_multiply_real_scalar_fast integrand_sub_integrand integrand_sub_real integrand_subtract_integrand_fast local_error multiply_fast operator(*) operator(+) operator(-) operator(.lterror.) real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand subtract_fast t t_fast Source Code integrand_object Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( assignment_integrand ), public, deferred, pass(lhs) :: assign_integrand = operator. subroutine assignment_integrand (lhs, rhs) Prototype Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( assignment_real ), public, deferred, pass(lhs) :: assign_real = real operator. pure subroutine assignment_real (lhs, rhs) Prototype Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. generic, public :: assignment(=) => assign_integrand , assign_real Overloading = assignament. private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. procedure( symmetric_operator ), public, deferred, pass(lhs) :: integrand_add_integrand + operator. pure function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( integrand_op_real ), public, deferred, pass(lhs) :: integrand_add_real + real operator. pure function integrand_op_real (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( integrand_dimension_interface ), public, deferred, pass(self) :: integrand_dimension Return integrand dimension. pure function integrand_dimension_interface (self) result(integrand_dimension) Prototype Return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand. Return Value integer(kind=I_P) Integrand dimension. procedure( symmetric_operator ), public, deferred, pass(lhs) :: integrand_multiply_integrand * operator. pure function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( integrand_op_real ), public, deferred, pass(lhs) :: integrand_multiply_real * real operator. pure function integrand_op_real (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( integrand_op_real_scalar ), public, deferred, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. pure function integrand_op_real_scalar (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure( symmetric_operator ), public, deferred, pass(lhs) :: integrand_sub_integrand - operator. pure function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( integrand_op_real ), public, deferred, pass(lhs) :: integrand_sub_real - real operator. pure function integrand_op_real (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( local_error_operator ), public, deferred, pass(lhs) :: local_error ||integrand - integrand|| operator. function local_error_operator (lhs, rhs) result(error) Prototype Estimate local truncation error between 2 solution approximations. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. generic, public :: multiply_fast => integrand_multiply_integrand_fast , integrand_multiply_real_scalar_fast Overloading multiply_fast method. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(*) => integrand_multiply_integrand , integrand_multiply_real , real_multiply_integrand , integrand_multiply_real_scalar , real_scalar_multiply_integrand Overloading * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(+) => integrand_add_integrand , integrand_add_real , real_add_integrand Overloading + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(-) => integrand_sub_integrand , integrand_sub_real , real_sub_integrand Overloading - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure( real_op_integrand ), public, deferred, pass(rhs) :: real_add_integrand real + operator. pure function real_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( real_op_integrand ), public, deferred, pass(rhs) :: real_multiply_integrand real * operator. pure function real_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( real_scalar_op_integrand ), public, deferred, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. pure function real_scalar_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( real_op_integrand ), public, deferred, pass(rhs) :: real_sub_integrand real - operator. pure function real_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( time_derivative ), public, deferred, pass(self) :: t Time derivative, residuals. function time_derivative (self, t) result(dState_dt) Prototype Time derivative function of integrand class, i.e. the residuals function. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Result of the time derivative function of integrand field. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Source Code type , abstract :: integrand_object !< Abstract type for building FOODIE ODE integrators. #ifdef CAF class ( * ), allocatable :: dummy_to_allow_extensions [:] !< Dummy member to allow concrete extensions with coarray members. #endif contains ! public deferred procedures that concrete integrand-field must implement procedure ( integrand_dimension_interface ), pass ( self ), deferred , public :: integrand_dimension !< Return integrand dimension. procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. ! operators procedure ( local_error_operator ), pass ( lhs ), deferred , public :: local_error !< `||integrand - integrand||` operator. generic , public :: operator (. lterror .) => local_error !< Estimate local truncation error. ! + procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_add_integrand !< `+` operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_add_real !< `+ real` operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_add_integrand !< `real +` operator. generic , public :: operator ( + ) => integrand_add_integrand , & integrand_add_real , & real_add_integrand !< Overloading `+` operator. ! * procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< `*` operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< `* real` operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< `real *` operator. procedure ( integrand_op_real_scalar ), pass ( lhs ), deferred , public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure ( real_scalar_op_integrand ), pass ( rhs ), deferred , public :: real_scalar_multiply_integrand !< `real_scalar *` operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & integrand_multiply_real , & real_multiply_integrand , & integrand_multiply_real_scalar , & real_scalar_multiply_integrand !< Overloading `*` operator. ! - procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_sub_integrand !< `-` operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_sub_real !< `- real` operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_sub_integrand !< `real -` operator. generic , public :: operator ( - ) => integrand_sub_integrand , & integrand_sub_real , & real_sub_integrand !< Overloading `-` operator. ! = procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< `=` operator. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< `= real` operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading `=` assignament. ! public methods for fast operational mode, must be overridden procedure , pass ( self ), public :: t_fast !< Time derivative, residuals, fast mode. procedure , pass ( opr ), public :: integrand_add_integrand_fast !< `+` fast operator. generic , public :: add_fast => integrand_add_integrand_fast !< Overloading `add_fast` method. procedure , pass ( opr ), public :: integrand_multiply_integrand_fast !< `*` fast operator. procedure , pass ( opr ), public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. generic , public :: multiply_fast => integrand_multiply_integrand_fast , & integrand_multiply_real_scalar_fast !< Overloading `multiply_fast` method. procedure , pass ( opr ), public :: integrand_subtract_integrand_fast !< `-` fast operator. generic , public :: subtract_fast => integrand_subtract_integrand_fast !< Overloading `subtract_fast` method. endtype integrand_object","tags":"","loc":"type/integrand_object.html","title":"integrand_object – FOODIE "},{"text":"type, public, extends( integrator_multistep_object ) :: integrator_adams_bashforth type~~integrator_adams_bashforth~~InheritsGraph type~integrator_adams_bashforth integrator_adams_bashforth type~integrand_object integrand_object type~integrand_object->type~integrator_adams_bashforth buffer, previous type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_multistep_object->type~integrator_adams_bashforth type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used. Note The time steps Dt(1:steps) passed to the integrate methods must be identical: this integrator supports only\n fixed time steps. Inherited By type~~integrator_adams_bashforth~~InheritedByGraph type~integrator_adams_bashforth integrator_adams_bashforth type~integrator_adams_bashforth_moulton integrator_adams_bashforth_moulton type~integrator_adams_bashforth->type~integrator_adams_bashforth_moulton predictor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables Dt autoupdate b buffer description_ error error_message iterations previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_adams_bashforth Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private, allocatable :: b (:) b coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, autoupdate, U, stop_on_fail) Create the actual Adams-Bashforth integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with Adams-Bashforth class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t) Integrate field with Adams-Bashforth class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistep_object ) :: integrator_adams_bashforth !< FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: b (:) !< *b* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_adams_bashforth","tags":"","loc":"type/integrator_adams_bashforth.html","title":"integrator_adams_bashforth – FOODIE "},{"text":"type, public, extends( integrator_multistep_object ) :: integrator_adams_bashforth_moulton type~~integrator_adams_bashforth_moulton~~InheritsGraph type~integrator_adams_bashforth_moulton integrator_adams_bashforth_moulton type~integrand_object integrand_object type~integrand_object->type~integrator_adams_bashforth_moulton buffer, previous type~integrator_adams_bashforth integrator_adams_bashforth type~integrand_object->type~integrator_adams_bashforth buffer, previous type~integrator_adams_moulton integrator_adams_moulton type~integrand_object->type~integrator_adams_moulton buffer, previous type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_adams_bashforth->type~integrator_adams_bashforth_moulton predictor type~integrator_adams_moulton->type~integrator_adams_bashforth_moulton corrector type~integrator_multistep_object->type~integrator_adams_bashforth_moulton type~integrator_multistep_object->type~integrator_adams_bashforth type~integrator_multistep_object->type~integrator_adams_moulton type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object var pantypeintegrator_adams_bashforth_moultonInheritsGraph = svgPanZoom('#typeintegrator_adams_bashforth_moultonInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Note The integrator must be created or initialized (predictor and corrector schemes selection) before used. Note The time steps Dt(1:steps) passed to the integrate methods must be identical: this integrator supports only\n fixed time steps. Variables Dt autoupdate buffer corrector description_ error error_message iterations predictor previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported scheme_number stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_adams_bashforth_moulton Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. type( integrator_adams_moulton ), private :: corrector Corrector solver. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. type( integrator_adams_bashforth ), private :: predictor Predictor solver. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with Adams-Bashforth-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. procedure, public, pass(self) :: integrate_fast Integrate integrand field. private subroutine integrate_fast (self, U, Dt, t) Integrate field with Adams-Bashforth-Moulton class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: scheme_number Return the scheme number in the list of supported schemes. private elemental function scheme_number (self, scheme) Return the scheme number in the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value integer(kind=I_P) Scheme number in the list of supported schemes. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistep_object ) :: integrator_adams_bashforth_moulton !< FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. !< !< @note The integrator must be created or initialized (predictor and corrector schemes selection) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private type ( integrator_adams_bashforth ) :: predictor !< Predictor solver. type ( integrator_adams_moulton ) :: corrector !< Corrector solver. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. procedure , pass ( self ) :: scheme_number !< Return the scheme number in the list of supported schemes. endtype integrator_adams_bashforth_moulton","tags":"","loc":"type/integrator_adams_bashforth_moulton.html","title":"integrator_adams_bashforth_moulton – FOODIE "},{"text":"type, public, extends( integrator_multistep_object ) :: integrator_adams_moulton type~~integrator_adams_moulton~~InheritsGraph type~integrator_adams_moulton integrator_adams_moulton type~integrand_object integrand_object type~integrand_object->type~integrator_adams_moulton buffer, previous type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_multistep_object->type~integrator_adams_moulton type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. Note The integrator must be created or initialized (initialize the b coefficients) before used. Note The time steps Dt(1:steps) passed to the integrate methods must be identical: this integrator supports only\n fixed time steps. Inherited By type~~integrator_adams_moulton~~InheritedByGraph type~integrator_adams_moulton integrator_adams_moulton type~integrator_adams_bashforth_moulton integrator_adams_bashforth_moulton type~integrator_adams_moulton->type~integrator_adams_bashforth_moulton corrector Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables Dt autoupdate b buffer description_ error error_message iterations previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_adams_moulton Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private, allocatable :: b (:) b coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual Adams-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with Adams-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t) Integrate field with Adams-Moulton class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistep_object ) :: integrator_adams_moulton !< FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. !< !< @note The integrator must be created or initialized (initialize the *b* coefficients) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: b (:) !< b coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_adams_moulton","tags":"","loc":"type/integrator_adams_moulton.html","title":"integrator_adams_moulton – FOODIE "},{"text":"type, public, extends( integrator_multistep_object ) :: integrator_back_df type~~integrator_back_df~~InheritsGraph type~integrator_back_df integrator_back_df type~integrand_object integrand_object type~integrand_object->type~integrator_back_df buffer, previous type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_multistep_object->type~integrator_back_df type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order\n accurate. Note The integrator must be created or initialized (initialize the a and b coefficients) before used. Note The time steps Dt(1:steps) passed to the integrate methods must be identical: this integrator supports only\n fixed time steps. Variables Dt a autoupdate b buffer description_ error error_message iterations previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_back_df Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private, allocatable :: a (:) \\alpha coefficients. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private :: b = 0.0_R_P \\beta coefficient. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual BDF integrator: initialize the alpha and beta coefficients. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistep_object ) :: integrator_back_df !< FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order !< accurate. !< !< @note The integrator must be created or initialized (initialize the *a* and *b* coefficients) before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: a (:) !< \\alpha coefficients. real ( R_P ) :: b = 0.0_R_P !< \\beta coefficient. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_back_df","tags":"","loc":"type/integrator_back_df.html","title":"integrator_back_df – FOODIE "},{"text":"type, public, extends( integrator_multistage_object ) :: integrator_euler_explicit type~~integrator_euler_explicit~~InheritsGraph type~integrator_euler_explicit integrator_euler_explicit type~integrand_object integrand_object type~integrand_object->type~integrator_euler_explicit buffer, stage type~integrator_multistage_object integrator_multistage_object type~integrand_object->type~integrator_multistage_object buffer, stage type~integrator_multistage_object->type~integrator_euler_explicit type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. Variables buffer description_ error error_message registers stage stages Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage assignment(=) check_error class_name description destroy destroy_abstract destroy_multistage has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error Source Code integrator_euler_explicit Components Type Visibility Attributes Name Initial class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. private subroutine assign_multistage (lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. private elemental subroutine destroy_multistage (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit Euler scheme, 1st order. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit Euler scheme, 1st order, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code type , extends ( integrator_multistage_object ) :: integrator_euler_explicit !< FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_euler_explicit","tags":"","loc":"type/integrator_euler_explicit.html","title":"integrator_euler_explicit – FOODIE "},{"text":"type, public, extends( integrator_multistep_object ) :: integrator_leapfrog type~~integrator_leapfrog~~InheritsGraph type~integrator_leapfrog integrator_leapfrog type~integrand_object integrand_object type~integrand_object->type~integrator_leapfrog buffer, filter, previous type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_multistep_object->type~integrator_leapfrog type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Note The integrator must be initialized before used. Note The time steps Dt(1:steps) passed to the integrate methods must be identical: this integrator supports only\n fixed time steps. Variables Dt alpha autoupdate buffer description_ error error_message filter is_filtered iterations nu previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_leapfrog Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private :: alpha Robert-Asselin-Williams filter coefficient. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. class( integrand_object ), private, allocatable :: filter Filter field displacement. logical, private :: is_filtered Flag to check if the integration if RAW filtered. integer(kind=I_P), public :: iterations Implicit iterations. real(kind=R_P), private :: nu Robert-Asselin filter coefficient. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, nu, alpha, autoupdate, U, stop_on_fail) Create the actual leapfrog integrator: initialize the filter coefficient. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with leapfrog class scheme. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t) Integrate field with leapfrog class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistep_object ) :: integrator_leapfrog !< FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. !< !< @note The integrator must be initialized before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ) :: nu !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha !< Robert-Asselin-Williams filter coefficient. logical :: is_filtered !< Flag to check if the integration if RAW filtered. class ( integrand_object ), allocatable :: filter !< Filter field displacement. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! overridden public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. endtype integrator_leapfrog","tags":"","loc":"type/integrator_leapfrog.html","title":"integrator_leapfrog – FOODIE "},{"text":"type, public, extends( integrator_multistep_object ) :: integrator_lmm_ssp type~~integrator_lmm_ssp~~InheritsGraph type~integrator_lmm_ssp integrator_lmm_ssp type~integrand_object integrand_object type~integrand_object->type~integrator_lmm_ssp buffer, previous type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_multistep_object->type~integrator_lmm_ssp type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property,\n from 2nd to 3rd order accurate. Note The integrator must be initialized before used. Note The time steps Dt(1:steps) passed to the integrate methods must be identical: this integrator supports only\n fixed time steps. Variables Dt a autoupdate b buffer description_ error error_message iterations previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_lmm_ssp Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private, allocatable :: a (:) a coefficients. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private, allocatable :: b (:) b coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, autoupdate, U, stop_on_fail) Create the actual LMM-SSP integrator: initialize the a,b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistep_object ) :: integrator_lmm_ssp !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property, !< from 2nd to 3rd order accurate. !< !< @note The integrator must be initialized before used. !< !< @note The time steps `Dt(1:steps)` passed to the integrate methods must be identical: this integrator supports only !< fixed time steps. private real ( R_P ), allocatable :: a (:) !< *a* coefficients. real ( R_P ), allocatable :: b (:) !< *b* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_lmm_ssp","tags":"","loc":"type/integrator_lmm_ssp.html","title":"integrator_lmm_ssp – FOODIE "},{"text":"type, public, extends( integrator_multistep_object ) :: integrator_lmm_ssp_vss type~~integrator_lmm_ssp_vss~~InheritsGraph type~integrator_lmm_ssp_vss integrator_lmm_ssp_vss type~integrand_object integrand_object type~integrand_object->type~integrator_lmm_ssp_vss buffer, previous type~integrator_multistep_object integrator_multistep_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_multistep_object->type~integrator_lmm_ssp_vss type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and\n variable stepsize (VSS), from 2nd to 3rd order accurate. Note The integrator must be created or initialized before used. Variables Dt autoupdate buffer description_ error error_message integrate_ integrate_fast_ iterations previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast integrate_order_2 integrate_order_2_fast integrate_order_3 integrate_order_3_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_lmm_ssp_vss Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. procedure( integrate_interface ), private, pointer :: integrate_ => integrate_order_2 Integrate integrand field. procedure( integrate_fast_interface ), private, pointer :: integrate_fast_ => integrate_order_2_fast Integrate integrand field, fast. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, autoupdate, U, stop_on_fail) Create the actual LMM-SSP-VSS integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, private, pass(self) :: integrate_order_2 Integrate integrand field by 2nd order formula. private subroutine integrate_order_2 (self, U, Dt, t) Integrate field with LMM-SSP-VSS 2nd order class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, private, pass(self) :: integrate_order_2_fast Integrate integrand field by 2nd order formula, fast mode. private subroutine integrate_order_2_fast (self, U, Dt, t) Integrate field with LMM-SSP-VSS 2nd order class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, private, pass(self) :: integrate_order_3 Integrate integrand field by 3rd order formula. private subroutine integrate_order_3 (self, U, Dt, t) Integrate field with LMM-SSP-VSS 3rd order class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, private, pass(self) :: integrate_order_3_fast Integrate integrand field by 3rd order formula, fast mode. private subroutine integrate_order_3_fast (self, U, Dt, t) Integrate field with LMM-SSP-VSS 3rd order class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistep_object ) :: integrator_lmm_ssp_vss !< FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and !< variable stepsize (VSS), from 2nd to 3rd order accurate. !< !< @note The integrator must be created or initialized before used. private procedure ( integrate_interface ), pointer :: integrate_ => integrate_order_2 !< Integrate integrand field. procedure ( integrate_fast_interface ), pointer :: integrate_fast_ => integrate_order_2_fast !< Integrate integrand field, fast. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! private methods procedure , pass ( self ), private :: integrate_order_2 !< Integrate integrand field by 2nd order formula. procedure , pass ( self ), private :: integrate_order_3 !< Integrate integrand field by 3rd order formula. procedure , pass ( self ), private :: integrate_order_2_fast !< Integrate integrand field by 2nd order formula, fast mode. procedure , pass ( self ), private :: integrate_order_3_fast !< Integrate integrand field by 3rd order formula, fast mode. endtype integrator_lmm_ssp_vss","tags":"","loc":"type/integrator_lmm_ssp_vss.html","title":"integrator_lmm_ssp_vss – FOODIE "},{"text":"type, public, extends( integrator_multistage_multistep_object ) :: integrator_ms_runge_kutta_ssp type~~integrator_ms_runge_kutta_ssp~~InheritsGraph type~integrator_ms_runge_kutta_ssp integrator_ms_runge_kutta_ssp type~integrand_object integrand_object type~integrand_object->type~integrator_ms_runge_kutta_ssp buffer, previous, stage type~integrator_multistage_multistep_object integrator_multistage_multistep_object type~integrand_object->type~integrator_multistage_multistep_object buffer, previous, stage type~integrator_multistage_multistep_object->type~integrator_ms_runge_kutta_ssp type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property,\n from 3rd to 8th order accurate. Note The integrator must be created or initialized (initialize the A,Ahat,B,Bhat,D,T coefficients) before used. Variables A Ahat B Bhat D Dt Q autoupdate buffer description_ error error_message iterations previous registers_stages registers_steps stage stages steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage_multistep assignment(=) check_error class_name description destroy destroy_abstract destroy_multistage_multistep has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_ms_runge_kutta_ssp Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: A (:,:) A coefficients. real(kind=R_P), private, allocatable :: Ahat (:,:) Ahat coefficients. real(kind=R_P), private, allocatable :: B (:) B coefficients. real(kind=R_P), private, allocatable :: Bhat (:) Bhat coefficients. real(kind=R_P), private, allocatable :: D (:,:) D coefficients. real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private, allocatable :: Q (:) T coefficients. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers_stages Number of registers used for stages. integer(kind=I_P), public :: registers_steps Number of registers used for steps. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage_multistep Assign members of integrator_multistage_multistep_object . private subroutine assign_multistage_multistep (lhs, rhs) Assign members of integrator_multistage_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage_multistep Destroy the integrator. private elemental subroutine destroy_multistage_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual MS-RK-SSP integrator: initialize the A,Ahat,B,Bhat,D,T coefficients. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_multistage_multistep_object ) :: integrator_ms_runge_kutta_ssp !< FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property, !< from 3rd to 8th order accurate. !< !< @note The integrator must be created or initialized (initialize the *A,Ahat,B,Bhat,D,T* coefficients) before used. private real ( R_P ), allocatable :: A (:,:) !< *A* coefficients. real ( R_P ), allocatable :: Ahat (:,:) !< *Ahat* coefficients. real ( R_P ), allocatable :: B (:) !< *B* coefficients. real ( R_P ), allocatable :: Bhat (:) !< *Bhat* coefficients. real ( R_P ), allocatable :: D (:,:) !< *D* coefficients. real ( R_P ), allocatable :: Q (:) !< *T* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_ms_runge_kutta_ssp","tags":"","loc":"type/integrator_ms_runge_kutta_ssp.html","title":"integrator_ms_runge_kutta_ssp – FOODIE "},{"text":"type, public, abstract, extends( integrator_object ) :: integrator_multistage_multistep_object type~~integrator_multistage_multistep_object~~InheritsGraph type~integrator_multistage_multistep_object integrator_multistage_multistep_object type~integrand_object integrand_object type~integrand_object->type~integrator_multistage_multistep_object buffer, previous, stage type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract type of FOODIE ODE integrators of the multistage/multistep family. Inherited By type~~integrator_multistage_multistep_object~~InheritedByGraph type~integrator_multistage_multistep_object integrator_multistage_multistep_object type~integrator_ms_runge_kutta_ssp integrator_ms_runge_kutta_ssp type~integrator_multistage_multistep_object->type~integrator_ms_runge_kutta_ssp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables Dt autoupdate buffer description_ error error_message iterations previous registers_stages registers_steps stage stages steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage_multistep assignment(=) check_error class_name description destroy_abstract destroy_multistage_multistep has_fast_mode integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_multistage_multistep_object Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers_stages Number of registers used for stages. integer(kind=I_P), public :: registers_steps Number of registers used for steps. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage_multistep Assign members of integrator_multistage_multistep_object . private subroutine assign_multistage_multistep (lhs, rhs) Assign members of integrator_multistage_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure( class_name_interface ), public, deferred, pass(self) :: class_name Return the class name of schemes. pure function class_name_interface (self) result(class_name) Prototype Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage_multistep Destroy the integrator. private elemental subroutine destroy_multistage_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. procedure( has_fast_mode_interface ), public, deferred, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. elemental function has_fast_mode_interface (self) result(has_fast_mode) Prototype Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( assignment_interface ), public, deferred, pass(lhs) :: integr_assign_integr Operator = . subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure( integrate_interface ), public, deferred, pass(self) :: integrate Integrate integrand field. subroutine integrate_interface (self, U, Dt, t) Prototype Integrate integrand field. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure( integrate_fast_interface ), public, deferred, pass(self) :: integrate_fast Integrate integrand field, fast mode. subroutine integrate_fast_interface (self, U, Dt, t) Prototype Integrate integrand field, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( is_supported_interface ), public, deferred, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. elemental function is_supported_interface (self, scheme) result(is_supported) Prototype Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Queried scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure( supported_schemes_interface ), public, deferred, pass(self) :: supported_schemes Return the list of supported schemes. pure function supported_schemes_interface (self) result(schemes) Prototype Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_object ), abstract :: integrator_multistage_multistep_object !< Abstract type of FOODIE ODE integrators of the multistage/multistep family. integer ( I_P ) :: registers_stages !< Number of registers used for stages. integer ( I_P ) :: registers_steps !< Number of registers used for steps. integer ( I_P ) :: stages !< Number of stages. integer ( I_P ) :: steps !< Number of time steps. logical :: autoupdate !< Perform cyclic autoupdate of previous time steps buffers. integer ( I_P ) :: iterations !< Implicit iterations. real ( R_P ), allocatable :: Dt (:) !< Previous time steps. real ( R_P ), allocatable :: t (:) !< Previous times. class ( integrand_object ), allocatable :: previous (:) !< Previous steps. class ( integrand_object ), allocatable :: stage (:) !< Stages. class ( integrand_object ), allocatable :: buffer !< Buffer used for fast integration. contains ! deferred methods procedure ( integrate_interface ), pass ( self ), deferred :: integrate !< Integrate integrand field. procedure ( integrate_fast_interface ), pass ( self ), deferred :: integrate_fast !< Integrate integrand field, fast mode. ! implemented deferred methods of parent procedure , pass ( self ) :: is_multistage !< Return .true. for multistage integrator. procedure , pass ( self ) :: is_multistep !< Return .true. for multistep integrator. procedure , pass ( self ) :: stages_number !< Return number of stages used. procedure , pass ( self ) :: steps_number !< Return number of steps used. ! public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. procedure , pass ( lhs ) :: assign_multistage_multistep !< Assign members of [[integrator_multistage_multistep_object]]. procedure , pass ( self ) :: destroy_multistage_multistep !< Destroy the integrator. procedure , nopass :: update_previous !< Cyclic update previous time steps. endtype integrator_multistage_multistep_object","tags":"","loc":"type/integrator_multistage_multistep_object.html","title":"integrator_multistage_multistep_object – FOODIE "},{"text":"type, public, abstract, extends( integrator_object ) :: integrator_multistage_object type~~integrator_multistage_object~~InheritsGraph type~integrator_multistage_object integrator_multistage_object type~integrand_object integrand_object type~integrand_object->type~integrator_multistage_object buffer, stage type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract type of FOODIE ODE integrators of the multistage family. Inherited By type~~integrator_multistage_object~~InheritedByGraph type~integrator_multistage_object integrator_multistage_object type~integrator_runge_kutta_lssp integrator_runge_kutta_lssp type~integrator_multistage_object->type~integrator_runge_kutta_lssp type~integrator_euler_explicit integrator_euler_explicit type~integrator_multistage_object->type~integrator_euler_explicit type~integrator_runge_kutta_ssp integrator_runge_kutta_ssp type~integrator_multistage_object->type~integrator_runge_kutta_ssp type~integrator_runge_kutta_emd integrator_runge_kutta_emd type~integrator_multistage_object->type~integrator_runge_kutta_emd type~integrator_runge_kutta_ls integrator_runge_kutta_ls type~integrator_multistage_object->type~integrator_runge_kutta_ls Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables buffer description_ error error_message registers stage stages Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage assignment(=) check_error class_name description destroy_abstract destroy_multistage has_fast_mode integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error Source Code integrator_multistage_object Components Type Visibility Attributes Name Initial class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. private subroutine assign_multistage (lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure( class_name_interface ), public, deferred, pass(self) :: class_name Return the class name of schemes. pure function class_name_interface (self) result(class_name) Prototype Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. private elemental subroutine destroy_multistage (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. procedure( has_fast_mode_interface ), public, deferred, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. elemental function has_fast_mode_interface (self) result(has_fast_mode) Prototype Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( assignment_interface ), public, deferred, pass(lhs) :: integr_assign_integr Operator = . subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure( integrate_interface ), public, deferred, pass(self) :: integrate Integrate integrand field. subroutine integrate_interface (self, U, Dt, t, new_Dt) Prototype Integrate integrand field. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure( integrate_fast_interface ), public, deferred, pass(self) :: integrate_fast Integrate integrand field, fast mode. subroutine integrate_fast_interface (self, U, Dt, t, new_Dt) Prototype Integrate integrand field, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( is_supported_interface ), public, deferred, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. elemental function is_supported_interface (self, scheme) result(is_supported) Prototype Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Queried scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure( supported_schemes_interface ), public, deferred, pass(self) :: supported_schemes Return the list of supported schemes. pure function supported_schemes_interface (self) result(schemes) Prototype Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code type , extends ( integrator_object ), abstract :: integrator_multistage_object !< Abstract type of FOODIE ODE integrators of the multistage family. integer ( I_P ) :: registers !< Number of registers used for stages. integer ( I_P ) :: stages !< Number of stages. class ( integrand_object ), allocatable :: stage (:) !< Stages. class ( integrand_object ), allocatable :: buffer !< Buffer used for fast integration. contains ! deferred methods procedure ( integrate_interface ), pass ( self ), deferred :: integrate !< Integrate integrand field. procedure ( integrate_fast_interface ), pass ( self ), deferred :: integrate_fast !< Integrate integrand field, fast mode. ! implemented deferred methods of parent procedure , pass ( self ) :: is_multistage !< Return .true. for multistage integrator. procedure , pass ( self ) :: is_multistep !< Return .true. for multistep integrator. procedure , pass ( self ) :: stages_number !< Return number of stages used. procedure , pass ( self ) :: steps_number !< Return number of steps used. ! public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. procedure , pass ( lhs ) :: assign_multistage !< Assign members of [[integrator_multistage_object]] and parents. procedure , pass ( self ) :: destroy_multistage !< Destroy the integrator. endtype integrator_multistage_object","tags":"","loc":"type/integrator_multistage_object.html","title":"integrator_multistage_object – FOODIE "},{"text":"type, public, abstract, extends( integrator_object ) :: integrator_multistep_object type~~integrator_multistep_object~~InheritsGraph type~integrator_multistep_object integrator_multistep_object type~integrand_object integrand_object type~integrand_object->type~integrator_multistep_object buffer, previous type~integrator_object integrator_object type~integrator_object->type~integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Abstract type of FOODIE ODE integrators of the multistep-implicit family. Inherited By type~~integrator_multistep_object~~InheritedByGraph type~integrator_multistep_object integrator_multistep_object type~integrator_back_df integrator_back_df type~integrator_multistep_object->type~integrator_back_df type~integrator_adams_moulton integrator_adams_moulton type~integrator_multistep_object->type~integrator_adams_moulton type~integrator_adams_bashforth integrator_adams_bashforth type~integrator_multistep_object->type~integrator_adams_bashforth type~integrator_lmm_ssp integrator_lmm_ssp type~integrator_multistep_object->type~integrator_lmm_ssp type~integrator_adams_bashforth_moulton integrator_adams_bashforth_moulton type~integrator_multistep_object->type~integrator_adams_bashforth_moulton type~integrator_leapfrog integrator_leapfrog type~integrator_multistep_object->type~integrator_leapfrog type~integrator_lmm_ssp_vss integrator_lmm_ssp_vss type~integrator_multistep_object->type~integrator_lmm_ssp_vss type~integrator_adams_moulton->type~integrator_adams_bashforth_moulton corrector type~integrator_adams_bashforth->type~integrator_adams_bashforth_moulton predictor Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables Dt autoupdate buffer description_ error error_message iterations previous registers steps t Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistep assignment(=) check_error class_name description destroy_abstract destroy_multistep has_fast_mode integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error update_previous Source Code integrator_multistep_object Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure( class_name_interface ), public, deferred, pass(self) :: class_name Return the class name of schemes. pure function class_name_interface (self) result(class_name) Prototype Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. procedure( has_fast_mode_interface ), public, deferred, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. elemental function has_fast_mode_interface (self) result(has_fast_mode) Prototype Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( assignment_interface ), public, deferred, pass(lhs) :: integr_assign_integr Operator = . subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure( integrate_interface ), public, deferred, pass(self) :: integrate Integrate integrand field. subroutine integrate_interface (self, U, Dt, t) Prototype Integrate integrand field. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. procedure( integrate_fast_interface ), public, deferred, pass(self) :: integrate_fast Integrate integrand field, fast mode. subroutine integrate_fast_interface (self, U, Dt, t) Prototype Integrate integrand field, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( is_supported_interface ), public, deferred, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. elemental function is_supported_interface (self, scheme) result(is_supported) Prototype Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Queried scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure( supported_schemes_interface ), public, deferred, pass(self) :: supported_schemes Return the list of supported schemes. pure function supported_schemes_interface (self) result(schemes) Prototype Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, nopass :: update_previous Cyclic update previous time steps. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code type , extends ( integrator_object ), abstract :: integrator_multistep_object !< Abstract type of FOODIE ODE integrators of the multistep-implicit family. integer ( I_P ) :: registers !< Number of registers used for steps. integer ( I_P ) :: steps !< Number of time steps. logical :: autoupdate !< Perform cyclic autoupdate of previous time steps buffers. integer ( I_P ) :: iterations !< Implicit iterations. real ( R_P ), allocatable :: Dt (:) !< Previous time steps. real ( R_P ), allocatable :: t (:) !< Previous times. class ( integrand_object ), allocatable :: previous (:) !< Previous steps. class ( integrand_object ), allocatable :: buffer !< Buffer used for fast integration. contains ! deferred methods procedure ( integrate_interface ), pass ( self ), deferred :: integrate !< Integrate integrand field. procedure ( integrate_fast_interface ), pass ( self ), deferred :: integrate_fast !< Integrate integrand field, fast mode. ! implemented deferred methods of parent procedure , pass ( self ) :: is_multistage !< Return .true. for multistage integrator. procedure , pass ( self ) :: is_multistep !< Return .true. for multistep integrator. procedure , pass ( self ) :: stages_number !< Return number of stages used. procedure , pass ( self ) :: steps_number !< Return number of steps used. ! public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. procedure , pass ( lhs ) :: assign_multistep !< Assign members of [[integrator_multistep_object]] and parents. procedure , pass ( self ) :: destroy_multistep !< Destroy the integrator. procedure , nopass :: update_previous !< Cyclic update previous time steps. endtype integrator_multistep_object","tags":"","loc":"type/integrator_multistep_object.html","title":"integrator_multistep_object – FOODIE "},{"text":"type, public, abstract :: integrator_object Abstract type of FOODIE ODE integrators. Inherited By type~~integrator_object~~InheritedByGraph type~integrator_object integrator_object type~integrator_multistep_object integrator_multistep_object type~integrator_object->type~integrator_multistep_object type~integrator_multistage_multistep_object integrator_multistage_multistep_object type~integrator_object->type~integrator_multistage_multistep_object type~integrator_multistage_object integrator_multistage_object type~integrator_object->type~integrator_multistage_object type~integrator_back_df integrator_back_df type~integrator_multistep_object->type~integrator_back_df type~integrator_adams_moulton integrator_adams_moulton type~integrator_multistep_object->type~integrator_adams_moulton type~integrator_adams_bashforth integrator_adams_bashforth type~integrator_multistep_object->type~integrator_adams_bashforth type~integrator_lmm_ssp integrator_lmm_ssp type~integrator_multistep_object->type~integrator_lmm_ssp type~integrator_adams_bashforth_moulton integrator_adams_bashforth_moulton type~integrator_multistep_object->type~integrator_adams_bashforth_moulton type~integrator_leapfrog integrator_leapfrog type~integrator_multistep_object->type~integrator_leapfrog type~integrator_lmm_ssp_vss integrator_lmm_ssp_vss type~integrator_multistep_object->type~integrator_lmm_ssp_vss type~integrator_ms_runge_kutta_ssp integrator_ms_runge_kutta_ssp type~integrator_multistage_multistep_object->type~integrator_ms_runge_kutta_ssp type~integrator_runge_kutta_lssp integrator_runge_kutta_lssp type~integrator_multistage_object->type~integrator_runge_kutta_lssp type~integrator_euler_explicit integrator_euler_explicit type~integrator_multistage_object->type~integrator_euler_explicit type~integrator_runge_kutta_ssp integrator_runge_kutta_ssp type~integrator_multistage_object->type~integrator_runge_kutta_ssp type~integrator_runge_kutta_emd integrator_runge_kutta_emd type~integrator_multistage_object->type~integrator_runge_kutta_emd type~integrator_runge_kutta_ls integrator_runge_kutta_ls type~integrator_multistage_object->type~integrator_runge_kutta_ls type~integrator_adams_moulton->type~integrator_adams_bashforth_moulton corrector type~integrator_adams_bashforth->type~integrator_adams_bashforth_moulton predictor var pantypeintegrator_objectInheritedByGraph = svgPanZoom('#typeintegrator_objectInheritedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables description_ error error_message Type-Bound Procedures assign_abstract assignment(=) check_error class_name description destroy_abstract has_fast_mode integr_assign_integr is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error Source Code integrator_object Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. Type-Bound Procedures procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure( class_name_interface ), public, deferred, pass(self) :: class_name Return the class name of schemes. pure function class_name_interface (self) result(class_name) Prototype Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure( has_fast_mode_interface ), public, deferred, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. elemental function has_fast_mode_interface (self) result(has_fast_mode) Prototype Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( assignment_interface ), public, deferred, pass(lhs) :: integr_assign_integr Operator = . subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure( is_multistagestep_interface ), public, deferred, pass(self) :: is_multistage Return .true. for multistage integrator. elemental function is_multistagestep_interface (self) result(is_multistagestep) Prototype Return .true. for multistage or multistep integrator. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( is_multistagestep_interface ), public, deferred, pass(self) :: is_multistep Return .true. for multistep integrator. elemental function is_multistagestep_interface (self) result(is_multistagestep) Prototype Return .true. for multistage or multistep integrator. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure( is_supported_interface ), public, deferred, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. elemental function is_supported_interface (self, scheme) result(is_supported) Prototype Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Queried scheme. Return Value logical Inquire result. procedure( stagesteps_number_interface ), public, deferred, pass(self) :: stages_number Return number of stages used. elemental function stagesteps_number_interface (self) result(stagesteps_number) Prototype Return number of stages/steps used. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Inquire result. procedure( stagesteps_number_interface ), public, deferred, pass(self) :: steps_number Return number of steps used. elemental function stagesteps_number_interface (self) result(stagesteps_number) Prototype Return number of stages/steps used. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Inquire result. procedure( supported_schemes_interface ), public, deferred, pass(self) :: supported_schemes Return the list of supported schemes. pure function supported_schemes_interface (self) result(schemes) Prototype Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code type , abstract :: integrator_object !< Abstract type of FOODIE ODE integrators. character ( len = :), allocatable :: description_ !< Informative description of the integrator. integer ( I_P ) :: error = 0 !< Error status code. character ( len = :), allocatable :: error_message !< Error message, hopefully meaningful. contains ! public methods procedure , pass ( lhs ) :: assign_abstract !< Assign ony members of abstract [[integrator_object]] type. procedure , pass ( self ) :: check_error !< Check for error occurrencies. procedure , pass ( self ) :: description !< Return informative integrator description. procedure , pass ( self ) :: destroy_abstract !< Destroy only members of abstract [[integrator_object]] type. procedure , pass ( self ) :: trigger_error !< Trigger an error. ! deferred methods procedure ( class_name_interface ), pass ( self ), deferred :: class_name !< Return the class name of schemes. procedure ( has_fast_mode_interface ), pass ( self ), deferred :: has_fast_mode !< Return .true. if the integrator class !< has *fast mode* integrate. procedure ( assignment_interface ), pass ( lhs ), deferred :: integr_assign_integr !< Operator `=`. procedure ( is_multistagestep_interface ), pass ( self ), deferred :: is_multistage !< Return .true. for multistage integrator. procedure ( is_multistagestep_interface ), pass ( self ), deferred :: is_multistep !< Return .true. for multistep integrator. procedure ( is_supported_interface ), pass ( self ), deferred :: is_supported !< Return .true. if the integrator class !< support the given scheme. procedure ( stagesteps_number_interface ), pass ( self ), deferred :: stages_number !< Return number of stages used. procedure ( stagesteps_number_interface ), pass ( self ), deferred :: steps_number !< Return number of steps used. procedure ( supported_schemes_interface ), pass ( self ), deferred :: supported_schemes !< Return the list of supported schemes. ! operators generic :: assignment ( = ) => integr_assign_integr !< Overload `=`. endtype integrator_object","tags":"","loc":"type/integrator_object.html","title":"integrator_object – FOODIE "},{"text":"type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_emd type~~integrator_runge_kutta_emd~~InheritsGraph type~integrator_runge_kutta_emd integrator_runge_kutta_emd type~integrand_object integrand_object type~integrand_object->type~integrator_runge_kutta_emd U1, U2, buffer, stage type~integrator_multistage_object integrator_multistage_object type~integrand_object->type~integrator_multistage_object buffer, stage type~integrator_multistage_object->type~integrator_runge_kutta_emd type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. Variables U1 U2 alph beta buffer description_ error error_message gamm pp1_inv registers stage stages tolerance Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage assignment(=) check_error class_name description destroy destroy_abstract destroy_multistage has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported new_Dt stages_number steps_number supported_schemes trigger_error Source Code integrator_runge_kutta_emd Components Type Visibility Attributes Name Initial class( integrand_object ), private, allocatable :: U1 First U evaluation. class( integrand_object ), private, allocatable :: U2 Second U evaluation. real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:,:) \\beta Butcher's coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. real(kind=R_P), private :: pp1_inv 1/(p+1) where p is the accuracy order of the lower accurate scheme. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. real(kind=R_P), private :: tolerance Tolerance on the local truncation error. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. private subroutine assign_multistage (lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. private elemental subroutine destroy_multistage (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, U, tolerance, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit embedded Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit embedded Runge-Kutta scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. private elemental subroutine new_Dt (self, error, Dt) Compute new estimation of the time step Dt. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_emd !< FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ) :: tolerance !< Tolerance on the local truncation error. real ( R_P ) :: pp1_inv !< 1/(p+1) where p is the accuracy order of the lower accurate scheme. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:,:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. class ( integrand_object ), allocatable :: U1 !< First U evaluation. class ( integrand_object ), allocatable :: U2 !< Second U evaluation. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! overridden public methods procedure , pass ( self ) :: allocate_integrand_members !< Allocate integrand members. ! private methods procedure , pass ( self ), private :: new_Dt !< Compute new estimation of the time step Dt. endtype integrator_runge_kutta_emd","tags":"","loc":"type/integrator_runge_kutta_emd.html","title":"integrator_runge_kutta_emd – FOODIE "},{"text":"type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_ls type~~integrator_runge_kutta_ls~~InheritsGraph type~integrator_runge_kutta_ls integrator_runge_kutta_ls type~integrand_object integrand_object type~integrand_object->type~integrator_runge_kutta_ls buffer, stage type~integrator_multistage_object integrator_multistage_object type~integrand_object->type~integrator_multistage_object buffer, stage type~integrator_multistage_object->type~integrator_runge_kutta_ls type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. Variables A B C buffer description_ error error_message registers stage stages Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage assignment(=) check_error class_name description destroy destroy_abstract destroy_multistage has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported registers_number stages_number steps_number supported_schemes trigger_error Source Code integrator_runge_kutta_ls Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), private, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), private, allocatable :: C (:) Low storage C coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. private subroutine assign_multistage (lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. private elemental subroutine destroy_multistage (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit low storage Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit low storage Runge-Kutta scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, nopass :: registers_number Return the number of registers used. private pure function registers_number () Return the number of registers used. Arguments None Return Value integer(kind=I_P) Number of registers used. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_ls !< FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. procedure , nopass :: registers_number !< Return the number of registers used. endtype integrator_runge_kutta_ls","tags":"","loc":"type/integrator_runge_kutta_ls.html","title":"integrator_runge_kutta_ls – FOODIE "},{"text":"type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_lssp type~~integrator_runge_kutta_lssp~~InheritsGraph type~integrator_runge_kutta_lssp integrator_runge_kutta_lssp type~integrand_object integrand_object type~integrand_object->type~integrator_runge_kutta_lssp buffer, stage type~integrator_multistage_object integrator_multistage_object type~integrand_object->type~integrator_multistage_object buffer, stage type~integrator_multistage_object->type~integrator_runge_kutta_lssp type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. Variables alpha buffer description_ error error_message integrate_ integrate_fast_ registers stage stages Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage assignment(=) check_error class_name description destroy destroy_abstract destroy_multistage has_fast_mode initialize initialize_order_s initialize_order_s_1 integr_assign_integr integrate integrate_fast integrate_order_s integrate_order_s_1 is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error Source Code integrator_runge_kutta_lssp Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alpha (:) \\alpha coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. procedure( integrate_interface ), private, pointer :: integrate_ => integrate_order_s_1 Integrate integrand field. procedure( integrate_fast_interface ), private, pointer :: integrate_fast_ => integrate_order_s_1_fast Integrate integrand field, fast. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. private subroutine assign_multistage (lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. private elemental subroutine destroy_multistage (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, U, stages, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. integer(kind=I_P), intent(in), optional :: stages Stages number. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, private, pass(self) :: initialize_order_s Integrate integrator for s-th order formula. private elemental subroutine initialize_order_s (self) Initialize integrator for s-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. procedure, private, pass(self) :: initialize_order_s_1 Integrate integrator for (s-1)-th order formula. private elemental subroutine initialize_order_s_1 (self) Initialize integrator for (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate integrand field by Linear SSP Runge-Kutta methods. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate integrand field by Linear SSP Runge-Kutta methods. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, private, pass(self) :: integrate_order_s Integrate integrand field by s-th order formula. private subroutine integrate_order_s (self, U, Dt, t) Integrate integrand field by s-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, private, pass(self) :: integrate_order_s_1 Integrate integrand field by (s-1)-th order formula. private subroutine integrate_order_s_1 (self, U, Dt, t) Integrate integrand field by (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_lssp !< FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ), allocatable :: alpha (:) !< \\alpha coefficients. procedure ( integrate_interface ), pointer :: integrate_ => integrate_order_s_1 !< Integrate integrand field. procedure ( integrate_fast_interface ), pointer :: integrate_fast_ => integrate_order_s_1_fast !< Integrate integrand field, fast. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. ! private methods procedure , pass ( self ), private :: initialize_order_s_1 !< Integrate integrator for (s-1)-th order formula. procedure , pass ( self ), private :: initialize_order_s !< Integrate integrator for s-th order formula. procedure , pass ( self ), private :: integrate_order_s_1 !< Integrate integrand field by (s-1)-th order formula. procedure , pass ( self ), private :: integrate_order_s !< Integrate integrand field by s-th order formula. endtype integrator_runge_kutta_lssp","tags":"","loc":"type/integrator_runge_kutta_lssp.html","title":"integrator_runge_kutta_lssp – FOODIE "},{"text":"type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_ssp type~~integrator_runge_kutta_ssp~~InheritsGraph type~integrator_runge_kutta_ssp integrator_runge_kutta_ssp type~integrand_object integrand_object type~integrand_object->type~integrator_runge_kutta_ssp buffer, stage type~integrator_multistage_object integrator_multistage_object type~integrand_object->type~integrator_multistage_object buffer, stage type~integrator_multistage_object->type~integrator_runge_kutta_ssp type~integrator_object integrator_object type~integrator_object->type~integrator_multistage_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coefficients) before used. Variables alph beta buffer description_ error error_message gamm registers stage stages Type-Bound Procedures allocate_integrand_members assign_abstract assign_multistage assignment(=) check_error class_name description destroy destroy_abstract destroy_multistage has_fast_mode initialize integr_assign_integr integrate integrate_fast is_multistage is_multistep is_supported stages_number steps_number supported_schemes trigger_error Source Code integrator_runge_kutta_ssp Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:) \\beta Butcher's coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. private subroutine assign_multistage (lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => integr_assign_integr Overload = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: check_error Check for error occurrencies. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. procedure, public, pass(self) :: class_name Return the class name of schemes. private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. procedure, public, pass(self) :: description Return informative integrator description. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. private elemental subroutine destroy_multistage (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: initialize Initialize (create) the integrator. private subroutine initialize (self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. procedure, public, pass(lhs) :: integr_assign_integr Operator = . private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit SSP Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit SSP Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. procedure, public, pass(self) :: stages_number Return number of stages used. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. procedure, public, pass(self) :: trigger_error Trigger an error. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code type , extends ( integrator_multistage_object ) :: integrator_runge_kutta_ssp !< FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coefficients) before used. private real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains ! deferred methods procedure , pass ( self ) :: class_name !< Return the class name of schemes. procedure , pass ( self ) :: has_fast_mode !< Return .true. if the integrator class has *fast mode* integrate. procedure , pass ( lhs ) :: integr_assign_integr !< Operator `=`. procedure , pass ( self ) :: integrate !< Integrate integrand field. procedure , pass ( self ) :: integrate_fast !< Integrate integrand field, fast mode. procedure , pass ( self ) :: is_supported !< Return .true. if the integrator class support the given scheme. procedure , pass ( self ) :: supported_schemes !< Return the list of supported schemes. ! public methods procedure , pass ( self ) :: destroy !< Destroy the integrator. procedure , pass ( self ) :: initialize !< Initialize (create) the integrator. endtype integrator_runge_kutta_ssp","tags":"","loc":"type/integrator_runge_kutta_ssp.html","title":"integrator_runge_kutta_ssp – FOODIE "},{"text":"type, public :: lcce_test type~~lcce_test~~InheritsGraph type~lcce_test lcce_test command_line_interface command_line_interface command_line_interface->type~lcce_test cli Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Class to handle linear constant coefficients equation test(s). Test is driven by the Command Line Interface (CLI) options. Test has only 1 public method execute : it executes test(s) accordingly to cli options. Variables Dt U0 a b cli error errors_analysis exact_solution final_time implicit_iterations is_fast output results scheme stages Type-Bound Procedures execute initialize test Source Code lcce_test Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. real(kind=R_P), private :: U0 = 0._R_P Initial conditions. real(kind=R_P), private :: a = 0._R_P a coefficient. real(kind=R_P), private :: b = 0._R_P b coefficient. type(command_line_interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error = 0 Error handler. logical, private :: errors_analysis = .false. Flag for activating errors analysis. logical, private :: exact_solution = .false. Flag for activating exact solution saving. real(kind=R_P), private :: final_time = 0.0_R_P Final integration time. integer(kind=I_P), private :: implicit_iterations = 0 Number of iterations (implicit solvers). logical, private :: is_fast = .false. Flag for activating fast schemes. character(len=99), private :: output = '' Output files basename. logical, private :: results = .false. Flag for activating results saving. character(len=99), private :: scheme = '' Scheme used. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). private subroutine execute (self) Execute selected test(s). Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(inout) :: self Test. procedure, private, pass(self) :: initialize Initialize test: set Command Line Interface, parse it and check its validity. private subroutine initialize (self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(inout) :: self Test. procedure, private, pass(self) :: test Perform the test. private subroutine test (self, scheme) Perform the test. Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(in) :: self Test. character(len=*), intent(in) :: scheme Selected scheme. Source Code type :: lcce_test !< Class to handle linear constant coefficients equation test(s). !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error = 0 !< Error handler. character ( 99 ) :: scheme = '' !< Scheme used. logical :: is_fast = . false . !< Flag for activating fast schemes. integer ( I_P ) :: implicit_iterations = 0 !< Number of iterations (implicit solvers). integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. real ( R_P ) :: a = 0._R_P !< *a* coefficient. real ( R_P ) :: b = 0._R_P !< *b* coefficient. real ( R_P ) :: U0 = 0._R_P !< Initial conditions. real ( R_P ) :: final_time = 0.0_R_P !< Final integration time. logical :: results = . false . !< Flag for activating results saving. character ( 99 ) :: output = '' !< Output files basename. logical :: exact_solution = . false . !< Flag for activating exact solution saving. logical :: errors_analysis = . false . !< Flag for activating errors analysis. contains ! public methods procedure , pass ( self ) :: execute !< Execute selected test(s). ! private methods procedure , pass ( self ), private :: initialize !< Initialize test: set Command Line Interface, parse it and check its validity. procedure , pass ( self ), private :: test !< Perform the test. endtype lcce_test","tags":"","loc":"type/lcce_test.html","title":"lcce_test – FOODIE "},{"text":"type, public :: oscillation_test type~~oscillation_test~~InheritsGraph type~oscillation_test oscillation_test command_line_interface command_line_interface command_line_interface->type~oscillation_test cli Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Class to handle oscillation test(s). Test is driven by the Command Line Interface (CLI) options. Test has only 1 public method execute : it executes test(s) accordingly to cli options. Variables Dt U0 cli error errors_analysis exact_solution final_time frequency implicit_iterations is_fast output results scheme stages Type-Bound Procedures execute initialize test Source Code oscillation_test Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. real(kind=R_P), private :: U0 (1:2) = [0._R_P, 0._R_P] Initial conditions. type(command_line_interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error = 0 Error handler. logical, private :: errors_analysis = .false. Flag for activating errors analysis. logical, private :: exact_solution = .false. Flag for activating exact solution saving. real(kind=R_P), private :: final_time = 0.0_R_P Final integration time. real(kind=R_P), private :: frequency = 0.0_R_P Oscillation frequency. integer(kind=I_P), private :: implicit_iterations = 0 Number of iterations (implicit solvers). logical, private :: is_fast = .false. Flag for activating fast schemes. character(len=99), private :: output = '' Output files basename. logical, private :: results = .false. Flag for activating results saving. character(len=99), private :: scheme = '' Scheme used. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). private subroutine execute (self) Execute test(s). Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. procedure, private, pass(self) :: initialize Initialize test: set Command Line Interface, parse it and check its validity. private subroutine initialize (self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. procedure, private, pass(self) :: test Perform the test. private subroutine test (self, scheme) Perform the test. Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(in) :: self Test. character(len=*), intent(in) :: scheme Selected scheme. Source Code type :: oscillation_test !< Class to handle oscillation test(s). !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error = 0 !< Error handler. character ( 99 ) :: scheme = '' !< Scheme used. logical :: is_fast = . false . !< Flag for activating fast schemes. integer ( I_P ) :: implicit_iterations = 0 !< Number of iterations (implicit solvers). integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. real ( R_P ) :: frequency = 0.0_R_P !< Oscillation frequency. real ( R_P ) :: U0 ( 1 : 2 ) = [ 0._R_P , 0._R_P ] !< Initial conditions. real ( R_P ) :: final_time = 0.0_R_P !< Final integration time. logical :: results = . false . !< Flag for activating results saving. character ( 99 ) :: output = '' !< Output files basename. logical :: exact_solution = . false . !< Flag for activating exact solution saving. logical :: errors_analysis = . false . !< Flag for activating errors analysis. contains ! public methods procedure , pass ( self ) :: execute !< Execute selected test(s). ! private methods procedure , pass ( self ), private :: initialize !< Initialize test: set Command Line Interface, parse it and check its validity. procedure , pass ( self ), private :: test !< Perform the test. endtype oscillation_test","tags":"","loc":"type/oscillation_test.html","title":"oscillation_test – FOODIE "},{"text":"type, public :: euler_1D_caf_nf type~~euler_1d_caf_nf~~InheritsGraph type~euler_1d_caf_nf euler_1D_caf_nf weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_caf_nf weno Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Euler 1D (CAF enabled) PDEs system field. Note This object does not use FOODIE. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E) Variables BC_L BC_R Dx Nc Ng Ni Np Ns U cp0 cv0 me ord we weno Type-Bound Procedures assign_integrand assignment(=) conservative2primitive destroy dt impose_boundary_conditions init output primitive2conservative reconstruct_interfaces_states riemann_solver synchronize t Source Code euler_1D_caf_nf Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: we = 0 Number of CAF images used. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_integrand Overloading = assignament. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. procedure, public, pass(self) :: destroy Destroy field. private subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self, conservative) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. procedure, private, pass(self) :: synchronize Synchronize CAF images. private subroutine synchronize (self) Synchronize CAF images. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_caf_nf ) Euler field time derivative. Source Code type :: euler_1D_caf_nf !< Euler 1D (CAF enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_caf_nf","tags":"","loc":"type/euler_1d_caf_nf.html","title":"euler_1D_caf_nf – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator TVD RK integrator. Note The integrator must be created or initialized (initialize the RK coeficients) before used. Variables alph beta gamm stages Type-Bound Procedures destroy init integrate Source Code tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), public :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. private elemental subroutine destroy_rk (self) Destoy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. private elemental subroutine init_rk (self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. private subroutine integrate_rk (self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_caf_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_caf_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D_caf type~~euler_1d_caf~~InheritsGraph type~euler_1d_caf euler_1D_caf weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_caf weno integrand integrand integrand->type~euler_1d_caf Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E) Variables BC_L BC_R Dx Nc Ng Ni Np Ns U cp0 cv0 me ord we weno Type-Bound Procedures add assign_integrand assign_real conservative2primitive destroy dt impose_boundary_conditions init integrand_multiply_integrand integrand_multiply_real local_error output primitive2conservative real_multiply_integrand reconstruct_interfaces_states riemann_solver sub synchronize t Source Code euler_1D_caf Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: we = 0 Number of CAF images used. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. procedure, public, pass(self) :: destroy Destroy field. private subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self, conservative) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_caf ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, private, pass(self) :: synchronize Synchronize CAF images. private subroutine synchronize (self) Synchronize CAF images. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. Source Code type , extends ( integrand ) :: euler_1D_caf !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. integer ( I_P ) :: me = 0 !< ID of this_image(). integer ( I_P ) :: we = 0 !< Number of CAF images used. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: synchronize !< Synchronize CAF images. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_caf","tags":"","loc":"type/euler_1d_caf.html","title":"euler_1D_caf – FOODIE "},{"text":"type, public :: euler_1D_omp_nf type~~euler_1d_omp_nf~~InheritsGraph type~euler_1d_omp_nf euler_1D_omp_nf weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_omp_nf weno Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Euler 1D (OpenMP enabled) PDEs system field. Note This object does not use FOODIE. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E) Variables BC_L BC_R Dx Nc Ng Ni Np Ns U cp0 cv0 ord weno Type-Bound Procedures assign_integrand assignment(=) conservative2primitive destroy dt impose_boundary_conditions init output primitive2conservative reconstruct_interfaces_states riemann_solver t Source Code euler_1D_omp_nf Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_integrand Overloading = assignament. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_omp_nf ) Euler field time derivative. Source Code type :: euler_1D_omp_nf !< Euler 1D (OpenMP enabled) PDEs system field. !< !< @note This object does not use FOODIE. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. generic , public :: assignment ( = ) => assign_integrand !< Overloading = assignament. ! private methods procedure , pass ( self ), private :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), private :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_omp_nf","tags":"","loc":"type/euler_1d_omp_nf.html","title":"euler_1D_omp_nf – FOODIE "},{"text":"type, public :: tvd_runge_kutta_integrator TVD RK integrator. Note The integrator must be created or initialized (initialize the RK coeficients) before used. Variables alph beta gamm stages Type-Bound Procedures destroy init integrate Source Code tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), public :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. private elemental subroutine destroy_rk (self) Destoy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. private elemental subroutine init_rk (self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. private subroutine integrate_rk (self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_omp_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_omp_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code type :: tvd_runge_kutta_integrator !< TVD RK integrator. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy => destroy_rk !< Destroy the integrator. procedure , pass ( self ), public :: init => init_rk !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate => integrate_rk !< Integrate integrand field. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator~2.html","title":"tvd_runge_kutta_integrator – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D_openmp type~~euler_1d_openmp~~InheritsGraph type~euler_1d_openmp euler_1D_openmp weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d_openmp weno integrand integrand integrand->type~euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Euler 1D (OpenMP enabled) PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E) Variables BC_L BC_R Dx Nc Ng Ni Np Ns U cp0 cv0 ord weno Type-Bound Procedures add assign_integrand assign_real conservative2primitive destroy dt impose_boundary_conditions init integrand_multiply_integrand integrand_multiply_real local_error output primitive2conservative real_multiply_integrand reconstruct_interfaces_states riemann_solver sub t Source Code euler_1D_openmp Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_openmp ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. Source Code type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !<||euler-euler||. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D_openmp","tags":"","loc":"type/euler_1d_openmp.html","title":"euler_1D_openmp – FOODIE "},{"text":"type, public, extends(integrand) :: burgers type~~burgers~~InheritsGraph type~burgers burgers integrand integrand integrand->type~burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Burgers equations field. It is a FOODIE integrand class concrete extension. Burgers PDE equation The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe\na wide range of different problems, from fluid dynamics to traffic flows, see [1]. \n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = [u]\\;\\;\\;\nF(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x]\n\\end{matrix}\n This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains\ncomplex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature\nof the viscous term. Bibliography [1] The partial differential equation ut + uux = nuxx , Hopf, Eberhard, Communications on Pure and Applied Mathematics,\n vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201–230, 1950. State variables organization State variable is organized as an array (rank 1) for whole physical domain. Variables Ni U dims h nu previous steps Type-Bound Procedures add assign_integrand assign_real dt init integrand_multiply_integrand integrand_multiply_real local_error output previous_step real_multiply_integrand sub t update_previous_steps x xx Source Code burgers Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: Ni = 0 Number of grid nodes. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. integer(kind=I_P), private :: steps = 0 Number of time steps stored. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. private function add_burgers (lhs, rhs) result(opr) Add two Burgers fields. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. private subroutine burgers_assign_burgers (lhs, rhs) Assign one Burgers field to another. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. private subroutine burgers_assign_real (lhs, rhs) Assign one real to a Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, CFL) result(dt) Compute the current time step, by means of CFL condition. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, Ni, h, nu, steps) Construct an initialized Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. private function burgers_multiply_burgers (lhs, rhs) result(opr) Multiply a Burgers field by another one. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. private function burgers_multiply_real (lhs, rhs) result(opr) Multiply a Burgers field by a real scalar. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: local_error => burgers_local_error Local error. private function burgers_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 burgers approximations. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract Burgers field. private pure function output (self) result(state) Output the Burgers field state. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:), allocatable Burgers state variable. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Extract previous time solution of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Burgers field. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. private function real_multiply_burgers (lhs, rhs) result(opr) Multiply a real scalar by a Burgers field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. private function sub_burgers (lhs, rhs) result(opr) Subtract two Burgers fields. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. private function dBurgers_dt (self, t) result(dState_dt) Time derivative of Burgers field, residuals function. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Burgers field time derivative. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. private function dBurgers_dx (self) result(derivative) Compute the first order spatial derivative of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. private function d2Burgers_dx2 (self) result(derivative) Compute the second order spatial derivative of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. Source Code type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: local_error => burgers_local_error !< Local error. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers","tags":"","loc":"type/burgers.html","title":"burgers – FOODIE "},{"text":"type, public, extends(integrand) :: euler_1D type~~euler_1d~~InheritsGraph type~euler_1d euler_1D weno_interpolator_upwind weno_interpolator_upwind weno_interpolator_upwind->type~euler_1d weno integrand integrand integrand->type~euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Euler 1D PDEs system field. It is a FOODIE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E) Variables BC_L BC_R Dx Nc Ng Ni Np Ns U cp0 cv0 ord previous steps weno Type-Bound Procedures add assign_integrand assign_real conservative2primitive destroy dt impose_boundary_conditions init integrand_multiply_integrand integrand_multiply_real local_error output previous_step primitive2conservative real_multiply_integrand reconstruct_interfaces_states riemann_solver sub t update_previous_steps Source Code euler_1D Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. integer(kind=I_P), private :: steps = 0 Number of time steps stored. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. procedure, public, pass(self) :: destroy Destroy field. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: local_error => euler_local_error Local error. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract Euler field. private pure function output (self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Extract previous time solution of Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private pure subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Source Code type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => euler_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. endtype euler_1D","tags":"","loc":"type/euler_1d.html","title":"euler_1D – FOODIE "},{"text":"type, public, extends(integrand) :: lorenz type~~lorenz~~InheritsGraph type~lorenz lorenz integrand integrand integrand->type~lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Lorenz equations field. It is a FOODIE integrand class concrete extension. Lorenz ODEs system The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a\nsystem, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. The Lorenz' ODEs system can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2 \\\\\n v_3\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n \\sigma (v_2-v_1) \\\\\n v_1(\\rho - v_3) -v_2 \\\\\n v_1 v_2 - \\beta v_3\n \\end{bmatrix}\n\\end{matrix} The parameters set is constant and it is here selected as: \\begin{matrix}\n \\sigma = 10 \\\\\n \\rho = 28 \\\\\n \\beta = \\frac{8}{3}\n\\end{matrix} These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. Bibliography [1] Deterministic Nonperiodic Flow , Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130–141,\ndoi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 [2] Scientific software design: the object-oriented way , Rouson, Damian, Jim Xia, and Xiaofeng Xu,\nCambridge University Press, 2011 State variables organization State variables are organized as an array (rank 1) of reals of dims elements, in this case 3 elements. Variables U beta dims previous rho sigma steps Type-Bound Procedures add assign_integrand assign_real init integrand_multiply_integrand integrand_multiply_real local_error output previous_step real_multiply_integrand sub t update_previous_steps Source Code lorenz Components Type Visibility Attributes Name Initial real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. integer(kind=I_P), private :: steps = 0 Number of time steps stored. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. private function add_lorenz (lhs, rhs) result(opr) Add two Lorenz fields. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. private subroutine lorenz_assign_lorenz (lhs, rhs) Assign one Lorenz field to another. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. private subroutine lorenz_assign_real (lhs, rhs) Assign one real to a Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, sigma, rho, beta, steps) Construct an initialized Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Multiply a lorenz field by another one. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. private function lorenz_multiply_real (lhs, rhs) result(opr) Multiply a Lorenz field by a real scalar. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: local_error => lorenz_local_error Local error. private function lorenz_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 lorenz approximations. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract Lorenz field. private pure function output (self) result(state) Output the Lorenz field state. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:), allocatable Lorenz state vector. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Extract previous time solution of Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Lorenz field. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. private function real_multiply_lorenz (lhs, rhs) result(opr) Multiply a real scalar by a Lorenz field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. private function sub_lorenz (lhs, rhs) result(opr) Subtract two Lorenz fields. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. private function dLorenz_dt (self, t) result(dState_dt) Time derivative of Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Lorenz field time derivative. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Source Code type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODIE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODIE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! ADT integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( lhs ), public :: local_error => lorenz_local_error !< Local error. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz","tags":"","loc":"type/lorenz.html","title":"lorenz – FOODIE "},{"text":"type, public, extends( integrand_tester_object ) :: integrand_ladvection type~~integrand_ladvection~~InheritsGraph type~integrand_ladvection integrand_ladvection interpolator_object interpolator_object interpolator_object->type~integrand_ladvection interpolator type~integrand_tester_object integrand_tester_object type~integrand_tester_object->type~integrand_ladvection type~integrand_object integrand_object type~integrand_object->type~integrand_tester_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). 1D linear advection field. It is a FOODIE integrand class concrete extension. 1D linear advection field The 1D linear advection equation is a conservation law that reads as\n\n\\begin{matrix}\nu_t = R(u)  \\Leftrightarrow u_t = F(u)_x \\\\\nF(u) = a * u\n\n where a is scalar constant coefficient. The PDE must completed with the proper initial and boundary conditions. Numerical grid organization The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at\n the cell center. The cell and (inter)faces numeration is as follow. cell            (inter)faces\n                 |                   |\n                 v                   v\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng |\n     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------|\n    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng Where Ni are the finite volumes (cells) used for discretizing the domain and Ng are the ghost cells used for imposing the\n left and right boundary conditions (for a total of 2Ng cells). Inherited By type~~integrand_ladvection~~InheritedByGraph type~integrand_ladvection integrand_ladvection type~test_object test_object type~integrand_ladvection->type~test_object ladvection_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables CFL Dx Ng Ni a dummy_to_allow_extensions initial_state interpolator length u w_scheme weno_eps weno_order Type-Bound Procedures add_fast assign_integrand assign_real assignment(=) compute_dx description destroy dt error exact_solution export_tecplot impose_boundary_conditions initialize integrand_add_integrand integrand_add_integrand_fast integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_integrand_fast integrand_multiply_real integrand_multiply_real_scalar integrand_multiply_real_scalar_fast integrand_sub_integrand integrand_sub_real integrand_subtract_integrand_fast local_error multiply_fast operator(*) operator(+) operator(-) operator(.lterror.) output parse_cli real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand reconstruct_interfaces set_cli set_sin_wave_initial_state set_square_wave_initial_state subtract_fast t t_fast Source Code integrand_ladvection Components Type Visibility Attributes Name Initial real(kind=R_P), public :: CFL = 0._R_P CFL value. real(kind=R_P), public :: Dx = 0._R_P Space step. integer(kind=I_P), public :: Ng = 0 Ghost cells number. integer(kind=I_P), public :: Ni = 0 Space dimension. real(kind=R_P), public :: a = 0._R_P Advection coefficient. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. character(len=99), public :: initial_state Initial state. class(interpolator_object), public, allocatable :: interpolator WENO interpolator. real(kind=R_P), public :: length = 0._R_P Domain length. real(kind=R_P), public, allocatable :: u (:) Integrand (state) variable. character(len=99), public :: w_scheme = '' WENO Scheme used. real(kind=R_P), public :: weno_eps = 0._R_P WENO epsilon to avoid division by zero, default value. integer(kind=I_P), public :: weno_order = 0 WENO reconstruction order. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_integrand = operator. private subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real = real operator. private pure subroutine assign_real (lhs, rhs) Assign one real to an advection field. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. generic, public :: assignment(=) => assign_integrand , assign_real Overloading = assignament. private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. procedure, public, pass(self) :: compute_dx Compute the space step by means of CFL condition. private pure function compute_dx (self, Dt) result(Dx) Compute the space step step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: Dt Time step. Return Value real(kind=R_P) Space step. procedure, public, pass(self) :: description Return an informative description of the test. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy field. private subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step by means of CFL condition. private pure function compute_dt (self, final_time, t) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: final_time Maximum integration time. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P) Time step. procedure, public, pass(self) :: error Return error. private pure function error (self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. procedure, public, pass(self) :: exact_solution Return exact solution. private pure function exact_solution (self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. procedure, public, pass(self) :: export_tecplot Export integrand to Tecplot file. private subroutine export_tecplot (self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private pure subroutine impose_boundary_conditions (self, u) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(inout) :: u (1-self%Ng:) Conservative variables. procedure, public, pass(self) :: initialize Initialize integrand. private subroutine initialize (self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. procedure, public, pass(lhs) :: integrand_add_integrand + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_add_real + real operator. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(self) :: integrand_dimension Return integrand dimension. private pure function integrand_dimension (self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. procedure, public, pass(lhs) :: integrand_multiply_integrand * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_multiply_real * real operator. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_sub_integrand - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(lhs) :: integrand_sub_real - real operator. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: local_error ||integrand_ladvection - integrand_ladvection|| operator. private function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 advection approximations. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. generic, public :: multiply_fast => integrand_multiply_integrand_fast , integrand_multiply_real_scalar_fast Overloading multiply_fast method. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(*) => integrand_multiply_integrand , integrand_multiply_real , real_multiply_integrand , integrand_multiply_real_scalar , real_scalar_multiply_integrand Overloading * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(+) => integrand_add_integrand , integrand_add_real , real_add_integrand Overloading + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(-) => integrand_sub_integrand , integrand_sub_real , real_sub_integrand Overloading - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract integrand state field. private pure function output (self) result(state) Output the advection field state. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. Return Value real(kind=R_P),\n  allocatable, (:) Advection state procedure, public, pass(self) :: parse_cli Initialize from command line interface. private subroutine parse_cli (self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. procedure, public, pass(rhs) :: real_add_integrand real + operator. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_multiply_integrand real * operator. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_ladvection ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_sub_integrand real - operator. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, private, pass(self) :: reconstruct_interfaces Reconstruct interface states. private subroutine reconstruct_interfaces (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: conservative (1-self%Ng:) Conservative variables. real(kind=R_P), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. procedure, public, nopass :: set_cli Set command line interface. private subroutine set_cli (cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. procedure, private, pass(self) :: set_sin_wave_initial_state Set initial state as a sin wave. private subroutine set_sin_wave_initial_state (self) Set initial state as a sin wave. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. procedure, private, pass(self) :: set_square_wave_initial_state Set initial state as a square wave. private subroutine set_square_wave_initial_state (self) Set initial state as a square wave. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: t => dU_dt Time derivative, residuals. private function dU_dt (self, t) result(dState_dt) Time derivative of advection field, the residuals function. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Advection field time derivative. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Source Code type , extends ( integrand_tester_object ) :: integrand_ladvection !< 1D linear advection field. !< !< It is a FOODIE integrand class concrete extension. !< !<### 1D linear advection field !< The 1D linear advection equation is a conservation law that reads as !< !<\\begin{matrix} !<u_t = R(u)  \\Leftrightarrow u_t = F(u)_x \\\\ !<F(u) = a * u !< !< where `a` is scalar constant coefficient. The PDE must completed with the proper initial and boundary conditions. !< !<#### Numerical grid organization !< The finite volume, Godunov's like approach is employed. The conservative variables (and the primitive ones) are co-located at !< the cell center. The cell and (inter)faces numeration is as follow. !<``` !<                cell            (inter)faces !<                 |                   | !<                 v                   v !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<     | 1-Ng  | 2-Ng  | ..... |  -1   |   0   |   1   |  2    | ..... |  Ni   | Ni+1  | Ni+1  | ..... |Ni+Ng-1| Ni+Ng | !<     |-------|-------|-.....-|-------|-------|-------|-------|-.....-|-------|-------|-------|-.....-|-------|-------| !<    0-Ng                             -1      0       1       2      Ni-1     Ni                                    Ni+Ng !<``` !< Where *Ni* are the finite volumes (cells) used for discretizing the domain and *Ng* are the ghost cells used for imposing the !< left and right boundary conditions (for a total of *2Ng* cells). character ( 99 ) :: w_scheme = '' !< WENO Scheme used. integer ( I_P ) :: weno_order = 0 !< WENO reconstruction order. real ( R_P ) :: weno_eps = 0._R_P !< WENO epsilon to avoid division by zero, default value. real ( R_P ) :: CFL = 0._R_P !< CFL value. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Ghost cells number. real ( R_P ) :: length = 0._R_P !< Domain length. real ( R_P ) :: Dx = 0._R_P !< Space step. real ( R_P ) :: a = 0._R_P !< Advection coefficient. real ( R_P ), allocatable :: u (:) !< Integrand (state) variable. class ( interpolator_object ), allocatable :: interpolator !< WENO interpolator. character ( 99 ) :: initial_state !< Initial state. contains ! auxiliary methods procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step by means of CFL condition. procedure , pass ( self ), public :: compute_dx !< Compute the space step by means of CFL condition. procedure , pass ( self ), public :: output !< Extract integrand state field. ! integrand_tester_object deferred methods procedure , pass ( self ), public :: description !< Return an informative description of the test. procedure , pass ( self ), public :: error !< Return error. procedure , pass ( self ), public :: exact_solution !< Return exact solution. procedure , pass ( self ), public :: export_tecplot !< Export integrand to Tecplot file. procedure , pass ( self ), public :: initialize !< Initialize integrand. procedure , pass ( self ), public :: parse_cli !< Initialize from command line interface. procedure , nopass , public :: set_cli !< Set command line interface. ! integrand_object deferred methods procedure , pass ( self ), public :: integrand_dimension !< Return integrand dimension. procedure , pass ( self ), public :: t => dU_dt !< Time derivative, residuals. ! operators procedure , pass ( lhs ), public :: local_error !<`||integrand_ladvection - integrand_ladvection||` operator. ! + procedure , pass ( lhs ), public :: integrand_add_integrand !< `+` operator. procedure , pass ( lhs ), public :: integrand_add_real !< `+ real` operator. procedure , pass ( rhs ), public :: real_add_integrand !< `real +` operator. ! * procedure , pass ( lhs ), public :: integrand_multiply_integrand !< `*` operator. procedure , pass ( lhs ), public :: integrand_multiply_real !< `* real` operator. procedure , pass ( rhs ), public :: real_multiply_integrand !< `real *` operator. procedure , pass ( lhs ), public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure , pass ( rhs ), public :: real_scalar_multiply_integrand !< `real_scalar *` operator. ! - procedure , pass ( lhs ), public :: integrand_sub_integrand !< `-` operator. procedure , pass ( lhs ), public :: integrand_sub_real !< `- real` operator. procedure , pass ( rhs ), public :: real_sub_integrand !< `real -` operator. ! = procedure , pass ( lhs ), public :: assign_integrand !< `=` operator. procedure , pass ( lhs ), public :: assign_real !< `= real` operator. ! override fast operators ! procedure, pass(self), public :: t_fast                              !< Time derivative, residuals, fast mode. ! procedure, pass(opr),  public :: integrand_add_integrand_fast        !< `+` fast operator. ! procedure, pass(opr),  public :: integrand_multiply_integrand_fast   !< `*` fast operator. ! procedure, pass(opr),  public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. ! procedure, pass(opr),  public :: integrand_subtract_integrand_fast   !< `-` fast operator. ! private methods procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces !< Reconstruct interface states. procedure , pass ( self ), private :: set_sin_wave_initial_state !< Set initial state as a sin wave. procedure , pass ( self ), private :: set_square_wave_initial_state !< Set initial state as a square wave. endtype integrand_ladvection","tags":"","loc":"type/integrand_ladvection.html","title":"integrand_ladvection – FOODIE "},{"text":"type, public, extends( integrand_tester_object ) :: integrand_lcce type~~integrand_lcce~~InheritsGraph type~integrand_lcce integrand_lcce type~integrand_tester_object integrand_tester_object type~integrand_tester_object->type~integrand_lcce type~integrand_object integrand_object type~integrand_object->type~integrand_tester_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). The linear constant coefficient equation field. It is a FOODIE integrand class concrete extension. ODE The linear constant coefficient equation is a linear pure ODE and it can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n y\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n a*y + b\n \\end{bmatrix}\n\\end{matrix} The coefficent a,b are constant with a \\ne 0. The exact solution is  U(t) = (U_0 + \\frac{b}{a}) e &#94;{a(t-t_0)} - \\frac{b){a}  where t_0 is the initial time of integration. Bibliography [1] ORDINARY DIFFERENTIAL EQUATIONS , Gabriel Nagy, 2017. Inherited By type~~integrand_lcce~~InheritedByGraph type~integrand_lcce integrand_lcce type~test_object test_object type~integrand_lcce->type~test_object lcce_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables U U0 a b dummy_to_allow_extensions Type-Bound Procedures add_fast assign_integrand assign_real assignment(=) description error exact_solution export_tecplot initialize integrand_add_integrand integrand_add_integrand_fast integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_integrand_fast integrand_multiply_real integrand_multiply_real_scalar integrand_multiply_real_scalar_fast integrand_sub_integrand integrand_sub_real integrand_subtract_integrand_fast local_error multiply_fast operator(*) operator(+) operator(-) operator(.lterror.) output parse_cli real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand set_cli subtract_fast t t_fast Source Code integrand_lcce Components Type Visibility Attributes Name Initial real(kind=R_P), private :: U = 0._R_P Integrand (state) variable. real(kind=R_P), private :: U0 = 0._R_P Integrand initial state. real(kind=R_P), private :: a = 0._R_P a constant. real(kind=R_P), private :: b = 0._R_P b constant. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_integrand = operator. private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real = real operator. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. generic, public :: assignment(=) => assign_integrand , assign_real Overloading = assignament. private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. procedure, public, pass(self) :: description Return an informative description of the test. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: error Return error. private pure function error (self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. procedure, public, pass(self) :: exact_solution Return exact solution. private pure function exact_solution (self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. procedure, public, pass(self) :: export_tecplot Export integrand to Tecplot file. private subroutine export_tecplot (self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. procedure, public, pass(self) :: initialize Initialize field. private pure subroutine initialize (self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. procedure, public, pass(lhs) :: integrand_add_integrand + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_add_real + real operator. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(self) :: integrand_dimension Return integrand dimension. private pure function integrand_dimension (self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. procedure, public, pass(lhs) :: integrand_multiply_integrand * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_multiply_real * real operator. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_sub_integrand - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(lhs) :: integrand_sub_real - real operator. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: local_error ||integrand_lcce - integrand_lcce|| operator. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. generic, public :: multiply_fast => integrand_multiply_integrand_fast , integrand_multiply_real_scalar_fast Overloading multiply_fast method. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(*) => integrand_multiply_integrand , integrand_multiply_real , real_multiply_integrand , integrand_multiply_real_scalar , real_scalar_multiply_integrand Overloading * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(+) => integrand_add_integrand , integrand_add_real , real_add_integrand Overloading + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(-) => integrand_sub_integrand , integrand_sub_real , real_sub_integrand Overloading - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract integrand state field. private pure function output (self) result(state) Extract integrand state field. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. Return Value real(kind=R_P) State. procedure, public, pass(self) :: parse_cli Initialize from command line interface. private subroutine parse_cli (self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. procedure, public, pass(rhs) :: real_add_integrand real + operator. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_multiply_integrand real * operator. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_lcce ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_sub_integrand real - operator. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, nopass :: set_cli Set command line interface. private subroutine set_cli (cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: t => dU_dt Time derivative, residuals. private pure function dU_dt (self, t) result(dState_dt) Time derivative of field. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Integrand time derivative. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Source Code type , extends ( integrand_tester_object ) :: integrand_lcce !< The linear constant coefficient equation field. !< !< It is a FOODIE integrand class concrete extension. !< !<### ODE !<The linear constant coefficient equation is a linear pure ODE and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< y !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< a*y + b !< \\end{bmatrix} !<\\end{matrix} !< !<The coefficent *a,b* are constant with a \\ne 0. The exact solution is !< !< U(t) = (U_0 + \\frac{b}{a}) e &#94;{a(t-t_0)} - \\frac{b){a}  !< !< where t_0 is the initial time of integration. !< !<#### Bibliography !< !<[1] *ORDINARY DIFFERENTIAL EQUATIONS*, Gabriel Nagy, 2017. !< private real ( R_P ) :: a = 0._R_P !< *a* constant. real ( R_P ) :: b = 0._R_P !< *b* constant. real ( R_P ) :: U = 0._R_P !< Integrand (state) variable. real ( R_P ) :: U0 = 0._R_P !< Integrand initial state. contains ! auxiliary methods procedure , pass ( self ), public :: output !< Extract integrand state field. ! integrand_tester_object deferred methods procedure , pass ( self ), public :: description !< Return an informative description of the test. procedure , pass ( self ), public :: error !< Return error. procedure , pass ( self ), public :: exact_solution !< Return exact solution. procedure , pass ( self ), public :: export_tecplot !< Export integrand to Tecplot file. procedure , pass ( self ), public :: initialize !< Initialize field. procedure , pass ( self ), public :: parse_cli !< Initialize from command line interface. procedure , nopass , public :: set_cli !< Set command line interface. ! integrand_object deferred methods procedure , pass ( self ), public :: integrand_dimension !< Return integrand dimension. procedure , pass ( self ), public :: t => dU_dt !< Time derivative, residuals. ! operators procedure , pass ( lhs ), public :: local_error !<`||integrand_lcce - integrand_lcce||` operator. ! + procedure , pass ( lhs ), public :: integrand_add_integrand !< `+` operator. procedure , pass ( lhs ), public :: integrand_add_real !< `+ real` operator. procedure , pass ( rhs ), public :: real_add_integrand !< `real +` operator. ! * procedure , pass ( lhs ), public :: integrand_multiply_integrand !< `*` operator. procedure , pass ( lhs ), public :: integrand_multiply_real !< `* real` operator. procedure , pass ( rhs ), public :: real_multiply_integrand !< `real *` operator. procedure , pass ( lhs ), public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure , pass ( rhs ), public :: real_scalar_multiply_integrand !< `real_scalar *` operator. ! - procedure , pass ( lhs ), public :: integrand_sub_integrand !< `-` operator. procedure , pass ( lhs ), public :: integrand_sub_real !< `- real` operator. procedure , pass ( rhs ), public :: real_sub_integrand !< `real -` operator. ! = procedure , pass ( lhs ), public :: assign_integrand !< `=` operator. procedure , pass ( lhs ), public :: assign_real !< `= real` operator. ! override fast operators procedure , pass ( self ), public :: t_fast !< Time derivative, residuals, fast mode. procedure , pass ( opr ), public :: integrand_add_integrand_fast !< `+` fast operator. procedure , pass ( opr ), public :: integrand_multiply_integrand_fast !< `*` fast operator. procedure , pass ( opr ), public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. procedure , pass ( opr ), public :: integrand_subtract_integrand_fast !< `-` fast operator. endtype integrand_lcce","tags":"","loc":"type/integrand_lcce.html","title":"integrand_lcce – FOODIE "},{"text":"type, public, extends( integrand_tester_object ) :: integrand_oscillation type~~integrand_oscillation~~InheritsGraph type~integrand_oscillation integrand_oscillation type~integrand_tester_object integrand_tester_object type~integrand_tester_object->type~integrand_oscillation type~integrand_object integrand_object type~integrand_object->type~integrand_tester_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). The oscillation equations field. It is a FOODIE integrand class concrete extension. Oscillation ODEs system The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n -f v_2 \\\\\n f v_1\n \\end{bmatrix}\n\\end{matrix} The frequency f is constant and it is here selected as f=10&#94;-4 . In the space v1-v2 the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not\nstable leading to a wrong path, see [1]. Bibliography [1] Numerical Methods for Fluid Dynamics With Applications to Geophysics , Dale R. Durran, Springer, 2010. State variables organization State variables are organized as an array (rank 1) of reals of n=2 elements. Inherited By type~~integrand_oscillation~~InheritedByGraph type~integrand_oscillation integrand_oscillation type~test_object test_object type~integrand_oscillation->type~test_object oscillation_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables U U0 dummy_to_allow_extensions f Type-Bound Procedures add_fast amplitude_phase assign_integrand assign_real assignment(=) description error exact_solution export_tecplot initialize integrand_add_integrand integrand_add_integrand_fast integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_integrand_fast integrand_multiply_real integrand_multiply_real_scalar integrand_multiply_real_scalar_fast integrand_sub_integrand integrand_sub_real integrand_subtract_integrand_fast local_error multiply_fast operator(*) operator(+) operator(-) operator(.lterror.) output parse_cli real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand set_cli subtract_fast t t_fast Source Code integrand_oscillation Components Type Visibility Attributes Name Initial real(kind=R_P), private :: U (1:2) = [0._R_P, 0._R_P] Integrand (state) variables. real(kind=R_P), private :: U0 (1:2) = [0._R_P, 0._R_P] Initial state. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: amplitude_phase Return amplitude and phase of the oscillation. private function amplitude_phase (self) result(ap) Compute amplitude and phase of the oscillation. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Advection field. Return Value real(kind=R_P)\n  (1:2) Amplitude and phase. procedure, public, pass(lhs) :: assign_integrand = operator. private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real = real operator. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. generic, public :: assignment(=) => assign_integrand , assign_real Overloading = assignament. private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. procedure, public, pass(self) :: description Return an informative description of the test. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: error Return error. private pure function error (self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. procedure, public, pass(self) :: exact_solution Return exact solution. private pure function exact_solution (self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. procedure, public, pass(self) :: export_tecplot Export integrand to Tecplot file. private subroutine export_tecplot (self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. procedure, public, pass(self) :: initialize Initialize field. private pure subroutine initialize (self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. procedure, public, pass(lhs) :: integrand_add_integrand + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_add_real + real operator. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(self) :: integrand_dimension Return integrand dimension. private pure function integrand_dimension (self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. procedure, public, pass(lhs) :: integrand_multiply_integrand * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_multiply_real * real operator. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: integrand_sub_integrand - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(lhs) :: integrand_sub_real - real operator. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: local_error ||integrand_oscillation - integrand_oscillation|| operator. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. generic, public :: multiply_fast => integrand_multiply_integrand_fast , integrand_multiply_real_scalar_fast Overloading multiply_fast method. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(*) => integrand_multiply_integrand , integrand_multiply_real , real_multiply_integrand , integrand_multiply_real_scalar , real_scalar_multiply_integrand Overloading * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(+) => integrand_add_integrand , integrand_add_real , real_add_integrand Overloading + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(-) => integrand_sub_integrand , integrand_sub_real , real_sub_integrand Overloading - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure, public, pass(self) :: output Extract integrand state field. private pure function output (self) result(state) Extract integrand state field. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. Return Value real(kind=R_P)\n  (1:2) State. procedure, public, pass(self) :: parse_cli Initialize from command line interface. private subroutine parse_cli (self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. procedure, public, pass(rhs) :: real_add_integrand real + operator. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_multiply_integrand real * operator. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(rhs) :: real_sub_integrand real - operator. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, nopass :: set_cli Set command line interface. private subroutine set_cli (cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: t => dU_dt Time derivative, residuals. private pure function dU_dt (self, t) result(dState_dt) Time derivative of integrand_oscillation field. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Integrand time derivative. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Source Code type , extends ( integrand_tester_object ) :: integrand_oscillation !< The oscillation equations field. !< !< It is a FOODIE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *n=2* elements. private real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). real ( R_P ) :: U0 ( 1 : 2 ) = [ 0._R_P , 0._R_P ] !< Initial state. real ( R_P ) :: U ( 1 : 2 ) = [ 0._R_P , 0._R_P ] !< Integrand (state) variables. contains ! auxiliary methods procedure , pass ( self ), public :: amplitude_phase !< Return amplitude and phase of the oscillation. procedure , pass ( self ), public :: output !< Extract integrand state field. ! integrand_tester_object deferred methods procedure , pass ( self ), public :: description !< Return an informative description of the test. procedure , pass ( self ), public :: error !< Return error. procedure , pass ( self ), public :: exact_solution !< Return exact solution. procedure , pass ( self ), public :: export_tecplot !< Export integrand to Tecplot file. procedure , pass ( self ), public :: initialize !< Initialize field. procedure , pass ( self ), public :: parse_cli !< Initialize from command line interface. procedure , nopass , public :: set_cli !< Set command line interface. ! integrand_object deferred methods procedure , pass ( self ), public :: integrand_dimension !< Return integrand dimension. procedure , pass ( self ), public :: t => dU_dt !< Time derivative, residuals. ! operators procedure , pass ( lhs ), public :: local_error !<`||integrand_oscillation - integrand_oscillation||` operator. ! + procedure , pass ( lhs ), public :: integrand_add_integrand !< `+` operator. procedure , pass ( lhs ), public :: integrand_add_real !< `+ real` operator. procedure , pass ( rhs ), public :: real_add_integrand !< `real +` operator. ! * procedure , pass ( lhs ), public :: integrand_multiply_integrand !< `*` operator. procedure , pass ( lhs ), public :: integrand_multiply_real !< `* real` operator. procedure , pass ( rhs ), public :: real_multiply_integrand !< `real *` operator. procedure , pass ( lhs ), public :: integrand_multiply_real_scalar !< `* real_scalar` operator. procedure , pass ( rhs ), public :: real_scalar_multiply_integrand !< `real_scalar *` operator. ! - procedure , pass ( lhs ), public :: integrand_sub_integrand !< `-` operator. procedure , pass ( lhs ), public :: integrand_sub_real !< `- real` operator. procedure , pass ( rhs ), public :: real_sub_integrand !< `real -` operator. ! = procedure , pass ( lhs ), public :: assign_integrand !< `=` operator. procedure , pass ( lhs ), public :: assign_real !< `= real` operator. ! override fast operators procedure , pass ( self ), public :: t_fast !< Time derivative, residuals, fast mode. procedure , pass ( opr ), public :: integrand_add_integrand_fast !< `+` fast operator. procedure , pass ( opr ), public :: integrand_multiply_integrand_fast !< `*` fast operator. procedure , pass ( opr ), public :: integrand_multiply_real_scalar_fast !< `* real_scalar` fast operator. procedure , pass ( opr ), public :: integrand_subtract_integrand_fast !< `-` fast operator. endtype integrand_oscillation","tags":"","loc":"type/integrand_oscillation.html","title":"integrand_oscillation – FOODIE "},{"text":"type, public, abstract, extends( integrand_object ) :: integrand_tester_object type~~integrand_tester_object~~InheritsGraph type~integrand_tester_object integrand_tester_object type~integrand_object integrand_object type~integrand_object->type~integrand_tester_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). The abstract tester integrand. This abstract provided some auxiliary methods useful for the tester machinery. Inherited By type~~integrand_tester_object~~InheritedByGraph type~integrand_tester_object integrand_tester_object type~test_object test_object type~integrand_tester_object->type~test_object integrand_0 type~integrand_ladvection integrand_ladvection type~integrand_tester_object->type~integrand_ladvection type~integrand_lcce integrand_lcce type~integrand_tester_object->type~integrand_lcce type~integrand_oscillation integrand_oscillation type~integrand_tester_object->type~integrand_oscillation type~integrand_ladvection->type~test_object ladvection_0 type~integrand_lcce->type~test_object lcce_0 type~integrand_oscillation->type~test_object oscillation_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables dummy_to_allow_extensions Type-Bound Procedures add_fast assign_integrand assign_real assignment(=) description error exact_solution export_tecplot initialize integrand_add_integrand integrand_add_integrand_fast integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_integrand_fast integrand_multiply_real integrand_multiply_real_scalar integrand_multiply_real_scalar_fast integrand_sub_integrand integrand_sub_real integrand_subtract_integrand_fast local_error multiply_fast operator(*) operator(+) operator(-) operator(.lterror.) parse_cli real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand set_cli subtract_fast t t_fast Source Code integrand_tester_object Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( assignment_integrand ), public, deferred, pass(lhs) :: assign_integrand = operator. subroutine assignment_integrand (lhs, rhs) Prototype Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( assignment_real ), public, deferred, pass(lhs) :: assign_real = real operator. pure subroutine assignment_real (lhs, rhs) Prototype Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. generic, public :: assignment(=) => assign_integrand , assign_real Overloading = assignament. private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. procedure( description_interface ), public, deferred, pass(self) :: description Return an informative description of the test. pure function description_interface (self, prefix) result(desc) Prototype Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( error_interface ), public, deferred, pass(self) :: error Return error. pure function error_interface (self, t, t0, U0) result(error) Prototype Return error. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. procedure( exact_solution_interface ), public, deferred, pass(self) :: exact_solution Return exact solution. pure function exact_solution_interface (self, t, t0, U0) result(exact) Prototype Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. procedure( export_tecplot_interface ), public, deferred, pass(self) :: export_tecplot Export integrand to Tecplot file. subroutine export_tecplot_interface (self, file_name, t, scheme, close_file, with_exact_solution, U0) Prototype Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize integrand. subroutine initialize_interface (self, Dt) Prototype Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. procedure( symmetric_operator ), public, deferred, pass(lhs) :: integrand_add_integrand + operator. pure function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( integrand_op_real ), public, deferred, pass(lhs) :: integrand_add_real + real operator. pure function integrand_op_real (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( integrand_dimension_interface ), public, deferred, pass(self) :: integrand_dimension Return integrand dimension. pure function integrand_dimension_interface (self) result(integrand_dimension) Prototype Return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand. Return Value integer(kind=I_P) Integrand dimension. procedure( symmetric_operator ), public, deferred, pass(lhs) :: integrand_multiply_integrand * operator. pure function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( integrand_op_real ), public, deferred, pass(lhs) :: integrand_multiply_real * real operator. pure function integrand_op_real (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( integrand_op_real_scalar ), public, deferred, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. pure function integrand_op_real_scalar (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. procedure( symmetric_operator ), public, deferred, pass(lhs) :: integrand_sub_integrand - operator. pure function symmetric_operator (lhs, rhs) result(operator_result) Prototype Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( integrand_op_real ), public, deferred, pass(lhs) :: integrand_sub_real - real operator. pure function integrand_op_real (lhs, rhs) result(operator_result) Prototype Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( local_error_operator ), public, deferred, pass(lhs) :: local_error ||integrand - integrand|| operator. function local_error_operator (lhs, rhs) result(error) Prototype Estimate local truncation error between 2 solution approximations. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. generic, public :: multiply_fast => integrand_multiply_integrand_fast , integrand_multiply_real_scalar_fast Overloading multiply_fast method. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. generic, public :: operator(*) => integrand_multiply_integrand , integrand_multiply_real , real_multiply_integrand , integrand_multiply_real_scalar , real_scalar_multiply_integrand Overloading * operator. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(+) => integrand_add_integrand , integrand_add_real , real_add_integrand Overloading + operator. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(-) => integrand_sub_integrand , integrand_sub_real , real_sub_integrand Overloading - operator. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. procedure( parse_cli_interface ), public, deferred, pass(self) :: parse_cli Initialize from command line interface. subroutine parse_cli_interface (self, cli) Prototype Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(inout) :: self Integrand. type(command_line_interface), intent(inout) :: cli Command line interface handler. procedure( real_op_integrand ), public, deferred, pass(rhs) :: real_add_integrand real + operator. pure function real_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( real_op_integrand ), public, deferred, pass(rhs) :: real_multiply_integrand real * operator. pure function real_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( real_scalar_op_integrand ), public, deferred, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. pure function real_scalar_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( real_op_integrand ), public, deferred, pass(rhs) :: real_sub_integrand real - operator. pure function real_op_integrand (lhs, rhs) result(operator_result) Prototype Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. procedure( set_cli_interface ), public, deferred, nopass :: set_cli Set command line interface. subroutine set_cli_interface (cli) Prototype Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. procedure( time_derivative ), public, deferred, pass(self) :: t Time derivative, residuals. function time_derivative (self, t) result(dState_dt) Prototype Time derivative function of integrand class, i.e. the residuals function. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Result of the time derivative function of integrand field. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Source Code type , abstract , extends ( integrand_object ) :: integrand_tester_object !< The abstract tester integrand. !< !< This abstract provided some auxiliary methods useful for the tester machinery. contains procedure ( description_interface ), pass ( self ), deferred :: description !< Return an informative description of the test. procedure ( error_interface ), pass ( self ), deferred :: error !< Return error. procedure ( exact_solution_interface ), pass ( self ), deferred :: exact_solution !< Return exact solution. procedure ( export_tecplot_interface ), pass ( self ), deferred :: export_tecplot !< Export integrand to Tecplot file. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize integrand. procedure ( parse_cli_interface ), pass ( self ), deferred :: parse_cli !< Initialize from command line interface. procedure ( set_cli_interface ), nopass , deferred :: set_cli !< Set command line interface. endtype integrand_tester_object","tags":"","loc":"type/integrand_tester_object.html","title":"integrand_tester_object – FOODIE "},{"text":"type, public :: test_object type~~test_object~~InheritsGraph type~test_object test_object command_line_interface command_line_interface command_line_interface->type~test_object cli type~integrand_oscillation integrand_oscillation type~integrand_oscillation->type~test_object oscillation_0 type~integrand_lcce integrand_lcce type~integrand_lcce->type~test_object lcce_0 type~integrand_ladvection integrand_ladvection type~integrand_ladvection->type~test_object ladvection_0 type~integrand_tester_object integrand_tester_object type~integrand_tester_object->type~test_object integrand_0 type~integrand_tester_object->type~integrand_oscillation type~integrand_tester_object->type~integrand_lcce type~integrand_tester_object->type~integrand_ladvection interpolator_object interpolator_object interpolator_object->type~integrand_ladvection interpolator type~integrand_object integrand_object type~integrand_object->type~integrand_tester_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Generic FOODIE test object. Test is driven by the Command Line Interface (CLI) options. Test has only 1 public method execute : it executes test(s) accordingly to cli options. Variables Dt cli error final_time implicit_iterations integrand_0 is_fast ladvection_0 lcce_0 oscillation_0 output save_frequency save_results scheme stages Type-Bound Procedures execute initialize Source Code test_object Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. type(command_line_interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error Error handler. real(kind=R_P), private :: final_time Final integration time. integer(kind=I_P), private :: implicit_iterations Number of iterations (implicit solvers). class( integrand_tester_object ), private, allocatable :: integrand_0 Initial conditions. logical, private :: is_fast Flag for activating fast schemes. type( integrand_ladvection ), private :: ladvection_0 Initial conditions for linear advection test. type( integrand_lcce ), private :: lcce_0 Initial conditions for linear constant coefficients eq. type( integrand_oscillation ), private :: oscillation_0 Initial conditions for oscillation test. character(len=99), private :: output Output files basename. integer(kind=I_P), private :: save_frequency Save frequency. logical, private :: save_results Flag for activating results saving. character(len=99), private :: scheme Scheme used. integer(kind=I_P), private :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). private subroutine execute (self) Execute test(s). Arguments Type Intent Optional Attributes Name class( test_object ), intent(inout) :: self Test. procedure, private, pass(self) :: initialize Initialize test: set Command Line Interface, parse it and check its validity. private subroutine initialize (self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( test_object ), intent(inout) :: self Test. Source Code type :: test_object !< Generic FOODIE test object. !< !< Test is driven by the Command Line Interface (CLI) options. !< !< Test has only 1 public method `execute`: it executes test(s) accordingly to cli options. private type ( command_line_interface ) :: cli !< Command line interface handler. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: scheme !< Scheme used. real ( R_P ), allocatable :: Dt (:) !< Time step(s) exercised. logical :: is_fast !< Flag for activating fast schemes. integer ( I_P ) :: implicit_iterations !< Number of iterations (implicit solvers). integer ( I_P ) :: stages !< Number of stages. real ( R_P ) :: final_time !< Final integration time. logical :: save_results !< Flag for activating results saving. character ( 99 ) :: output !< Output files basename. integer ( I_P ) :: save_frequency !< Save frequency. type ( integrand_lcce ) :: lcce_0 !< Initial conditions for linear constant coefficients eq. type ( integrand_ladvection ) :: ladvection_0 !< Initial conditions for linear advection test. type ( integrand_oscillation ) :: oscillation_0 !< Initial conditions for oscillation test. class ( integrand_tester_object ), allocatable :: integrand_0 !< Initial conditions. contains ! public methods procedure , pass ( self ) :: execute !< Execute selected test(s). ! private methods procedure , pass ( self ), private :: initialize !< Initialize test: set Command Line Interface, parse it and check its validity. endtype test_object","tags":"","loc":"type/test_object.html","title":"test_object – FOODIE "},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private subroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure subroutine assignment_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_real.html","title":"assignment_real – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function integrand_dimension_interface(self) result(integrand_dimension) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand. Return Value integer(kind=I_P) Integrand dimension. Description Return integrand dimension.","tags":"","loc":"interface/integrand_dimension_interface.html","title":"integrand_dimension_interface – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function integrand_op_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Description Asymmetric type operator integrand.op.real .","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function integrand_op_real_scalar(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Description Asymmetric type operator integrand.op.real .","tags":"","loc":"interface/integrand_op_real_scalar.html","title":"integrand_op_real_scalar – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private function local_error_operator(lhs, rhs) result(error) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Description Estimate local truncation error between 2 solution approximations.","tags":"","loc":"interface/local_error_operator.html","title":"local_error_operator – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function real_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Description Asymmetric type operator real.op.integrand .","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function real_scalar_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Description Asymmetric type operator real.op.integrand .","tags":"","loc":"interface/real_scalar_op_integrand.html","title":"real_scalar_op_integrand – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FOODIE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private function time_derivative(self, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable,(:) Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – FOODIE"},{"text":"abstract interface Abstract interfaces of integrator_lmm_ssp_vss methods. private subroutine integrate_fast_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with LMM-SSP class scheme.","tags":"","loc":"interface/integrate_fast_interface.html","title":"integrate_fast_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrator_lmm_ssp_vss methods. private subroutine integrate_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with LMM-SSP class scheme.","tags":"","loc":"interface/integrate_interface.html","title":"integrate_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_multistage_multistep_object . private subroutine integrate_fast_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate integrand field, fast mode.","tags":"","loc":"interface/integrate_fast_interface~2.html","title":"integrate_fast_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_multistage_multistep_object . private subroutine integrate_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate integrand field.","tags":"","loc":"interface/integrate_interface~2.html","title":"integrate_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_multistage_object . private subroutine integrate_fast_interface(self, U, Dt, t, new_Dt) Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Description Integrate integrand field, fast mode.","tags":"","loc":"interface/integrate_fast_interface~3.html","title":"integrate_fast_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_multistage_object . private subroutine integrate_interface(self, U, Dt, t, new_Dt) Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Description Integrate integrand field.","tags":"","loc":"interface/integrate_interface~3.html","title":"integrate_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_multistep_object . private subroutine integrate_fast_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Description Integrate integrand field, fast mode.","tags":"","loc":"interface/integrate_fast_interface~4.html","title":"integrate_fast_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_multistep_object . private subroutine integrate_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Description Integrate integrand field.","tags":"","loc":"interface/integrate_interface~4.html","title":"integrate_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private subroutine assignment_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assignment_interface.html","title":"assignment_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private pure function class_name_interface(self) result(class_name) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Description Return the class name of schemes.","tags":"","loc":"interface/class_name_interface.html","title":"class_name_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface~2.html","title":"description_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function has_fast_mode_interface(self) result(has_fast_mode) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Description Return .true. if the integrator class has fast mode integrate.","tags":"","loc":"interface/has_fast_mode_interface.html","title":"has_fast_mode_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function is_multistagestep_interface(self) result(is_multistagestep) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Description Return .true. for multistage or multistep integrator.","tags":"","loc":"interface/is_multistagestep_interface.html","title":"is_multistagestep_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function is_supported_interface(self, scheme) result(is_supported) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Queried scheme. Return Value logical Inquire result. Description Return .true. if the integrator class support the given scheme.","tags":"","loc":"interface/is_supported_interface.html","title":"is_supported_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function stagesteps_number_interface(self) result(stagesteps_number) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Inquire result. Description Return number of stages/steps used.","tags":"","loc":"interface/stagesteps_number_interface.html","title":"stagesteps_number_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of deferred methods of integrator_object . private pure function supported_schemes_interface(self) result(schemes) Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Description Return the list of supported schemes.","tags":"","loc":"interface/supported_schemes_interface.html","title":"supported_schemes_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrator_runge_kutta_lssp methods. private subroutine integrate_fast_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Description Integrate field with Linear SSP Runge-Kutta scheme, fast mode.","tags":"","loc":"interface/integrate_fast_interface~5.html","title":"integrate_fast_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrator_runge_kutta_lssp methods. private subroutine integrate_interface(self, U, Dt, t) Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Description Integrate field with Linear SSP Runge-Kutta scheme.","tags":"","loc":"interface/integrate_interface~5.html","title":"integrate_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrand_tester_object class. private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return informative integrator description.","tags":"","loc":"interface/description_interface.html","title":"description_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrand_tester_object class. private pure function error_interface(self, t, t0, U0) result(error) Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Error. Description Return error.","tags":"","loc":"interface/error_interface.html","title":"error_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrand_tester_object class. private pure function exact_solution_interface(self, t, t0, U0) result(exact) Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Exact solution. Description Return exact solution.","tags":"","loc":"interface/exact_solution_interface.html","title":"exact_solution_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrand_tester_object class. private subroutine export_tecplot_interface(self, file_name, t, scheme, close_file, with_exact_solution, U0) Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Description Export integrand to Tecplot file.","tags":"","loc":"interface/export_tecplot_interface.html","title":"export_tecplot_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrand_tester_object class. private subroutine initialize_interface(self, Dt) Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. Description Initialize integrand.","tags":"","loc":"interface/initialize_interface.html","title":"initialize_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrand_tester_object class. private subroutine parse_cli_interface(self, cli) Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(inout) :: self Integrand. type(command_line_interface), intent(inout) :: cli Command line interface handler. Description Initialize from command line interface.","tags":"","loc":"interface/parse_cli_interface.html","title":"parse_cli_interface – FOODIE"},{"text":"abstract interface Abstract interfaces of integrand_tester_object class. private subroutine set_cli_interface(cli) Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. Description Set command line interface.","tags":"","loc":"interface/set_cli_interface.html","title":"set_cli_interface – FOODIE"},{"text":"public pure function foodie_integrator_class_names() result(names) Return the list of available intergrator class of schemes names. Arguments None Return Value character(len=99),\n  allocatable,(:) Available integrator class names. Calls proc~~foodie_integrator_class_names~~CallsGraph proc~foodie_integrator_class_names foodie_integrator_class_names class_name class_name proc~foodie_integrator_class_names->class_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~foodie_integrator_class_names~~CalledByGraph proc~foodie_integrator_class_names foodie_integrator_class_names proc~is_class_available is_class_available proc~is_class_available->proc~foodie_integrator_class_names proc~execute execute proc~execute->proc~is_class_available proc~is_available is_available proc~execute->proc~is_available proc~execute~3 execute proc~execute~3->proc~is_class_available proc~execute~3->proc~is_available proc~is_available->proc~is_class_available proc~execute~2 execute proc~execute~2->proc~is_class_available proc~execute~2->proc~is_available Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code foodie_integrator_class_names Source Code pure function foodie_integrator_class_names () result ( names ) !< Return the list of available intergrator class of schemes names. character ( len = 99 ), allocatable :: names (:) !< Available integrator class names. type ( integrator_adams_bashforth ) :: int_adams_bashforth !< Integrator Adams Bashforth. type ( integrator_adams_bashforth_moulton ) :: int_adams_bashforth_moulton !< Integrator Adams Bashforth Moulton. type ( integrator_adams_moulton ) :: int_adams_moulton !< Integrator Adams Moulton. type ( integrator_back_df ) :: int_back_df !< Integrator back differentiation formula. type ( integrator_euler_explicit ) :: int_euler_explicit !< Integrator euler explicit. type ( integrator_leapfrog ) :: int_leapfrog !< Integrator leapfrog. type ( integrator_lmm_ssp ) :: int_lmm_ssp !< Integrator lmm SSP. type ( integrator_lmm_ssp_vss ) :: int_lmm_ssp_vss !< Integrator lmm SSP VSS. type ( integrator_ms_runge_kutta_ssp ) :: int_ms_runge_kutta_ssp !< Integrator multistep Runge Kutta ssp. type ( integrator_runge_kutta_emd ) :: int_runge_kutta_emd !< Integrator Runge Kutta embdedded. type ( integrator_runge_kutta_ls ) :: int_runge_kutta_ls !< Integrator Runge Kutta low storage. type ( integrator_runge_kutta_lssp ) :: int_runge_kutta_lssp !< Integrator linear Runge Kutta SSP. type ( integrator_runge_kutta_ssp ) :: int_runge_kutta_ssp !< Integrator Runge Kutta SSP. names = [ int_adams_bashforth % class_name ()] names = [ names , int_adams_bashforth_moulton % class_name ()] names = [ names , int_adams_moulton % class_name ()] names = [ names , int_back_df % class_name ()] names = [ names , int_euler_explicit % class_name ()] names = [ names , int_leapfrog % class_name ()] names = [ names , int_lmm_ssp % class_name ()] names = [ names , int_lmm_ssp_vss % class_name ()] names = [ names , int_ms_runge_kutta_ssp % class_name ()] names = [ names , int_runge_kutta_emd % class_name ()] names = [ names , int_runge_kutta_ls % class_name ()] names = [ names , int_runge_kutta_lssp % class_name ()] names = [ names , int_runge_kutta_ssp % class_name ()] endfunction foodie_integrator_class_names","tags":"","loc":"proc/foodie_integrator_class_names.html","title":"foodie_integrator_class_names – FOODIE"},{"text":"public pure function foodie_integrator_schemes(class_name) result(schemes) Return the list of all available intergrator schemes, or only the schemes belonging to the given class name. Note In the case the class name passed is not available the schemes array is returned not allocated and not warnings are\n given: it is up to the caller to check the status of the schemes array. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: class_name Return only the schemes belogn to the given class. Return Value character(len=99),\n  allocatable,(:) Available integrators. Calls proc~~foodie_integrator_schemes~~CallsGraph proc~foodie_integrator_schemes foodie_integrator_schemes supported_schemes supported_schemes proc~foodie_integrator_schemes->supported_schemes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~foodie_integrator_schemes~~CalledByGraph proc~foodie_integrator_schemes foodie_integrator_schemes proc~execute execute proc~execute->proc~foodie_integrator_schemes proc~is_available is_available proc~execute->proc~is_available proc~execute~3 execute proc~execute~3->proc~foodie_integrator_schemes proc~execute~3->proc~is_available proc~is_scheme_available is_scheme_available proc~is_scheme_available->proc~foodie_integrator_schemes proc~execute~2 execute proc~execute~2->proc~foodie_integrator_schemes proc~execute~2->proc~is_available proc~is_available->proc~is_scheme_available Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code foodie_integrator_schemes Source Code pure function foodie_integrator_schemes ( class_name ) result ( schemes ) !< Return the list of all available intergrator schemes, or only the schemes belonging to the given class name. !< !< @note In the case the class name passed is not available the schemes array is returned not allocated and not warnings are !< given: it is up to the caller to check the status of the schemes array. character ( * ), intent ( in ), optional :: class_name !< Return only the schemes belogn to the given class. character ( len = 99 ), allocatable :: schemes (:) !< Available integrators. type ( integrator_adams_bashforth ) :: int_adams_bashforth !< Integrator Adams Bashforth. type ( integrator_adams_bashforth_moulton ) :: int_adams_bashforth_moulton !< Integrator Adams Bashforth Moulton. type ( integrator_adams_moulton ) :: int_adams_moulton !< Integrator Adams Moulton. type ( integrator_back_df ) :: int_back_df !< Integrator back differentiation formula. type ( integrator_euler_explicit ) :: int_euler_explicit !< Integrator euler explicit. type ( integrator_leapfrog ) :: int_leapfrog !< Integrator leapfrog. type ( integrator_lmm_ssp ) :: int_lmm_ssp !< Integrator lmm SSP. type ( integrator_lmm_ssp_vss ) :: int_lmm_ssp_vss !< Integrator lmm SSP VSS. type ( integrator_ms_runge_kutta_ssp ) :: int_ms_runge_kutta_ssp !< Integrator multistep Runge Kutta ssp. type ( integrator_runge_kutta_emd ) :: int_runge_kutta_emd !< Integrator Runge Kutta embdedded. type ( integrator_runge_kutta_ls ) :: int_runge_kutta_ls !< Integrator Runge Kutta low storage. type ( integrator_runge_kutta_lssp ) :: int_runge_kutta_lssp !< Integrator linear Runge Kutta SSP. type ( integrator_runge_kutta_ssp ) :: int_runge_kutta_ssp !< Integrator Runge Kutta SSP. if ( present ( class_name )) then if ( trim ( int_adams_bashforth % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_adams_bashforth % supported_schemes () elseif ( trim ( int_adams_bashforth_moulton % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_adams_bashforth_moulton % supported_schemes () elseif ( trim ( int_adams_moulton % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_adams_moulton % supported_schemes () elseif ( trim ( int_back_df % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_back_df % supported_schemes () elseif ( trim ( int_euler_explicit % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_euler_explicit % supported_schemes () elseif ( trim ( int_leapfrog % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_leapfrog % supported_schemes () elseif ( trim ( int_lmm_ssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_lmm_ssp % supported_schemes () elseif ( trim ( int_lmm_ssp_vss % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_lmm_ssp_vss % supported_schemes () elseif ( trim ( int_ms_runge_kutta_ssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_ms_runge_kutta_ssp % supported_schemes () elseif ( trim ( int_runge_kutta_emd % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_emd % supported_schemes () elseif ( trim ( int_runge_kutta_ls % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_ls % supported_schemes () elseif ( trim ( int_runge_kutta_lssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_lssp % supported_schemes () elseif ( trim ( int_runge_kutta_ssp % class_name ()) == trim ( adjustl ( class_name ))) then schemes = int_runge_kutta_ssp % supported_schemes () endif else schemes = int_adams_bashforth % supported_schemes () schemes = [ schemes , int_adams_bashforth_moulton % supported_schemes ()] schemes = [ schemes , int_adams_moulton % supported_schemes ()] schemes = [ schemes , int_back_df % supported_schemes ()] schemes = [ schemes , int_euler_explicit % supported_schemes ()] schemes = [ schemes , int_leapfrog % supported_schemes ()] schemes = [ schemes , int_lmm_ssp % supported_schemes ()] schemes = [ schemes , int_lmm_ssp_vss % supported_schemes ()] schemes = [ schemes , int_ms_runge_kutta_ssp % supported_schemes ()] schemes = [ schemes , int_runge_kutta_emd % supported_schemes ()] schemes = [ schemes , int_runge_kutta_ls % supported_schemes ()] schemes = [ schemes , int_runge_kutta_lssp % supported_schemes ()] schemes = [ schemes , int_runge_kutta_ssp % supported_schemes ()] endif endfunction foodie_integrator_schemes","tags":"","loc":"proc/foodie_integrator_schemes.html","title":"foodie_integrator_schemes – FOODIE"},{"text":"public pure function is_available(scheme) Return .true. if the given scheme (or class of schemes name) is available in the FOODIE library. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. Return Value logical Availability result. Calls proc~~is_available~~CallsGraph proc~is_available is_available proc~is_class_available is_class_available proc~is_available->proc~is_class_available proc~is_scheme_available is_scheme_available proc~is_available->proc~is_scheme_available proc~foodie_integrator_class_names foodie_integrator_class_names proc~is_class_available->proc~foodie_integrator_class_names proc~foodie_integrator_schemes foodie_integrator_schemes proc~is_scheme_available->proc~foodie_integrator_schemes class_name class_name proc~foodie_integrator_class_names->class_name supported_schemes supported_schemes proc~foodie_integrator_schemes->supported_schemes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~is_available~~CalledByGraph proc~is_available is_available proc~execute execute proc~execute->proc~is_available proc~execute~2 execute proc~execute~2->proc~is_available proc~execute~3 execute proc~execute~3->proc~is_available Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_available Source Code pure function is_available ( scheme ) !< Return .true. if the given scheme (or class of schemes name) is available in the FOODIE library. character ( * ), intent ( in ) :: scheme !< Selected integrator given. logical :: is_available !< Availability result. is_available = is_class_available ( scheme = scheme ) if ( is_available ) return is_available = is_scheme_available ( scheme = scheme ) if ( is_available ) return endfunction is_available","tags":"","loc":"proc/is_available.html","title":"is_available – FOODIE"},{"text":"public pure function is_class_available(scheme) Return .true. if the given class of schemes name is available. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. Return Value logical Availability result. Calls proc~~is_class_available~~CallsGraph proc~is_class_available is_class_available proc~foodie_integrator_class_names foodie_integrator_class_names proc~is_class_available->proc~foodie_integrator_class_names class_name class_name proc~foodie_integrator_class_names->class_name Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~is_class_available~~CalledByGraph proc~is_class_available is_class_available proc~execute execute proc~execute->proc~is_class_available proc~is_available is_available proc~execute->proc~is_available proc~execute~3 execute proc~execute~3->proc~is_class_available proc~execute~3->proc~is_available proc~is_available->proc~is_class_available proc~execute~2 execute proc~execute~2->proc~is_class_available proc~execute~2->proc~is_available Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_class_available Source Code pure function is_class_available ( scheme ) !< Return .true. if the given class of schemes name is available. character ( * ), intent ( in ) :: scheme !< Selected integrator given. logical :: is_class_available !< Availability result. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. integer ( I_P ) :: i !< Counter. integrator_class_names = foodie_integrator_class_names () is_class_available = . false . do i = 1 , size ( integrator_class_names , dim = 1 ) is_class_available = ( trim ( adjustl ( scheme )) == trim ( adjustl ( integrator_class_names ( i )))) if ( is_class_available ) return enddo endfunction is_class_available","tags":"","loc":"proc/is_class_available.html","title":"is_class_available – FOODIE"},{"text":"public pure function is_scheme_available(scheme) Return .true. if the given scheme (class name) is available in the FOODIE library. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. Return Value logical Availability result. Calls proc~~is_scheme_available~~CallsGraph proc~is_scheme_available is_scheme_available proc~foodie_integrator_schemes foodie_integrator_schemes proc~is_scheme_available->proc~foodie_integrator_schemes supported_schemes supported_schemes proc~foodie_integrator_schemes->supported_schemes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~is_scheme_available~~CalledByGraph proc~is_scheme_available is_scheme_available proc~is_available is_available proc~is_available->proc~is_scheme_available proc~execute execute proc~execute->proc~is_available proc~execute~2 execute proc~execute~2->proc~is_available proc~execute~3 execute proc~execute~3->proc~is_available Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_scheme_available Source Code pure function is_scheme_available ( scheme ) !< Return .true. if the given scheme (class name) is available in the FOODIE library. character ( * ), intent ( in ) :: scheme !< Selected integrator given. logical :: is_scheme_available !< Availability result. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: i !< Counter. integrator_schemes = foodie_integrator_schemes () is_scheme_available = . false . do i = 1 , size ( integrator_schemes , dim = 1 ) is_scheme_available = ( trim ( adjustl ( scheme )) == trim ( adjustl ( integrator_schemes ( i )))) if ( is_scheme_available ) return enddo endfunction is_scheme_available","tags":"","loc":"proc/is_scheme_available.html","title":"is_scheme_available – FOODIE"},{"text":"public subroutine foodie_integrator_factory(scheme, integrator, stages, tolerance, nu, alpha, iterations, autoupdate, U) Return a concrete instance of integrator_object given a scheme selection. This is the FOODIE integrators factory. Note If an error occurs the error status of integrator_object is updated. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. class( integrator_object ), intent(out), allocatable :: integrator The FOODIE integrator. integer(kind=I_P), intent(in), optional :: stages Stages of multi-stage methods. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate for multistep. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. Called By proc~~foodie_integrator_factory~~CalledByGraph proc~foodie_integrator_factory foodie_integrator_factory proc~integrate~16 integrate proc~integrate~16->proc~foodie_integrator_factory proc~integrate~14 integrate proc~integrate~14->proc~foodie_integrator_factory proc~integrate~15 integrate proc~integrate~15->proc~foodie_integrator_factory proc~execute~3 execute proc~execute~3->proc~integrate~16 proc~test test proc~test->proc~integrate~14 proc~test~2 test proc~test~2->proc~integrate~15 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code foodie_integrator_factory Source Code subroutine foodie_integrator_factory ( scheme , integrator , stages , tolerance , nu , alpha , iterations , autoupdate , U ) !< Return a concrete instance of [[integrator_object]] given a scheme selection. !< !< This is the FOODIE integrators factory. !< !< @note If an error occurs the error status of [[integrator_object]] is updated. character ( * ), intent ( in ) :: scheme !< Selected integrator given. class ( integrator_object ), allocatable , intent ( out ) :: integrator !< The FOODIE integrator. integer ( I_P ), optional , intent ( in ) :: stages !< Stages of multi-stage methods. real ( R_P ), optional , intent ( in ) :: tolerance !< Tolerance on the local truncation error. real ( R_P ), optional , intent ( in ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( in ) :: alpha !< Robert-Asselin filter coefficient. integer ( I_P ), optional , intent ( in ) :: iterations !< Implicit iterations. logical , optional , intent ( in ) :: autoupdate !< Enable cyclic autoupdate for multistep. class ( integrand_object ), optional , intent ( in ) :: U !< Integrand molding prototype. type ( integrator_adams_bashforth ) :: int_adams_bashforth !< Integrator Adams Bashforth. type ( integrator_adams_bashforth_moulton ) :: int_adams_bashforth_moulton !< Integrator Adams Bashforth Moulton. type ( integrator_adams_moulton ) :: int_adams_moulton !< Integrator Adams Moulton. type ( integrator_back_df ) :: int_back_df !< Integrator back differentiation formula. type ( integrator_euler_explicit ) :: int_euler_explicit !< Integrator euler explicit. type ( integrator_leapfrog ) :: int_leapfrog !< Integrator leapfrog. type ( integrator_lmm_ssp ) :: int_lmm_ssp !< Integrator LMM SSP. type ( integrator_lmm_ssp_vss ) :: int_lmm_ssp_vss !< Integrator LMM SSP VSS. type ( integrator_ms_runge_kutta_ssp ) :: int_ms_runge_kutta_ssp !< Integrator multistep Runge Kutta ssp. type ( integrator_runge_kutta_emd ) :: int_runge_kutta_emd !< Integrator Runge Kutta_embdedded. type ( integrator_runge_kutta_ls ) :: int_runge_kutta_ls !< Integrator Runge Kutta low storage. type ( integrator_runge_kutta_lssp ) :: int_runge_kutta_lssp !< Integrator linear Runge Kutta SSP. type ( integrator_runge_kutta_ssp ) :: int_runge_kutta_ssp !< Integrator Runge Kutta SSP. if ( index ( trim ( adjustl ( scheme )), trim ( int_adams_bashforth_moulton % class_name ())) > 0 ) then allocate ( integrator_adams_bashforth_moulton :: integrator ) select type ( integrator ) type is ( integrator_adams_bashforth_moulton ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_adams_bashforth % class_name ())) > 0 ) then allocate ( integrator_adams_bashforth :: integrator ) select type ( integrator ) type is ( integrator_adams_bashforth ) call integrator % initialize ( scheme = scheme , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_adams_moulton % class_name ())) > 0 ) then allocate ( integrator_adams_moulton :: integrator ) select type ( integrator ) type is ( integrator_adams_moulton ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_back_df % class_name ())) > 0 ) then allocate ( integrator_back_df :: integrator ) select type ( integrator ) type is ( integrator_back_df ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_euler_explicit % class_name ())) > 0 ) then allocate ( integrator_euler_explicit :: integrator ) select type ( integrator ) type is ( integrator_euler_explicit ) call integrator % initialize ( scheme = scheme , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_leapfrog % class_name ())) > 0 ) then allocate ( integrator_leapfrog :: integrator ) select type ( integrator ) type is ( integrator_leapfrog ) call integrator % initialize ( scheme = scheme , nu = nu , alpha = alpha , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_lmm_ssp_vss % class_name ())) > 0 ) then allocate ( integrator_lmm_ssp_vss :: integrator ) select type ( integrator ) type is ( integrator_lmm_ssp_vss ) call integrator % initialize ( scheme = scheme , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_lmm_ssp % class_name ())) > 0 ) then allocate ( integrator_lmm_ssp :: integrator ) select type ( integrator ) type is ( integrator_lmm_ssp ) call integrator % initialize ( scheme = scheme , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_ms_runge_kutta_ssp % class_name ())) > 0 ) then allocate ( integrator_ms_runge_kutta_ssp :: integrator ) select type ( integrator ) type is ( integrator_ms_runge_kutta_ssp ) call integrator % initialize ( scheme = scheme , iterations = iterations , autoupdate = autoupdate , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_emd % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_emd :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_emd ) call integrator % initialize ( scheme = scheme , tolerance = tolerance , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_lssp % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_lssp :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_lssp ) call integrator % initialize ( scheme = scheme , stages = stages , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_ls % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_ls :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_ls ) call integrator % initialize ( scheme = scheme , U = U ) endselect elseif ( index ( trim ( adjustl ( scheme )), trim ( int_runge_kutta_ssp % class_name ())) > 0 ) then allocate ( integrator_runge_kutta_ssp :: integrator ) select type ( integrator ) type is ( integrator_runge_kutta_ssp ) call integrator % initialize ( scheme = scheme , U = U ) endselect else write ( stderr , '(A)' ) 'error: \"' // trim ( adjustl ( scheme )) // '\" scheme is unknown!' stop endif endsubroutine foodie_integrator_factory","tags":"","loc":"proc/foodie_integrator_factory.html","title":"foodie_integrator_factory – FOODIE"},{"text":"private pure subroutine integrand_add_integrand_fast(opr, lhs, rhs) + fast operator. Note This procedure must be overridden, it does not implement anything. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_add_integrand_fast Source Code pure subroutine integrand_add_integrand_fast ( opr , lhs , rhs ) !< `+` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_add_integrand_fast","tags":"","loc":"proc/integrand_add_integrand_fast.html","title":"integrand_add_integrand_fast – FOODIE"},{"text":"private pure subroutine integrand_multiply_integrand_fast(opr, lhs, rhs) * fast operator. Note This procedure must be overridden, it does not implement anything. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_multiply_integrand_fast Source Code pure subroutine integrand_multiply_integrand_fast ( opr , lhs , rhs ) !< `*` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_multiply_integrand_fast","tags":"","loc":"proc/integrand_multiply_integrand_fast.html","title":"integrand_multiply_integrand_fast – FOODIE"},{"text":"private pure subroutine integrand_multiply_real_scalar_fast(opr, lhs, rhs) * real_scalar fast operator. Note This procedure must be overridden, it does not implement anything. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code integrand_multiply_real_scalar_fast Source Code pure subroutine integrand_multiply_real_scalar_fast ( opr , lhs , rhs ) !< `* real_scalar` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_multiply_real_scalar_fast","tags":"","loc":"proc/integrand_multiply_real_scalar_fast.html","title":"integrand_multiply_real_scalar_fast – FOODIE"},{"text":"private pure subroutine integrand_subtract_integrand_fast(opr, lhs, rhs) - fast operator. Note This procedure must be overridden, it does not implement anything. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_subtract_integrand_fast Source Code pure subroutine integrand_subtract_integrand_fast ( opr , lhs , rhs ) !< `-` fast operator. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine integrand_subtract_integrand_fast","tags":"","loc":"proc/integrand_subtract_integrand_fast.html","title":"integrand_subtract_integrand_fast – FOODIE"},{"text":"private subroutine t_fast(self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Note This procedure must be overridden, it does not implement anything. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Source Code t_fast Source Code subroutine t_fast ( self , t ) !< Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. !< !< @note This procedure must be overridden, it does not implement anything. class ( integrand_object ), intent ( inout ) :: self !< Integrand field. real ( R_P ), intent ( in ), optional :: t !< Time. endsubroutine t_fast","tags":"","loc":"proc/t_fast.html","title":"t_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_adams_bashforth ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % b )) deallocate ( self % b ) endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, autoupdate, U, stop_on_fail) Create the actual Adams-Bashforth integrator: initialize the b coefficients. Note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and\n the integrator error status is updated consistently for external-provided errors handling. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , autoupdate , U , stop_on_fail ) !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'adams_bashforth_1' ) self % steps = 1 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 1.0_R_P case ( 'adams_bashforth_2' ) self % steps = 2 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 1.0_R_P / 2.0_R_P self % b ( 2 ) = 3.0_R_P / 2.0_R_P case ( 'adams_bashforth_3' ) self % steps = 3 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 5.0_R_P / 1 2.0_R_P self % b ( 2 ) = - 1 6.0_R_P / 1 2.0_R_P self % b ( 3 ) = 2 3.0_R_P / 1 2.0_R_P case ( 'adams_bashforth_4' ) self % steps = 4 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 9.0_R_P / 2 4.0_R_P self % b ( 2 ) = 3 7.0_R_P / 2 4.0_R_P self % b ( 3 ) = - 5 9.0_R_P / 2 4.0_R_P self % b ( 4 ) = 5 5.0_R_P / 2 4.0_R_P case ( 'adams_bashforth_5' ) self % steps = 5 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 25 1.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 127 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 261 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = - 277 4.0_R_P / 72 0.0_R_P self % b ( 5 ) = 190 1.0_R_P / 72 0.0_R_P case ( 'adams_bashforth_6' ) self % steps = 6 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 47 5.0_R_P / 144 0.0_R_P self % b ( 2 ) = 287 7.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 729 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 998 2.0_R_P / 144 0.0_R_P self % b ( 5 ) = - 792 3.0_R_P / 144 0.0_R_P self % b ( 6 ) = 427 7.0_R_P / 144 0.0_R_P case ( 'adams_bashforth_7' ) self % steps = 7 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 1908 7.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 13447 2.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 40713 9.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 68825 6.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 70554 9.0_R_P / 6048 0.0_R_P self % b ( 6 ) = - 44728 8.0_R_P / 6048 0.0_R_P self % b ( 7 ) = 19872 1.0_R_P / 6048 0.0_R_P case ( 'adams_bashforth_8' ) self % steps = 8 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 3679 9.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 29576 7.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 104172 3.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 210224 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 266447 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 218387 7.0_R_P / 12096 0.0_R_P self % b ( 7 ) = - 115216 9.0_R_P / 12096 0.0_R_P self % b ( 8 ) = 43424 1.0_R_P / 12096 0.0_R_P case ( 'adams_bashforth_9' ) self % steps = 9 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 107001 7.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 966410 6.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 3883348 6.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 9117264 2.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 13796848 0.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 13985526 2.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 9547678 6.0_R_P / 362880 0.0_R_P self % b ( 8 ) = - 4312520 6.0_R_P / 362880 0.0_R_P self % b ( 9 ) = 1409724 7.0_R_P / 362880 0.0_R_P case ( 'adams_bashforth_10' ) self % steps = 10 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 208275 3.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 2088481 1.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 9430732 0.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 25261822 4.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 44477216 2.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 53836383 8.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 45466177 6.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 26593268 0.0_R_P / 725760 0.0_R_P self % b ( 9 ) = - 10499518 9.0_R_P / 725760 0.0_R_P self % b ( 10 ) = 3027724 7.0_R_P / 725760 0.0_R_P case ( 'adams_bashforth_11' ) self % steps = 11 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 13421126 5.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 147957434 8.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 741790445 1.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 2232963492 0.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 4485716843 4.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 6317620147 2.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 6371637895 8.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 4611302901 6.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 2359106380 5.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = - 827179512 4.0_R_P / 47900160 0.0_R_P self % b ( 11 ) = 213250956 7.0_R_P / 47900160 0.0_R_P case ( 'adams_bashforth_12' ) self % steps = 12 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 26274726 5.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 315864244 5.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 1741024827 1.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 5818910762 7.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 13136586729 0.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 21110357329 8.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 24774163937 4.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 21413935536 6.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 13557935675 7.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 6163322718 5.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = - 1943381016 3.0_R_P / 95800320 0.0_R_P self % b ( 12 ) = 452776639 9.0_R_P / 95800320 0.0_R_P case ( 'adams_bashforth_13' ) self % steps = 13 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 916055108573 4.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 5506097466241 2.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 20232291373837 0.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 50714036972842 5.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 91588338715244 4.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 122644308612940 8.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 123358924494176 4.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 93288454605589 5.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 52492457990515 0.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 21469659100261 2.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = - 6149755279727 4.0_R_P / 261534873600 0.0_R_P self % b ( 13 ) = 1306440652362 7.0_R_P / 261534873600 0.0_R_P case ( 'adams_bashforth_14' ) self % steps = 14 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 138274192962 1.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 1938285359378 7.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 12617497268190 6.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 50558614119643 0.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 139330630715575 5.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 279386960287907 7.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 420455192553452 4.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 482567132348845 2.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 424676735330575 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 285442957179080 5.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 144531335168190 6.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 53724705251566 2.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = - 14097075067962 1.0_R_P / 523069747200 0.0_R_P self % b ( 14 ) = 2751155497687 5.0_R_P / 523069747200 0.0_R_P case ( 'adams_bashforth_15' ) self % steps = 15 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 12259481390411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 85923647668423 1.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 372880725657747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 1120584975351517 9.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 2470450365560772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 4128021633628425 9.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 5324673866064691 2.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 5347102665994050 9.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 4182526993250772 8.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 2529891033708142 9.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 1164363753057747 2.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 396642167021548 1.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = - 96012286640411 2.0_R_P / 3138418483200 0.0_R_P self % b ( 15 ) = 17323349859884 9.0_R_P / 3138418483200 0.0_R_P case ( 'adams_bashforth_16' ) self % steps = 16 ; allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % b ( 1 ) = - 1608812922937 5.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 25765027591582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 193444319689259 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 903857175273408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 2941791091125181 9.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 7072435158284348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 12993009410423733 1.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 18608754426359664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 21002058891232194 9.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 18746314011290289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 13196319194082858 1.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 7255811707225973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 3060737386052056 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 962209690951533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = - 216156767124884 9.0_R_P / 6276836966400 0.0_R_P self % b ( 16 ) = 36255512642707 3.0_R_P / 6276836966400 0.0_R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_adams_bashforth ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_adams_bashforth ) if ( allocated ( rhs % b )) lhs % b = rhs % b endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with Adams-Bashforth class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth class scheme. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. do s = 1 , self % steps U = U + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % b ( s ))) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with Adams-Bashforth class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth class scheme, fast mode. class ( integrator_adams_bashforth ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. do s = 1 , self % steps self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~2.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~2.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~2.html","title":"is_supported – FOODIE"},{"text":"private elemental function scheme_number(self, scheme) Return the scheme number in the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value integer(kind=I_P) Scheme number in the list of supported schemes. Source Code scheme_number Source Code elemental function scheme_number ( self , scheme ) !< Return the scheme number in the list of supported schemes. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ) :: scheme_number !< Scheme number in the list of supported schemes. integer ( I_P ) :: s !< Counter. scheme_number = 0 do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then scheme_number = s exit endif enddo endfunction scheme_number","tags":"","loc":"proc/scheme_number.html","title":"scheme_number – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_adams_bashforth_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~2.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep call self % predictor % destroy call self % corrector % destroy endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual Adams-Bashforth-Moulton integrator: initialize the *b* coefficients. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. character ( len = 99 ), allocatable :: schemes_ab (:) !< Adams-Bashforth schemes. character ( len = 99 ), allocatable :: schemes_am (:) !< Adams-Moulton schemes. integer ( I_P ) :: scheme_number_ !< Scheme number in the list of supported schemes. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) scheme_number_ = self % scheme_number ( scheme = scheme ) schemes_ab = self % predictor % supported_schemes () schemes_am = self % corrector % supported_schemes () self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations call self % predictor % initialize ( scheme = schemes_ab ( scheme_number_ ), U = U , autoupdate = . false .) call self % corrector % initialize ( scheme = schemes_am ( scheme_number_ ), U = U , iterations = self % iterations , autoupdate = . false .) self % steps = self % predictor % steps_number () self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~2.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_adams_bashforth_moulton ) lhs % steps = rhs % steps lhs % predictor = rhs % predictor lhs % corrector = rhs % corrector endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~2.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with Adams-Bashforth-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth-Moulton class scheme. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. integer ( I_P ) :: s !< Step counter. do s = 1 , self % steps self % predictor % previous ( s ) = self % previous ( s ) self % predictor % t ( s ) = self % t ( s ) self % predictor % Dt ( s ) = self % Dt ( s ) enddo do s = 1 , self % steps - 1 self % corrector % previous ( s ) = self % predictor % previous ( s + 1 ) self % corrector % t ( s ) = self % predictor % t ( s + 1 ) self % corrector % Dt ( s ) = self % predictor % Dt ( s + 1 ) enddo call self % predictor % integrate ( U = U , Dt = Dt , t = t ) call self % corrector % integrate ( U = U , Dt = Dt , t = t ) if ( self % autoupdate ) & call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with Adams-Bashforth-Moulton class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with Adams-Bashforth-Moulton class scheme, fast mode. class ( integrator_adams_bashforth_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( in ) :: t !< Times. integer ( I_P ) :: s !< Step counter. do s = 1 , self % steps self % predictor % previous ( s ) = self % previous ( s ) enddo self % predictor % t (:) = self % t ( 1 : self % steps ) self % predictor % Dt (:) = self % Dt ( 1 : self % steps ) do s = 1 , self % steps - 1 self % corrector % previous ( s ) = self % previous ( s + 1 ) enddo self % corrector % t (:) = self % t ( 2 : self % steps ) self % corrector % Dt (:) = self % Dt ( 2 : self % steps ) call self % predictor % integrate_fast ( U = U , Dt = Dt , t = t ) call self % corrector % integrate_fast ( U = U , Dt = Dt , t = t ) if ( self % autoupdate ) & call self % update_previous ( U = U , previous = self % previous ( 1 : self % steps ), Dt = Dt , t = t , previous_t = self % t ( 1 : self % steps )) endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~2.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~3.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~3.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~3.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_adams_moulton ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~3.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_adams_moulton ), intent ( INOUT ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % b )) deallocate ( self % b ) endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual Adams-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual Adams-Moulton integrator: initialize the *b* coefficients. class ( integrator_adams_moulton ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'adams_moulton_0' ) self % steps = 0 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 1.0_R_P case ( 'adams_moulton_1' ) self % steps = 1 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 1.0_R_P / 2.0_R_P self % b ( 1 ) = 1.0_R_P / 2.0_R_P case ( 'adams_moulton_2' ) self % steps = 2 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 1.0_R_P / 1 2.0_R_P self % b ( 1 ) = 8.0_R_P / 1 2.0_R_P self % b ( 2 ) = 5.0_R_P / 1 2.0_R_P case ( 'adams_moulton_3' ) self % steps = 3 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 1.0_R_P / 2 4.0_R_P self % b ( 1 ) = - 5.0_R_P / 2 4.0_R_P self % b ( 2 ) = 1 9.0_R_P / 2 4.0_R_P self % b ( 3 ) = 9.0_R_P / 2 4.0_R_P case ( 'adams_moulton_4' ) self % steps = 4 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 1 9.0_R_P / 72 0.0_R_P self % b ( 1 ) = 10 6.0_R_P / 72 0.0_R_P self % b ( 2 ) = - 26 4.0_R_P / 72 0.0_R_P self % b ( 3 ) = 64 6.0_R_P / 72 0.0_R_P self % b ( 4 ) = 25 1.0_R_P / 72 0.0_R_P case ( 'adams_moulton_5' ) self % steps = 5 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 2 7.0_R_P / 144 0.0_R_P self % b ( 1 ) = - 17 3.0_R_P / 144 0.0_R_P self % b ( 2 ) = 48 2.0_R_P / 144 0.0_R_P self % b ( 3 ) = - 79 8.0_R_P / 144 0.0_R_P self % b ( 4 ) = 142 7.0_R_P / 144 0.0_R_P self % b ( 5 ) = 47 5.0_R_P / 144 0.0_R_P case ( 'adams_moulton_6' ) self % steps = 6 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 86 3.0_R_P / 6048 0.0_R_P self % b ( 1 ) = 631 2.0_R_P / 6048 0.0_R_P self % b ( 2 ) = - 2021 1.0_R_P / 6048 0.0_R_P self % b ( 3 ) = 3750 4.0_R_P / 6048 0.0_R_P self % b ( 4 ) = - 4646 1.0_R_P / 6048 0.0_R_P self % b ( 5 ) = 6511 2.0_R_P / 6048 0.0_R_P self % b ( 6 ) = 1908 7.0_R_P / 6048 0.0_R_P case ( 'adams_moulton_7' ) self % steps = 7 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 137 5.0_R_P / 12096 0.0_R_P self % b ( 1 ) = - 1135 1.0_R_P / 12096 0.0_R_P self % b ( 2 ) = 4149 9.0_R_P / 12096 0.0_R_P self % b ( 3 ) = - 8854 7.0_R_P / 12096 0.0_R_P self % b ( 4 ) = 12313 3.0_R_P / 12096 0.0_R_P self % b ( 5 ) = - 12179 7.0_R_P / 12096 0.0_R_P self % b ( 6 ) = 13984 9.0_R_P / 12096 0.0_R_P self % b ( 7 ) = 3679 9.0_R_P / 12096 0.0_R_P case ( 'adams_moulton_8' ) self % steps = 8 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 3395 3.0_R_P / 362880 0.0_R_P self % b ( 1 ) = 31287 4.0_R_P / 362880 0.0_R_P self % b ( 2 ) = - 129121 4.0_R_P / 362880 0.0_R_P self % b ( 3 ) = 314633 8.0_R_P / 362880 0.0_R_P self % b ( 4 ) = - 503312 0.0_R_P / 362880 0.0_R_P self % b ( 5 ) = 559535 8.0_R_P / 362880 0.0_R_P self % b ( 6 ) = - 460459 4.0_R_P / 362880 0.0_R_P self % b ( 7 ) = 446709 4.0_R_P / 362880 0.0_R_P self % b ( 8 ) = 107001 7.0_R_P / 362880 0.0_R_P case ( 'adams_moulton_9' ) self % steps = 9 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 5728 1.0_R_P / 725760 0.0_R_P self % b ( 1 ) = - 58343 5.0_R_P / 725760 0.0_R_P self % b ( 2 ) = 268786 4.0_R_P / 725760 0.0_R_P self % b ( 3 ) = - 739403 2.0_R_P / 725760 0.0_R_P self % b ( 4 ) = 1351008 2.0_R_P / 725760 0.0_R_P self % b ( 5 ) = - 1728364 6.0_R_P / 725760 0.0_R_P self % b ( 6 ) = 1600232 0.0_R_P / 725760 0.0_R_P self % b ( 7 ) = - 1127130 4.0_R_P / 725760 0.0_R_P self % b ( 8 ) = 944971 7.0_R_P / 725760 0.0_R_P self % b ( 9 ) = 208275 3.0_R_P / 725760 0.0_R_P case ( 'adams_moulton_10' ) self % steps = 10 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 325043 3.0_R_P / 47900160 0.0_R_P self % b ( 1 ) = 3628487 6.0_R_P / 47900160 0.0_R_P self % b ( 2 ) = - 18477619 5.0_R_P / 47900160 0.0_R_P self % b ( 3 ) = 56745098 4.0_R_P / 47900160 0.0_R_P self % b ( 4 ) = - 117059704 2.0_R_P / 47900160 0.0_R_P self % b ( 5 ) = 171077452 8.0_R_P / 47900160 0.0_R_P self % b ( 6 ) = - 182331156 6.0_R_P / 47900160 0.0_R_P self % b ( 7 ) = 144620508 0.0_R_P / 47900160 0.0_R_P self % b ( 8 ) = - 89017554 9.0_R_P / 47900160 0.0_R_P self % b ( 9 ) = 65618565 2.0_R_P / 47900160 0.0_R_P self % b ( 10 ) = 13421126 5.0_R_P / 47900160 0.0_R_P case ( 'adams_moulton_11' ) self % steps = 11 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 567526 5.0_R_P / 95800320 0.0_R_P self % b ( 1 ) = - 6892878 1.0_R_P / 95800320 0.0_R_P self % b ( 2 ) = 38470932 7.0_R_P / 95800320 0.0_R_P self % b ( 3 ) = - 130597111 5.0_R_P / 95800320 0.0_R_P self % b ( 4 ) = 300773941 8.0_R_P / 95800320 0.0_R_P self % b ( 5 ) = - 496316651 4.0_R_P / 95800320 0.0_R_P self % b ( 6 ) = 604352148 6.0_R_P / 95800320 0.0_R_P self % b ( 7 ) = - 551946058 2.0_R_P / 95800320 0.0_R_P self % b ( 8 ) = 382882888 5.0_R_P / 95800320 0.0_R_P self % b ( 9 ) = - 209249067 3.0_R_P / 95800320 0.0_R_P self % b ( 10 ) = 137479921 9.0_R_P / 95800320 0.0_R_P self % b ( 11 ) = 26274726 5.0_R_P / 95800320 0.0_R_P case ( 'adams_moulton_12' ) self % steps = 12 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 1369577909 3.0_R_P / 261534873600 0.0_R_P self % b ( 1 ) = 17984282256 6.0_R_P / 261534873600 0.0_R_P self % b ( 2 ) = - 109209699226 8.0_R_P / 261534873600 0.0_R_P self % b ( 3 ) = 406332786317 0.0_R_P / 261534873600 0.0_R_P self % b ( 4 ) = - 1034471179498 5.0_R_P / 261534873600 0.0_R_P self % b ( 5 ) = 1905818565279 6.0_R_P / 261534873600 0.0_R_P self % b ( 6 ) = - 2620434446515 2.0_R_P / 261534873600 0.0_R_P self % b ( 7 ) = 2734587069843 6.0_R_P / 261534873600 0.0_R_P self % b ( 8 ) = - 2184753803989 5.0_R_P / 261534873600 0.0_R_P self % b ( 9 ) = 1346577425651 0.0_R_P / 261534873600 0.0_R_P self % b ( 10 ) = - 661642095742 8.0_R_P / 261534873600 0.0_R_P self % b ( 11 ) = 391755121698 6.0_R_P / 261534873600 0.0_R_P self % b ( 12 ) = 70360425435 7.0_R_P / 261534873600 0.0_R_P case ( 'adams_moulton_13' ) self % steps = 13 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 2446657909 3.0_R_P / 523069747200 0.0_R_P self % b ( 1 ) = - 34545708639 5.0_R_P / 523069747200 0.0_R_P self % b ( 2 ) = 226807881438 6.0_R_P / 523069747200 0.0_R_P self % b ( 3 ) = - 918163560513 4.0_R_P / 523069747200 0.0_R_P self % b ( 4 ) = 2562025977783 5.0_R_P / 523069747200 0.0_R_P self % b ( 5 ) = - 5217791088266 1.0_R_P / 523069747200 0.0_R_P self % b ( 6 ) = 8010102102918 0.0_R_P / 523069747200 0.0_R_P self % b ( 7 ) = - 9439333865389 2.0_R_P / 523069747200 0.0_R_P self % b ( 8 ) = 8618022868956 3.0_R_P / 523069747200 0.0_R_P self % b ( 9 ) = - 6118868013128 5.0_R_P / 523069747200 0.0_R_P self % b ( 10 ) = 3392899013361 8.0_R_P / 523069747200 0.0_R_P self % b ( 11 ) = - 1514123508411 0.0_R_P / 523069747200 0.0_R_P self % b ( 12 ) = 815316796218 1.0_R_P / 523069747200 0.0_R_P self % b ( 13 ) = 138274192962 1.0_R_P / 523069747200 0.0_R_P case ( 'adams_moulton_14' ) self % steps = 14 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = - 13228284012 7.0_R_P / 3138418483200 0.0_R_P self % b ( 1 ) = 199875923633 6.0_R_P / 3138418483200 0.0_R_P self % b ( 2 ) = - 1411048096992 7.0_R_P / 3138418483200 0.0_R_P self % b ( 3 ) = 6175942669254 4.0_R_P / 3138418483200 0.0_R_P self % b ( 4 ) = - 18750493659793 1.0_R_P / 3138418483200 0.0_R_P self % b ( 5 ) = 41855180460126 4.0_R_P / 3138418483200 0.0_R_P self % b ( 6 ) = - 71031283419734 7.0_R_P / 3138418483200 0.0_R_P self % b ( 7 ) = 93460083349094 4.0_R_P / 3138418483200 0.0_R_P self % b ( 8 ) = - 96360540082473 3.0_R_P / 3138418483200 0.0_R_P self % b ( 9 ) = 78191161807163 2.0_R_P / 3138418483200 0.0_R_P self % b ( 10 ) = - 49954720375483 7.0_R_P / 3138418483200 0.0_R_P self % b ( 11 ) = 25172489460793 6.0_R_P / 3138418483200 0.0_R_P self % b ( 12 ) = - 10288514895621 7.0_R_P / 3138418483200 0.0_R_P self % b ( 13 ) = 5077096753486 4.0_R_P / 3138418483200 0.0_R_P self % b ( 14 ) = 816416873759 9.0_R_P / 3138418483200 0.0_R_P case ( 'adams_moulton_15' ) self % steps = 15 ; allocate ( self % b ( 0 : self % steps )) ; self % b = 0.0_R_P self % b ( 0 ) = 24020824582 3.0_R_P / 6276836966400 0.0_R_P self % b ( 1 ) = - 386768936759 9.0_R_P / 6276836966400 0.0_R_P self % b ( 2 ) = 2921938428408 7.0_R_P / 6276836966400 0.0_R_P self % b ( 3 ) = - 13751571378931 9.0_R_P / 6276836966400 0.0_R_P self % b ( 4 ) = 45140310893348 3.0_R_P / 6276836966400 0.0_R_P self % b ( 5 ) = - 109635523540233 1.0_R_P / 6276836966400 0.0_R_P self % b ( 6 ) = 203934587954664 3.0_R_P / 6276836966400 0.0_R_P self % b ( 7 ) = - 296636573026569 9.0_R_P / 6276836966400 0.0_R_P self % b ( 8 ) = 341494172885289 3.0_R_P / 6276836966400 0.0_R_P self % b ( 9 ) = - 312945307199358 1.0_R_P / 6276836966400 0.0_R_P self % b ( 10 ) = 228516859834973 3.0_R_P / 6276836966400 0.0_R_P self % b ( 11 ) = - 132697866305806 9.0_R_P / 6276836966400 0.0_R_P self % b ( 12 ) = 61274454106533 7.0_R_P / 6276836966400 0.0_R_P self % b ( 13 ) = - 23099216372384 9.0_R_P / 6276836966400 0.0_R_P self % b ( 14 ) = 10514505875707 3.0_R_P / 6276836966400 0.0_R_P self % b ( 15 ) = 1608812922937 5.0_R_P / 6276836966400 0.0_R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~3.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_adams_moulton ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_adams_moulton ) lhs % steps = rhs % steps if ( allocated ( rhs % b )) lhs % b = rhs % b endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~3.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with Adams-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with Adams-Moulton class scheme. class ( integrator_adams_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. if ( self % steps > 0 ) then if ( self % iterations > 0 ) then ! perform fixed point iterations allocate ( delta , mold = U ) delta = self % previous ( self % steps ) do s = 0 , self % steps - 1 delta = delta + ( self % previous ( s + 1 )% t ( t = self % t ( s + 1 )) * ( Dt * self % b ( s ))) enddo do s = 1 , self % iterations U = delta + ( U % t ( t = self % t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps ))) enddo else U = self % previous ( self % steps ) + ( U % t ( t = self % t ( self % steps ) + Dt ) * ( Dt * self % b ( self % steps ))) do s = 0 , self % steps - 1 U = U + ( self % previous ( s + 1 )% t ( t = self % t ( s + 1 )) * ( Dt * self % b ( s ))) enddo endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) else U = U + ( U % t ( t = t ) * ( Dt * self % b ( 0 ))) endif endsubroutine integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with Adams-Moulton class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with Adams-Moulton class scheme, fast mode. class ( integrator_adams_moulton ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. if ( self % steps > 0 ) then if ( self % iterations > 0 ) then ! perform fixed point iterations allocate ( delta , mold = U ) delta = self % previous ( self % steps ) do s = 0 , self % steps - 1 self % buffer = self % previous ( s + 1 ) call self % buffer % t_fast ( t = self % t ( s + 1 )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call delta % add_fast ( lhs = delta , rhs = self % buffer ) enddo do s = 1 , self % iterations self % buffer = U call self % buffer % t_fast ( t = self % t ( self % steps ) + Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( self % steps )) call U % add_fast ( lhs = delta , rhs = self % buffer ) enddo else self % buffer = U call self % buffer % t_fast ( t = self % t ( self % steps ) + Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( self % steps )) call U % add_fast ( lhs = self % previous ( self % steps ), rhs = self % buffer ) do s = 0 , self % steps - 1 self % buffer = self % previous ( s + 1 ) call self % buffer % t_fast ( t = self % t ( s + 1 )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) else self % buffer = U call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( 0 )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~3.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~4.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~4.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~4.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_back_df ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~4.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % a )) deallocate ( self % a ) self % b = 0.0_R_P endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual BDF integrator: initialize the alpha and beta coefficients. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual BDF integrator: initialize the *alpha* and *beta* coefficients. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'back_df_1' ) self % steps = 1 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = - 1.0_R_P self % b = 1.0_R_P case ( 'back_df_2' ) self % steps = 2 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = 1.0_R_P / 3.0_R_P self % a ( 2 ) = - 4.0_R_P / 3.0_R_P self % b = 2.0_R_P / 3.0_R_P case ( 'back_df_3' ) self % steps = 3 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = - 2.0_R_P / 1 1.0_R_P self % a ( 2 ) = 9.0_R_P / 1 1.0_R_P self % a ( 3 ) = - 1 8.0_R_P / 1 1.0_R_P self % b = 6.0_R_P / 1 1.0_R_P case ( 'back_df_4' ) self % steps = 4 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = 3.0_R_P / 2 5.0_R_P self % a ( 2 ) = - 1 6.0_R_P / 2 5.0_R_P self % a ( 3 ) = 3 6.0_R_P / 2 5.0_R_P self % a ( 4 ) = - 4 8.0_R_P / 2 5.0_R_P self % b = 1 2.0_R_P / 2 5.0_R_P case ( 'back_df_5' ) self % steps = 5 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = - 1 2.0_R_P / 13 7.0_R_P self % a ( 2 ) = 7 5.0_R_P / 13 7.0_R_P self % a ( 3 ) = - 20 0.0_R_P / 13 7.0_R_P self % a ( 4 ) = 30 0.0_R_P / 13 7.0_R_P self % a ( 5 ) = - 30 0.0_R_P / 13 7.0_R_P self % b = 6 0.0_R_P / 13 7.0_R_P case ( 'back_df_6' ) self % steps = 6 ; allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P self % a ( 1 ) = 1 0.0_R_P / 14 7.0_R_P self % a ( 2 ) = - 7 2.0_R_P / 14 7.0_R_P self % a ( 3 ) = 22 5.0_R_P / 14 7.0_R_P self % a ( 4 ) = - 40 0.0_R_P / 14 7.0_R_P self % a ( 5 ) = 45 0.0_R_P / 14 7.0_R_P self % a ( 6 ) = - 36 0.0_R_P / 14 7.0_R_P self % b = 6 0.0_R_P / 14 7.0_R_P case default endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~4.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_back_df ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_back_df ) lhs % steps = rhs % steps if ( allocated ( rhs % a )) lhs % a = rhs % a lhs % b = rhs % b endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~4.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with BDF class scheme. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. allocate ( delta , mold = U ) delta = self % previous ( self % steps ) * ( - self % a ( self % steps )) do s = 1 , self % steps - 1 delta = delta + ( self % previous ( s ) * ( - self % a ( s ))) enddo do s = 1 , self % iterations U = delta + ( U % t ( t = self % t ( self % steps ) + Dt ) * ( Dt * self % b )) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate","tags":"","loc":"proc/integrate~4.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with BDF class scheme. class ( integrator_back_df ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. class ( integrand_object ), allocatable :: delta !< Delta RHS for fixed point iterations. integer ( I_P ) :: s !< Steps counter. allocate ( delta , mold = U ) call delta % multiply_fast ( lhs = self % previous ( self % steps ), rhs =- self % a ( self % steps )) do s = 1 , self % steps - 1 call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs =- self % a ( s )) call delta % add_fast ( lhs = delta , rhs = self % buffer ) enddo do s = 1 , self % iterations self % buffer = U call self % buffer % t_fast ( t = self % t ( self % steps ) + Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ) call U % add_fast ( lhs = delta , rhs = self % buffer ) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~4.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~5.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~5.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~5.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_euler_explicit ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~5.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , U , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) self % stages = 0 self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~5.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_euler_explicit ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistage ( rhs = rhs ) endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~5.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t, new_Dt) Integrate field with explicit Euler scheme, 1st order. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit Euler scheme, 1st order. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. U = U + ( U % t ( t = t ) * Dt ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate","tags":"","loc":"proc/integrate~5.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t, new_Dt) Integrate field with explicit Euler scheme, 1st order, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit Euler scheme, 1st order, fast mode. class ( integrator_euler_explicit ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. self % buffer = U call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call U % add_fast ( lhs = U , rhs = self % buffer ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~5.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~6.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~6.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~6.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_leapfrog ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~6.html","title":"supported_schemes – FOODIE"},{"text":"private subroutine allocate_integrand_members(self, U) Allocate members of interpolator being of integrand_object class. Note It is assumed that the integrator has been properly initialized before calling this method. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. Source Code allocate_integrand_members Source Code subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistep () . and . self % registers > 0 ) then if ( allocated ( self % Dt )) deallocate ( self % Dt ) allocate ( self % Dt ( 1 : self % registers )) ; self % Dt = 0._R_P if ( allocated ( self % t )) deallocate ( self % t ) allocate ( self % t ( 1 : self % registers )) ; self % t = 0._R_P if ( allocated ( self % previous )) deallocate ( self % previous ) allocate ( self % previous ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % previous ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif if ( self % is_filtered ) then if ( allocated ( self % filter )) deallocate ( self % filter ) allocate ( self % filter , mold = U ) self % filter = U endif endsubroutine allocate_integrand_members","tags":"","loc":"proc/allocate_integrand_members.html","title":"allocate_integrand_members – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_leapfrog ), intent ( INOUT ) :: self !< Integrator. call self % destroy_multistep self % nu = 0._R_P self % alpha = 0._R_P self % is_filtered = . false . if ( allocated ( self % filter )) deallocate ( self % filter ) endsubroutine destroy","tags":"","loc":"proc/destroy~6.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, nu, alpha, autoupdate, U, stop_on_fail) Create the actual leapfrog integrator: initialize the filter coefficient. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , nu , alpha , autoupdate , U , stop_on_fail ) !< Create the actual leapfrog integrator: initialize the filter coefficient. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), intent ( in ), optional :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), intent ( in ), optional :: alpha !< Robert-Asselin filter coefficient. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'leapfrog_raw' ) self % nu = 0.01_R_P ; if ( present ( nu )) self % nu = nu self % alpha = 0.53_R_P ; if ( present ( alpha )) self % alpha = alpha self % is_filtered = . true . endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % steps = 2 self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~6.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_leapfrog ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_leapfrog ) lhs % nu = rhs % nu lhs % alpha = rhs % alpha lhs % is_filtered = rhs % is_filtered if ( allocated ( lhs % filter )) deallocate ( lhs % filter ) if ( allocated ( rhs % filter )) then allocate ( lhs % filter , mold = rhs % filter ) lhs % filter = rhs % filter endif endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~6.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with leapfrog class scheme. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with leapfrog class scheme. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. U = self % previous ( 1 ) + ( self % previous ( 2 )% t ( t = t ) * ( Dt * 2._R_P )) if ( self % is_filtered ) then self % filter = ( self % previous ( 1 ) - ( self % previous ( 2 ) * 2._R_P ) + U ) * self % nu * 0.5_R_P self % previous ( 2 ) = self % previous ( 2 ) + ( self % filter * self % alpha ) U = U + ( self % filter * ( self % alpha - 1._R_P )) endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous ) endsubroutine integrate","tags":"","loc":"proc/integrate~6.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with leapfrog class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with leapfrog class scheme, fast mode. class ( integrator_leapfrog ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. self % buffer = self % previous ( 2 ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * 2._R_P ) call U % add_fast ( lhs = self % previous ( 1 ), rhs = self % buffer ) if ( self % is_filtered ) then call self % buffer % multiply_fast ( lhs = self % previous ( 2 ), rhs = 2._R_P ) call self % buffer % subtract_fast ( lhs = self % previous ( 1 ), rhs = self % buffer ) call self % buffer % add_fast ( lhs = self % buffer , rhs = U ) call self % filter % multiply_fast ( lhs = self % buffer , rhs = self % nu * 0.5_R_P ) call self % buffer % multiply_fast ( lhs = self % filter , rhs = self % alpha ) call self % previous ( 2 )% add_fast ( lhs = self % previous ( 2 ), rhs = self % buffer ) call self % buffer % multiply_fast ( lhs = self % filter , rhs = self % alpha - 1._R_P ) call U % add_fast ( lhs = U , rhs = self % buffer ) endif if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous ) endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~6.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~7.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~7.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~7.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_lmm_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~7.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep if ( allocated ( self % a )) deallocate ( self % a ) if ( allocated ( self % b )) deallocate ( self % b ) endsubroutine destroy","tags":"","loc":"proc/destroy~7.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, autoupdate, U, stop_on_fail) Create the actual LMM-SSP integrator: initialize the a,b coefficients. Note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and\n the integrator error status is updated consistently for external-provided errors handling. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , autoupdate , U , stop_on_fail ) !< Create the actual LMM-SSP integrator: initialize the *a,b* coefficients. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'lmm_ssp_steps_3_order_2' ) self % steps = 3 allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % a ( 1 ) = 1._R_P / 4._R_P self % a ( 2 ) = 0._R_P self % a ( 3 ) = 3._R_P / 4._R_P self % b ( 1 ) = 0._R_P self % b ( 2 ) = 0._R_P self % b ( 3 ) = 3._R_P / 2._R_P case ( 'lmm_ssp_steps_4_order_3' ) self % steps = 4 allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % a ( 1 ) = 1 1._R_P / 2 7._R_P self % a ( 2 ) = 0._R_P self % a ( 3 ) = 0._R_P self % a ( 4 ) = 1 6._R_P / 2 7._R_P self % b ( 1 ) = 1 2._R_P / 2 7._R_P self % b ( 2 ) = 0._R_P self % b ( 3 ) = 0._R_P self % b ( 4 ) = 1 6._R_P / 9._R_P case ( 'lmm_ssp_steps_5_order_3' ) self % steps = 5 allocate ( self % a ( 1 : self % steps )) ; self % a = 0.0_R_P allocate ( self % b ( 1 : self % steps )) ; self % b = 0.0_R_P self % a ( 1 ) = 7._R_P / 3 2._R_P self % a ( 2 ) = 0._R_P self % a ( 3 ) = 0._R_P self % a ( 4 ) = 0._R_P self % a ( 5 ) = 2 5._R_P / 3 2._R_P self % b ( 1 ) = 5._R_P / 1 6._R_P self % b ( 2 ) = 0._R_P self % b ( 3 ) = 0._R_P self % b ( 4 ) = 0._R_P self % b ( 5 ) = 2 5._R_P / 1 6._R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~7.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_lmm_ssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_lmm_ssp ) lhs % steps = rhs % steps if ( allocated ( rhs % a )) lhs % a = rhs % a if ( allocated ( rhs % b )) lhs % b = rhs % b endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~7.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. U = U * 0._R_P do s = 1 , self % steps if ( self % a ( s ) /= 0._R_P ) U = U + ( self % previous ( s ) * self % a ( s )) if ( self % b ( s ) /= 0._R_P ) U = U + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % b ( s ))) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate","tags":"","loc":"proc/integrate~7.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme, fast mode. class ( integrator_lmm_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< Steps counter. call U % multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % steps if ( self % a ( s ) /= 0._R_P ) then call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs = self % a ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif if ( self % b ( s ) /= 0._R_P ) then self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % b ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~7.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~8.html","title":"class_name – FOODIE"},{"text":"private pure function dt_ratio(Dt, s) result(ratio) Return Dt(n+s)/Dt(n+Ns) ratio. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: Dt (:) Time steps. integer(kind=I_P), intent(in) :: s Step index. Return Value real(kind=R_P) Time steps ratio. Called By proc~~dt_ratio~~CalledByGraph proc~dt_ratio dt_ratio proc~omega omega proc~omega->proc~dt_ratio proc~integrate_order_2 integrate_order_2 proc~integrate_order_2->proc~omega proc~integrate_order_3_fast integrate_order_3_fast proc~integrate_order_3_fast->proc~omega proc~integrate_order_3 integrate_order_3 proc~integrate_order_3->proc~omega proc~integrate_order_2_fast integrate_order_2_fast proc~integrate_order_2_fast->proc~omega Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code dt_ratio Source Code pure function dt_ratio ( Dt , s ) result ( ratio ) !< Return `Dt(n+s)/Dt(n+Ns)` ratio. real ( R_P ), intent ( in ) :: Dt (:) !< Time steps. integer ( I_P ), intent ( in ) :: s !< Step index. real ( R_P ) :: ratio !< Time steps ratio. ratio = Dt ( s ) / Dt ( ubound ( Dt , dim = 1 )) endfunction dt_ratio","tags":"","loc":"proc/dt_ratio.html","title":"dt_ratio – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~8.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~8.html","title":"is_supported – FOODIE"},{"text":"private pure function omega(Dt, s) Return omega=sum(dt_ratio(i)), i=1, s . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: Dt (:) Time steps. integer(kind=I_P), intent(in) :: s Step index. Return Value real(kind=R_P) Omega sum. Calls proc~~omega~~CallsGraph proc~omega omega proc~dt_ratio dt_ratio proc~omega->proc~dt_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~omega~~CalledByGraph proc~omega omega proc~integrate_order_2 integrate_order_2 proc~integrate_order_2->proc~omega proc~integrate_order_3_fast integrate_order_3_fast proc~integrate_order_3_fast->proc~omega proc~integrate_order_3 integrate_order_3 proc~integrate_order_3->proc~omega proc~integrate_order_2_fast integrate_order_2_fast proc~integrate_order_2_fast->proc~omega Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code omega Source Code pure function omega ( Dt , s ) !< Return `omega=sum(dt_ratio(i)), i=1, s`. real ( R_P ), intent ( in ) :: Dt (:) !< Time steps. integer ( I_P ), intent ( in ) :: s !< Step index. real ( R_P ) :: omega !< Omega sum. integer ( I_P ) :: i !< Counter. omega = 0._R_P do i = 1 , s omega = omega + dt_Ratio ( Dt = Dt , s = i ) enddo endfunction omega","tags":"","loc":"proc/omega.html","title":"omega – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_lmm_ssp_vss ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~8.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. call self % destroy_multistep self % integrate_ => integrate_order_2 endsubroutine destroy","tags":"","loc":"proc/destroy~8.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, autoupdate, U, stop_on_fail) Create the actual LMM-SSP-VSS integrator. Note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and\n the integrator error status is updated consistently for external-provided errors handling. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , autoupdate , U , stop_on_fail ) !< Create the actual LMM-SSP-VSS integrator. !< !< @note If the integrator is initialized with a bad (unsupported) number of required time steps the initialization fails and !< the integrator error status is updated consistently for external-provided errors handling. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'lmm_ssp_vss_steps_2_order_2' ) self % steps = 2 self % integrate_ => integrate_order_2 self % integrate_fast_ => integrate_order_2_fast case ( 'lmm_ssp_vss_steps_3_order_2' ) self % steps = 3 self % integrate_ => integrate_order_2 self % integrate_fast_ => integrate_order_2_fast case ( 'lmm_ssp_vss_steps_3_order_3' ) self % steps = 3 self % integrate_ => integrate_order_3 self % integrate_fast_ => integrate_order_3_fast case ( 'lmm_ssp_vss_steps_4_order_3' ) self % steps = 4 self % integrate_ => integrate_order_3 self % integrate_fast_ => integrate_order_3_fast case ( 'lmm_ssp_vss_steps_5_order_3' ) self % steps = 5 self % integrate_ => integrate_order_3 self % integrate_fast_ => integrate_order_3_fast endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % registers = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~8.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_lmm_ssp_vss ) if ( associated ( rhs % integrate_ )) lhs % integrate_ => rhs % integrate_ endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~8.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. call self % integrate_ ( U = U , Dt = Dt , t = t ) endsubroutine integrate","tags":"","loc":"proc/integrate~8.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme, fast mode. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. call self % integrate_fast_ ( U = U , Dt = Dt , t = t ) endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~8.html","title":"integrate_fast – FOODIE"},{"text":"private subroutine integrate_order_2(self, U, Dt, t) Integrate field with LMM-SSP-VSS 2nd order class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Calls proc~~integrate_order_2~~CallsGraph proc~integrate_order_2 integrate_order_2 proc~omega omega proc~integrate_order_2->proc~omega proc~dt_ratio dt_ratio proc~omega->proc~dt_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate_order_2 Source Code subroutine integrate_order_2 ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 2nd order class scheme. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. real ( R_P ) :: omega_sq !< Square of omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) omega_sq = omega_ * omega_ U = ( self % previous ( 1 ) * ( 1._R_P / omega_sq )) + ( self % previous ( self % steps ) * (( omega_sq - 1._R_P ) / omega_sq )) + & ( self % previous ( self % steps )% t ( t = self % t ( self % steps )) * ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / omega_ )) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_2","tags":"","loc":"proc/integrate_order_2.html","title":"integrate_order_2 – FOODIE"},{"text":"private subroutine integrate_order_2_fast(self, U, Dt, t) Integrate field with LMM-SSP-VSS 2nd order class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Calls proc~~integrate_order_2_fast~~CallsGraph proc~integrate_order_2_fast integrate_order_2_fast proc~omega omega proc~integrate_order_2_fast->proc~omega proc~dt_ratio dt_ratio proc~omega->proc~dt_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate_order_2_fast Source Code subroutine integrate_order_2_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 2nd order class scheme, fast mode. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. real ( R_P ) :: omega_sq !< Square of omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) omega_sq = omega_ * omega_ call U % multiply_fast ( lhs = self % previous ( 1 ), rhs = 1._R_P / omega_sq ) call self % buffer % multiply_fast ( lhs = self % previous ( self % steps ), rhs = ( omega_sq - 1._R_P ) / omega_sq ) call U % add_fast ( lhs = U , rhs = self % buffer ) self % buffer = self % previous ( self % steps ) call self % buffer % t_fast ( t = self % t ( self % steps )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / omega_ ) call U % add_fast ( lhs = U , rhs = self % buffer ) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_2_fast","tags":"","loc":"proc/integrate_order_2_fast.html","title":"integrate_order_2_fast – FOODIE"},{"text":"private subroutine integrate_order_3(self, U, Dt, t) Integrate field with LMM-SSP-VSS 3rd order class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Calls proc~~integrate_order_3~~CallsGraph proc~integrate_order_3 integrate_order_3 proc~omega omega proc~integrate_order_3->proc~omega proc~dt_ratio dt_ratio proc~omega->proc~dt_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate_order_3 Source Code subroutine integrate_order_3 ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 3rd order class scheme. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) U = ( self % previous ( 1 ) * (( 3._R_P * omega_ + 2._R_P ) / omega_ ** 3 )) + & ( self % previous ( self % steps ) * ((( omega_ + 1._R_P ) ** 2 ) * ( omega_ - 2._R_P ) / omega_ ** 3 )) + & ( self % previous ( 1 )% t ( t = self % t ( 1 )) * ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / omega_ ** 2 )) + & ( self % previous ( self % steps )% t ( t = self % t ( self % steps )) * ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) ** 2 / omega_ ** 2 )) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_3","tags":"","loc":"proc/integrate_order_3.html","title":"integrate_order_3 – FOODIE"},{"text":"private subroutine integrate_order_3_fast(self, U, Dt, t) Integrate field with LMM-SSP-VSS 3rd order class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Calls proc~~integrate_order_3_fast~~CallsGraph proc~integrate_order_3_fast integrate_order_3_fast proc~omega omega proc~integrate_order_3_fast->proc~omega proc~dt_ratio dt_ratio proc~omega->proc~dt_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate_order_3_fast Source Code subroutine integrate_order_3_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP-VSS 3rd order class scheme, fast mode. class ( integrator_lmm_ssp_vss ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ) :: omega_ !< Omega coefficient. omega_ = omega ( Dt = self % Dt , s = self % steps - 1 ) call U % multiply_fast ( lhs = self % previous ( 1 ), rhs = ( 3._R_P * omega_ + 2._R_P ) / ( omega_ ** 3 )) call self % buffer % multiply_fast ( lhs = self % previous ( self % steps ), rhs = ((( omega_ + 1._R_P ) ** 2 ) * ( omega_ - 2._R_P ) / ( omega_ ** 3 ))) call U % add_fast ( lhs = U , rhs = self % buffer ) self % buffer = self % previous ( 1 ) call self % buffer % t_fast ( t = self % t ( 1 )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = self % Dt ( self % steps ) * ( omega_ + 1._R_P ) / ( omega_ ** 2 )) call U % add_fast ( lhs = U , rhs = self % buffer ) self % buffer = self % previous ( self % steps ) call self % buffer % t_fast ( t = self % t ( self % steps )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = ( self % Dt ( self % steps ) * ( omega_ + 1._R_P ) ** 2 / ( omega_ ** 2 ))) call U % add_fast ( lhs = U , rhs = self % buffer ) if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_Dt = self % Dt , previous_t = self % t ) endsubroutine integrate_order_3_fast","tags":"","loc":"proc/integrate_order_3_fast.html","title":"integrate_order_3_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~9.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~9.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~9.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_ms_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~9.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage_multistep if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % Ahat )) deallocate ( self % Ahat ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % Bhat )) deallocate ( self % Bhat ) if ( allocated ( self % D )) deallocate ( self % D ) if ( allocated ( self % Q )) deallocate ( self % Q ) endsubroutine destroy","tags":"","loc":"proc/destroy~9.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual MS-RK-SSP integrator: initialize the A,Ahat,B,Bhat,D,T coefficients. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , iterations , autoupdate , U , stop_on_fail ) !< Create the actual MS-RK-SSP integrator: initialize the *A,Ahat,B,Bhat,D,T* coefficients. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. integer ( I_P ), intent ( in ), optional :: iterations !< Implicit iterations. logical , intent ( in ), optional :: autoupdate !< Enable cyclic autoupdate of previous time steps. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'ms_runge_kutta_ssp_steps_2_stages_2_order_3' ) self % steps = 2 self % stages = 2 allocate ( self % A ( 1 : self % stages , 1 : self % stages )) ; self % A = 0._R_P self % A ( 2 , 1 ) = 0.910683602522959_R_P allocate ( self % Ahat ( 1 : self % stages , 1 : self % steps )) ; self % Ahat = 0._R_P self % Ahat ( 2 , 1 ) = - 1.11985107194706e-19_R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P self % B ( 1 ) = 0.535898384862245_R_P self % B ( 2 ) = 0.803847577293368_R_P allocate ( self % Bhat ( 1 : self % steps )) ; self % Bhat = 0._R_P self % Bhat ( 1 ) = 0.267949192431123_R_P allocate ( self % D ( 1 : self % stages , 1 : self % steps )) ; self % D = 0._R_P self % D ( 2 , 1 ) = 1._R_P / 3._R_P self % D ( 2 , 2 ) = 2._R_P / 3._R_P allocate ( self % Q ( 1 : self % steps )) ; self % Q = 0._R_P self % Q ( 1 ) = 0.607695154586736_R_P self % Q ( 2 ) = 0.392304845413264_R_P case ( 'ms_runge_kutta_ssp_steps_3_stages_2_order_3' ) self % steps = 3 self % stages = 2 allocate ( self % A ( 1 : self % stages , 1 : self % stages )) ; self % A = 0._R_P self % A ( 2 , 1 ) = 0.731058363135786_R_P allocate ( self % Ahat ( 1 : self % stages , 1 : self % steps )) ; self % Ahat = 0._R_P self % Ahat ( 2 , 1 ) = 0.127467809251820_R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P self % B ( 1 ) = 0.618048297723782_R_P self % B ( 2 ) = 0.759677988437936_R_P allocate ( self % Bhat ( 1 : self % steps )) ; self % Bhat = 0._R_P self % Bhat ( 1 ) = 0.246670340394148_R_P allocate ( self % D ( 1 : self % stages , 1 : self % steps )) ; self % D = 0._R_P self % D ( 2 , 1 ) = 0.186433848116852_R_P self % D ( 2 , 2 ) = 1.80945758995975e-24_R_P self % D ( 2 , 3 ) = 0.813566151883148_R_P allocate ( self % Q ( 1 : self % steps )) ; self % Q = 0._R_P self % Q ( 1 ) = 0.312198313277933_R_P self % Q ( 2 ) = 2.58493941422821e-24_R_P self % Q ( 3 ) = 0.687801686722067_R_P case ( 'ms_runge_kutta_ssp_steps_4_stages_5_order_8' ) self % steps = 4 self % stages = 5 allocate ( self % A ( 1 : self % stages , 1 : self % stages )) ; self % A = 0._R_P self % A ( 2 , 1 ) = 0.0112355687952080_R_P self % A ( 3 , 1 ) = 0.782384118905967_R_P self % A ( 4 , 1 ) = 0.0997788285846345_R_P self % A ( 5 , 1 ) = 0.0173871875042219_R_P self % A ( 4 , 2 ) = 0.775239818309315_R_P self % A ( 5 , 2 ) = 0.781995253645396_R_P self % A ( 4 , 3 ) = 0.522304633131092_R_P self % A ( 5 , 3 ) = 0.0817254029032851_R_P self % A ( 5 , 4 ) = 0.654483113500859_R_P allocate ( self % Ahat ( 1 : self % stages , 1 : self % steps )) ; self % Ahat = 0._R_P self % Ahat ( 2 , 1 ) = 0.000422703250336666_R_P self % Ahat ( 3 , 1 ) = 0.0959783036454617_R_P self % Ahat ( 4 , 1 ) = 0.0140562464699573_R_P self % Ahat ( 5 , 1 ) = 0.0519851819388547_R_P self % Ahat ( 2 , 2 ) = 0.259546324808661_R_P self % Ahat ( 3 , 2 ) = 0.382496291927802_R_P self % Ahat ( 4 , 2 ) = 0.195323228972419_R_P self % Ahat ( 5 , 2 ) = 0.435648262830826_R_P self % Ahat ( 2 , 3 ) = 0.752684925098657_R_P self % Ahat ( 3 , 3 ) = 0.563081036068107_R_P self % Ahat ( 4 , 3 ) = 0.209815168854422_R_P self % Ahat ( 5 , 3 ) = 0.151720560507208_R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P self % B ( 1 ) = 0.711472565648602_R_P self % B ( 2 ) = 0.0953138922500395_R_P self % B ( 3 ) = 0.0808915576045876_R_P self % B ( 4 ) = 0.214580109044146_R_P self % B ( 5 ) = 0.351640244526174_R_P allocate ( self % Bhat ( 1 : self % steps )) ; self % Bhat = 0._R_P self % Bhat ( 1 ) = 0.00614782373612238_R_P self % Bhat ( 2 ) = 0.138226341918060_R_P self % Bhat ( 3 ) = 0.541410372692778_R_P allocate ( self % D ( 1 : self % stages , 1 : self % steps )) ; self % D = 0._R_P self % D ( 2 , 1 ) = 0.0273928990974108_R_P self % D ( 3 , 1 ) = 0.283607987548794_R_P self % D ( 4 , 1 ) = 0.0642241421937960_R_P self % D ( 5 , 1 ) = 0.194681462814288_R_P self % D ( 2 , 2 ) = 0.554039201229659_R_P self % D ( 3 , 2 ) = 0.0914454235177934_R_P self % D ( 4 , 2 ) = 0.198601843371796_R_P self % D ( 5 , 2 ) = 0.293086617882372_R_P self % D ( 2 , 3 ) = 0.348927848402249_R_P self % D ( 3 , 3 ) = 0.437897855084625_R_P self % D ( 4 , 3 ) = 0.662266498804591_R_P self % D ( 5 , 3 ) = 0.158740367819382_R_P self % D ( 2 , 4 ) = 0.0696400512706807_R_P self % D ( 3 , 4 ) = 0.187048733848788_R_P self % D ( 4 , 4 ) = 0.0749075156298171_R_P self % D ( 5 , 4 ) = 0.353491551483958_R_P allocate ( self % Q ( 1 : self % steps )) ; self % Q = 0._R_P self % Q ( 1 ) = 0.0273988434707855_R_P self % Q ( 2 ) = 0.286296288278021_R_P self % Q ( 3 ) = 0.484893800452111_R_P self % Q ( 4 ) = 0.201411067799082_R_P endselect self % autoupdate = . true . ; if ( present ( autoupdate )) self % autoupdate = autoupdate self % iterations = 1 ; if ( present ( iterations )) self % iterations = iterations self % registers_stages = self % stages self % registers_steps = self % steps if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~9.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_multistage_multistep ( rhs = rhs ) select type ( rhs ) class is ( integrator_ms_runge_kutta_ssp ) if ( allocated ( rhs % A )) lhs % A = rhs % A if ( allocated ( rhs % Ahat )) lhs % Ahat = rhs % Ahat if ( allocated ( rhs % B )) lhs % B = rhs % B if ( allocated ( rhs % Bhat )) lhs % Bhat = rhs % Bhat if ( allocated ( rhs % D )) lhs % D = rhs % D if ( allocated ( rhs % Q )) lhs % Q = rhs % Q endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~9.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: k , kk !< Stages counters. integer ( I_P ) :: s !< Steps counter. ! computing stages self % stage ( 1 ) = U do k = 2 , self % stages self % stage ( k ) = U * 0._R_P do s = 1 , self % steps if ( self % D ( k , s ) /= 0._R_P ) self % stage ( k ) = self % stage ( k ) + ( self % previous ( s ) * self % D ( k , s )) enddo do s = 1 , self % steps - 1 if ( self % Ahat ( k , s ) /= 0._R_P ) self % stage ( k ) = self % stage ( k ) + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % Ahat ( k , s ))) enddo do kk = 1 , k - 1 if ( self % A ( k , kk ) /= 0._R_P ) self % stage ( k ) = self % stage ( k ) + ( self % stage ( kk )% t ( t = t ) * ( Dt * self % A ( k , kk ))) enddo enddo ! computing new time step U = U * 0._R_P do s = 1 , self % steps if ( self % Q ( s ) /= 0._R_P ) U = U + ( self % previous ( s ) * self % Q ( s )) enddo do s = 1 , self % steps - 1 if ( self % Bhat ( s ) /= 0._R_P ) U = U + ( self % previous ( s )% t ( t = self % t ( s )) * ( Dt * self % Bhat ( s ))) enddo do k = 1 , self % stages if ( self % B ( k ) /= 0._R_P ) U = U + ( self % stage ( k )% t ( t = t ) * ( Dt * self % B ( k ))) enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate","tags":"","loc":"proc/integrate~9.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t ) !< Integrate field with LMM-SSP class scheme, fast mode. class ( integrator_ms_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: k , kk !< Stages counters. integer ( I_P ) :: s !< Steps counter. ! computing stages self % stage ( 1 ) = U do k = 2 , self % stages call self % stage ( k )% multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % steps if ( self % D ( k , s ) /= 0._R_P ) then call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs = self % D ( k , s )) call self % stage ( k )% add_fast ( lhs = self % stage ( k ), rhs = self % buffer ) endif enddo do s = 1 , self % steps - 1 if ( self % Ahat ( k , s ) /= 0._R_P ) then self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % Ahat ( k , s )) call self % stage ( k )% add_fast ( lhs = self % stage ( k ), rhs = self % buffer ) endif enddo do kk = 1 , k - 1 if ( self % A ( k , kk ) /= 0._R_P ) then self % buffer = self % stage ( kk ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % A ( k , kk )) call self % stage ( k )% add_fast ( lhs = self % stage ( k ), rhs = self % buffer ) endif enddo enddo ! computing new time step U = U * 0._R_P do s = 1 , self % steps if ( self % Q ( s ) /= 0._R_P ) then call self % buffer % multiply_fast ( lhs = self % previous ( s ), rhs = self % Q ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo do s = 1 , self % steps - 1 if ( self % Bhat ( s ) /= 0._R_P ) then self % buffer = self % previous ( s ) call self % buffer % t_fast ( t = self % t ( s )) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % Bhat ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo do k = 1 , self % stages if ( self % B ( k ) /= 0._R_P ) U = U + ( self % stage ( k )% t ( t = t ) * ( Dt * self % B ( k ))) if ( self % B ( k ) /= 0._R_P ) then self % buffer = self % stage ( k ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * self % B ( k )) call U % add_fast ( lhs = U , rhs = self % buffer ) endif enddo if ( self % autoupdate ) call self % update_previous ( U = U , previous = self % previous , Dt = Dt , t = t , previous_t = self % t ) endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~9.html","title":"integrate_fast – FOODIE"},{"text":"private elemental function is_multistage(self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code is_multistage Source Code elemental function is_multistage ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistage !< Inquire result. is_multistage = . true . endfunction is_multistage","tags":"","loc":"proc/is_multistage.html","title":"is_multistage – FOODIE"},{"text":"private elemental function is_multistep(self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code is_multistep Source Code elemental function is_multistep ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistep !< Inquire result. is_multistep = . true . endfunction is_multistep","tags":"","loc":"proc/is_multistep.html","title":"is_multistep – FOODIE"},{"text":"private elemental function stages_number(self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. Source Code stages_number Source Code elemental function stages_number ( self ) !< Return number of stages used. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: stages_number !< Number of stages used. stages_number = self % stages endfunction stages_number","tags":"","loc":"proc/stages_number.html","title":"stages_number – FOODIE"},{"text":"private elemental function steps_number(self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. Source Code steps_number Source Code elemental function steps_number ( self ) !< Return number of steps used. class ( integrator_multistage_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: steps_number !< Number of steps used. steps_number = self % steps endfunction steps_number","tags":"","loc":"proc/steps_number.html","title":"steps_number – FOODIE"},{"text":"private subroutine allocate_integrand_members(self, U) Allocate members of interpolator being of integrand_object class. Note It is assumed that the integrator has been properly initialized before calling this method. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. Source Code allocate_integrand_members Source Code subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_multistage_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistage () . and . self % registers_stages > 0 ) then if ( allocated ( self % stage )) deallocate ( self % stage ) allocate ( self % stage ( 1 : self % registers_stages ), mold = U ) do s = 1 , self % registers_stages self % stage ( s ) = U enddo endif if ( self % is_multistep () . and . self % registers_steps > 0 ) then if ( allocated ( self % Dt )) deallocate ( self % Dt ) allocate ( self % Dt ( 1 : self % registers_steps )) ; self % Dt = 0._R_P if ( allocated ( self % t )) deallocate ( self % t ) allocate ( self % t ( 1 : self % registers_steps )) ; self % t = 0._R_P if ( allocated ( self % previous )) deallocate ( self % previous ) allocate ( self % previous ( 1 : self % registers_steps ), mold = U ) do s = 1 , self % registers_steps self % previous ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif endsubroutine allocate_integrand_members","tags":"","loc":"proc/allocate_integrand_members~2.html","title":"allocate_integrand_members – FOODIE"},{"text":"private subroutine assign_multistage_multistep(lhs, rhs) Assign members of integrator_multistage_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code assign_multistage_multistep Source Code subroutine assign_multistage_multistep ( lhs , rhs ) !< Assign members of [[integrator_multistage_multistep_object]] and parents. class ( integrator_multistage_multistep_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: s !< Counter. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_multistage_multistep_object ) lhs % registers_stages = rhs % registers_stages lhs % registers_steps = rhs % registers_steps lhs % stages = rhs % stages lhs % steps = rhs % steps lhs % autoupdate = rhs % autoupdate lhs % iterations = rhs % iterations if ( allocated ( lhs % Dt )) deallocate ( lhs % Dt ) if ( allocated ( rhs % Dt )) lhs % Dt = rhs % Dt if ( allocated ( lhs % t )) deallocate ( lhs % t ) if ( allocated ( rhs % t )) lhs % t = rhs % t if ( allocated ( lhs % previous )) deallocate ( lhs % previous ) if ( allocated ( rhs % previous )) then allocate ( lhs % previous ( 1 : lhs % registers_steps ), mold = rhs % previous ) do s = 1 , lhs % registers_steps lhs % previous ( s ) = rhs % previous ( s ) enddo endif if ( allocated ( lhs % stage )) deallocate ( lhs % stage ) if ( allocated ( rhs % stage )) then allocate ( lhs % stage ( 1 : lhs % registers_stages ), mold = rhs % stage ) do s = 1 , lhs % registers_stages lhs % stage ( s ) = rhs % stage ( s ) enddo endif if ( allocated ( lhs % buffer )) deallocate ( lhs % buffer ) if ( allocated ( rhs % buffer )) then allocate ( lhs % buffer , mold = rhs % buffer ) lhs % buffer = rhs % buffer endif endselect endsubroutine assign_multistage_multistep","tags":"","loc":"proc/assign_multistage_multistep.html","title":"assign_multistage_multistep – FOODIE"},{"text":"private elemental subroutine destroy_multistage_multistep(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. Source Code destroy_multistage_multistep Source Code elemental subroutine destroy_multistage_multistep ( self ) !< Destroy the integrator. class ( integrator_multistage_multistep_object ), intent ( inout ) :: self !< Integrator. call self % destroy_abstract self % registers_stages = 0 self % registers_steps = 0 self % stages = 0 self % steps = - 1 self % autoupdate = . false . self % iterations = 0 if ( allocated ( self % Dt )) deallocate ( self % Dt ) if ( allocated ( self % t )) deallocate ( self % t ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % stage )) deallocate ( self % stage ) if ( allocated ( self % buffer )) deallocate ( self % buffer ) endsubroutine destroy_multistage_multistep","tags":"","loc":"proc/destroy_multistage_multistep.html","title":"destroy_multistage_multistep – FOODIE"},{"text":"private subroutine update_previous(U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code update_previous Source Code subroutine update_previous ( U , previous , Dt , t , previous_Dt , previous_t ) !< Cyclic update previous time steps. class ( integrand_object ), intent ( in ) :: U !< Field to be integrated. class ( integrand_object ), intent ( inout ) :: previous ( 1 :) !< Previous time steps solutions of integrand. real ( R_P ), intent ( in ), optional :: Dt !< Time step. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), intent ( inout ), optional :: previous_Dt ( 1 :) !< Time step. real ( R_P ), intent ( inout ), optional :: previous_t ( 1 :) !< Time. integer ( I_P ) :: last_step !< Last step. integer ( I_P ) :: s !< Steps counter. last_step = size ( previous , dim = 1 ) do s = 1 , last_step - 1 previous ( s ) = previous ( s + 1 ) if ( present ( previous_Dt )) previous_Dt ( s ) = previous_Dt ( s + 1 ) if ( present ( previous_t )) previous_t ( s ) = previous_t ( s + 1 ) enddo previous ( last_step ) = U if ( present ( previous_Dt )) previous_Dt ( last_step ) = Dt if ( present ( previous_t )) previous_t ( last_step ) = t + Dt endsubroutine update_previous","tags":"","loc":"proc/update_previous.html","title":"update_previous – FOODIE"},{"text":"private elemental function is_multistage(self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code is_multistage Source Code elemental function is_multistage ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. logical :: is_multistage !< Inquire result. is_multistage = . true . endfunction is_multistage","tags":"","loc":"proc/is_multistage~2.html","title":"is_multistage – FOODIE"},{"text":"private elemental function is_multistep(self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code is_multistep Source Code elemental function is_multistep ( self ) !< Return .true. for multistage integrator. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. logical :: is_multistep !< Inquire result. is_multistep = . false . endfunction is_multistep","tags":"","loc":"proc/is_multistep~2.html","title":"is_multistep – FOODIE"},{"text":"private elemental function stages_number(self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. Source Code stages_number Source Code elemental function stages_number ( self ) !< Return number of stages used. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: stages_number !< Number of stages used. stages_number = self % stages endfunction stages_number","tags":"","loc":"proc/stages_number~2.html","title":"stages_number – FOODIE"},{"text":"private elemental function steps_number(self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. Source Code steps_number Source Code elemental function steps_number ( self ) !< Return number of steps used. class ( integrator_multistage_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: steps_number !< Number of steps used. steps_number = 0 endfunction steps_number","tags":"","loc":"proc/steps_number~2.html","title":"steps_number – FOODIE"},{"text":"private subroutine allocate_integrand_members(self, U) Allocate members of interpolator being of integrand_object class. Note It is assumed that the integrator has been properly initialized before calling this method. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. Source Code allocate_integrand_members Source Code subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_multistage_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistage () . and . self % registers > 0 ) then if ( allocated ( self % stage )) deallocate ( self % stage ) allocate ( self % stage ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % stage ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif endsubroutine allocate_integrand_members","tags":"","loc":"proc/allocate_integrand_members~3.html","title":"allocate_integrand_members – FOODIE"},{"text":"private subroutine assign_multistage(lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code assign_multistage Source Code subroutine assign_multistage ( lhs , rhs ) !< Assign members of [[integrator_multistage_object]] and parents. class ( integrator_multistage_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: s !< Counter. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_multistage_object ) lhs % registers = rhs % registers lhs % stages = rhs % stages if ( allocated ( lhs % stage )) deallocate ( lhs % stage ) if ( allocated ( rhs % stage )) then allocate ( lhs % stage ( 1 : lhs % registers ), mold = rhs % stage ) do s = 1 , lhs % registers lhs % stage ( s ) = rhs % stage ( s ) enddo endif if ( allocated ( lhs % buffer )) deallocate ( lhs % buffer ) if ( allocated ( rhs % buffer )) then allocate ( lhs % buffer , mold = rhs % buffer ) lhs % buffer = rhs % buffer endif endselect endsubroutine assign_multistage","tags":"","loc":"proc/assign_multistage.html","title":"assign_multistage – FOODIE"},{"text":"private elemental subroutine destroy_multistage(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. Source Code destroy_multistage Source Code elemental subroutine destroy_multistage ( self ) !< Destroy the integrator. class ( integrator_multistage_object ), intent ( inout ) :: self !< Integrator. call self % destroy_abstract self % registers = 0 self % stages = 0 if ( allocated ( self % stage )) deallocate ( self % stage ) if ( allocated ( self % buffer )) deallocate ( self % buffer ) endsubroutine destroy_multistage","tags":"","loc":"proc/destroy_multistage.html","title":"destroy_multistage – FOODIE"},{"text":"private elemental function is_multistage(self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code is_multistage Source Code elemental function is_multistage ( self ) !< Return .true. for multistage integrator. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistage !< Inquire result. is_multistage = . false . endfunction is_multistage","tags":"","loc":"proc/is_multistage~3.html","title":"is_multistage – FOODIE"},{"text":"private elemental function is_multistep(self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code is_multistep Source Code elemental function is_multistep ( self ) !< Return .true. for multistage integrator. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. logical :: is_multistep !< Inquire result. is_multistep = . true . endfunction is_multistep","tags":"","loc":"proc/is_multistep~3.html","title":"is_multistep – FOODIE"},{"text":"private elemental function stages_number(self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. Source Code stages_number Source Code elemental function stages_number ( self ) !< Return number of stages used. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: stages_number !< Number of stages used. stages_number = 0 endfunction stages_number","tags":"","loc":"proc/stages_number~3.html","title":"stages_number – FOODIE"},{"text":"private elemental function steps_number(self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. Source Code steps_number Source Code elemental function steps_number ( self ) !< Return number of steps used. class ( integrator_multistep_object ), intent ( in ) :: self !< Integrator. integer ( I_P ) :: steps_number !< Number of steps used. steps_number = self % steps endfunction steps_number","tags":"","loc":"proc/steps_number~3.html","title":"steps_number – FOODIE"},{"text":"private subroutine allocate_integrand_members(self, U) Allocate members of interpolator being of integrand_object class. Note It is assumed that the integrator has been properly initialized before calling this method. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. Source Code allocate_integrand_members Source Code subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_multistep_object ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistep () . and . self % registers > 0 ) then if ( allocated ( self % Dt )) deallocate ( self % Dt ) allocate ( self % Dt ( 1 : self % registers )) ; self % Dt = 0._R_P if ( allocated ( self % t )) deallocate ( self % t ) allocate ( self % t ( 1 : self % registers )) ; self % t = 0._R_P if ( allocated ( self % previous )) deallocate ( self % previous ) allocate ( self % previous ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % previous ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif endsubroutine allocate_integrand_members","tags":"","loc":"proc/allocate_integrand_members~4.html","title":"allocate_integrand_members – FOODIE"},{"text":"private subroutine assign_multistep(lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code assign_multistep Source Code subroutine assign_multistep ( lhs , rhs ) !< Assign members of [[integrator_multistep_object]] and parents. class ( integrator_multistep_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. integer ( I_P ) :: s !< Counter. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_multistep_object ) lhs % registers = rhs % registers lhs % steps = rhs % steps lhs % autoupdate = rhs % autoupdate lhs % iterations = rhs % iterations if ( allocated ( lhs % Dt )) deallocate ( lhs % Dt ) if ( allocated ( rhs % Dt )) lhs % Dt = rhs % Dt if ( allocated ( lhs % t )) deallocate ( lhs % t ) if ( allocated ( rhs % t )) lhs % t = rhs % t if ( allocated ( lhs % previous )) deallocate ( lhs % previous ) if ( allocated ( rhs % previous )) then allocate ( lhs % previous ( 1 : lhs % registers ), mold = rhs % previous ) do s = 1 , lhs % registers lhs % previous ( s ) = rhs % previous ( s ) enddo endif if ( allocated ( lhs % buffer )) deallocate ( lhs % buffer ) if ( allocated ( rhs % buffer )) then allocate ( lhs % buffer , mold = rhs % buffer ) lhs % buffer = rhs % buffer endif endselect endsubroutine assign_multistep","tags":"","loc":"proc/assign_multistep.html","title":"assign_multistep – FOODIE"},{"text":"private elemental subroutine destroy_multistep(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. Source Code destroy_multistep Source Code elemental subroutine destroy_multistep ( self ) !< Destroy the integrator. class ( integrator_multistep_object ), intent ( inout ) :: self !< Integrator. call self % destroy_abstract self % registers = 0 self % steps = - 1 self % autoupdate = . false . self % iterations = 0 if ( allocated ( self % Dt )) deallocate ( self % Dt ) if ( allocated ( self % t )) deallocate ( self % t ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % buffer )) deallocate ( self % buffer ) endsubroutine destroy_multistep","tags":"","loc":"proc/destroy_multistep.html","title":"destroy_multistep – FOODIE"},{"text":"private subroutine update_previous(U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time. Source Code update_previous Source Code subroutine update_previous ( U , previous , Dt , t , previous_Dt , previous_t ) !< Cyclic update previous time steps. class ( integrand_object ), intent ( in ) :: U !< Field to be integrated. class ( integrand_object ), intent ( inout ) :: previous ( 1 :) !< Previous time steps solutions of integrand. real ( R_P ), intent ( in ), optional :: Dt !< Time step. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), intent ( inout ), optional :: previous_Dt ( 1 :) !< Time step. real ( R_P ), intent ( inout ), optional :: previous_t ( 1 :) !< Time. integer ( I_P ) :: last_step !< Last step. integer ( I_P ) :: s !< Steps counter. last_step = size ( previous , dim = 1 ) do s = 1 , last_step - 1 previous ( s ) = previous ( s + 1 ) if ( present ( previous_Dt )) previous_Dt ( s ) = previous_Dt ( s + 1 ) if ( present ( previous_t )) previous_t ( s ) = previous_t ( s + 1 ) enddo previous ( last_step ) = U if ( present ( previous_Dt )) previous_Dt ( last_step ) = Dt if ( present ( previous_t )) previous_t ( last_step ) = t + Dt endsubroutine update_previous","tags":"","loc":"proc/update_previous~2.html","title":"update_previous – FOODIE"},{"text":"private pure function description(self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrator_object ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix if ( allocated ( self % description_ )) then desc = prefix // self % description_ else desc = prefix // self % class_name () endif endfunction description","tags":"","loc":"proc/description.html","title":"description – FOODIE"},{"text":"private subroutine assign_abstract(lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code assign_abstract Source Code subroutine assign_abstract ( lhs , rhs ) !< Assign ony members of abstract [[integrator_object]] type. class ( integrator_object ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. if ( allocated ( rhs % description_ )) lhs % description_ = rhs % description_ lhs % error = rhs % error if ( allocated ( rhs % error_message )) lhs % error_message = rhs % error_message endsubroutine assign_abstract","tags":"","loc":"proc/assign_abstract.html","title":"assign_abstract – FOODIE"},{"text":"private subroutine check_error(self, is_severe) Check for error occurencies. If is_severe=.true. an stop is called. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code check_error Source Code subroutine check_error ( self , is_severe ) !< Check for error occurencies. !< !< If `is_severe=.true.` an stop is called. class ( integrator_object ), intent ( in ) :: self !< Integrator. logical , intent ( in ), optional :: is_severe !< Flag to activate severe faliure, namely errors trigger a stop. if ( self % error /= 0 ) then if ( allocated ( self % error_message )) then write ( stderr , '(A)' ) 'error: ' // self % error_message else write ( stderr , '(A)' ) 'error: an obscure error occurred!' endif write ( stderr , '(A,I4)' ) 'error code: ' , self % error if ( present ( is_severe )) then if ( is_severe ) stop endif endif endsubroutine check_error","tags":"","loc":"proc/check_error.html","title":"check_error – FOODIE"},{"text":"private elemental subroutine destroy_abstract(self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. Source Code destroy_abstract Source Code elemental subroutine destroy_abstract ( self ) !< Destroy only members of abstract [[integrator_object]] type. class ( integrator_object ), intent ( inout ) :: self !< Integrator. if ( allocated ( self % description_ )) deallocate ( self % description_ ) self % error = 0 if ( allocated ( self % error_message )) deallocate ( self % error_message ) endsubroutine destroy_abstract","tags":"","loc":"proc/destroy_abstract.html","title":"destroy_abstract – FOODIE"},{"text":"private subroutine trigger_error(self, error, error_message, is_severe) Check for error occurencies. If is_severe=.true. an stop is called. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. Source Code trigger_error Source Code subroutine trigger_error ( self , error , error_message , is_severe ) !< Check for error occurencies. !< !< If `is_severe=.true.` an stop is called. class ( integrator_object ), intent ( inout ) :: self !< Integrator. integer ( I_P ), intent ( in ) :: error !< Error status code. character ( len =* ), intent ( in ), optional :: error_message !< Error message, hopefully meaningful. logical , intent ( in ), optional :: is_severe !< Flag to activate severe faliure, namely errors trigger a stop. self % error = error if ( present ( error_message )) self % error_message = error_message call self % check_error ( is_severe = is_severe ) endsubroutine trigger_error","tags":"","loc":"proc/trigger_error.html","title":"trigger_error – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~10.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~10.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~10.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~10.html","title":"supported_schemes – FOODIE"},{"text":"private subroutine allocate_integrand_members(self, U) Allocate members of interpolator being of integrand_object class. Note It is assumed that the integrator has been properly initialized before calling this method. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. Source Code allocate_integrand_members Source Code subroutine allocate_integrand_members ( self , U ) !< Allocate members of interpolator being of [[integrand_object]] class. !< !< @note It is assumed that the integrator has been properly initialized before calling this method. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( in ) :: U !< Integrand. integer ( I_P ) :: s !< Counter. if ( self % is_multistage () . and . self % registers > 0 ) then if ( allocated ( self % stage )) deallocate ( self % stage ) allocate ( self % stage ( 1 : self % registers ), mold = U ) do s = 1 , self % registers self % stage ( s ) = U enddo endif if ( self % has_fast_mode ()) then if ( allocated ( self % buffer )) deallocate ( self % buffer ) allocate ( self % buffer , mold = U ) self % buffer = U endif if ( allocated ( self % U1 )) deallocate ( self % U1 ) allocate ( self % U1 , mold = U ) self % U1 = U if ( allocated ( self % U2 )) deallocate ( self % U2 ) allocate ( self % U2 , mold = U ) self % U2 = U endsubroutine allocate_integrand_members","tags":"","loc":"proc/allocate_integrand_members~5.html","title":"allocate_integrand_members – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage self % tolerance = 0._R_P self % pp1_inv = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) endsubroutine destroy","tags":"","loc":"proc/destroy~10.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, U, tolerance, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , U , tolerance , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. real ( R_P ), intent ( in ), optional :: tolerance !< Tolerance on the local truncation error (default 0.01). logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) self % tolerance = 0.01_R_P ; if ( present ( tolerance )) self % tolerance = tolerance select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_emd_stages_2_order_2' ) ! do not use, seems to not work! self % stages = 2 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 2._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.5_R_P ; self % beta ( 1 , 2 ) = 5._R_P self % beta ( 2 , 1 ) = 1._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 'runge_kutta_emd_stages_6_order_5' ) self % stages = 6 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 5._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 7._R_P / 37 8._R_P ; self % beta ( 1 , 2 ) = 282 5._R_P / 2764 8._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 25 0._R_P / 62 1._R_P ; self % beta ( 3 , 2 ) = 1857 5._R_P / 4838 4._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 59 4._R_P ; self % beta ( 4 , 2 ) = 1352 5._R_P / 5529 6._R_P self % beta ( 5 , 1 ) = 0._R_P ; self % beta ( 5 , 2 ) = 27 7._R_P / 1433 6._R_P self % beta ( 6 , 1 ) = 51 2._R_P / 177 1._R_P ; self % beta ( 6 , 2 ) = 1._R_P / 4._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 1 0._R_P ; self % alph ( 4 , 2 ) = - 9._R_P / 1 0._R_P ; self % alph ( 4 , 3 ) = 6._R_P / 5._R_P self % alph ( 5 , 1 ) =- 1 1._R_P / 5 4._R_P ; self % alph ( 5 , 2 ) = 5._R_P / 2._R_P ; self % alph ( 5 , 3 ) =- 7 0._R_P / 2 7._R_P self % alph ( 6 , 1 ) = 163 1._R_P / 5529 6._R_P ; self % alph ( 6 , 2 ) = 17 5._R_P / 51 2._R_P ; self % alph ( 6 , 3 ) = 57 5._R_P / 1382 4._R_P self % alph ( 5 , 4 ) = 3 5._R_P / 2 7._R_P self % alph ( 6 , 4 ) = 4427 5._R_P / 11059 2._R_P ; self % alph ( 6 , 5 ) = 25 3._R_P / 409 6._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 3._R_P / 5._R_P self % gamm ( 5 ) = 1._R_P self % gamm ( 6 ) = 7._R_P / 8._R_P case ( 'runge_kutta_emd_stages_7_order_4' ) self % stages = 7 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 4._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 3 5._R_P / 38 4._R_P ; self % beta ( 1 , 2 ) = 517 9._R_P / 5760 0._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 50 0._R_P / 111 3._R_P ; self % beta ( 3 , 2 ) = 757 1._R_P / 1669 5._R_P self % beta ( 4 , 1 ) = 12 5._R_P / 19 2._R_P ; self % beta ( 4 , 2 ) = 39 3._R_P / 64 0._R_P self % beta ( 5 , 1 ) = - 218 7._R_P / 678 4._R_P ; self % beta ( 5 , 2 ) = - 9209 7._R_P / 33920 0._R_P self % beta ( 6 , 1 ) = 1 1._R_P / 8 4._R_P ; self % beta ( 6 , 2 ) = 18 7._R_P / 210 0._R_P self % beta ( 7 , 1 ) = 0._R_P ; self % beta ( 7 , 2 ) = 1._R_P / 4 0._R_P self % alph ( 2 , 1 ) = 1._R_P / 5._R_P self % alph ( 3 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 3 , 2 ) = 9._R_P / 4 0._R_P self % alph ( 4 , 1 ) = 4 4._R_P / 4 5._R_P ; self % alph ( 4 , 2 ) =- 5 6._R_P / 1 5._R_P ; self % alph ( 4 , 3 ) = 3 2._R_P / 9._R_P self % alph ( 5 , 1 ) = 1937 2._R_P / 656 1._R_P ; self % alph ( 5 , 2 ) =- 2536 0._R_P / 218 7._R_P ; self % alph ( 5 , 3 ) = 6444 8._R_P / 656 1._R_P self % alph ( 6 , 1 ) = 901 7._R_P / 316 8._R_P ; self % alph ( 6 , 2 ) =- 35 5._R_P / 3 3._R_P ; self % alph ( 6 , 3 ) = 4673 2._R_P / 524 7._R_P self % alph ( 7 , 1 ) = 3 5._R_P / 38 4._R_P ; self % alph ( 7 , 2 ) = 0._R_P ; self % alph ( 7 , 3 ) = 50 0._R_P / 111 3._R_P self % alph ( 5 , 4 ) =- 21 2._R_P / 72 9._R_P self % alph ( 6 , 4 ) = 4 9._R_P / 17 6._R_P ; self % alph ( 6 , 5 ) =- 510 3._R_P / 1865 6._R_P self % alph ( 7 , 4 ) = 12 5._R_P / 19 2._R_P ; self % alph ( 7 , 5 ) =- 218 7._R_P / 678 4._R_P ; self % alph ( 7 , 6 ) = 1 1._R_P / 8 4._R_P self % gamm ( 2 ) = 1._R_P / 5._R_P self % gamm ( 3 ) = 3._R_P / 1 0._R_P self % gamm ( 4 ) = 4._R_P / 5._R_P self % gamm ( 5 ) = 8._R_P / 9._R_P self % gamm ( 6 ) = 1._R_P self % gamm ( 7 ) = 1._R_P case ( 'runge_kutta_emd_stages_9_order_6' ) self % stages = 9 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 6._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % beta ( 1 , 2 ) = 1523166 5._R_P / 51083033 4._R_P self % beta ( 2 , 1 ) = 0._R_P ; self % beta ( 2 , 2 ) = 0._R_P self % beta ( 3 , 1 ) = 5751301 1._R_P / 20186425 0._R_P ; self % beta ( 3 , 2 ) = 5945299 1._R_P / 11605044 8._R_P self % beta ( 4 , 1 ) = 1558730 6._R_P / 35450157 1._R_P ; self % beta ( 4 , 2 ) = - 2839851 7._R_P / 12243773 8._R_P self % beta ( 5 , 1 ) = 7178302 1._R_P / 23498286 5._R_P ; self % beta ( 5 , 2 ) = 5667382 4._R_P / 13701055 9._R_P self % beta ( 6 , 1 ) = 2967200 0._R_P / 18048016 7._R_P ; self % beta ( 6 , 2 ) = 6800384 9._R_P / 42667358 3._R_P self % beta ( 7 , 1 ) = 6556762 1._R_P / 12706095 2._R_P ; self % beta ( 7 , 2 ) = 709763 1._R_P / 3756402 1._R_P self % beta ( 8 , 1 ) = - 7907457 0._R_P / 21055759 7._R_P ; self % beta ( 8 , 2 ) = - 7122642 9._R_P / 58309374 2._R_P self % beta ( 9 , 1 ) = 0._R_P ; self % beta ( 9 , 2 ) = 1._R_P / 2 0._R_P self % alph ( 2 , 1 ) = 2._R_P / 1 5._R_P self % alph ( 3 , 1 ) = 1._R_P / 2 0._R_P ; self % alph ( 3 , 2 ) = 3._R_P / 2 0._R_P self % alph ( 4 , 1 ) = 3._R_P / 4 0._R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 8672701 5._R_P / 19685155 3._R_P ; self % alph ( 5 , 2 ) =- 6012907 3._R_P / 5262471 2._R_P self % alph ( 6 , 1 ) =- 8686084 9._R_P / 4562896 7._R_P ; self % alph ( 6 , 2 ) = 11102288 5._R_P / 2571648 7._R_P self % alph ( 7 , 1 ) = 7775959 1._R_P / 1609646 7._R_P ; self % alph ( 7 , 2 ) =- 4925280 9._R_P / 645255 5._R_P self % alph ( 8 , 1 ) = 23756426 3._R_P / 3928029 5._R_P ; self % alph ( 8 , 2 ) =- 10052323 9._R_P / 1067794 0._R_P self % alph ( 9 , 1 ) = 1757234 9._R_P / 28926252 3._R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 4 , 3 ) = 9._R_P / 4 0._R_P self % alph ( 5 , 3 ) = 95743643 4._R_P / 137835237 7._R_P ; self % alph ( 5 , 4 ) = 8388683 2._R_P / 14784244 1._R_P self % alph ( 6 , 3 ) = 10804668 2._R_P / 10116766 9._R_P ; self % alph ( 6 , 4 ) =- 14175674 6._R_P / 3600546 1._R_P self % alph ( 7 , 3 ) =- 38168011 1._R_P / 5157298 4._R_P ; self % alph ( 7 , 4 ) = 87926957 9._R_P / 6678883 1._R_P self % alph ( 8 , 3 ) =- 26557484 6._R_P / 2733024 7._R_P ; self % alph ( 8 , 4 ) = 31797841 1._R_P / 1898871 3._R_P self % alph ( 9 , 3 ) = 5751301 1._R_P / 20186425 0._R_P ; self % alph ( 9 , 4 ) = 1558730 6._R_P / 35450157 1._R_P self % alph ( 6 , 5 ) = 7313986 2._R_P / 6017063 3._R_P self % alph ( 7 , 5 ) =- 9045312 1._R_P / 3372216 2._R_P ; self % alph ( 7 , 6 ) = 11117955 2._R_P / 15715582 7._R_P self % alph ( 8 , 5 ) =- 12449438 5._R_P / 3545362 7._R_P ; self % alph ( 8 , 6 ) = 8682244 4._R_P / 10013863 5._R_P self % alph ( 9 , 5 ) = 7178302 1._R_P / 23498286 5._R_P ; self % alph ( 9 , 6 ) = 2967200 0._R_P / 18048016 7._R_P self % alph ( 8 , 7 ) =- 1287352 3._R_P / 72423262 5._R_P self % alph ( 9 , 7 ) = 6556762 1._R_P / 12706095 2._R_P ; self % alph ( 9 , 8 ) =- 7907457 0._R_P / 21055759 7._R_P self % gamm ( 2 ) = 2._R_P / 1 5._R_P self % gamm ( 3 ) = 1._R_P / 5._R_P self % gamm ( 4 ) = 3._R_P / 1 0._R_P self % gamm ( 5 ) = 1 4._R_P / 2 5._R_P self % gamm ( 6 ) = 1 9._R_P / 2 5._R_P self % gamm ( 7 ) = 3522660 7._R_P / 3568827 9._R_P self % gamm ( 8 ) = 1._R_P self % gamm ( 9 ) = 1._R_P case ( 'runge_kutta_emd_stages_17_order_10' ) self % stages = 17 allocate ( self % beta ( 1 : self % stages , 1 : 2 )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % pp1_inv = 1._R_P / ( 1 0._R_P + 1._R_P ) self % beta ( 1 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 1 , 2 ) = 0.033333333333333333333_R_P self % beta ( 2 , 1 ) = 0.025_R_P ; self % beta ( 2 , 2 ) = 1._R_P / 3 6._R_P self % beta ( 3 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 3 , 2 ) = 0.033333333333333333333_R_P self % beta ( 4 , 1 ) = 0._R_P ; self % beta ( 4 , 2 ) = 0._R_P self % beta ( 5 , 1 ) = 0.05_R_P ; self % beta ( 5 , 2 ) = 0.05_R_P self % beta ( 6 , 1 ) = 0._R_P ; self % beta ( 6 , 2 ) = 0._R_P self % beta ( 7 , 1 ) = 0.04_R_P ; self % beta ( 7 , 2 ) = 0.04_R_P self % beta ( 8 , 1 ) = 0._R_P ; self % beta ( 8 , 2 ) = 0._R_P self % beta ( 9 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 9 , 2 ) = 0.189237478148923490158_R_P self % beta ( 10 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 10 , 2 ) = 0.277429188517743176508_R_P self % beta ( 11 , 1 ) = 0.277429188517743176508_R_P ; self % beta ( 11 , 2 ) = 0.277429188517743176508_R_P self % beta ( 12 , 1 ) = 0.189237478148923490158_R_P ; self % beta ( 12 , 2 ) = 0.189237478148923490158_R_P self % beta ( 13 , 1 ) =- 0.04_R_P ; self % beta ( 13 , 2 ) =- 0.04_R_P self % beta ( 14 , 1 ) =- 0.05_R_P ; self % beta ( 14 , 2 ) =- 0.05_R_P self % beta ( 15 , 1 ) =- 0.033333333333333333333_R_P ; self % beta ( 15 , 2 ) =- 0.033333333333333333333_R_P self % beta ( 16 , 1 ) =- 0.025_R_P ; self % beta ( 16 , 2 ) =- 1._R_P / 3 6._R_P self % beta ( 17 , 1 ) = 0.033333333333333333333_R_P ; self % beta ( 17 , 2 ) = 0.033333333333333333333_R_P self % alph ( 2 , 1 ) = 0.1_R_P self % alph ( 3 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 3 , 2 ) = 1.454534402178273228052_R_P self % alph ( 4 , 1 ) = 0.202259190301118170324_R_P ; self % alph ( 4 , 2 ) = 0._R_P self % alph ( 5 , 1 ) = 0.184024714708643575149_R_P ; self % alph ( 5 , 2 ) = 0._R_P self % alph ( 6 , 1 ) = 0.087900734020668133731_R_P ; self % alph ( 6 , 2 ) = 0._R_P self % alph ( 7 , 1 ) = 0.085970050490246030218_R_P ; self % alph ( 7 , 2 ) = 0._R_P self % alph ( 8 , 1 ) = 0.120930449125333720660_R_P ; self % alph ( 8 , 2 ) = 0._R_P self % alph ( 9 , 1 ) = 0.110854379580391483508_R_P ; self % alph ( 9 , 2 ) = 0._R_P self % alph ( 10 , 1 ) = 0.112054414752879004829_R_P ; self % alph ( 10 , 2 ) = 0._R_P self % alph ( 11 , 1 ) = 0.113976783964185986138_R_P ; self % alph ( 11 , 2 ) = 0._R_P self % alph ( 12 , 1 ) = 0.079831452828019604635_R_P ; self % alph ( 12 , 2 ) = 0._R_P self % alph ( 13 , 1 ) = 0.985115610164857280120_R_P ; self % alph ( 13 , 2 ) = 0._R_P self % alph ( 14 , 1 ) = 0.895080295771632891049_R_P ; self % alph ( 14 , 2 ) = 0._R_P self % alph ( 15 , 1 ) =- 0.915176561375291440520_R_P ; self % alph ( 15 , 2 ) = 1.454534402178273228052_R_P self % alph ( 16 , 1 ) = 0.1_R_P ; self % alph ( 16 , 2 ) = 0._R_P self % alph ( 17 , 1 ) = 0.181781300700095283888_R_P ; self % alph ( 17 , 2 ) = 0.675_R_P self % alph ( 4 , 3 ) = 0.606777570903354510974_R_P self % alph ( 5 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 5 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 6 , 3 ) = 0._R_P ; self % alph ( 6 , 4 ) = 0.410459702520260645318_R_P self % alph ( 7 , 3 ) = 0._R_P ; self % alph ( 7 , 4 ) = 0.330885963040722183948_R_P self % alph ( 8 , 3 ) = 0._R_P ; self % alph ( 8 , 4 ) = 0._R_P self % alph ( 9 , 3 ) = 0._R_P ; self % alph ( 9 , 4 ) = 0._R_P self % alph ( 10 , 3 ) = 0._R_P ; self % alph ( 10 , 4 ) = 0._R_P self % alph ( 11 , 3 ) = 0._R_P ; self % alph ( 11 , 4 ) = 0._R_P self % alph ( 12 , 3 ) = 0._R_P ; self % alph ( 12 , 4 ) = 0._R_P self % alph ( 13 , 3 ) = 0._R_P ; self % alph ( 13 , 4 ) = 0.330885963040722183948_R_P self % alph ( 14 , 3 ) = 0.197966831227192369068_R_P ; self % alph ( 14 , 4 ) =- 0.072954784731363262918_R_P self % alph ( 15 , 3 ) = 0._R_P ; self % alph ( 15 , 4 ) = 0._R_P self % alph ( 16 , 3 ) =- 0.157178665799771163367_R_P ; self % alph ( 16 , 4 ) = 0._R_P self % alph ( 17 , 3 ) = 0.342758159847189839942_R_P ; self % alph ( 17 , 4 ) = 0._R_P self % alph ( 6 , 5 ) = 0.482713753678866489204_R_P self % alph ( 7 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 7 , 6 ) =- 0.073185637507085073678_R_P self % alph ( 8 , 5 ) = 0.260124675758295622809_R_P ; self % alph ( 8 , 6 ) = 0.032540262154909133015_R_P self % alph ( 9 , 5 ) = 0._R_P ; self % alph ( 9 , 6 ) =- 0.060576148825500558762_R_P self % alph ( 10 , 5 ) = 0._R_P ; self % alph ( 10 , 6 ) =- 0.144942775902865915672_R_P self % alph ( 11 , 5 ) = 0._R_P ; self % alph ( 11 , 6 ) =- 0.076881336420335693858_R_P self % alph ( 12 , 5 ) = 0._R_P ; self % alph ( 12 , 6 ) =- 0.052032968680060307651_R_P self % alph ( 13 , 5 ) = 0.489662957309450192844_R_P ; self % alph ( 13 , 6 ) =- 1.378964865748435675821_R_P self % alph ( 14 , 5 ) = 0._R_P ; self % alph ( 14 , 6 ) =- 0.851236239662007619739_R_P self % alph ( 15 , 5 ) =- 0.777333643644968233538_R_P ; self % alph ( 15 , 6 ) = 0._R_P self % alph ( 16 , 5 ) = 0._R_P ; self % alph ( 16 , 6 ) = 0._R_P self % alph ( 17 , 5 ) = 0.259111214548322744512_R_P ; self % alph ( 17 , 6 ) =- 0.358278966717952089048_R_P self % alph ( 8 , 7 ) =- 0.059578021181736100156_R_P self % alph ( 9 , 7 ) = 0.321763705601778390100_R_P ; self % alph ( 9 , 8 ) = 0.510485725608063031577_R_P self % alph ( 10 , 7 ) =- 0.333269719096256706589_R_P ; self % alph ( 10 , 8 ) = 0.499269229556880061353_R_P self % alph ( 11 , 7 ) = 0.239527360324390649107_R_P ; self % alph ( 11 , 8 ) = 0.397774662368094639047_R_P self % alph ( 12 , 7 ) =- 0.057695414616854888173_R_P ; self % alph ( 12 , 8 ) = 0.194781915712104164976_R_P self % alph ( 13 , 7 ) =- 0.861164195027635666673_R_P ; self % alph ( 13 , 8 ) = 5.784288136375372200229_R_P self % alph ( 14 , 7 ) = 0.398320112318533301719_R_P ; self % alph ( 14 , 8 ) = 3.639372631810356060294_R_P self % alph ( 15 , 7 ) =- 0.091089566215517606959_R_P ; self % alph ( 15 , 8 ) = 0._R_P self % alph ( 16 , 7 ) = 0._R_P ; self % alph ( 16 , 8 ) = 0._R_P self % alph ( 17 , 7 ) =- 1.045948959408833060950_R_P ; self % alph ( 17 , 8 ) = 0.930327845415626983292_R_P self % alph ( 10 , 9 ) = 0.509504608929686104236_R_P self % alph ( 11 , 9 ) = 0.010755895687360745555_R_P ; self % alph ( 11 , 10 ) =- 0.327769124164018874147_R_P self % alph ( 12 , 9 ) = 0.145384923188325069727_R_P ; self % alph ( 12 , 10 ) =- 0.078294271035167077755_R_P self % alph ( 13 , 9 ) = 3.288077619851035668904_R_P ; self % alph ( 13 , 10 ) =- 2.386339050931363840134_R_P self % alph ( 14 , 9 ) = 1.548228770398303223653_R_P ; self % alph ( 14 , 10 ) =- 2.122217147040537160260_R_P self % alph ( 15 , 9 ) = 0._R_P ; self % alph ( 15 , 10 ) = 0._R_P self % alph ( 16 , 9 ) = 0._R_P ; self % alph ( 16 , 10 ) = 0._R_P self % alph ( 17 , 9 ) = 1.779509594317081024461_R_P ; self % alph ( 17 , 10 ) = 0.1_R_P self % alph ( 12 , 11 ) =- 0.114503299361098912184_R_P self % alph ( 13 , 11 ) =- 3.254793424836439186545_R_P ; self % alph ( 13 , 12 ) =- 2.163435416864229823539_R_P self % alph ( 14 , 11 ) =- 1.583503985453261727133_R_P ; self % alph ( 14 , 12 ) =- 1.715616082859362649220_R_P self % alph ( 15 , 11 ) = 0._R_P ; self % alph ( 15 , 12 ) = 0._R_P self % alph ( 16 , 11 ) = 0._R_P ; self % alph ( 16 , 12 ) = 0._R_P self % alph ( 17 , 11 ) =- 0.282547569539044081612_R_P ; self % alph ( 17 , 12 ) =- 0.159327350119972549169_R_P self % alph ( 14 , 13 ) =- 0.024403640575012745213_R_P self % alph ( 15 , 13 ) = 0.091089566215517606959_R_P ; self % alph ( 15 , 14 ) = 0.777333643644968233538_R_P self % alph ( 16 , 13 ) = 0._R_P ; self % alph ( 16 , 14 ) = 0._R_P self % alph ( 17 , 13 ) =- 0.145515894647001510860_R_P ; self % alph ( 17 , 14 ) =- 0.259111214548322744512_R_P self % alph ( 16 , 15 ) = 0.157178665799771163367_R_P self % alph ( 17 , 15 ) =- 0.342758159847189839942_R_P ; self % alph ( 17 , 16 ) =- 0.675_R_P self % gamm ( 2 ) = 0.1_R_P self % gamm ( 3 ) = 0.539357840802981787532_R_P self % gamm ( 4 ) = 0.809036761204472681298_R_P self % gamm ( 5 ) = 0.309036761204472681298_R_P self % gamm ( 6 ) = 0.981074190219795268254_R_P self % gamm ( 7 ) = 0.833333333333333333333_R_P self % gamm ( 8 ) = 0.354017365856802376329_R_P self % gamm ( 9 ) = 0.882527661964732346425_R_P self % gamm ( 10 ) = 0.642615758240322548157_R_P self % gamm ( 11 ) = 0.357384241759677451842_R_P self % gamm ( 12 ) = 0.117472338035267653574_R_P self % gamm ( 13 ) = 0.833333333333333333333_R_P self % gamm ( 14 ) = 0.309036761204472681298_R_P self % gamm ( 15 ) = 0.539357840802981787532_R_P self % gamm ( 16 ) = 0.1_R_P self % gamm ( 17 ) = 1._R_P endselect self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~10.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_emd ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_emd ) lhs % tolerance = rhs % tolerance lhs % pp1_inv = rhs % pp1_inv lhs % stages = rhs % stages if ( allocated ( rhs % alph )) lhs % alph = rhs % alph if ( allocated ( rhs % beta )) lhs % beta = rhs % beta if ( allocated ( rhs % gamm )) lhs % gamm = rhs % gamm endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~10.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t, new_Dt) Integrate field with explicit embedded Runge-Kutta scheme. The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit embedded Runge-Kutta scheme. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. real ( R_P ) :: Dt_ !< Time step, local variable. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. Dt_ = Dt do ! compute stages do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 self % stage ( s ) = self % stage ( s ) + ( self % stage ( ss ) * ( Dt_ * self % alph ( s , ss ))) enddo self % stage ( s ) = self % stage ( s )% t ( t = t + self % gamm ( s ) * Dt_ ) enddo ! compute new time step self % U1 = U self % U2 = U do s = 1 , self % stages self % U1 = self % U1 + ( self % stage ( s ) * ( Dt_ * self % beta ( s , 1 ))) self % U2 = self % U2 + ( self % stage ( s ) * ( Dt_ * self % beta ( s , 2 ))) enddo error = self % U2 . lterror . self % U1 if ( error <= self % tolerance ) exit call self % new_Dt ( error = error , Dt = Dt_ ) enddo U = self % U1 if ( present ( new_Dt )) new_Dt = Dt_ endsubroutine integrate","tags":"","loc":"proc/integrate~10.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t, new_Dt) Integrate field with explicit embedded Runge-Kutta scheme, fast mode. The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit embedded Runge-Kutta scheme, fast mode. !< !< The time steps is adaptively resized using the local truncation error estimation by means of the embedded pairs of RK schemes. class ( integrator_runge_kutta_emd ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. real ( R_P ) :: Dt_ !< Time step, local variable. real ( R_P ) :: error !< Local truncation error estimation. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. Dt_ = Dt do ! compute stages do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 call self % buffer % multiply_fast ( lhs = self % stage ( ss ), rhs = Dt_ * self % alph ( s , ss )) call self % stage ( s )% add_fast ( lhs = self % stage ( s ), rhs = self % buffer ) enddo call self % stage ( s )% t_fast ( t = t + self % gamm ( s ) * Dt_ ) enddo ! compute new time step self % U1 = U self % U2 = U do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = Dt_ * self % beta ( s , 1 )) call self % U1 % add_fast ( lhs = self % U1 , rhs = self % buffer ) call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = Dt_ * self % beta ( s , 2 )) call self % U2 % add_fast ( lhs = self % U2 , rhs = self % buffer ) enddo error = self % U2 . lterror . self % U1 if ( error <= self % tolerance ) exit call self % new_Dt ( error = error , Dt = Dt_ ) enddo U = self % U1 if ( present ( new_Dt )) new_Dt = Dt_ endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~10.html","title":"integrate_fast – FOODIE"},{"text":"private elemental subroutine new_Dt(self, error, Dt) Compute new estimation of the time step Dt. The formula employed is:  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  Note 0.9 is a safety factor. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step. Source Code new_Dt Source Code elemental subroutine new_Dt ( self , error , Dt ) !< Compute new estimation of the time step Dt. !< !< The formula employed is: !< !<  Dt_{new} = 0.9 Dt_{old} \\left( \\frac{tolerance}{error} \\right)&#94;{\\frac{1}{p+1}}  !< !< @note 0.9 is a safety factor. class ( integrator_runge_kutta_emd ), intent ( in ) :: self !< Integrator. real ( R_P ), intent ( in ) :: error !< Local truncation error estimation. real ( R_P ), intent ( inout ) :: Dt !< Time step. if ( error > self % tolerance ) Dt = 0.9_R_P * Dt * ( self % tolerance / error ) ** self % pp1_inv endsubroutine new_Dt","tags":"","loc":"proc/new_dt.html","title":"new_Dt – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~11.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~11.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~11.html","title":"is_supported – FOODIE"},{"text":"private pure function registers_number() Return the number of registers used. Arguments None Return Value integer(kind=I_P) Number of registers used. Source Code registers_number Source Code pure function registers_number () !< Return the number of registers used. integer ( I_P ) :: registers_number !< Number of registers used. registers_number = registers endfunction registers_number","tags":"","loc":"proc/registers_number.html","title":"registers_number – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_ls ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~11.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) endsubroutine destroy","tags":"","loc":"proc/destroy~11.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , U , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_ls_stages_1_order_1' ) self % stages = 1 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % B ( 1 ) = 1._R_P case ( 'runge_kutta_ls_stages_5_order_4' ) self % stages = 5 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) case ( 'runge_kutta_ls_stages_6_order_4' ) self % stages = 6 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.122000000000_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.691750960670_R_P ; self % B ( 2 ) = 0.477263056358_R_P ; self % C ( 2 ) = 0.122000000000_R_P self % A ( 3 ) = - 1.727127405211_R_P ; self % B ( 3 ) = 0.381941220320_R_P ; self % C ( 3 ) = 0.269115878630_R_P self % A ( 4 ) = - 0.694890150986_R_P ; self % B ( 4 ) = 0.447757195744_R_P ; self % C ( 4 ) = 0.447717183551_R_P self % A ( 5 ) = - 1.039942756197_R_P ; self % B ( 5 ) = 0.498614246822_R_P ; self % C ( 5 ) = 0.749979795490_R_P self % A ( 6 ) = - 1.531977447611_R_P ; self % B ( 6 ) = 0.186648570846_R_P ; self % C ( 6 ) = 0.898555413085_R_P case ( 'runge_kutta_ls_stages_7_order_4' ) self % stages = 7 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.117322146869_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.647900745934_R_P ; self % B ( 2 ) = 0.503270262127_R_P ; self % C ( 2 ) = 0.117322146869_R_P self % A ( 3 ) = - 2.704760863204_R_P ; self % B ( 3 ) = 0.233663281658_R_P ; self % C ( 3 ) = 0.294523230758_R_P self % A ( 4 ) = - 0.460080550118_R_P ; self % B ( 4 ) = 0.283419634625_R_P ; self % C ( 4 ) = 0.305658622131_R_P self % A ( 5 ) = - 0.500581787785_R_P ; self % B ( 5 ) = 0.540367414023_R_P ; self % C ( 5 ) = 0.582864148403_R_P self % A ( 6 ) = - 1.906532255913_R_P ; self % B ( 6 ) = 0.371499414620_R_P ; self % C ( 6 ) = 0.858664273599_R_P self % A ( 7 ) = - 1.450000000000_R_P ; self % B ( 7 ) = 0.136670099385_R_P ; self % C ( 7 ) = 0.868664273599_R_P case ( 'runge_kutta_ls_stages_12_order_4' ) self % stages = 12 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0650008435125904_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.0923311242368072_R_P ; self % B ( 2 ) = 0.0161459902249842_R_P ; self % C ( 2 ) = 0.0650008435125904_R_P self % A ( 3 ) = - 0.9441056581158819_R_P ; self % B ( 3 ) = 0.5758627178358159_R_P ; self % C ( 3 ) = 0.0796560563081853_R_P self % A ( 4 ) = - 4.3271273247576394_R_P ; self % B ( 4 ) = 0.1649758848361671_R_P ; self % C ( 4 ) = 0.1620416710085376_R_P self % A ( 5 ) = - 2.1557771329026072_R_P ; self % B ( 5 ) = 0.3934619494248182_R_P ; self % C ( 5 ) = 0.2248877362907778_R_P self % A ( 6 ) = - 0.9770727190189062_R_P ; self % B ( 6 ) = 0.0443509641602719_R_P ; self % C ( 6 ) = 0.2952293985641261_R_P self % A ( 7 ) = - 0.7581835342571139_R_P ; self % B ( 7 ) = 0.2074504268408778_R_P ; self % C ( 7 ) = 0.3318332506149405_R_P self % A ( 8 ) = - 1.7977525470825499_R_P ; self % B ( 8 ) = 0.6914247433015102_R_P ; self % C ( 8 ) = 0.4094724050198658_R_P self % A ( 9 ) = - 2.6915667972700770_R_P ; self % B ( 9 ) = 0.3766646883450449_R_P ; self % C ( 9 ) = 0.6356954475753369_R_P self % A ( 10 ) = - 4.6466798960268143_R_P ; self % B ( 10 ) = 0.0757190350155483_R_P ; self % C ( 10 ) = 0.6806551557645497_R_P self % A ( 11 ) = - 0.1539613783825189_R_P ; self % B ( 11 ) = 0.2027862031054088_R_P ; self % C ( 11 ) = 0.7143773712418350_R_P self % A ( 12 ) = - 0.5943293901830616_R_P ; self % B ( 12 ) = 0.2167029365631842_R_P ; self % C ( 12 ) = 0.9032588871651854_R_P case ( 'runge_kutta_ls_stages_13_order_4' ) self % stages = 13 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0271990297818803_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.6160178650170565_R_P ; self % B ( 2 ) = 0.1772488819905108_R_P ; self % C ( 2 ) = 0.0271990297818803_R_P self % A ( 3 ) = - 0.4449487060774118_R_P ; self % B ( 3 ) = 0.0378528418949694_R_P ; self % C ( 3 ) = 0.0952594339119365_R_P self % A ( 4 ) = - 1.0952033345276178_R_P ; self % B ( 4 ) = 0.6086431830142991_R_P ; self % C ( 4 ) = 0.1266450286591127_R_P self % A ( 5 ) = - 1.2256030785959187_R_P ; self % B ( 5 ) = 0.2154313974316100_R_P ; self % C ( 5 ) = 0.1825883045699772_R_P self % A ( 6 ) = - 0.2740182222332805_R_P ; self % B ( 6 ) = 0.2066152563885843_R_P ; self % C ( 6 ) = 0.3737511439063931_R_P self % A ( 7 ) = - 0.0411952089052647_R_P ; self % B ( 7 ) = 0.0415864076069797_R_P ; self % C ( 7 ) = 0.5301279418422206_R_P self % A ( 8 ) = - 0.1797084899153560_R_P ; self % B ( 8 ) = 0.0219891884310925_R_P ; self % C ( 8 ) = 0.5704177433952291_R_P self % A ( 9 ) = - 1.1771530652064288_R_P ; self % B ( 9 ) = 0.9893081222650993_R_P ; self % C ( 9 ) = 0.5885784947099155_R_P self % A ( 10 ) = - 0.4078831463120878_R_P ; self % B ( 10 ) = 0.0063199019859826_R_P ; self % C ( 10 ) = 0.6160769826246714_R_P self % A ( 11 ) = - 0.8295636426191777_R_P ; self % B ( 11 ) = 0.3749640721105318_R_P ; self % C ( 11 ) = 0.6223252334314046_R_P self % A ( 12 ) = - 4.7895970584252288_R_P ; self % B ( 12 ) = 1.6080235151003195_R_P ; self % C ( 12 ) = 0.6897593128753419_R_P self % A ( 13 ) = - 0.6606671432964504_R_P ; self % B ( 13 ) = 0.0961209123818189_R_P ; self % C ( 13 ) = 0.9126827615920843_R_P case ( 'runge_kutta_ls_stages_14_order_4' ) self % stages = 14 allocate ( self % A ( 1 : self % stages )) ; self % A = 0._R_P allocate ( self % B ( 1 : self % stages )) ; self % B = 0._R_P allocate ( self % C ( 1 : self % stages )) ; self % C = 0._R_P self % A ( 1 ) = 0._R_P ; self % B ( 1 ) = 0.0367762454319673_R_P ; self % C ( 1 ) = 0._R_P self % A ( 2 ) = - 0.7188012108672410_R_P ; self % B ( 2 ) = 0.3136296607553959_R_P ; self % C ( 2 ) = 0.0367762454319673_R_P self % A ( 3 ) = - 0.7785331173421570_R_P ; self % B ( 3 ) = 0.1531848691869027_R_P ; self % C ( 3 ) = 0.1249685262725025_R_P self % A ( 4 ) = - 0.0053282796654044_R_P ; self % B ( 4 ) = 0.0030097086818182_R_P ; self % C ( 4 ) = 0.2446177702277698_R_P self % A ( 5 ) = - 0.8552979934029281_R_P ; self % B ( 5 ) = 0.3326293790646110_R_P ; self % C ( 5 ) = 0.2476149531070420_R_P self % A ( 6 ) = - 3.9564138245774565_R_P ; self % B ( 6 ) = 0.2440251405350864_R_P ; self % C ( 6 ) = 0.2969311120382472_R_P self % A ( 7 ) = - 1.5780575380587385_R_P ; self % B ( 7 ) = 0.3718879239592277_R_P ; self % C ( 7 ) = 0.3978149645802642_R_P self % A ( 8 ) = - 2.0837094552574054_R_P ; self % B ( 8 ) = 0.6204126221582444_R_P ; self % C ( 8 ) = 0.5270854589440328_R_P self % A ( 9 ) = - 0.7483334182761610_R_P ; self % B ( 9 ) = 0.1524043173028741_R_P ; self % C ( 9 ) = 0.6981269994175695_R_P self % A ( 10 ) = - 0.7032861106563359_R_P ; self % B ( 10 ) = 0.0760894927419266_R_P ; self % C ( 10 ) = 0.8190890835352128_R_P self % A ( 11 ) = 0.0013917096117681_R_P ; self % B ( 11 ) = 0.0077604214040978_R_P ; self % C ( 11 ) = 0.8527059887098624_R_P self % A ( 12 ) = - 0.0932075369637460_R_P ; self % B ( 12 ) = 0.0024647284755382_R_P ; self % C ( 12 ) = 0.8604711817462826_R_P self % A ( 13 ) = - 0.9514200470875948_R_P ; self % B ( 13 ) = 0.0780348340049386_R_P ; self % C ( 13 ) = 0.8627060376969976_R_P self % A ( 14 ) = - 7.1151571693922548_R_P ; self % B ( 14 ) = 5.5059777270269628_R_P ; self % C ( 14 ) = 0.8734213127600976_R_P endselect self % registers = 2 if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~11.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_ls ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_ls ) lhs % stages = rhs % stages if ( allocated ( rhs % A )) lhs % A = rhs % A if ( allocated ( rhs % B )) lhs % B = rhs % B if ( allocated ( rhs % C )) lhs % C = rhs % C endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~11.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t, new_Dt) Integrate field with explicit low storage Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit low storage Runge-Kutta scheme. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U self % stage ( 2 ) = U * 0._R_P do s = 1 , self % stages self % stage ( 2 ) = ( self % stage ( 2 ) * self % A ( s )) + ( self % stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt ) self % stage ( 1 ) = self % stage ( 1 ) + ( self % stage ( 2 ) * self % B ( s )) enddo U = self % stage ( 1 ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate","tags":"","loc":"proc/integrate~11.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t, new_Dt) Integrate field with explicit low storage Runge-Kutta scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit low storage Runge-Kutta scheme, fast mode. class ( integrator_runge_kutta_ls ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U call self % stage ( 2 )% multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % stages self % buffer = self % stage ( 1 ) call self % buffer % t_fast ( t = t + self % C ( s ) * Dt ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call self % stage ( 2 )% multiply_fast ( lhs = self % stage ( 2 ), rhs = self % A ( s )) call self % stage ( 2 )% add_fast ( lhs = self % stage ( 2 ), rhs = self % buffer ) call self % buffer % multiply_fast ( lhs = self % stage ( 2 ), rhs = self % B ( s )) call self % stage ( 1 )% add_fast ( lhs = self % stage ( 1 ), rhs = self % buffer ) enddo U = self % stage ( 1 ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~11.html","title":"integrate_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~12.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~12.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~12.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_lssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~12.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage if ( allocated ( self % alpha )) deallocate ( self % alpha ) self % integrate_ => integrate_order_s_1 endsubroutine destroy","tags":"","loc":"proc/destroy~12.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, U, stages, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. integer(kind=I_P), intent(in), optional :: stages Stages number. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Calls proc~~initialize~12~~CallsGraph proc~initialize~12 initialize str str proc~initialize~12->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize Source Code subroutine initialize ( self , scheme , U , stages , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. integer ( I_P ), intent ( in ), optional :: stages !< Stages number. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_lssp_stages_s_order_s_1' ) self % integrate_ => integrate_order_s_1 self % integrate_fast_ => integrate_order_s_1_fast self % stages = 2 ; if ( present ( stages )) self % stages = stages if ( self % stages < 2 ) then error stop 'error: the number of stages of \"runge_kutta_lssp_stages_s_order_s_1\" must be >=2' endif allocate ( self % alpha ( 1 : self % stages )) ; self % alpha = 0._R_P call self % initialize_order_s_1 case ( 'runge_kutta_lssp_stages_s_order_s' ) self % integrate_ => integrate_order_s self % integrate_fast_ => integrate_order_s_fast self % stages = 1 ; if ( present ( stages )) self % stages = stages if ( self % stages < 1 ) then error stop 'error: the number of stages of \"runge_kutta_lssp_stages_s_order_s\" must be >=1' endif allocate ( self % alpha ( 1 : self % stages )) ; self % alpha = 0._R_P call self % initialize_order_s endselect self % description_ = trim ( adjustl ( scheme )) // '_stages_' // trim ( str ( self % stages , no_sign = . true .)) self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~12.html","title":"initialize – FOODIE"},{"text":"private elemental subroutine initialize_order_s(self) Initialize integrator for s-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. Calls proc~~initialize_order_s~~CallsGraph proc~initialize_order_s initialize_order_s alpha alpha proc~initialize_order_s->alpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize_order_s Source Code elemental subroutine initialize_order_s ( self ) !< Initialize integrator for s-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. associate ( alpha => self % alpha ) alpha ( 1 ) = 1._R_P do i = 2 , self % stages alpha ( i ) = 1._R_P / product ([( j , j = 1 , i )]) do j = i - 1 , 2 , - 1 alpha ( j ) = 1._R_P / ( j - 1 ) * alpha ( j - 1 ) enddo alpha ( 1 ) = 1._R_P do j = 2 , i alpha ( 1 ) = alpha ( 1 ) - alpha ( j ) enddo enddo endassociate endsubroutine initialize_order_s","tags":"","loc":"proc/initialize_order_s.html","title":"initialize_order_s – FOODIE"},{"text":"private elemental subroutine initialize_order_s_1(self) Initialize integrator for (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. Calls proc~~initialize_order_s_1~~CallsGraph proc~initialize_order_s_1 initialize_order_s_1 alpha alpha proc~initialize_order_s_1->alpha Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code initialize_order_s_1 Source Code elemental subroutine initialize_order_s_1 ( self ) !< Initialize integrator for (s-1)-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. associate ( alpha => self % alpha ) alpha ( 1 ) = 0._R_P alpha ( 2 ) = 1._R_P do i = 3 , self % stages alpha ( i ) = 2._R_P / i * alpha ( i - 1 ) do j = i - 1 , 2 , - 1 alpha ( j ) = 2._R_P / ( j - 1 ) * alpha ( j - 1 ) enddo alpha ( 1 ) = 1._R_P do j = 2 , i alpha ( 1 ) = alpha ( 1 ) - alpha ( j ) enddo enddo endassociate endsubroutine initialize_order_s_1","tags":"","loc":"proc/initialize_order_s_1.html","title":"initialize_order_s_1 – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_lssp ) lhs % stages = rhs % stages if ( allocated ( rhs % alpha )) lhs % alpha = rhs % alpha endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~12.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t, new_Dt) Integrate integrand field by Linear SSP Runge-Kutta methods. Note This method can be used after the integrator is created (i.e. the RK coefficients are initialized). Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate integrand field by Linear SSP Runge-Kutta methods. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coefficients are initialized). class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. call self % integrate_ ( U = U , Dt = Dt , t = t ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate","tags":"","loc":"proc/integrate~12.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t, new_Dt) Integrate integrand field by Linear SSP Runge-Kutta methods. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate integrand field by Linear SSP Runge-Kutta methods. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( out ), optional :: new_Dt !< New adapted time step. call self % integrate_fast_ ( U = U , Dt = Dt , t = t ) if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~12.html","title":"integrate_fast – FOODIE"},{"text":"private subroutine integrate_order_s(self, U, Dt, t) Integrate integrand field by s-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_order_s Source Code subroutine integrate_order_s ( self , U , Dt , t ) !< Integrate integrand field by s-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % stage ( s ) = self % stage ( s - 1 ) + ( self % stage ( s - 1 )% t ( t = t ) * Dt ) enddo self % stage ( self % stages ) = self % stage ( self % stages ) + ( self % stage ( self % stages )% t ( t = t ) * Dt ) ! computing new time step U = U * 0._R_P do s = 1 , self % stages U = U + ( self % stage ( s ) * self % alpha ( s )) enddo endsubroutine integrate_order_s","tags":"","loc":"proc/integrate_order_s.html","title":"integrate_order_s – FOODIE"},{"text":"private subroutine integrate_order_s_1(self, U, Dt, t) Integrate integrand field by (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_order_s_1 Source Code subroutine integrate_order_s_1 ( self , U , Dt , t ) !< Integrate integrand field by (s-1)-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % stage ( s ) = self % stage ( s - 1 ) + ( self % stage ( s - 1 )% t ( t = t ) * ( Dt * 0.5_R_P )) enddo self % stage ( self % stages ) = self % stage ( self % stages ) + ( self % stage ( self % stages )% t ( t = t ) * ( Dt * 0.5_R_P )) ! computing new time step U = U * 0._R_P do s = 1 , self % stages U = U + ( self % stage ( s ) * self % alpha ( s )) enddo endsubroutine integrate_order_s_1","tags":"","loc":"proc/integrate_order_s_1.html","title":"integrate_order_s_1 – FOODIE"},{"text":"private subroutine integrate_order_s_1_fast(self, U, Dt, t) Integrate integrand field by (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_order_s_1_fast Source Code subroutine integrate_order_s_1_fast ( self , U , Dt , t ) !< Integrate integrand field by (s-1)-th order formula. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % buffer = self % stage ( s - 1 ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * 0.5_R_P ) call self % stage ( s )% add_fast ( lhs = self % stage ( s - 1 ), rhs = self % buffer ) enddo self % buffer = self % stage ( self % stages ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt * 0.5_R_P ) call self % stage ( self % stages )% add_fast ( lhs = self % stage ( self % stages ), rhs = self % buffer ) ! computing new time step call U % multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = self % alpha ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo endsubroutine integrate_order_s_1_fast","tags":"","loc":"proc/integrate_order_s_1_fast.html","title":"integrate_order_s_1_fast – FOODIE"},{"text":"private subroutine integrate_order_s_fast(self, U, Dt, t) Integrate integrand field by s-th order formula, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_order_s_fast Source Code subroutine integrate_order_s_fast ( self , U , Dt , t ) !< Integrate integrand field by s-th order formula, fast mode. class ( integrator_runge_kutta_lssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. ! computing stages self % stage ( 1 ) = U do s = 2 , self % stages self % buffer = self % stage ( s - 1 ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call self % stage ( s )% add_fast ( lhs = self % stage ( s - 1 ), rhs = self % buffer ) enddo self % buffer = self % stage ( self % stages ) call self % buffer % t_fast ( t = t ) call self % buffer % multiply_fast ( lhs = self % buffer , rhs = Dt ) call self % stage ( self % stages )% add_fast ( lhs = self % stage ( self % stages ), rhs = self % buffer ) ! computing new time step call U % multiply_fast ( lhs = U , rhs = 0._R_P ) do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = self % alpha ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo endsubroutine integrate_order_s_fast","tags":"","loc":"proc/integrate_order_s_fast.html","title":"integrate_order_s_fast – FOODIE"},{"text":"private pure function class_name(self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. Source Code class_name Source Code pure function class_name ( self ) !< Return the class name of schemes. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ) :: class_name !< Class name. class_name = trim ( adjustl ( class_name_ )) endfunction class_name","tags":"","loc":"proc/class_name~13.html","title":"class_name – FOODIE"},{"text":"private elemental function has_fast_mode(self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. Source Code has_fast_mode Source Code elemental function has_fast_mode ( self ) !< Return .true. if the integrator class has *fast mode* integrate. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. logical :: has_fast_mode !< Inquire result. has_fast_mode = has_fast_mode_ endfunction has_fast_mode","tags":"","loc":"proc/has_fast_mode~13.html","title":"has_fast_mode – FOODIE"},{"text":"private elemental function is_supported(self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. Source Code is_supported Source Code elemental function is_supported ( self , scheme ) !< Return .true. if the integrator class support the given scheme. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. logical :: is_supported !< Inquire result. integer ( I_P ) :: s !< Counter. is_supported = . false . do s = lbound ( supported_schemes_ , dim = 1 ), ubound ( supported_schemes_ , dim = 1 ) if ( trim ( adjustl ( scheme )) == trim ( adjustl ( supported_schemes_ ( s )))) then is_supported = . true . return endif enddo endfunction is_supported","tags":"","loc":"proc/is_supported~13.html","title":"is_supported – FOODIE"},{"text":"private pure function supported_schemes(self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable,(:) Queried scheme. Source Code supported_schemes Source Code pure function supported_schemes ( self ) result ( schemes ) !< Return the list of supported schemes. class ( integrator_runge_kutta_ssp ), intent ( in ) :: self !< Integrator. character ( len = 99 ), allocatable :: schemes (:) !< Queried scheme. allocate ( schemes ( lbound ( supported_schemes_ , dim = 1 ): ubound ( supported_schemes_ , dim = 1 ))) schemes = supported_schemes_ endfunction supported_schemes","tags":"","loc":"proc/supported_schemes~13.html","title":"supported_schemes – FOODIE"},{"text":"private elemental subroutine destroy(self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy the integrator. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. call self % destroy_multistage if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) endsubroutine destroy","tags":"","loc":"proc/destroy~13.html","title":"destroy – FOODIE"},{"text":"private subroutine initialize(self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. Source Code initialize Source Code subroutine initialize ( self , scheme , U , stop_on_fail ) !< Create the actual RK integrator: initialize the Butcher' table coefficients. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_object ), intent ( in ), optional :: U !< Integrand molding prototype. logical , intent ( in ), optional :: stop_on_fail !< Stop execution if initialization fail. if ( self % is_supported ( scheme = scheme )) then call self % destroy self % description_ = trim ( adjustl ( scheme )) select case ( trim ( adjustl ( scheme ))) case ( 'runge_kutta_ssp_stages_1_order_1' ) self % stages = 1 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 1._R_P case ( 'runge_kutta_ssp_stages_2_order_2' ) self % stages = 2 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 'runge_kutta_ssp_stages_3_order_3' ) self % stages = 3 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 'runge_kutta_ssp_stages_5_order_4' ) self % stages = 5 allocate ( self % beta ( 1 : self % stages )) ; self % beta = 0._R_P allocate ( self % alph ( 1 : self % stages , 1 : self % stages )) ; self % alph = 0._R_P allocate ( self % gamm ( 1 : self % stages )) ; self % gamm = 0._R_P self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect self % registers = self % stages if ( present ( U )) call self % allocate_integrand_members ( U = U ) else call self % trigger_error ( error = ERROR_UNSUPPORTED_SCHEME , & error_message = '\"' // trim ( adjustl ( scheme )) // '\" unsupported scheme' , & is_severe = stop_on_fail ) endif endsubroutine initialize","tags":"","loc":"proc/initialize~13.html","title":"initialize – FOODIE"},{"text":"private subroutine integr_assign_integr(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. Source Code integr_assign_integr Source Code subroutine integr_assign_integr ( lhs , rhs ) !< Operator `=`. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: lhs !< Left hand side. class ( integrator_object ), intent ( in ) :: rhs !< Right hand side. call lhs % assign_abstract ( rhs = rhs ) select type ( rhs ) class is ( integrator_runge_kutta_ssp ) lhs % stages = rhs % stages if ( allocated ( rhs % alph )) lhs % alph = rhs % alph if ( allocated ( rhs % beta )) lhs % beta = rhs % beta if ( allocated ( rhs % gamm )) lhs % gamm = rhs % gamm endselect endsubroutine integr_assign_integr","tags":"","loc":"proc/integr_assign_integr~13.html","title":"integr_assign_integr – FOODIE"},{"text":"private subroutine integrate(self, U, Dt, t, new_Dt) Integrate field with explicit SSP Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate Source Code subroutine integrate ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit SSP Runge-Kutta scheme. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. ! computing stages do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 self % stage ( s ) = self % stage ( s ) + ( self % stage ( ss ) * ( Dt * self % alph ( s , ss ))) enddo self % stage ( s ) = self % stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages U = U + ( self % stage ( s ) * ( Dt * self % beta ( s ))) enddo if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate","tags":"","loc":"proc/integrate~13.html","title":"integrate – FOODIE"},{"text":"private subroutine integrate_fast(self, U, Dt, t, new_Dt) Integrate field with explicit SSP Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Source Code integrate_fast Source Code subroutine integrate_fast ( self , U , Dt , t , new_Dt ) !< Integrate field with explicit SSP Runge-Kutta scheme. class ( integrator_runge_kutta_ssp ), intent ( inout ) :: self !< Integrator. class ( integrand_object ), intent ( inout ) :: U !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), optional , intent ( out ) :: new_Dt !< New adapted time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. ! computing stages self % buffer = U do s = 1 , self % stages self % stage ( s ) = U do ss = 1 , s - 1 call self % buffer % multiply_fast ( lhs = self % stage ( ss ), rhs = Dt * self % alph ( s , ss )) call self % stage ( s )% add_fast ( lhs = self % stage ( s ), rhs = self % buffer ) enddo call self % stage ( s )% t_fast ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages call self % buffer % multiply_fast ( lhs = self % stage ( s ), rhs = Dt * self % beta ( s )) call U % add_fast ( lhs = U , rhs = self % buffer ) enddo if ( present ( new_Dt )) new_Dt = Dt endsubroutine integrate_fast","tags":"","loc":"proc/integrate_fast~13.html","title":"integrate_fast – FOODIE"},{"text":"public elemental function is_admissible(n, adm_range) Check if the queried number n is admitted by the admissible range list adm_range . The admissible range list must be formatted as string containing admissible numbers; valid list are:\n+ adm_range = '1-5' => 1, 2, 3, 4, 5 are admissible numbers;\n+ adm_range = '1,3,5,10-12' => 1, 3, 5, 10, 11, 12 are admissible numbers;\n+ adm_range = '1-4,8,21-22' => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; You can mix any number of range ( min-max format) and/or single number ( , comma separated) entries. Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: n Number queried. character(len=*), intent(in) :: adm_range Admissible range string. Return Value logical Is true is the number is in adm_range . Calls proc~~is_admissible~~CallsGraph proc~is_admissible is_admissible proc~tokenize tokenize proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code is_admissible Source Code elemental function is_admissible ( n , adm_range ) !< Check if the queried number *n* is admitted by the *admissible* range list *adm_range*. !< !< The admissible range list must be formatted as string containing admissible numbers; valid list are: !<+ `adm_range = '1-5'` => 1, 2, 3, 4, 5 are admissible numbers; !<+ `adm_range = '1,3,5,10-12'` => 1, 3, 5, 10, 11, 12 are admissible numbers; !<+ `adm_range = '1-4,8,21-22'` => 1, 2, 3, 4, 8, 21, 22 are admissible numbers; !< !< You can mix any number of range (`min-max` format) and/or single number (`,` comma separated) entries. integer ( I_P ), intent ( IN ) :: n !< Number queried. character ( * ), intent ( IN ) :: adm_range !< Admissible range string. logical :: is_admissible !< Is true is the number is in *adm_range*. character ( len ( adm_range )), allocatable :: tokens (:) !< Tokens for parsing *adm_range* string. character ( len ( adm_range )), allocatable :: subtokens (:) !< Tokens for parsing *adm_range* string. integer ( I_P ) :: t !< Counter. integer ( I_P ) :: n_parsed ( 1 : 2 ) !< Values parsed from *adm_range*.. is_admissible = . false . call tokenize ( string = adm_range , delimiter = ',' , toks = tokens ) search_me : do t = 1 , size ( tokens ) if ( index ( tokens ( t ), '-' ) > 0 ) then call tokenize ( string = tokens ( t ), delimiter = '-' , toks = subtokens ) read ( subtokens ( 1 ), * ) n_parsed ( 1 ) read ( subtokens ( 2 ), * ) n_parsed ( 2 ) is_admissible = ( n_parsed ( 1 ) <= n . and . n <= n_parsed ( 2 )) else read ( tokens ( t ), * ) n_parsed ( 1 ) is_admissible = ( n_parsed ( 1 ) == n ) endif if ( is_admissible ) exit search_me enddo search_me endfunction is_admissible","tags":"","loc":"proc/is_admissible.html","title":"is_admissible – FOODIE"},{"text":"private pure subroutine tokenize(string, delimiter, toks, Nt) Tokenize a string in order to parse it. Note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input\n string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with\n only one element set to char(0). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(string)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I_P), intent(out), optional :: Nt Number of tokens. Called By proc~~tokenize~~CalledByGraph proc~tokenize tokenize proc~is_admissible is_admissible proc~is_admissible->proc~tokenize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tokenize Source Code pure subroutine tokenize ( string , delimiter , toks , Nt ) !< Tokenize a string in order to parse it. !< !< @note The dummy array containing tokens must be allocatable and its character elements must have the same length of the input !< string. If the length of the delimiter is higher than the input string one then the output tokens array is allocated with !< only one element set to char(0). character ( len =* ), intent ( IN ) :: string !< String to be tokenized. character ( len =* ), intent ( IN ) :: delimiter !< Delimiter of tokens. character ( len = len ( string )), allocatable , intent ( OUT ) :: toks (:) !< Tokens. integer ( I_P ), optional , intent ( OUT ) :: Nt !< Number of tokens. character ( len = len ( string )) :: strsub !< Temporary string. integer ( I_P ) :: dlen !< Delimiter length. integer ( I_P ) :: c !< Counter. integer ( I_P ) :: n !< Counter. integer ( I_P ) :: t !< Counter. ! initialize if ( allocated ( toks )) deallocate ( toks ) strsub = string dlen = len ( delimiter ) if ( dlen > len ( string )) then allocate ( toks ( 1 : 1 )) toks ( 1 ) = char ( 0 ) if ( present ( Nt )) Nt = 1 return endif ! compute the number of tokens n = 1 do c = 1 , len ( strsub ) - dlen ! loop over string characters if ( strsub ( c : c + dlen - 1 ) == delimiter ) n = n + 1 enddo allocate ( toks ( 1 : n )) ! tokenize do t = 1 , n ! loop over tokens c = index ( strsub , delimiter ) if ( c > 0 ) then toks ( t ) = strsub ( 1 : c - 1 ) strsub = strsub ( c + dlen :) else toks ( t ) = strsub endif enddo if ( present ( Nt )) Nt = n endsubroutine tokenize","tags":"","loc":"proc/tokenize.html","title":"tokenize – FOODIE"},{"text":"private pure function observed_order(error, Dt) Estimate the order of accuracy using 2 subsequent refined numerical solutions. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:2) Computed errors. real(kind=R_P), intent(in) :: Dt (1:2) Time steps used. Return Value real(kind=R_P) Estimation of the order of accuracy. Called By proc~~observed_order~~CalledByGraph proc~observed_order observed_order proc~test test proc~test->proc~observed_order Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code observed_order Source Code pure function observed_order ( error , Dt ) !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. real ( R_P ), intent ( IN ) :: error ( 1 : 2 ) !< Computed errors. real ( R_P ), intent ( IN ) :: Dt ( 1 : 2 ) !< Time steps used. real ( R_P ) :: observed_order !< Estimation of the order of accuracy. observed_order = log ( error ( 1 ) / error ( 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) endfunction observed_order","tags":"","loc":"proc/observed_order.html","title":"observed_order – FOODIE"},{"text":"private subroutine check_scheme_has_fast_mode(scheme, integrator) Check if a scheme support fast mode integrate. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Scheme name. class( integrator_object ), intent(in) :: integrator Integrator instance. Called By proc~~check_scheme_has_fast_mode~~CalledByGraph proc~check_scheme_has_fast_mode check_scheme_has_fast_mode proc~integrate~14 integrate proc~integrate~14->proc~check_scheme_has_fast_mode proc~test test proc~test->proc~integrate~14 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_scheme_has_fast_mode Source Code subroutine check_scheme_has_fast_mode ( scheme , integrator ) !< Check if a scheme support fast mode integrate. character ( * ), intent ( in ) :: scheme !< Scheme name. class ( integrator_object ), intent ( in ) :: integrator !< Integrator instance. if (. not . integrator % has_fast_mode ()) then write ( stderr , '(A)' ) 'error: ' // trim ( adjustl ( scheme )) // ' has not fast integrate mode!' stop endif endsubroutine check_scheme_has_fast_mode","tags":"","loc":"proc/check_scheme_has_fast_mode.html","title":"check_scheme_has_fast_mode – FOODIE"},{"text":"private subroutine execute(self) Execute selected test(s). Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(inout) :: self Test. Calls proc~~execute~~CallsGraph proc~execute execute proc~foodie_integrator_schemes foodie_integrator_schemes proc~execute->proc~foodie_integrator_schemes proc~is_class_available is_class_available proc~execute->proc~is_class_available proc~is_available is_available proc~execute->proc~is_available supported_schemes supported_schemes proc~foodie_integrator_schemes->supported_schemes proc~foodie_integrator_class_names foodie_integrator_class_names proc~is_class_available->proc~foodie_integrator_class_names proc~is_available->proc~is_class_available proc~is_scheme_available is_scheme_available proc~is_available->proc~is_scheme_available class_name class_name proc~foodie_integrator_class_names->class_name proc~is_scheme_available->proc~foodie_integrator_schemes var panprocexecuteCallsGraph = svgPanZoom('#procexecuteCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code execute Source Code subroutine execute ( self ) !< Execute selected test(s). class ( lcce_test ), intent ( inout ) :: self !< Test. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: s !< Counter. call self % initialize if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if ( is_class_available ( scheme = self % scheme )) then integrator_schemes = foodie_integrator_schemes ( class_name = self % scheme ) elseif ( is_available ( scheme = self % scheme )) then integrator_schemes = [ trim ( adjustl ( self % scheme ))] endif else integrator_schemes = foodie_integrator_schemes () endif do s = 1 , size ( integrator_schemes , dim = 1 ) self % scheme = trim ( integrator_schemes ( s )) call self % test ( scheme = self % scheme ) enddo endsubroutine execute","tags":"","loc":"proc/execute.html","title":"execute – FOODIE"},{"text":"private subroutine initialize(self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(inout) :: self Test. Source Code initialize Source Code subroutine initialize ( self ) !< Initialize test: set Command Line Interface, parse it and check its validity. class ( lcce_test ), intent ( inout ) :: self !< Test. call set_cli call parse_cli contains subroutine set_cli () !< Set Command Line Interface. associate ( cli => self % cli ) call cli % init ( progname = 'foodie_test_lcce' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on linear constant coefficients equation integration' , & examples = [ \"foodie_test_lcce --scheme euler_explicit --save_results  \" , & \"foodie_test_lcce --scheme all -r                         \" ]) call cli % add ( switch = '--scheme' , switch_ab = '-s' , help = 'integrator scheme used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--fast' , help = 'activate fast solvers' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--iterations' , help = 'iterations number for implicit schemes' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--stages' , help = 'stages number' , required = . false ., def = '4' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'time step' , required = . false ., def = '0.01' , act = 'store' ) call cli % add ( switch = '--a' , switch_ab = '-a' , help = '\"a\" coefficient' , required = . false ., def = '-1.0' , act = 'store' ) call cli % add ( switch = '--b' , switch_ab = '-b' , help = '\"b\" coefficient' , required = . false ., def = '0.0' , act = 'store' ) call cli % add ( switch = '--U0' , switch_ab = '-U0' , help = 'initial state' , required = . false ., def = '1.0' , act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'final integration time' , required = . false ., def = '1.0' , act = 'store' ) call cli % add ( switch = '--save_results' , switch_ab = '-r' , help = 'save result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'output files basename' , required = . false ., act = 'store' , def = 'foodie_test_lcce' ) call cli % add ( switch = '--exact_solution' , help = 'save exact solutiion' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--errors_analysis' , help = 'peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) endassociate endsubroutine set_cli subroutine parse_cli () !< Parse Command Line Interface and check its validity. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: i !< Counter. call self % cli % parse ( error = self % error ) call self % cli % get ( switch = '-s' , val = self % scheme , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--fast' , val = self % is_fast , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--iterations' , val = self % implicit_iterations , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--stages' , val = self % stages , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get_varying ( switch = '-Dt' , val = self % Dt , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-a' , val = self % a , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-b' , val = self % b , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-U0' , val = self % U0 , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-tf' , val = self % final_time , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-r' , val = self % results , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--output' , val = self % output , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--exact_solution' , val = self % exact_solution , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--errors_analysis' , val = self % errors_analysis , error = self % error ) ; if ( self % error /= 0 ) stop if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if (. not . is_available ( scheme = self % scheme )) then integrator_class_names = foodie_integrator_class_names () integrator_schemes = foodie_integrator_schemes () print '(A)' , 'Error: the scheme \"' // trim ( adjustl ( self % scheme )) // '\" is unknown!' print '(A)' , 'Supported classes of schemes are:' do i = 1 , size ( integrator_class_names , dim = 1 ) print '(A)' , '  ' // trim ( integrator_class_names ( i )) enddo print '(A)' , 'Supported schemes are:' do i = 1 , size ( integrator_schemes , dim = 1 ) print '(A)' , '  ' // trim ( integrator_schemes ( i )) enddo stop endif endif if (. not . is_dt_valid ()) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str ( self % final_time , . true .) print \"(A)\" , 'Time step: ' // str ( self % Dt , . true .) stop endif if ( self % errors_analysis ) then if (. not .( size ( self % Dt , dim = 1 ) > 1 )) self % errors_analysis = . false . endif endsubroutine parse_cli function is_dt_valid () !< Verify if the selected time step Dt is valid. logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) if (. not . is_dt_valid ) exit enddo endfunction is_dt_valid endsubroutine initialize","tags":"","loc":"proc/initialize~14.html","title":"initialize – FOODIE"},{"text":"private subroutine integrate(scheme, a, b, U0, final_time, Dt, iterations, stages, is_fast, solution, error, last_step) Integrate domain by means of the given scheme. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected scheme. real(kind=R_P), intent(in) :: a a coefficient. real(kind=R_P), intent(in) :: b b coefficient. real(kind=R_P), intent(in) :: U0 Initial state. real(kind=R_P), intent(in) :: final_time Final integration time. real(kind=R_P), intent(in) :: Dt Time step. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. integer(kind=I_P), intent(in) :: stages Number of stages. logical, intent(in) :: is_fast Activate fast mode integration. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step, X-Y. real(kind=R_P), intent(out) :: error Error (norm L2) with respect the exact solution. integer(kind=I_P), intent(out) :: last_step Last time step computed. Calls proc~~integrate~14~~CallsGraph proc~integrate~14 integrate proc~foodie_integrator_factory foodie_integrator_factory proc~integrate~14->proc~foodie_integrator_factory proc~check_scheme_has_fast_mode check_scheme_has_fast_mode proc~integrate~14->proc~check_scheme_has_fast_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~integrate~14~~CalledByGraph proc~integrate~14 integrate proc~test test proc~test->proc~integrate~14 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate Source Code subroutine integrate ( scheme , a , b , U0 , final_time , Dt , iterations , stages , is_fast , solution , error , last_step ) !< Integrate domain by means of the given scheme. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), intent ( in ) :: a !< *a* coefficient. real ( R_P ), intent ( in ) :: b !< *b* coefficient. real ( R_P ), intent ( in ) :: U0 !< Initial state. real ( R_P ), intent ( in ) :: final_time !< Final integration time. real ( R_P ), intent ( in ) :: Dt !< Time step. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. integer ( I_P ), intent ( in ) :: stages !< Number of stages. logical , intent ( in ) :: is_fast !< Activate fast mode integration. real ( R_P ), allocatable , intent ( out ) :: solution (:,:) !< Solution at each time step, X-Y. real ( R_P ), intent ( out ) :: error !< Error (norm L2) with respect the exact solution. integer ( I_P ), intent ( out ) :: last_step !< Last time step computed. class ( integrator_object ), allocatable :: integrator !< The integrator. type ( integrand_lcce ) :: domain !< Linear constant coefficients equation field. type ( integrand_lcce ), allocatable :: previous (:) !< Previous time steps solutions. type ( integrand_lcce ), allocatable :: stage (:) !< Runge-Kutta stages. type ( integrand_lcce ) :: buffer !< Buffer field. type ( integrand_lcce ) :: filter !< Filter displacement. integer :: step !< Time steps counter. integer :: step_offset !< Time steps counter offset for slicing previous data array. real ( R_P ), allocatable :: Dts (:) !< Time steps for variable stepsize. real ( R_P ) :: Dt_a !< Adaptive time step. call domain % initialize ( a = a , b = b , U0 = U0 ) if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : domain % integrand_dimension (), 0 : int ( final_time / Dt ))) solution = 0.0_R_P solution ( 1 :, 0 ) = domain % output () call foodie_integrator_factory ( scheme = scheme , integrator = integrator , stages = stages , tolerance = 1 e2_R_P ) if ( is_fast ) call check_scheme_has_fast_mode ( scheme = trim ( adjustl ( scheme )), integrator = integrator ) if ( integrator % is_multistep ()) allocate ( previous ( 1 : integrator % steps_number ())) if ( integrator % is_multistage ()) allocate ( stage ( 1 : integrator % stages_number ())) select type ( integrator ) type is ( integrator_adams_bashforth ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_bashforth_moulton ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_moulton ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : integrator % steps_number () + 1 )) if ( integrator % steps_number () == 0 ) then step_offset = 1 ! for 0 step-(a convention)-solver offset is 1 else step_offset = integrator % steps_number () ! for >0 step-solver offset is steps endif step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then if ( iterations > 1 ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif else if ( iterations > 1 ) then call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_back_df ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_euler_explicit ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_leapfrog ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( index ( scheme , 'raw' ) > 0 ) then if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step ), filter = filter ) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step ), filter = filter ) endif else if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp_vss ) if ( allocated ( Dts )) deallocate ( Dts ) ; allocate ( Dts ( 1 : integrator % steps_number ())) ; Dts = Dt step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_ms_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & stage = stage , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & stage = stage , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_emd ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 Dt_a = Dt if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt_a , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt_a , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ls ) if ( allocated ( stage )) deallocate ( stage ) ; allocate ( stage ( 1 : integrator % registers_number ())) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_lssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step endselect error = 0._R_P do step = 0 , last_step domain = solution ( 1 :, step ) error = error + ( domain % output () - domain % exact_solution ( t = solution ( 0 , step ))) ** 2 enddo error = sqrt ( error ) endsubroutine integrate","tags":"","loc":"proc/integrate~14.html","title":"integrate – FOODIE"},{"text":"private subroutine save_results(results, output, scheme, a, b, U0, save_exact_solution, solution) Save results (and plots). Arguments Type Intent Optional Attributes Name logical, intent(in) :: results Flag for activating results saving. character(len=*), intent(in) :: output Output files basename coming from CLI. character(len=*), intent(in) :: scheme Selected scheme: must be defined into solvers . real(kind=R_P), intent(in) :: a a coefficient. real(kind=R_P), intent(in) :: b b coefficient. real(kind=R_P), intent(in) :: U0 Initial state. logical, intent(in) :: save_exact_solution Flag for saving exact solution. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Calls proc~~save_results~~CallsGraph proc~save_results save_results strz strz proc~save_results->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_results~~CalledByGraph proc~save_results save_results proc~test test proc~test->proc~save_results Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( results , output , scheme , a , b , U0 , save_exact_solution , solution ) !< Save results (and plots). logical , intent ( in ) :: results !< Flag for activating results saving. character ( * ), intent ( in ) :: output !< Output files basename coming from CLI. character ( * ), intent ( in ) :: scheme !< Selected scheme: must be defined into *solvers*. real ( R_P ), intent ( in ) :: a !< *a* coefficient. real ( R_P ), intent ( in ) :: b !< *b* coefficient. real ( R_P ), intent ( in ) :: U0 !< Initial state. logical , intent ( in ) :: save_exact_solution !< Flag for saving exact solution. real ( R_P ), intent ( in ) :: solution ( 0 :, 0 :) !< Solution at each time step. character ( len = :), allocatable :: title !< Output files title. character ( len = :), allocatable :: basename !< Output files basename. type ( integrand_lcce ) :: lcce !< Linear constant coefficients field. integer ( I_P ) :: rawfile !< Raw file unit for saving results. integer ( I_P ) :: s !< Counter. basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-' // trim ( adjustl ( scheme )) title = 'linear constant coefficients equation integration, solver=' // trim ( adjustl ( scheme )) if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"u\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(2(' // FR_P // ',1X))' ) solution (:, s ) enddo close ( rawfile ) endif if ( save_exact_solution ) then call lcce % initialize ( a = a , b = b , U0 = U0 ) basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-exact_solution' title = 'linear constant coefficients equation integration, solver=exact solution' open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"u\"' write ( rawfile , '(A)' ) 'ZONE T=\"exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(2(' // FR_P // ',1X))' ) solution ( 0 , s ), lcce % exact_solution ( t = solution ( 0 , s )) enddo close ( rawfile ) endif endsubroutine save_results","tags":"","loc":"proc/save_results.html","title":"save_results – FOODIE"},{"text":"private subroutine test(self, scheme) Perform the test. Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(in) :: self Test. character(len=*), intent(in) :: scheme Selected scheme. Calls proc~~test~~CallsGraph proc~test test proc~save_results save_results proc~test->proc~save_results proc~integrate~14 integrate proc~test->proc~integrate~14 proc~observed_order observed_order proc~test->proc~observed_order strz strz proc~save_results->strz proc~foodie_integrator_factory foodie_integrator_factory proc~integrate~14->proc~foodie_integrator_factory proc~check_scheme_has_fast_mode check_scheme_has_fast_mode proc~integrate~14->proc~check_scheme_has_fast_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test Source Code subroutine test ( self , scheme ) !< Perform the test. class ( lcce_test ), intent ( in ) :: self !< Test. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. real ( R_P ), allocatable :: error (:) !< Error (norm L2) with respect the exact solution. real ( R_P ), allocatable :: order (:) !< Observed order based on subsequent refined solutions. integer ( I_P ) :: last_step !< Last time step computed. integer ( I_P ) :: t !< Counter. print \"(A)\" , trim ( adjustl ( scheme )) allocate ( error ( 1 : size ( self % Dt ))) error = 0.0_R_P if ( self % errors_analysis ) then allocate ( order ( 1 : size ( error , dim = 1 ) - 1 )) order = 0.0_R_P endif do t = 1 , size ( self % Dt , dim = 1 ) call integrate ( scheme = scheme , & a = self % a , & b = self % b , & U0 = self % U0 , & final_time = self % final_time , & Dt = self % Dt ( t ), & iterations = self % implicit_iterations , & stages = self % stages , & is_fast = self % is_fast , & solution = solution , & error = error ( t ), & last_step = last_step ) if ( allocated ( solution )) then print \"(A,G0,A,G0,A,G0)\" , \"  steps: \" , last_step , \" Dt: \" , self % Dt ( t ), \", error: \" , error ( t ) if ( self % errors_analysis . and . t > 1 ) then order ( t - 1 ) = observed_order ( error = error ( t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print \"(A,F7.3)\" , \"    observed order: \" , order ( t - 1 ) endif call save_results ( results = self % results , & output = self % output , & scheme = trim ( adjustl ( scheme )), & a = self % a , & b = self % b , & U0 = self % U0 , & save_exact_solution = self % exact_solution , & solution = solution ( 0 : 1 , 0 : last_step )) endif enddo endsubroutine test","tags":"","loc":"proc/test.html","title":"test – FOODIE"},{"text":"private pure function observed_order(error, Dt) Estimate the order of accuracy using 2 subsequent refined numerical solutions. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:,1:) Computed errors. real(kind=R_P), intent(in) :: Dt (1:) Time steps used. Return Value real(kind=R_P)\n  (1:size(error,dim=1)) Estimation of the order of accuracy. Called By proc~~observed_order~2~~CalledByGraph proc~observed_order~2 observed_order proc~test~2 test proc~test~2->proc~observed_order~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code observed_order Source Code pure function observed_order ( error , Dt ) !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. real ( R_P ), intent ( in ) :: error ( 1 :, 1 :) !< Computed errors. real ( R_P ), intent ( in ) :: Dt ( 1 :) !< Time steps used. real ( R_P ) :: observed_order ( 1 : size ( error , dim = 1 )) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. do v = 1 , size ( error , dim = 1 ) observed_order ( v ) = log ( error ( v , 1 ) / error ( v , 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) enddo endfunction observed_order","tags":"","loc":"proc/observed_order~2.html","title":"observed_order – FOODIE"},{"text":"private subroutine check_scheme_has_fast_mode(scheme, integrator) Check if a scheme support fast mode integrate. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Scheme name. class( integrator_object ), intent(in) :: integrator Integrator instance. Called By proc~~check_scheme_has_fast_mode~2~~CalledByGraph proc~check_scheme_has_fast_mode~2 check_scheme_has_fast_mode proc~integrate~15 integrate proc~integrate~15->proc~check_scheme_has_fast_mode~2 proc~test~2 test proc~test~2->proc~integrate~15 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_scheme_has_fast_mode Source Code subroutine check_scheme_has_fast_mode ( scheme , integrator ) !< Check if a scheme support fast mode integrate. character ( * ), intent ( in ) :: scheme !< Scheme name. class ( integrator_object ), intent ( in ) :: integrator !< Integrator instance. if (. not . integrator % has_fast_mode ()) then write ( stderr , '(A)' ) 'error: ' // trim ( adjustl ( scheme )) // ' has not fast integrate mode!' stop endif endsubroutine check_scheme_has_fast_mode","tags":"","loc":"proc/check_scheme_has_fast_mode~2.html","title":"check_scheme_has_fast_mode – FOODIE"},{"text":"private subroutine execute(self) Execute test(s). Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Calls proc~~execute~2~~CallsGraph proc~execute~2 execute proc~foodie_integrator_schemes foodie_integrator_schemes proc~execute~2->proc~foodie_integrator_schemes proc~is_class_available is_class_available proc~execute~2->proc~is_class_available proc~is_available is_available proc~execute~2->proc~is_available supported_schemes supported_schemes proc~foodie_integrator_schemes->supported_schemes proc~foodie_integrator_class_names foodie_integrator_class_names proc~is_class_available->proc~foodie_integrator_class_names proc~is_available->proc~is_class_available proc~is_scheme_available is_scheme_available proc~is_available->proc~is_scheme_available class_name class_name proc~foodie_integrator_class_names->class_name proc~is_scheme_available->proc~foodie_integrator_schemes var panprocexecute2CallsGraph = svgPanZoom('#procexecute2CallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code execute Source Code subroutine execute ( self ) !< Execute test(s). class ( oscillation_test ), intent ( inout ) :: self !< Test. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: s !< Counter. call self % initialize if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if ( is_class_available ( scheme = self % scheme )) then integrator_schemes = foodie_integrator_schemes ( class_name = self % scheme ) elseif ( is_available ( scheme = self % scheme )) then integrator_schemes = [ trim ( adjustl ( self % scheme ))] endif else integrator_schemes = foodie_integrator_schemes () endif do s = 1 , size ( integrator_schemes , dim = 1 ) self % scheme = trim ( integrator_schemes ( s )) call self % test ( scheme = self % scheme ) enddo endsubroutine execute","tags":"","loc":"proc/execute~2.html","title":"execute – FOODIE"},{"text":"private subroutine initialize(self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. Source Code initialize Source Code subroutine initialize ( self ) !< Initialize test: set Command Line Interface, parse it and check its validity. class ( oscillation_test ), intent ( inout ) :: self !< Test. call set_cli call parse_cli contains subroutine set_cli () !< Set Command Line Interface. associate ( cli => self % cli ) call cli % init ( progname = 'foodie_test_oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Oscillation equations integration' , & examples = [ \"foodie_test_oscillation --scheme euler_explicit --save_results  \" , & \"foodie_test_oscillation --scheme all -r                         \" ]) call cli % add ( switch = '--scheme' , switch_ab = '-s' , help = 'integrator scheme used' , required = . false ., def = 'all' , act = 'store' ) call cli % add ( switch = '--fast' , help = 'activate fast solvers' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--iterations' , help = 'iterations number for implicit schemes' , required = . false ., act = 'store' , def = '5' ) call cli % add ( switch = '--stages' , help = 'stages number' , required = . false ., def = '2' , act = 'store' ) call cli % add ( switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'time step' , required = . false ., def = '1e2' , act = 'store' ) call cli % add ( switch = '--frequency' , switch_ab = '-f' , help = 'frequency' , required = . false ., def = '1e-4' , act = 'store' ) call cli % add ( switch = '--U0' , switch_ab = '-U0' , nargs = '2' , help = 'initial state' , required = . false ., def = '0.0 1.0' , act = 'store' ) call cli % add ( switch = '--t_final' , switch_ab = '-tf' , help = 'final integration time' , required = . false ., def = '1e5' , act = 'store' ) call cli % add ( switch = '--save_results' , switch_ab = '-r' , help = 'save result' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'output file basename' , required = . false ., act = 'store' , def = 'foodie_test_oscillation' ) call cli % add ( switch = '--exact_solution' , help = 'save exact solutiion' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--errors_analysis' , help = 'peform errors analysis' , required = . false ., act = 'store_true' , def = '.false.' ) endassociate endsubroutine set_cli subroutine parse_cli () !< Parse Command Line Interface and check its validity. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. integer ( I_P ) :: i !< Counter. call self % cli % parse ( error = self % error ) call self % cli % get ( switch = '-s' , val = self % scheme , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--fast' , val = self % is_fast , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--iterations' , val = self % implicit_iterations , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--stages' , val = self % stages , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get_varying ( switch = '-Dt' , val = self % Dt , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-f' , val = self % frequency , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-U0' , val = self % U0 , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-tf' , val = self % final_time , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '-r' , val = self % results , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--output' , val = self % output , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--exact_solution' , val = self % exact_solution , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( switch = '--errors_analysis' , val = self % errors_analysis , error = self % error ) ; if ( self % error /= 0 ) stop if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if (. not . is_available ( scheme = self % scheme )) then integrator_class_names = foodie_integrator_class_names () integrator_schemes = foodie_integrator_schemes () print '(A)' , 'Error: the scheme \"' // trim ( adjustl ( self % scheme )) // '\" is unknown!' print '(A)' , 'Supported classes of schemes are:' do i = 1 , size ( integrator_class_names , dim = 1 ) print '(A)' , '  ' // trim ( integrator_class_names ( i )) enddo print '(A)' , 'Supported schemes are:' do i = 1 , size ( integrator_schemes , dim = 1 ) print '(A)' , '  ' // trim ( integrator_schemes ( i )) enddo stop endif endif if (. not . is_dt_valid ()) then print \"(A)\" , 'Error: the final integration time must be an exact multiple of the time step used!' print \"(A)\" , 'Final integration time: ' // str ( self % final_time , . true .) print \"(A)\" , 'Time step: ' // str ( self % Dt , . true .) stop endif if ( self % errors_analysis ) then if (. not .( size ( self % Dt , dim = 1 ) > 1 )) self % errors_analysis = . false . endif endsubroutine parse_cli function is_dt_valid () !< Verify if the selected time step Dt is valid. logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) if (. not . is_dt_valid ) exit enddo endfunction is_dt_valid endsubroutine initialize","tags":"","loc":"proc/initialize~15.html","title":"initialize – FOODIE"},{"text":"private subroutine integrate(scheme, frequency, U0, final_time, Dt, iterations, stages, is_fast, solution, error, last_step) Integrate domain by means of the given scheme. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected scheme. real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: U0 (1:) Initial state. real(kind=R_P), intent(in) :: final_time Final integration time. real(kind=R_P), intent(in) :: Dt Time step. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. integer(kind=I_P), intent(in) :: stages Number of stages. logical, intent(in) :: is_fast Activate fast mode integration. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step, X-Y. real(kind=R_P), intent(out) :: error (1:) Error (norm L2) with respect the exact solution. integer(kind=I_P), intent(out) :: last_step Last time step computed. Calls proc~~integrate~15~~CallsGraph proc~integrate~15 integrate proc~foodie_integrator_factory foodie_integrator_factory proc~integrate~15->proc~foodie_integrator_factory proc~check_scheme_has_fast_mode~2 check_scheme_has_fast_mode proc~integrate~15->proc~check_scheme_has_fast_mode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~integrate~15~~CalledByGraph proc~integrate~15 integrate proc~test~2 test proc~test~2->proc~integrate~15 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate Source Code subroutine integrate ( scheme , frequency , U0 , final_time , Dt , iterations , stages , is_fast , solution , error , last_step ) !< Integrate domain by means of the given scheme. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( in ) :: U0 ( 1 :) !< Initial state. real ( R_P ), intent ( in ) :: final_time !< Final integration time. real ( R_P ), intent ( in ) :: Dt !< Time step. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. integer ( I_P ), intent ( in ) :: stages !< Number of stages. logical , intent ( in ) :: is_fast !< Activate fast mode integration. real ( R_P ), allocatable , intent ( out ) :: solution (:,:) !< Solution at each time step, X-Y. real ( R_P ), intent ( out ) :: error ( 1 :) !< Error (norm L2) with respect the exact solution. integer ( I_P ), intent ( out ) :: last_step !< Last time step computed. class ( integrator_object ), allocatable :: integrator !< The integrator. type ( integrand_oscillation ) :: domain !< Oscillation field. type ( integrand_oscillation ), allocatable :: previous (:) !< Previous time steps solutions. type ( integrand_oscillation ), allocatable :: stage (:) !< Runge-Kutta stages. type ( integrand_oscillation ) :: buffer !< Buffer oscillation field. type ( integrand_oscillation ) :: filter !< Filter displacement. integer :: step !< Time steps counter. integer :: step_offset !< Time steps counter offset for slicing previous data array. real ( R_P ), allocatable :: Dts (:) !< Time steps for variable stepsize. real ( R_P ) :: Dt_a !< Adaptive time step. call domain % initialize ( U0 = U0 , frequency = frequency ) if ( allocated ( solution )) deallocate ( solution ) ; allocate ( solution ( 0 : domain % integrand_dimension (), 0 : int ( final_time / Dt ))) solution = 0.0_R_P solution ( 1 :, 0 ) = domain % output () call foodie_integrator_factory ( scheme = scheme , integrator = integrator , stages = stages , tolerance = 1 e2_R_P ) if ( is_fast ) call check_scheme_has_fast_mode ( scheme = trim ( adjustl ( scheme )), integrator = integrator ) if ( integrator % is_multistep ()) allocate ( previous ( 1 : integrator % steps_number ())) if ( integrator % is_multistage ()) allocate ( stage ( 1 : integrator % stages_number ())) select type ( integrator ) type is ( integrator_adams_bashforth ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_bashforth_moulton ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_adams_moulton ) if ( allocated ( previous )) deallocate ( previous ) ; allocate ( previous ( 1 : integrator % steps_number () + 1 )) if ( integrator % steps_number () == 0 ) then step_offset = 1 ! for 0 step-(a convention)-solver offset is 1 else step_offset = integrator % steps_number () ! for >0 step-solver offset is steps endif step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then if ( iterations > 1 ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif else if ( iterations > 1 ) then call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 ), & iterations = iterations ) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - step_offset : step - 1 )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_back_df ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_euler_explicit ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_leapfrog ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( index ( scheme , 'raw' ) > 0 ) then if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step ), filter = filter ) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step ), filter = filter ) endif else if ( is_fast ) then call integrator % integrate_fast ( U = domain , previous = previous , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , previous = previous , Dt = Dt , t = solution ( 0 , step )) endif endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_lmm_ssp_vss ) if ( allocated ( Dts )) deallocate ( Dts ) ; allocate ( Dts ( 1 : integrator % steps_number ())) ; Dts = Dt step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & buffer = buffer , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & Dt = Dts , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_ms_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( integrator % steps_number () >= step ) then domain = [ domain % exact_solution ( t = step * Dt )] previous ( step ) = domain else if ( is_fast ) then call integrator % integrate_fast ( U = domain , & previous = previous , & stage = stage , & buffer = buffer , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) else call integrator % integrate ( U = domain , & previous = previous , & stage = stage , & Dt = Dt , & t = solution ( 0 , step - integrator % steps_number (): step - 1 )) endif endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_emd ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 Dt_a = Dt if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt_a , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt_a , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ls ) if ( allocated ( stage )) deallocate ( stage ) ; allocate ( stage ( 1 : integrator % registers_number ())) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_lssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step type is ( integrator_runge_kutta_ssp ) step = 0 do while ( solution ( 0 , step ) < final_time . and . step < ubound ( solution , dim = 2 )) step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = domain , stage = stage , buffer = buffer , Dt = Dt , t = solution ( 0 , step )) else call integrator % integrate ( U = domain , stage = stage , Dt = Dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * Dt solution ( 1 :, step ) = domain % output () enddo last_step = step endselect error = 0._R_P do step = 0 , last_step domain = solution ( 1 :, step ) error = error + ( domain % output () - domain % exact_solution ( t = solution ( 0 , step ))) ** 2 enddo error = sqrt ( error ) endsubroutine integrate","tags":"","loc":"proc/integrate~15.html","title":"integrate – FOODIE"},{"text":"private subroutine save_results(results, output, scheme, frequency, U0, save_exact_solution, solution) Save results (and plots). Arguments Type Intent Optional Attributes Name logical, intent(in) :: results Flag for activating results saving. character(len=*), intent(in) :: output Output files basename coming from CLI. character(len=*), intent(in) :: scheme Selected scheme: must be defined into solvers . real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: U0 (1:) Initial state. logical, intent(in) :: save_exact_solution Flag for saving exact solution. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. Calls proc~~save_results~2~~CallsGraph proc~save_results~2 save_results strz strz proc~save_results~2->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_results~2~~CalledByGraph proc~save_results~2 save_results proc~test~2 test proc~test~2->proc~save_results~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( results , output , scheme , frequency , U0 , save_exact_solution , solution ) !< Save results (and plots). logical , intent ( in ) :: results !< Flag for activating results saving. character ( * ), intent ( in ) :: output !< Output files basename coming from CLI. character ( * ), intent ( in ) :: scheme !< Selected scheme: must be defined into *solvers*. real ( R_P ), intent ( in ) :: frequency !< Oscillation frequency. real ( R_P ), intent ( in ) :: U0 ( 1 :) !< Initial state. logical , intent ( in ) :: save_exact_solution !< Flag for saving exact solution. real ( R_P ), intent ( in ) :: solution ( 0 :, 0 :) !< Solution at each time step. character ( len = :), allocatable :: title !< Output files title. character ( len = :), allocatable :: basename !< Output files basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( integrand_oscillation ) :: oscillator !< Oscillation field. integer ( I_P ) :: s !< Counter. basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-' // trim ( adjustl ( scheme )) title = 'oscillation equations integration, solver=' // trim ( adjustl ( scheme )) if ( results ) then open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution (:, s ), amplitude_phase ( solution ( 1 : 2 , s )) enddo close ( rawfile ) endif if ( save_exact_solution ) then call oscillator % initialize ( U0 = U0 , frequency = frequency ) basename = trim ( adjustl ( output )) // '-' // trim ( strz ( ubound ( solution , dim = 2 ), 10 )) // '-time_steps-exact_solution' title = 'linear constant coefficients equation integration, solver=exact solution' open ( newunit = rawfile , file = basename // '.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) 'VARIABLES=\"t\" \"u\"' write ( rawfile , '(A)' ) 'ZONE T=\"exact solution\"' do s = 0 , ubound ( solution , dim = 2 ) write ( rawfile , '(5(' // FR_P // ',1X))' ) solution ( 0 , s ), oscillator % exact_solution ( t = solution ( 0 , s )), & amplitude_phase ( oscillator % exact_solution ( t = solution ( 0 , s ))) enddo close ( rawfile ) endif contains function amplitude_phase ( sol ) result ( ap ) !< Compute amplitude and phase of the solution provided in X-Y domain. real ( R_P ), intent ( in ) :: sol ( 1 :) !< Solution in X-Y domain. real ( R_P ) :: ap ( 1 : 2 ) !< Amplitude and phase solution. ap ( 1 ) = sqrt ( sol ( 1 ) ** 2 + sol ( 2 ) ** 2 ) ap ( 2 ) = atan ( - sol ( 1 ) / sol ( 2 )) endfunction amplitude_phase endsubroutine save_results","tags":"","loc":"proc/save_results~2.html","title":"save_results – FOODIE"},{"text":"private subroutine test(self, scheme) Perform the test. Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(in) :: self Test. character(len=*), intent(in) :: scheme Selected scheme. Calls proc~~test~2~~CallsGraph proc~test~2 test proc~observed_order~2 observed_order proc~test~2->proc~observed_order~2 proc~integrate~15 integrate proc~test~2->proc~integrate~15 proc~save_results~2 save_results proc~test~2->proc~save_results~2 proc~foodie_integrator_factory foodie_integrator_factory proc~integrate~15->proc~foodie_integrator_factory proc~check_scheme_has_fast_mode~2 check_scheme_has_fast_mode proc~integrate~15->proc~check_scheme_has_fast_mode~2 strz strz proc~save_results~2->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test Source Code subroutine test ( self , scheme ) !< Perform the test. class ( oscillation_test ), intent ( in ) :: self !< Test. character ( * ), intent ( in ) :: scheme !< Selected scheme. real ( R_P ), allocatable :: solution (:,:) !< Solution at each time step. real ( R_P ), allocatable :: error (:,:) !< Error (norm L2) with respect the exact solution. real ( R_P ), allocatable :: order (:,:) !< Observed order based on subsequent refined solutions. type ( integrand_oscillation ) :: oscillator !< Molding integrand oscillator. integer ( I_P ) :: last_step !< Last time step computed. integer ( I_P ) :: t !< Counter. print \"(A)\" , trim ( adjustl ( scheme )) allocate ( error ( 1 : oscillator % integrand_dimension (), 1 : size ( self % Dt ))) error = 0.0_R_P if ( self % errors_analysis ) then allocate ( order ( 1 : oscillator % integrand_dimension (), 1 : size ( error , dim = 2 ) - 1 )) order = 0.0_R_P endif do t = 1 , size ( self % Dt , dim = 1 ) call integrate ( scheme = scheme , & frequency = self % frequency , & U0 = self % U0 , & final_time = self % final_time , & Dt = self % Dt ( t ), & iterations = self % implicit_iterations , & stages = self % stages , & is_fast = self % is_fast , & solution = solution , & error = error (:, t ), & last_step = last_step ) if ( allocated ( solution )) then print \"(A,I10,4(A,G10.3))\" , \"    steps: \" , last_step , & \" Dt: \" , self % Dt ( t ), \", f*Dt: \" , self % frequency * self % Dt ( t ), & \", E(x): \" , error ( 1 , t ), \", E(y): \" , error ( 2 , t ) if ( self % errors_analysis . and . t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print \"(A,F10.2,A,F10.2)\" , \"      Observed order, O(x): \" , order ( 1 , t - 1 ), \", O(y): \" , order ( 2 , t - 1 ) endif call save_results ( results = self % results , & output = self % output , & scheme = trim ( adjustl ( scheme )), & frequency = self % frequency , & U0 = self % U0 , & save_exact_solution = self % exact_solution , & solution = solution (:, 0 : last_step )) endif enddo endsubroutine test","tags":"","loc":"proc/test~2.html","title":"test – FOODIE"},{"text":"subroutine init() Initialize the simulation. Arguments None Calls proc~~init~~CallsGraph proc~init init strz strz proc~init->strz proc~save_time_serie save_time_serie proc~init->proc~save_time_serie str str proc~init->str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~init~~CalledByGraph proc~init init program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Calls proc~~save_results~3~~CallsGraph proc~save_results~3 save_results str str proc~save_results~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_results~3~~CalledByGraph proc~save_results~3 save_results program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~save_results~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~3.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Calls proc~~save_time_serie~~CallsGraph proc~save_time_serie save_time_serie str str proc~save_time_serie->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~~CalledByGraph proc~save_time_serie save_time_serie program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~save_time_serie proc~init init program~integrate_euler_1d_caf->proc~init proc~init->proc~save_time_serie Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_time_serie Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – FOODIE"},{"text":"subroutine synchronize() Synchronize CAF images. Arguments None Called By proc~~synchronize~~CalledByGraph proc~synchronize synchronize program~integrate_euler_1d_caf integrate_euler_1D_caf program~integrate_euler_1d_caf->proc~synchronize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code synchronize Source Code subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize.html","title":"synchronize – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Called By proc~~e~~CalledByGraph proc~e E proc~riemann_solver riemann_solver proc~riemann_solver->proc~e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code E Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Source Code H Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h.html","title":"H – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Called By proc~~a~~CalledByGraph proc~a a proc~compute_dt compute_dt proc~compute_dt->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code a Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a.html","title":"a – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Calls proc~~compute_dt~~CallsGraph proc~compute_dt compute_dt proc~a a proc~compute_dt->proc~a Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_dt Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Source Code conservative2primitive Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive.html","title":"conservative2primitive – FOODIE"},{"text":"private function dEuler_dt(self) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_caf_nf ) Euler field time derivative. Source Code dEuler_dt Source Code function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_caf_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – FOODIE"},{"text":"private pure function output(self, conservative) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Source Code output Source Code pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output.html","title":"output – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Source Code p Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p.html","title":"p – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Source Code primitive2conservative Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative.html","title":"primitive2conservative – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Source Code r Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r.html","title":"r – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Called By proc~~compute_inter_states~~CalledByGraph proc~compute_inter_states compute_inter_states proc~riemann_solver riemann_solver proc~riemann_solver->proc~compute_inter_states Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_inter_states Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states.html","title":"compute_inter_states – FOODIE"},{"text":"private subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. Source Code destroy Source Code subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~14.html","title":"destroy – FOODIE"},{"text":"private elemental subroutine destroy_rk(self) Destoy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Source Code destroy_rk Source Code elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk","tags":"","loc":"proc/destroy_rk.html","title":"destroy_rk – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. Source Code euler_assign_euler Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_caf_nf ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine impose_boundary_conditions(self, primitive) Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Source Code impose_boundary_conditions Source Code subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Calls proc~~init~2~~CallsGraph proc~init~2 init weno_constructor_upwind weno_constructor_upwind proc~init~2->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~2.html","title":"init – FOODIE"},{"text":"private elemental subroutine init_rk(self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Source Code init_rk Source Code elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk","tags":"","loc":"proc/init_rk.html","title":"init_rk – FOODIE"},{"text":"private subroutine integrate_rk(self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_caf_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_caf_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_rk Source Code subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_caf_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_caf_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk","tags":"","loc":"proc/integrate_rk.html","title":"integrate_rk – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Source Code reconstruct_interfaces_states Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Calls proc~~riemann_solver~~CallsGraph proc~riemann_solver riemann_solver proc~compute_inter_states compute_inter_states proc~riemann_solver->proc~compute_inter_states proc~e E proc~riemann_solver->proc~e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code riemann_solver Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine synchronize(self) Synchronize CAF images. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Calls proc~~synchronize~2~~CallsGraph proc~synchronize~2 synchronize images images proc~synchronize~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code synchronize Source Code subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~2.html","title":"synchronize – FOODIE"},{"text":"subroutine init() Initialize the simulation. Arguments None Calls proc~~init~3~~CallsGraph proc~init~3 init strz strz proc~init~3->strz proc~save_time_serie~2 save_time_serie proc~init~3->proc~save_time_serie~2 str str proc~init~3->str proc~save_time_serie~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~init~3~~CalledByGraph proc~init~3 init program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~init~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~3.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Calls proc~~save_results~4~~CallsGraph proc~save_results~4 save_results str str proc~save_results~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_results~4~~CalledByGraph proc~save_results~4 save_results program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~save_results~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~4.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Calls proc~~save_time_serie~2~~CallsGraph proc~save_time_serie~2 save_time_serie str str proc~save_time_serie~2->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~2~~CalledByGraph proc~save_time_serie~2 save_time_serie program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~save_time_serie~2 proc~init~3 init program~integrate_euler_1d_caf~2->proc~init~3 proc~init~3->proc~save_time_serie~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_time_serie Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~2.html","title":"save_time_serie – FOODIE"},{"text":"subroutine synchronize() Synchronize CAF images. Arguments None Called By proc~~synchronize~3~~CalledByGraph proc~synchronize~3 synchronize program~integrate_euler_1d_caf~2 integrate_euler_1D_caf program~integrate_euler_1d_caf~2->proc~synchronize~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code synchronize Source Code subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~3.html","title":"synchronize – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Called By proc~~e~2~~CalledByGraph proc~e~2 E proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->proc~e~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code E Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~2.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Source Code H Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~2.html","title":"H – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Called By proc~~a~2~~CalledByGraph proc~a~2 a proc~compute_dt~2 compute_dt proc~compute_dt~2->proc~a~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code a Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~2.html","title":"a – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code add_euler Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Calls proc~~compute_dt~2~~CallsGraph proc~compute_dt~2 compute_dt proc~a~2 a proc~compute_dt~2->proc~a~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_dt Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~2.html","title":"compute_dt – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Source Code conservative2primitive Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~2.html","title":"conservative2primitive – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. Source Code dEuler_dt Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_caf :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_caf ) dState_dt = self endselect select type ( dState_dt ) class is ( euler_1D_caf ) do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~2.html","title":"dEuler_dt – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code euler_local_error Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_euler Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_real Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – FOODIE"},{"text":"private pure function output(self, conservative) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Source Code output Source Code pure function output ( self , conservative ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. logical , optional , intent ( IN ) :: conservative !< Output conservative variables instead of primitive. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( conservative )) then state = self % U else allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~2.html","title":"output – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Source Code p Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~2.html","title":"p – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Source Code primitive2conservative Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~2.html","title":"primitive2conservative – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Source Code r Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~2.html","title":"r – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_caf ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code real_multiply_euler Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_caf ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = rhs endselect select type ( opr ) class is ( euler_1D_caf ) opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code sub_euler Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_caf :: opr ) select type ( opr ) class is ( euler_1D_caf ) opr = lhs endselect select type ( opr ) class is ( euler_1D_caf ) select type ( rhs ) class is ( euler_1D_caf ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler.html","title":"sub_euler – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Called By proc~~compute_inter_states~2~~CalledByGraph proc~compute_inter_states~2 compute_inter_states proc~riemann_solver~2 riemann_solver proc~riemann_solver~2->proc~compute_inter_states~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_inter_states Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~2.html","title":"compute_inter_states – FOODIE"},{"text":"private subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. Source Code destroy Source Code subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) self % me = 0 self % we = 0 if ( allocated ( remote_U )) deallocate ( remote_U ) if ( allocated ( U_L )) deallocate ( U_L ) if ( allocated ( U_R )) deallocate ( U_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~15.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Source Code euler_assign_euler Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_caf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R lhs % me = rhs % me lhs % we = rhs % we endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~2.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code euler_assign_real Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – FOODIE"},{"text":"private subroutine impose_boundary_conditions(self, primitive) Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Source Code impose_boundary_conditions Source Code subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. character ( len = :), allocatable :: bc_type !< String containing BC type. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- call self % synchronize bc_type = trim ( adjustl ( self % BC_L )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = 1 - self % Ng , 0 primitive (:, i ) = self % conservative2primitive ( U_L (:, self % Ni + i )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect endif bc_type = trim ( adjustl ( self % BC_R )) if ( 'CON' == bc_type ( 1 : 3 )) then ! connection between remote images do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = self % conservative2primitive ( U_R (:, i - self % Ni )) enddo else select case ( bc_type ( 1 : 3 )) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect endif return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~2.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Calls proc~~init~4~~CallsGraph proc~init~4 init weno_constructor_upwind weno_constructor_upwind proc~init~4->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , me , we , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension (local image). integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), intent ( IN ) :: me !< ID of this_image(). integer ( I_P ), intent ( IN ) :: we !< Number of CAF images used. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo self % me = me self % we = we #ifdef CAF if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )[ * ]) #else if ( allocated ( remote_U )) deallocate ( remote_U ) ; allocate ( remote_U ( 1 : self % Nc , 1 : Ni )) #endif if ( allocated ( U_L )) deallocate ( U_L ) ; allocate ( U_L ( 1 : self % Nc , 1 : self % Ni )) if ( allocated ( U_R )) deallocate ( U_R ) ; allocate ( U_R ( 1 : self % Nc , 1 : self % Ni )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~4.html","title":"init – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Source Code reconstruct_interfaces_states Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~2.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Calls proc~~riemann_solver~2~~CallsGraph proc~riemann_solver~2 riemann_solver proc~compute_inter_states~2 compute_inter_states proc~riemann_solver~2->proc~compute_inter_states~2 proc~e~2 E proc~riemann_solver~2->proc~e~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code riemann_solver Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~2.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine synchronize(self) Synchronize CAF images. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. Calls proc~~synchronize~4~~CallsGraph proc~synchronize~4 synchronize images images proc~synchronize~4->images Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code synchronize Source Code subroutine synchronize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_caf ), intent ( IN ) :: self !< Euler field. integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( self % we > 1 ) then remote_U = self % U if ( self % me == 1 ) then sync images ( self % me + 1 ) U_R (:,:) = remote_U (:,:)[ self % me + 1 ] else if ( self % me == self % we ) then sync images ( self % me - 1 ) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] else sync images ([ self % me - 1 , self % me + 1 ]) U_L (:,:) = remote_U (:,:)[ self % me - 1 ] U_R (:,:) = remote_U (:,:)[ self % me + 1 ] endif endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize","tags":"","loc":"proc/synchronize~4.html","title":"synchronize – FOODIE"},{"text":"subroutine init() Initialize the field. Arguments None Called By proc~~init~5~~CalledByGraph proc~init~5 init program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~init~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~5.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Calls proc~~save_results~5~~CallsGraph proc~save_results~5 save_results str str proc~save_results~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_results~5~~CalledByGraph proc~save_results~5 save_results program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~save_results~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~5.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Calls proc~~save_time_serie~3~~CallsGraph proc~save_time_serie~3 save_time_serie str str proc~save_time_serie~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~3~~CalledByGraph proc~save_time_serie~3 save_time_serie program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie->proc~save_time_serie~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_time_serie Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~3.html","title":"save_time_serie – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Called By proc~~e~3~~CalledByGraph proc~e~3 E proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->proc~e~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code E Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~3.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Source Code H Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~3.html","title":"H – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Called By proc~~a~3~~CalledByGraph proc~a~3 a proc~compute_dt~3 compute_dt proc~compute_dt~3->proc~a~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code a Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~3.html","title":"a – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Calls proc~~compute_dt~3~~CallsGraph proc~compute_dt~3 compute_dt proc~a~3 a proc~compute_dt~3->proc~a~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_dt Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~3.html","title":"compute_dt – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Source Code conservative2primitive Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~3.html","title":"conservative2primitive – FOODIE"},{"text":"private function dEuler_dt(self) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_omp_nf ) Euler field time derivative. Source Code dEuler_dt Source Code function dEuler_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. type ( euler_1D_omp_nf ) :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals dState_dt = self !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~3.html","title":"dEuler_dt – FOODIE"},{"text":"private pure function output(self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Source Code output Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~3.html","title":"output – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Source Code p Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~3.html","title":"p – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Source Code primitive2conservative Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~3.html","title":"primitive2conservative – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Source Code r Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~3.html","title":"r – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Called By proc~~compute_inter_states~3~~CalledByGraph proc~compute_inter_states~3 compute_inter_states proc~riemann_solver~3 riemann_solver proc~riemann_solver~3->proc~compute_inter_states~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_inter_states Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~3.html","title":"compute_inter_states – FOODIE"},{"text":"private pure subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. Source Code destroy Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~16.html","title":"destroy – FOODIE"},{"text":"private elemental subroutine destroy_rk(self) Destoy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Source Code destroy_rk Source Code elemental subroutine destroy_rk ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy_rk","tags":"","loc":"proc/destroy_rk~2.html","title":"destroy_rk – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. Source Code euler_assign_euler Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: lhs !< Left hand side. class ( euler_1D_omp_nf ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_omp_nf ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~3.html","title":"euler_assign_euler – FOODIE"},{"text":"private pure subroutine impose_boundary_conditions(self, primitive) Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Source Code impose_boundary_conditions Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~3.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Calls proc~~init~6~~CallsGraph proc~init~6 init weno_constructor_upwind weno_constructor_upwind proc~init~6->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~6.html","title":"init – FOODIE"},{"text":"private elemental subroutine init_rk(self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Source Code init_rk Source Code elemental subroutine init_rk ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_rk","tags":"","loc":"proc/init_rk~2.html","title":"init_rk – FOODIE"},{"text":"private subroutine integrate_rk(self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_omp_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_omp_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Source Code integrate_rk Source Code subroutine integrate_rk ( self , U , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( euler_1D_omp_nf ), intent ( INOUT ) :: U !< Field to be integrated. class ( euler_1D_omp_nf ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! computing stages do s = 1 , self % stages stage ( s ) = U do ss = 1 , s - 1 stage ( s )% U = stage ( s )% U + stage ( ss )% U * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , self % stages U % U = U % U + stage ( s )% U * ( Dt * self % beta ( s )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate_rk","tags":"","loc":"proc/integrate_rk~2.html","title":"integrate_rk – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Source Code reconstruct_interfaces_states Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~3.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Calls proc~~riemann_solver~3~~CallsGraph proc~riemann_solver~3 riemann_solver proc~compute_inter_states~3 compute_inter_states proc~riemann_solver~3->proc~compute_inter_states~3 proc~e~3 E proc~riemann_solver~3->proc~e~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code riemann_solver Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_omp_nf ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~3.html","title":"riemann_solver – FOODIE"},{"text":"subroutine init() Initialize the field. Arguments None Called By proc~~init~7~~CalledByGraph proc~init~7 init program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~init~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~7.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Calls proc~~save_results~6~~CallsGraph proc~save_results~6 save_results str str proc~save_results~6->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_results~6~~CalledByGraph proc~save_results~6 save_results program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~save_results~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~6.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Calls proc~~save_time_serie~4~~CallsGraph proc~save_time_serie~4 save_time_serie str str proc~save_time_serie~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~4~~CalledByGraph proc~save_time_serie~4 save_time_serie program~integrate_euler_1d_openmp integrate_euler_1D_openmp program~integrate_euler_1d_openmp->proc~save_time_serie~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_time_serie Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~4.html","title":"save_time_serie – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Called By proc~~e~4~~CalledByGraph proc~e~4 E proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->proc~e~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code E Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~4.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Source Code H Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~4.html","title":"H – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Called By proc~~a~4~~CalledByGraph proc~a~4 a proc~compute_dt~4 compute_dt proc~compute_dt~4->proc~a~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code a Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~4.html","title":"a – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code add_euler Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) + rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler~2.html","title":"add_euler – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Calls proc~~compute_dt~4~~CallsGraph proc~compute_dt~4 compute_dt proc~a~4 a proc~compute_dt~4->proc~a~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_dt Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~4.html","title":"compute_dt – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Source Code conservative2primitive Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~4.html","title":"conservative2primitive – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. Source Code dEuler_dt Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F) do i = 0 , self % Ni F (:, i ) = 0._R_P enddo allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 - self % Ng , self % Ni + self % Ng P (:, i ) = 0._R_P enddo allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 0 , self % Ni + 1 PR (:, :, i ) = 0._R_P enddo ! compute primitive variables !$OMP PARALLEL DO PRIVATE(i) SHARED(self, P) do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DO PRIVATE(i) SHARED(self, F, PR) do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self endselect !$OMP PARALLEL PRIVATE(i) SHARED(self, dState_dt, F) select type ( dState_dt ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~4.html","title":"dEuler_dt – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code euler_local_error Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }} }  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: v !< Variables counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) error = 0._R_P do i = 1 , lhs % Ni do v = 1 , lhs % Nc error = error + ( lhs % U ( v , i ) - rhs % U ( v , i )) ** 2 / lhs % U ( v , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error~2.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_euler Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler~2.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_real Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) * rhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real~2.html","title":"euler_multiply_real – FOODIE"},{"text":"private pure function output(self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Source Code output Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~4.html","title":"output – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Source Code p Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~4.html","title":"p – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Source Code primitive2conservative Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~4.html","title":"primitive2conservative – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Source Code r Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~4.html","title":"r – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_openmp ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code real_multiply_euler Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , rhs % Ni opr % U (:, i ) = rhs % U (:, i ) * lhs enddo endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler~2.html","title":"real_multiply_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code sub_euler Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs, opr) select type ( opr ) class is ( euler_1D_openmp ) select type ( rhs ) class is ( euler_1D_openmp ) !$OMP DO do i = 1 , lhs % Ni opr % U (:, i ) = lhs % U (:, i ) - rhs % U (:, i ) enddo endselect endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler~2.html","title":"sub_euler – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Called By proc~~compute_inter_states~4~~CalledByGraph proc~compute_inter_states~4 compute_inter_states proc~riemann_solver~4 riemann_solver proc~riemann_solver~4->proc~compute_inter_states~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_inter_states Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~4.html","title":"compute_inter_states – FOODIE"},{"text":"private pure subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. Source Code destroy Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~17.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Source Code euler_assign_euler Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) then if ( allocated ( lhs % U )) deallocate ( lhs % U ) ; allocate ( lhs % U ( 1 : lhs % Nc , 1 : lhs % Ni )) endif if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect !$OMP PARALLEL DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) select type ( rhs ) class is ( euler_1D_openmp ) if ( allocated ( rhs % U )) then !$OMP DO do i = 1 , lhs % Ni lhs % U (:, i ) = rhs % U (:, i ) enddo endif endselect !$OMP END PARALLEL return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~4.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code euler_assign_real Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) then !$OMP PARALLEL DO DEFAULT(NONE) PRIVATE(i) SHARED(lhs, rhs) do i = 1 , lhs % Ni lhs % U (:, i ) = rhs enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real~2.html","title":"euler_assign_real – FOODIE"},{"text":"private pure subroutine impose_boundary_conditions(self, primitive) Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Source Code impose_boundary_conditions Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~4.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Calls proc~~init~8~~CallsGraph proc~init~8 init weno_constructor_upwind weno_constructor_upwind proc~init~8->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~8.html","title":"init – FOODIE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Source Code reconstruct_interfaces_states Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo endselect !$OMP END PARALLEL return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~4.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Calls proc~~riemann_solver~4~~CallsGraph proc~riemann_solver~4 riemann_solver proc~e~4 E proc~riemann_solver~4->proc~e~4 proc~compute_inter_states~4 compute_inter_states proc~riemann_solver~4->proc~compute_inter_states~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code riemann_solver Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~4.html","title":"riemann_solver – FOODIE"},{"text":"subroutine init() Initialize the field. Arguments None Called By proc~~init~9~~CalledByGraph proc~init~9 init program~integrate_burgers integrate_burgers program~integrate_burgers->proc~init~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~9.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, filename) Save plots of results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Called By proc~~save_results~7~~CalledByGraph proc~save_results~7 save_results proc~test_ab test_ab proc~test_ab->proc~save_results~7 proc~test_ls_rk test_ls_rk proc~test_ls_rk->proc~save_results~7 proc~test_euler test_euler proc~test_euler->proc~save_results~7 proc~test_tvd_rk test_tvd_rk proc~test_tvd_rk->proc~save_results~7 proc~test_leapfrog test_leapfrog proc~test_leapfrog->proc~save_results~7 program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ab program~integrate_burgers->proc~test_ls_rk program~integrate_burgers->proc~test_euler program~integrate_burgers->proc~test_tvd_rk program~integrate_burgers->proc~test_leapfrog Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~7.html","title":"save_results – FOODIE"},{"text":"subroutine test_ab() Test explicit Adams-Bashforth class of ODE solvers. Arguments None Calls proc~~test_ab~~CallsGraph proc~test_ab test_ab str str proc~test_ab->str proc~save_results~7 save_results proc~test_ab->proc~save_results~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_ab~~CalledByGraph proc~test_ab test_ab program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ab Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_ab Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Test explicit forward Euler ODE solver. Arguments None Calls proc~~test_euler~~CallsGraph proc~test_euler test_euler proc~save_results~7 save_results proc~test_euler->proc~save_results~7 str str proc~test_euler->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_euler~~CalledByGraph proc~test_euler test_euler program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_euler Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Test explicit leapfrog class of ODE solvers. Arguments None Calls proc~~test_leapfrog~~CallsGraph proc~test_leapfrog test_leapfrog proc~save_results~7 save_results proc~test_leapfrog->proc~save_results~7 str str proc~test_leapfrog->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~~CalledByGraph proc~test_leapfrog test_leapfrog program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_leapfrog Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_leapfrog Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Test explicit low storage Runge-Kutta class of ODE solvers. Arguments None Calls proc~~test_ls_rk~~CallsGraph proc~test_ls_rk test_ls_rk str str proc~test_ls_rk->str proc~save_results~7 save_results proc~test_ls_rk->proc~save_results~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~~CalledByGraph proc~test_ls_rk test_ls_rk program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_ls_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_ls_rk Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Arguments None Calls proc~~test_tvd_rk~~CallsGraph proc~test_tvd_rk test_tvd_rk str str proc~test_tvd_rk->str proc~save_results~7 save_results proc~test_tvd_rk->proc~save_results~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~~CalledByGraph proc~test_tvd_rk test_tvd_rk program~integrate_burgers integrate_burgers program~integrate_burgers->proc~test_tvd_rk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_tvd_rk Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk.html","title":"test_tvd_rk – FOODIE"},{"text":"private function add_burgers(lhs, rhs) result(opr) Add two Burgers fields. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code add_burgers Source Code function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers","tags":"","loc":"proc/add_burgers.html","title":"add_burgers – FOODIE"},{"text":"private function burgers_local_error(lhs, rhs) result(error) Estimate local truncation error between 2 burgers approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code burgers_local_error Source Code function burgers_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 burgers approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_local_error","tags":"","loc":"proc/burgers_local_error.html","title":"burgers_local_error – FOODIE"},{"text":"private function burgers_multiply_burgers(lhs, rhs) result(opr) Multiply a Burgers field by another one. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code burgers_multiply_burgers Source Code function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers","tags":"","loc":"proc/burgers_multiply_burgers.html","title":"burgers_multiply_burgers – FOODIE"},{"text":"private function burgers_multiply_real(lhs, rhs) result(opr) Multiply a Burgers field by a real scalar. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code burgers_multiply_real Source Code function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real","tags":"","loc":"proc/burgers_multiply_real.html","title":"burgers_multiply_real – FOODIE"},{"text":"private pure function compute_dt(self, CFL) result(dt) Compute the current time step, by means of CFL condition. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Source Code compute_dt Source Code pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~5.html","title":"compute_dt – FOODIE"},{"text":"private function d2Burgers_dx2(self) result(derivative) Compute the second order spatial derivative of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative.","tags":"","loc":"proc/d2burgers_dx2.html","title":"d2Burgers_dx2 – FOODIE"},{"text":"private function dBurgers_dt(self, t) result(dState_dt) Time derivative of Burgers field, residuals function. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Burgers field time derivative. Source Code dBurgers_dt Source Code function dBurgers_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx () * self % nu dState_dt = dState_dt - self * self % x () endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt","tags":"","loc":"proc/dburgers_dt.html","title":"dBurgers_dt – FOODIE"},{"text":"private function dBurgers_dx(self) result(derivative) Compute the first order spatial derivative of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative.","tags":"","loc":"proc/dburgers_dx.html","title":"dBurgers_dx – FOODIE"},{"text":"private pure function output(self) result(state) Output the Burgers field state. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Source Code output Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~5.html","title":"output – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Extract previous time solution of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Burgers field. Source Code previous_step Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step.html","title":"previous_step – FOODIE"},{"text":"private function real_multiply_burgers(lhs, rhs) result(opr) Multiply a real scalar by a Burgers field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code real_multiply_burgers Source Code function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers","tags":"","loc":"proc/real_multiply_burgers.html","title":"real_multiply_burgers – FOODIE"},{"text":"private function sub_burgers(lhs, rhs) result(opr) Subtract two Burgers fields. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code sub_burgers Source Code function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers","tags":"","loc":"proc/sub_burgers.html","title":"sub_burgers – FOODIE"},{"text":"private subroutine burgers_assign_burgers(lhs, rhs) Assign one Burgers field to another. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Source Code burgers_assign_burgers Source Code subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers","tags":"","loc":"proc/burgers_assign_burgers.html","title":"burgers_assign_burgers – FOODIE"},{"text":"private subroutine burgers_assign_real(lhs, rhs) Assign one real to a Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code burgers_assign_real Source Code subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real","tags":"","loc":"proc/burgers_assign_real.html","title":"burgers_assign_real – FOODIE"},{"text":"private subroutine init(self, initial_state, Ni, h, nu, steps) Construct an initialized Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Source Code init Source Code subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~10.html","title":"init – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Source Code update_previous_steps Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps.html","title":"update_previous_steps – FOODIE"},{"text":"subroutine average_solution() Average the solution over an average grid. Arguments None Called By proc~~average_solution~~CalledByGraph proc~average_solution average_solution proc~save_results~8 save_results proc~save_results~8->proc~average_solution proc~test_leapfrog~2 test_leapfrog proc~test_leapfrog~2->proc~save_results~8 proc~test_tvd_rk~2 test_tvd_rk proc~test_tvd_rk~2->proc~save_results~8 proc~test_ab~2 test_ab proc~test_ab~2->proc~save_results~8 proc~test_ls_rk~2 test_ls_rk proc~test_ls_rk~2->proc~save_results~8 proc~test_euler~2 test_euler proc~test_euler~2->proc~save_results~8 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_leapfrog~2 program~integrate_euler_1d->proc~test_tvd_rk~2 program~integrate_euler_1d->proc~test_ab~2 program~integrate_euler_1d->proc~test_ls_rk~2 program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code average_solution Source Code subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution","tags":"","loc":"proc/average_solution.html","title":"average_solution – FOODIE"},{"text":"subroutine init() Initialize the field. Arguments None Calls proc~~init~11~~CallsGraph proc~init~11 init str str proc~init~11->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~init~11~~CalledByGraph proc~init~11 init program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~init~11 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str ( s ,. true .)) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str ( s ,. true .)) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~11.html","title":"init – FOODIE"},{"text":"subroutine save_results(title, basename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output basename. Calls proc~~save_results~8~~CallsGraph proc~save_results~8 save_results str str proc~save_results~8->str proc~average_solution average_solution proc~save_results~8->proc~average_solution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_results~8~~CalledByGraph proc~save_results~8 save_results proc~test_leapfrog~2 test_leapfrog proc~test_leapfrog~2->proc~save_results~8 proc~test_tvd_rk~2 test_tvd_rk proc~test_tvd_rk~2->proc~save_results~8 proc~test_ab~2 test_ab proc~test_ab~2->proc~save_results~8 proc~test_ls_rk~2 test_ls_rk proc~test_ls_rk~2->proc~save_results~8 proc~test_euler~2 test_euler proc~test_euler~2->proc~save_results~8 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_leapfrog~2 program~integrate_euler_1d->proc~test_tvd_rk~2 program~integrate_euler_1d->proc~test_ab~2 program~integrate_euler_1d->proc~test_ls_rk~2 program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str ( Ni ,. true .)) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str ( Ni ,. true .)) // ' cells\", I=' // trim ( str ( Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 1 ,. true .)) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str ( Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str ( Ni ,. true .)) // ' to av_Ni: ' // trim ( str ( av_Ni ,. true .)) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str ( Ni ,. true .)) // ' cells averaged over ' // trim ( str ( av_Ni ,. true .)) // & ' cells\", I=' // trim ( str ( av_Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 1 ,. true .)) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str ( av_Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str ( av_Ni ,. true .)) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str ( v ,. true .)) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str ( Ni ,. true .)) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~8.html","title":"save_results – FOODIE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Calls proc~~save_time_serie~5~~CallsGraph proc~save_time_serie~5 save_time_serie str str proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~save_time_serie~5~~CalledByGraph proc~save_time_serie~5 save_time_serie proc~test_leapfrog~2 test_leapfrog proc~test_leapfrog~2->proc~save_time_serie~5 proc~test_tvd_rk~2 test_tvd_rk proc~test_tvd_rk~2->proc~save_time_serie~5 proc~test_ab~2 test_ab proc~test_ab~2->proc~save_time_serie~5 proc~test_ls_rk~2 test_ls_rk proc~test_ls_rk~2->proc~save_time_serie~5 proc~test_euler~2 test_euler proc~test_euler~2->proc~save_time_serie~5 program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_leapfrog~2 program~integrate_euler_1d->proc~test_tvd_rk~2 program~integrate_euler_1d->proc~test_ab~2 program~integrate_euler_1d->proc~test_ls_rk~2 program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_time_serie Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str ( Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 2 ,. true .)) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str ( Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~5.html","title":"save_time_serie – FOODIE"},{"text":"subroutine test_ab() Test explicit Adams-Bashforth class of ODE solvers. Arguments None Calls proc~~test_ab~2~~CallsGraph proc~test_ab~2 test_ab str str proc~test_ab~2->str proc~save_results~8 save_results proc~test_ab~2->proc~save_results~8 proc~save_time_serie~5 save_time_serie proc~test_ab~2->proc~save_time_serie~5 proc~save_results~8->str proc~average_solution average_solution proc~save_results~8->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_ab~2~~CalledByGraph proc~test_ab~2 test_ab program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ab~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_ab Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~2.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Test explicit forward Euler ODE solver. Arguments None Calls proc~~test_euler~2~~CallsGraph proc~test_euler~2 test_euler str str proc~test_euler~2->str proc~save_results~8 save_results proc~test_euler~2->proc~save_results~8 proc~save_time_serie~5 save_time_serie proc~test_euler~2->proc~save_time_serie~5 proc~save_results~8->str proc~average_solution average_solution proc~save_results~8->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_euler~2~~CalledByGraph proc~test_euler~2 test_euler program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_euler~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_euler Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~2.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Test explicit leapfrog class of ODE solvers. Arguments None Calls proc~~test_leapfrog~2~~CallsGraph proc~test_leapfrog~2 test_leapfrog str str proc~test_leapfrog~2->str proc~save_results~8 save_results proc~test_leapfrog~2->proc~save_results~8 proc~save_time_serie~5 save_time_serie proc~test_leapfrog~2->proc~save_time_serie~5 proc~save_results~8->str proc~average_solution average_solution proc~save_results~8->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~2~~CalledByGraph proc~test_leapfrog~2 test_leapfrog program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_leapfrog~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_leapfrog Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~2.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Test explicit low storage Runge-Kutta class of ODE solvers. Arguments None Calls proc~~test_ls_rk~2~~CallsGraph proc~test_ls_rk~2 test_ls_rk str str proc~test_ls_rk~2->str proc~save_results~8 save_results proc~test_ls_rk~2->proc~save_results~8 proc~save_time_serie~5 save_time_serie proc~test_ls_rk~2->proc~save_time_serie~5 proc~save_results~8->str proc~average_solution average_solution proc~save_results~8->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~2~~CalledByGraph proc~test_ls_rk~2 test_ls_rk program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_ls_rk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_ls_rk Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~2.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Arguments None Calls proc~~test_tvd_rk~2~~CallsGraph proc~test_tvd_rk~2 test_tvd_rk str str proc~test_tvd_rk~2->str proc~save_results~8 save_results proc~test_tvd_rk~2->proc~save_results~8 proc~save_time_serie~5 save_time_serie proc~test_tvd_rk~2->proc~save_time_serie~5 proc~save_results~8->str proc~average_solution average_solution proc~save_results~8->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~2~~CalledByGraph proc~test_tvd_rk~2 test_tvd_rk program~integrate_euler_1d integrate_euler_1D program~integrate_euler_1d->proc~test_tvd_rk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_tvd_rk Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~2.html","title":"test_tvd_rk – FOODIE"},{"text":"private elemental function E(p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Called By proc~~e~5~~CalledByGraph proc~e~5 E proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->proc~e~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code E Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~5.html","title":"E – FOODIE"},{"text":"private elemental function H(p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Source Code H Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~5.html","title":"H – FOODIE"},{"text":"private elemental function a(p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Called By proc~~a~5~~CalledByGraph proc~a~5 a proc~compute_dt~6 compute_dt proc~compute_dt~6->proc~a~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code a Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~5.html","title":"a – FOODIE"},{"text":"private function add_euler(lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code add_euler Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler~3.html","title":"add_euler – FOODIE"},{"text":"private pure function compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Calls proc~~compute_dt~6~~CallsGraph proc~compute_dt~6 compute_dt proc~a~5 a proc~compute_dt~6->proc~a~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_dt Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~6.html","title":"compute_dt – FOODIE"},{"text":"private pure function conservative2primitive(self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Source Code conservative2primitive Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~5.html","title":"conservative2primitive – FOODIE"},{"text":"private function dEuler_dt(self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. Calls proc~~deuler_dt~5~~CallsGraph proc~deuler_dt~5 dEuler_dt u u proc~deuler_dt~5->u Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code dEuler_dt Source Code function dEuler_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~5.html","title":"dEuler_dt – FOODIE"},{"text":"private function euler_local_error(lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code euler_local_error Source Code function euler_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 euler approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: j !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) error = 0._R_P do i = 1 , lhs % Ni do j = 1 , lhs % Nc error = error + ( lhs % U ( j , i ) - rhs % U ( j , i )) ** 2 / lhs % U ( j , i ) ** 2 enddo enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_local_error","tags":"","loc":"proc/euler_local_error~3.html","title":"euler_local_error – FOODIE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_euler Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler~3.html","title":"euler_multiply_euler – FOODIE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code euler_multiply_real Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real~3.html","title":"euler_multiply_real – FOODIE"},{"text":"private pure function output(self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Source Code output Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~6.html","title":"output – FOODIE"},{"text":"private elemental function p(r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Source Code p Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~5.html","title":"p – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Extract previous time solution of Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Euler field. Source Code previous_step Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~2.html","title":"previous_step – FOODIE"},{"text":"private pure function primitive2conservative(self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Source Code primitive2conservative Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~5.html","title":"primitive2conservative – FOODIE"},{"text":"private elemental function r(p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Source Code r Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~5.html","title":"r – FOODIE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code real_multiply_euler Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler~3.html","title":"real_multiply_euler – FOODIE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code sub_euler Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler~3.html","title":"sub_euler – FOODIE"},{"text":"private pure subroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Called By proc~~compute_inter_states~5~~CalledByGraph proc~compute_inter_states~5 compute_inter_states proc~riemann_solver~5 riemann_solver proc~riemann_solver~5->proc~compute_inter_states~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compute_inter_states Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~5.html","title":"compute_inter_states – FOODIE"},{"text":"private pure subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. Source Code destroy Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~18.html","title":"destroy – FOODIE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Source Code euler_assign_euler Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~5.html","title":"euler_assign_euler – FOODIE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code euler_assign_real Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real~3.html","title":"euler_assign_real – FOODIE"},{"text":"private pure subroutine impose_boundary_conditions(self, primitive) Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Source Code impose_boundary_conditions Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~5.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Calls proc~~init~12~~CallsGraph proc~init~12 init weno_constructor_upwind weno_constructor_upwind proc~init~12->weno_constructor_upwind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code init Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~12.html","title":"init – FOODIE"},{"text":"private pure subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Source Code reconstruct_interfaces_states Source Code pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~5.html","title":"reconstruct_interfaces_states – FOODIE"},{"text":"private pure subroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Calls proc~~riemann_solver~5~~CallsGraph proc~riemann_solver~5 riemann_solver proc~compute_inter_states~5 compute_inter_states proc~riemann_solver~5->proc~compute_inter_states~5 proc~e~5 E proc~riemann_solver~5->proc~e~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code riemann_solver Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~5.html","title":"riemann_solver – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Source Code update_previous_steps Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~2.html","title":"update_previous_steps – FOODIE"},{"text":"subroutine save_results(title, filename) Save plots of results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Called By proc~~save_results~9~~CalledByGraph proc~save_results~9 save_results proc~test_ab~3 test_ab proc~test_ab~3->proc~save_results~9 proc~test_tvd_rk~3 test_tvd_rk proc~test_tvd_rk~3->proc~save_results~9 proc~test_leapfrog~3 test_leapfrog proc~test_leapfrog~3->proc~save_results~9 proc~test_ls_rk~3 test_ls_rk proc~test_ls_rk~3->proc~save_results~9 proc~test_euler~3 test_euler proc~test_euler~3->proc~save_results~9 program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ab~3 program~integrate_lorenz->proc~test_tvd_rk~3 program~integrate_lorenz->proc~test_leapfrog~3 program~integrate_lorenz->proc~test_ls_rk~3 program~integrate_lorenz->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code save_results Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~9.html","title":"save_results – FOODIE"},{"text":"subroutine test_ab() Test explicit Adams-Bashforth class of ODE solvers. Arguments None Calls proc~~test_ab~3~~CallsGraph proc~test_ab~3 test_ab str str proc~test_ab~3->str proc~save_results~9 save_results proc~test_ab~3->proc~save_results~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_ab~3~~CalledByGraph proc~test_ab~3 test_ab program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ab~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_ab Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~3.html","title":"test_ab – FOODIE"},{"text":"subroutine test_euler() Test explicit forward Euler ODE solver. Arguments None Calls proc~~test_euler~3~~CallsGraph proc~test_euler~3 test_euler proc~save_results~9 save_results proc~test_euler~3->proc~save_results~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_euler~3~~CalledByGraph proc~test_euler~3 test_euler program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_euler~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_euler Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~3.html","title":"test_euler – FOODIE"},{"text":"subroutine test_leapfrog() Test explicit leapfrog class of ODE solvers. Arguments None Calls proc~~test_leapfrog~3~~CallsGraph proc~test_leapfrog~3 test_leapfrog proc~save_results~9 save_results proc~test_leapfrog~3->proc~save_results~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_leapfrog~3~~CalledByGraph proc~test_leapfrog~3 test_leapfrog program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_leapfrog~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_leapfrog Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~3.html","title":"test_leapfrog – FOODIE"},{"text":"subroutine test_ls_rk() Test explicit low storage Runge-Kutta class of ODE solvers. Arguments None Calls proc~~test_ls_rk~3~~CallsGraph proc~test_ls_rk~3 test_ls_rk str str proc~test_ls_rk~3->str proc~save_results~9 save_results proc~test_ls_rk~3->proc~save_results~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_ls_rk~3~~CalledByGraph proc~test_ls_rk~3 test_ls_rk program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_ls_rk~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_ls_rk Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~3.html","title":"test_ls_rk – FOODIE"},{"text":"subroutine test_tvd_rk() Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Arguments None Calls proc~~test_tvd_rk~3~~CallsGraph proc~test_tvd_rk~3 test_tvd_rk str str proc~test_tvd_rk~3->str proc~save_results~9 save_results proc~test_tvd_rk~3->proc~save_results~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~test_tvd_rk~3~~CalledByGraph proc~test_tvd_rk~3 test_tvd_rk program~integrate_lorenz integrate_lorenz program~integrate_lorenz->proc~test_tvd_rk~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code test_tvd_rk Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~3.html","title":"test_tvd_rk – FOODIE"},{"text":"private function add_lorenz(lhs, rhs) result(opr) Add two Lorenz fields. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code add_lorenz Source Code function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz","tags":"","loc":"proc/add_lorenz.html","title":"add_lorenz – FOODIE"},{"text":"private function dLorenz_dt(self, t) result(dState_dt) Time derivative of Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Lorenz field time derivative. Source Code dLorenz_dt Source Code function dLorenz_dt ( self , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt","tags":"","loc":"proc/dlorenz_dt.html","title":"dLorenz_dt – FOODIE"},{"text":"private function lorenz_local_error(lhs, rhs) result(error) Estimate local truncation error between 2 lorenz approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code lorenz_local_error Source Code function lorenz_local_error ( lhs , rhs ) result ( error ) !--------------------------------------------------------------------------------------------------------------------------------- !< Estimate local truncation error between 2 lorenz approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) error = 0._R_P do i = 1 , lhs % dims error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_local_error","tags":"","loc":"proc/lorenz_local_error.html","title":"lorenz_local_error – FOODIE"},{"text":"private function lorenz_multiply_lorenz(lhs, rhs) result(opr) Multiply a lorenz field by another one. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code lorenz_multiply_lorenz Source Code function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz","tags":"","loc":"proc/lorenz_multiply_lorenz.html","title":"lorenz_multiply_lorenz – FOODIE"},{"text":"private function lorenz_multiply_real(lhs, rhs) result(opr) Multiply a Lorenz field by a real scalar. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code lorenz_multiply_real Source Code function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real","tags":"","loc":"proc/lorenz_multiply_real.html","title":"lorenz_multiply_real – FOODIE"},{"text":"private pure function output(self) result(state) Output the Lorenz field state. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Source Code output Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~7.html","title":"output – FOODIE"},{"text":"private function previous_step(self, n) result(previous) Extract previous time solution of Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Lorenz field. Source Code previous_step Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~3.html","title":"previous_step – FOODIE"},{"text":"private function real_multiply_lorenz(lhs, rhs) result(opr) Multiply a real scalar by a Lorenz field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code real_multiply_lorenz Source Code function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz","tags":"","loc":"proc/real_multiply_lorenz.html","title":"real_multiply_lorenz – FOODIE"},{"text":"private function sub_lorenz(lhs, rhs) result(opr) Subtract two Lorenz fields. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Source Code sub_lorenz Source Code function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz","tags":"","loc":"proc/sub_lorenz.html","title":"sub_lorenz – FOODIE"},{"text":"private subroutine init(self, initial_state, sigma, rho, beta, steps) Construct an initialized Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Source Code init Source Code subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~13.html","title":"init – FOODIE"},{"text":"private subroutine lorenz_assign_lorenz(lhs, rhs) Assign one Lorenz field to another. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Source Code lorenz_assign_lorenz Source Code subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz","tags":"","loc":"proc/lorenz_assign_lorenz.html","title":"lorenz_assign_lorenz – FOODIE"},{"text":"private subroutine lorenz_assign_real(lhs, rhs) Assign one real to a Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code lorenz_assign_real Source Code subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real","tags":"","loc":"proc/lorenz_assign_real.html","title":"lorenz_assign_real – FOODIE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Source Code update_previous_steps Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~3.html","title":"update_previous_steps – FOODIE"},{"text":"private pure function compute_dt(self, final_time, t) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: final_time Maximum integration time. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P) Time step. Source Code compute_dt Source Code pure function compute_dt ( self , final_time , t ) result ( Dt ) !< Compute the current time step by means of CFL condition. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ) :: final_time !< Maximum integration time. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ) :: Dt !< Time step. associate ( a => self % a , Dx => self % Dx , CFL => self % CFL ) Dt = Dx * CFL / abs ( a ) if ( present ( t )) then if (( t + Dt ) > final_time ) Dt = final_time - t endif endassociate endfunction compute_dt","tags":"","loc":"proc/compute_dt~7.html","title":"compute_dt – FOODIE"},{"text":"private pure function compute_dx(self, Dt) result(Dx) Compute the space step step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: Dt Time step. Return Value real(kind=R_P) Space step. Source Code compute_dx Source Code pure function compute_dx ( self , Dt ) result ( Dx ) !< Compute the space step step by means of CFL condition. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ) :: Dx !< Space step. associate ( a => self % a , CFL => self % CFL ) Dx = Dt / CFL * abs ( a ) endassociate endfunction compute_dx","tags":"","loc":"proc/compute_dx.html","title":"compute_dx – FOODIE"},{"text":"private function dU_dt(self, t) result(dState_dt) Time derivative of advection field, the residuals function. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable,(:) Advection field time derivative. Source Code dU_dt Source Code function dU_dt ( self , t ) result ( dState_dt ) !< Time derivative of advection field, the residuals function. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), allocatable :: dState_dt (:) !< Advection field time derivative. real ( R_P ) :: u ( 1 - self % Ng : self % Ni + self % Ng ) !< Conservative variable. real ( R_P ) :: ur ( 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed conservative variable. real ( R_P ) :: f ( 0 : self % Ni ) !< Flux of conservative variable. integer ( I_P ) :: i !< Counter. do i = 1 , self % Ni u ( i ) = self % u ( i ) enddo call self % impose_boundary_conditions ( u = u ) call self % reconstruct_interfaces ( conservative = u , r_conservative = ur ) do i = 0 , self % Ni call solve_riemann_problem ( state_left = ur ( 2 , i ), state_right = ur ( 1 , i + 1 ), flux = f ( i )) enddo allocate ( dState_dt ( 1 : self % Ni )) do i = 1 , self % Ni dState_dt ( i ) = ( f ( i - 1 ) - f ( i )) / self % Dx enddo contains subroutine solve_riemann_problem ( state_left , state_right , flux ) !< Solver Riemann problem of linear advection by upwinding. real ( R_P ), intent ( in ) :: state_left !< Left state. real ( R_P ), intent ( in ) :: state_right !< right state. real ( R_P ), intent ( out ) :: flux !< Flux of conservative variable. if ( self % a > 0._R_P ) then flux = self % a * state_left else flux = self % a * state_right endif endsubroutine solve_riemann_problem endfunction dU_dt","tags":"","loc":"proc/du_dt.html","title":"dU_dt – FOODIE"},{"text":"private pure function description(self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~2~~CallsGraph proc~description~2 description strz strz proc~description~2->strz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrand_ladvection ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix // 'linear_advection-' // trim ( self % initial_state ) // '-Ni_' // trim ( strz ( self % Ni , 10 )) endfunction description","tags":"","loc":"proc/description~2.html","title":"description – FOODIE"},{"text":"private pure function error(self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Error. Source Code error Source Code pure function error ( self , t , t0 , U0 ) !< Return error. class ( integrand_ladvection ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: error (:) !< Error. integer ( I_P ) :: i !< Counter. allocate ( error ( 1 : 1 )) error = 0._R_P if ( present ( U0 )) then select type ( U0 ) type is ( integrand_ladvection ) do i = 1 , self % Ni error = error + ( U0 % u ( i ) - self % u ( i )) ** 2 enddo endselect error = self % Dx * sqrt ( error ) endif endfunction error","tags":"","loc":"proc/error.html","title":"error – FOODIE"},{"text":"private pure function exact_solution(self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Exact solution. Source Code exact_solution Source Code pure function exact_solution ( self , t , t0 , U0 ) result ( exact ) !< Return exact solution. class ( integrand_ladvection ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: exact (:) !< Exact solution. integer ( I_P ) :: offset !< Cells offset. integer ( I_P ) :: i !< Counter. allocate ( exact ( 1 : self % Ni )) if ( present ( U0 )) then select type ( U0 ) type is ( integrand_ladvection ) offset = nint ( mod ( self % a * t , self % length ) / self % Dx ) do i = 1 , self % Ni - offset exact ( i + offset ) = U0 % u ( i ) enddo do i = self % Ni - offset + 1 , self % Ni exact ( i - self % Ni + offset ) = U0 % u ( i ) enddo endselect else exact = self % u ( 1 : self % Ni ) * 0._R_P endif endfunction exact_solution","tags":"","loc":"proc/exact_solution.html","title":"exact_solution – FOODIE"},{"text":"private pure function integrand_add_integrand(lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_add_integrand Source Code pure function integrand_add_integrand ( lhs , rhs ) result ( opr ) !< `+` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_ladvection ) opr = lhs % u + rhs % u endselect endfunction integrand_add_integrand","tags":"","loc":"proc/integrand_add_integrand.html","title":"integrand_add_integrand – FOODIE"},{"text":"private pure function integrand_add_real(lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_add_real Source Code pure function integrand_add_real ( lhs , rhs ) result ( opr ) !< `+ real` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % u + rhs endfunction integrand_add_real","tags":"","loc":"proc/integrand_add_real.html","title":"integrand_add_real – FOODIE"},{"text":"private pure function integrand_dimension(self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. Source Code integrand_dimension Source Code pure function integrand_dimension ( self ) !< return integrand dimension. class ( integrand_ladvection ), intent ( in ) :: self !< integrand. integer ( I_P ) :: integrand_dimension !< integrand dimension. integrand_dimension = self % Ni endfunction integrand_dimension","tags":"","loc":"proc/integrand_dimension.html","title":"integrand_dimension – FOODIE"},{"text":"private pure function integrand_multiply_integrand(lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_integrand Source Code pure function integrand_multiply_integrand ( lhs , rhs ) result ( opr ) !< `*` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_ladvection ) opr = lhs % U * rhs % U endselect endfunction integrand_multiply_integrand","tags":"","loc":"proc/integrand_multiply_integrand.html","title":"integrand_multiply_integrand – FOODIE"},{"text":"private pure function integrand_multiply_real(lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_real Source Code pure function integrand_multiply_real ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real","tags":"","loc":"proc/integrand_multiply_real.html","title":"integrand_multiply_real – FOODIE"},{"text":"private pure function integrand_multiply_real_scalar(lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_real_scalar Source Code pure function integrand_multiply_real_scalar ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real_scalar","tags":"","loc":"proc/integrand_multiply_real_scalar.html","title":"integrand_multiply_real_scalar – FOODIE"},{"text":"private pure function integrand_sub_integrand(lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_sub_integrand Source Code pure function integrand_sub_integrand ( lhs , rhs ) result ( opr ) !< `-` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_ladvection ) opr = lhs % U - rhs % U endselect endfunction integrand_sub_integrand","tags":"","loc":"proc/integrand_sub_integrand.html","title":"integrand_sub_integrand – FOODIE"},{"text":"private pure function integrand_sub_real(lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_sub_real Source Code pure function integrand_sub_real ( lhs , rhs ) result ( opr ) !< `- real` operator. class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U - rhs endfunction integrand_sub_real","tags":"","loc":"proc/integrand_sub_real.html","title":"integrand_sub_real – FOODIE"},{"text":"private function local_error(lhs, rhs) result(error) Estimate local truncation error between 2 advection approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%u_i - rhs\\%u_i)&#94;2}{lhs\\%u_i&#94;2} }} }  Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code local_error Source Code function local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 advection approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{\\sum_i{ \\frac{(lhs\\%u_i - rhs\\%u_i)&#94;2}{lhs\\%u_i&#94;2} }} }  class ( integrand_ladvection ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. select type ( rhs ) class is ( integrand_ladvection ) error = 0._R_P do i = 1 , lhs % Ni error = error + ( lhs % u ( i ) - rhs % u ( i )) ** 2 enddo error = sqrt ( error ) endselect endfunction local_error","tags":"","loc":"proc/local_error.html","title":"local_error – FOODIE"},{"text":"private pure function output(self) result(state) Output the advection field state. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. Return Value real(kind=R_P),\n  allocatable,(:) Advection state Source Code output Source Code pure function output ( self ) result ( state ) !< Output the advection field state. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), allocatable :: state (:) !< Advection state state = self % u ( 1 : self % Ni ) endfunction output","tags":"","loc":"proc/output~8.html","title":"output – FOODIE"},{"text":"private pure function real_add_integrand(lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_add_integrand Source Code pure function real_add_integrand ( lhs , rhs ) result ( opr ) !< `real +` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_ladvection ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs + rhs % U endfunction real_add_integrand","tags":"","loc":"proc/real_add_integrand.html","title":"real_add_integrand – FOODIE"},{"text":"private pure function real_multiply_integrand(lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_multiply_integrand Source Code pure function real_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. class ( integrand_ladvection ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_multiply_integrand","tags":"","loc":"proc/real_multiply_integrand.html","title":"real_multiply_integrand – FOODIE"},{"text":"private pure function real_scalar_multiply_integrand(lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_ladvection ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_scalar_multiply_integrand Source Code pure function real_scalar_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( integrand_ladvection ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_scalar_multiply_integrand","tags":"","loc":"proc/real_scalar_multiply_integrand.html","title":"real_scalar_multiply_integrand – FOODIE"},{"text":"private pure function real_sub_integrand(lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_sub_integrand Source Code pure function real_sub_integrand ( lhs , rhs ) result ( opr ) !< `real -` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_ladvection ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs - rhs % U endfunction real_sub_integrand","tags":"","loc":"proc/real_sub_integrand.html","title":"real_sub_integrand – FOODIE"},{"text":"private subroutine assign_integrand(lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code assign_integrand Source Code subroutine assign_integrand ( lhs , rhs ) !< `=` operator. class ( integrand_ladvection ), intent ( inout ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( integrand_ladvection ) lhs % w_scheme = rhs % w_scheme lhs % weno_order = rhs % weno_order lhs % weno_eps = rhs % weno_eps lhs % CFL = rhs % CFL lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % length = rhs % length lhs % Dx = rhs % Dx lhs % a = rhs % a if ( allocated ( rhs % u )) then lhs % u = rhs % u else if ( allocated ( lhs % u )) deallocate ( lhs % u ) endif if ( allocated ( rhs % interpolator )) then if ( allocated ( lhs % interpolator )) then call lhs % interpolator % destroy deallocate ( lhs % interpolator ) endif allocate ( lhs % interpolator , mold = rhs % interpolator ) lhs % interpolator = rhs % interpolator else if ( allocated ( lhs % interpolator )) deallocate ( lhs % interpolator ) endif lhs % initial_state = rhs % initial_state endselect endsubroutine assign_integrand","tags":"","loc":"proc/assign_integrand.html","title":"assign_integrand – FOODIE"},{"text":"private pure subroutine assign_real(lhs, rhs) Assign one real to an advection field. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Source Code assign_real Source Code pure subroutine assign_real ( lhs , rhs ) !< Assign one real to an advection field. class ( integrand_ladvection ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. lhs % u = rhs endsubroutine assign_real","tags":"","loc":"proc/assign_real.html","title":"assign_real – FOODIE"},{"text":"private subroutine destroy(self) Destroy field. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. Source Code destroy Source Code subroutine destroy ( self ) !< Destroy field. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. type ( integrand_ladvection ) :: fresh !< Fresh field to reset self. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~19.html","title":"destroy – FOODIE"},{"text":"private subroutine export_tecplot(self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Calls proc~~export_tecplot~~CallsGraph proc~export_tecplot export_tecplot str str proc~export_tecplot->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code export_tecplot Source Code subroutine export_tecplot ( self , file_name , t , scheme , close_file , with_exact_solution , U0 ) !< Export integrand to Tecplot file. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. character ( * ), intent ( in ), optional :: file_name !< File name. real ( R_P ), intent ( in ), optional :: t !< Time. character ( * ), intent ( in ), optional :: scheme !< Scheme used to integrate integrand. logical , intent ( in ), optional :: close_file !< Flag for closing file. logical , intent ( in ), optional :: with_exact_solution !< Flag for export also exact solution. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. logical :: with_exact_solution_ !< Flag for export also exact solution, local variable. logical , save :: is_open = . false . !< Flag for checking if file is open. integer ( I_P ), save :: file_unit !< File unit. real ( R_P ), allocatable :: exact_solution (:) !< Exact solution. integer ( I_P ) :: i !< Counter. if ( present ( close_file )) then if ( close_file . and . is_open ) then close ( unit = file_unit ) is_open = . false . endif else with_exact_solution_ = . false . ; if ( present ( with_exact_solution )) with_exact_solution_ = with_exact_solution if ( present ( file_name )) then if ( is_open ) close ( unit = file_unit ) open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) is_open = . true . write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"x\" \"u\"' endif if ( present ( t ) . and . present ( scheme ) . and . is_open ) then write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // str ( t ) // ' ' // trim ( adjustl ( scheme )) // '\"' do i = 1 , self % Ni write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) self % Dx * i - 0.5_R_P * self % Dx , self % u ( i ) enddo if ( with_exact_solution_ ) then exact_solution = self % exact_solution ( t = t , U0 = U0 ) write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // str ( t ) // ' exact solution\"' do i = 1 , self % Ni write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) self % Dx * i - 0.5_R_P * self % Dx , exact_solution ( i ) enddo endif endif endif endsubroutine export_tecplot","tags":"","loc":"proc/export_tecplot.html","title":"export_tecplot – FOODIE"},{"text":"private pure subroutine impose_boundary_conditions(self, u) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(inout) :: u (1-self%Ng:) Conservative variables. Source Code impose_boundary_conditions Source Code pure subroutine impose_boundary_conditions ( self , u ) !< Impose boundary conditions. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( inout ) :: u ( 1 - self % Ng :) !< Conservative variables. integer ( I_P ) :: i !< Space counter. do i = 1 - self % Ng , 0 u ( i ) = u ( self % Ni + i ) enddo do i = self % Ni + 1 , self % Ni + self % Ng u ( i ) = u ( i - self % Ni ) enddo endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~6.html","title":"impose_boundary_conditions – FOODIE"},{"text":"private subroutine initialize(self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. Source Code initialize Source Code subroutine initialize ( self , Dt ) !< Initialize integrand. class ( integrand_ladvection ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. self % Dx = self % compute_dx ( Dt = Dt ) self % Ni = nint ( self % length / self % Dx ) select case ( trim ( adjustl ( self % initial_state ))) case ( 'sin_wave' ) call self % set_sin_wave_initial_state case ( 'square_wave' ) call self % set_square_wave_initial_state endselect endsubroutine initialize","tags":"","loc":"proc/initialize~16.html","title":"initialize – FOODIE"},{"text":"private subroutine parse_cli(self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. Calls proc~~parse_cli~~CallsGraph proc~parse_cli parse_cli wenoof_create wenoof_create proc~parse_cli->wenoof_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parse_cli Source Code subroutine parse_cli ( self , cli ) !< Initialize from command line interface. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call self % destroy call cli % get ( group = 'linear_advection' , switch = '--cfl' , val = self % CFL , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--w-scheme' , val = self % w_scheme , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--weno-order' , val = self % weno_order , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--weno-eps' , val = self % weno_eps , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '-a' , val = self % a , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--length' , val = self % length , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '--Ni' , val = self % Ni , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'linear_advection' , switch = '-is' , val = self % initial_state , error = cli % error ) ; if ( cli % error /= 0 ) stop self % Ng = ( self % weno_order + 1 ) / 2 self % Dx = self % length / self % Ni if ( self % weno_order > 1 ) call wenoof_create ( interpolator_type = trim ( adjustl ( self % w_scheme )), & S = self % Ng , & interpolator = self % interpolator , & eps = self % weno_eps ) endsubroutine parse_cli","tags":"","loc":"proc/parse_cli.html","title":"parse_cli – FOODIE"},{"text":"private subroutine reconstruct_interfaces(self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: conservative (1-self%Ng:) Conservative variables. real(kind=R_P), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. Source Code reconstruct_interfaces Source Code subroutine reconstruct_interfaces ( self , conservative , r_conservative ) !< Reconstruct interfaces states. class ( integrand_ladvection ), intent ( in ) :: self !< Advection field. real ( R_P ), intent ( in ) :: conservative ( 1 - self % Ng :) !< Conservative variables. real ( R_P ), intent ( inout ) :: r_conservative ( 1 :, 0 :) !< Reconstructed conservative vars. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng ) !< Stencils. real ( R_P ) :: CR ( 1 : 2 ) !< Reconstrcuted intrafaces. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. select case ( self % weno_order ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , self % Ni + 1 r_conservative ( 1 , i ) = conservative ( i ) r_conservative ( 2 , i ) = r_conservative ( 1 , i ) enddo case ( 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 ) ! 3rd-17th order WENO reconstruction do i = 0 , self % Ni + 1 do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 C ( f , j - i ) = conservative ( j ) enddo enddo call self % interpolator % interpolate ( stencil = C (:, :), interpolation = CR (:)) do f = 1 , 2 r_conservative ( f , i ) = CR ( f ) enddo enddo endselect endsubroutine reconstruct_interfaces","tags":"","loc":"proc/reconstruct_interfaces.html","title":"reconstruct_interfaces – FOODIE"},{"text":"private subroutine set_cli(cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. Source Code set_cli Source Code subroutine set_cli ( cli ) !< Set command line interface. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % add_group ( description = 'linear advection test settings' , group = 'linear_advection' ) call cli % add ( group = 'linear_advection' , switch = '--w-scheme' , help = 'WENO scheme' , required = . false ., act = 'store' , & def = 'reconstructor-JS' , choices = 'reconstructor-JS,reconstructor-M-JS,reconstructor-M-Z,reconstructor-Z' ) call cli % add ( group = 'linear_advection' , switch = '--weno-order' , help = 'WENO order' , required = . false ., act = 'store' , def = '1' ) call cli % add ( group = 'linear_advection' , switch = '--weno-eps' , help = 'WENO epsilon parameter' , required = . false ., act = 'store' , & def = '0.000001' ) call cli % add ( group = 'linear_advection' , switch = '--cfl' , help = 'CFL value' , required = . false ., act = 'store' , def = '0.8' ) call cli % add ( group = 'linear_advection' , switch = '-a' , help = 'advection coefficient' , required = . false ., act = 'store' , def = '1.0' ) call cli % add ( group = 'linear_advection' , switch = '--length' , help = 'domain lenth' , required = . false ., act = 'store' , def = '1.0' ) call cli % add ( group = 'linear_advection' , switch = '--Ni' , help = 'number finite volumes used' , required = . false ., act = 'store' , & def = '100' ) call cli % add ( group = 'linear_advection' , switch = '--initial_state' , switch_ab = '-is' , help = 'initial state' , required = . false ., & act = 'store' , def = 'sin_wave' , choices = 'sin_wave,square_wave' ) endsubroutine set_cli","tags":"","loc":"proc/set_cli.html","title":"set_cli – FOODIE"},{"text":"private subroutine set_sin_wave_initial_state(self) Set initial state as a sin wave. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. Source Code set_sin_wave_initial_state Source Code subroutine set_sin_wave_initial_state ( self ) !< Set initial state as a sin wave. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. real ( R_P ) :: x !< Cell center x-abscissa values. real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. if ( allocated ( self % u )) deallocate ( self % u ) ; allocate ( self % u ( 1 : self % Ni )) do i = 1 , self % Ni x = self % Dx * i - 0.5_R_P * self % Dx self % u ( i ) = sin ( x * 2 * pi ) enddo endsubroutine set_sin_wave_initial_state","tags":"","loc":"proc/set_sin_wave_initial_state.html","title":"set_sin_wave_initial_state – FOODIE"},{"text":"private subroutine set_square_wave_initial_state(self) Set initial state as a square wave. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. Source Code set_square_wave_initial_state Source Code subroutine set_square_wave_initial_state ( self ) !< Set initial state as a square wave. class ( integrand_ladvection ), intent ( inout ) :: self !< Advection field. real ( R_P ) :: x !< Cell center x-abscissa values. integer ( I_P ) :: i !< Space counter. if ( allocated ( self % u )) deallocate ( self % u ) ; allocate ( self % u ( 1 : self % Ni )) do i = 1 , self % Ni x = self % Dx * i - 0.5_R_P * self % Dx if ( x < 0.25_R_P ) then self % u ( i ) = 0._R_P elseif ( 0.25_R_P <= x . and . x < 0.75_R_P ) then self % u ( i ) = 1._R_P else self % u ( i ) = 0._R_P endif enddo endsubroutine set_square_wave_initial_state","tags":"","loc":"proc/set_square_wave_initial_state.html","title":"set_square_wave_initial_state – FOODIE"},{"text":"private pure function dU_dt(self, t) result(dState_dt) Time derivative of field. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable,(:) Integrand time derivative. Source Code dU_dt Source Code pure function dU_dt ( self , t ) result ( dState_dt ) !< Time derivative of field. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), allocatable :: dState_dt (:) !< Integrand time derivative. dState_dt = [ self % a * self % U + self % b ] endfunction dU_dt","tags":"","loc":"proc/du_dt~2.html","title":"dU_dt – FOODIE"},{"text":"private pure function description(self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix // 'linear_constant_coefficients_eq' endfunction description","tags":"","loc":"proc/description~3.html","title":"description – FOODIE"},{"text":"private pure function error(self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Error. Source Code error Source Code pure function error ( self , t , t0 , U0 ) !< Return error. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: error (:) !< Error. allocate ( error ( 1 : 1 )) error = abs ([ self % U ] - self % exact_solution ( t = t , t0 = t0 )) endfunction error","tags":"","loc":"proc/error~2.html","title":"error – FOODIE"},{"text":"private pure function exact_solution(self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Exact solution. Source Code exact_solution Source Code pure function exact_solution ( self , t , t0 , U0 ) result ( exact ) !< Return exact solution. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: exact (:) !< Exact solution. real ( R_P ) :: t0_ !< Initial time, local variable. allocate ( exact ( 1 : 1 )) t0_ = 0._R_P ; if ( present ( t0 )) t0_ = t0 exact ( 1 ) = ( self % U0 + self % b / self % a ) * exp ( self % a * ( t - t0_ )) - self % b / self % a endfunction exact_solution","tags":"","loc":"proc/exact_solution~2.html","title":"exact_solution – FOODIE"},{"text":"private pure function integrand_add_integrand(lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_add_integrand Source Code pure function integrand_add_integrand ( lhs , rhs ) result ( opr ) !< `+` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_lcce ) opr = [ lhs % U + rhs % U ] endselect endfunction integrand_add_integrand","tags":"","loc":"proc/integrand_add_integrand~2.html","title":"integrand_add_integrand – FOODIE"},{"text":"private pure function integrand_add_real(lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_add_real Source Code pure function integrand_add_real ( lhs , rhs ) result ( opr ) !< `+ real` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U + rhs ( 1 )] endfunction integrand_add_real","tags":"","loc":"proc/integrand_add_real~2.html","title":"integrand_add_real – FOODIE"},{"text":"private pure function integrand_dimension(self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. Source Code integrand_dimension Source Code pure function integrand_dimension ( self ) !< return integrand dimension. class ( integrand_lcce ), intent ( in ) :: self !< integrand. integer ( I_P ) :: integrand_dimension !< integrand dimension. integrand_dimension = 1 endfunction integrand_dimension","tags":"","loc":"proc/integrand_dimension~2.html","title":"integrand_dimension – FOODIE"},{"text":"private pure function integrand_multiply_integrand(lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_integrand Source Code pure function integrand_multiply_integrand ( lhs , rhs ) result ( opr ) !< `*` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_lcce ) opr = [ lhs % U * rhs % U ] endselect endfunction integrand_multiply_integrand","tags":"","loc":"proc/integrand_multiply_integrand~2.html","title":"integrand_multiply_integrand – FOODIE"},{"text":"private pure function integrand_multiply_real(lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_real Source Code pure function integrand_multiply_real ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U * rhs ( 1 )] endfunction integrand_multiply_real","tags":"","loc":"proc/integrand_multiply_real~2.html","title":"integrand_multiply_real – FOODIE"},{"text":"private pure function integrand_multiply_real_scalar(lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_real_scalar Source Code pure function integrand_multiply_real_scalar ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U * rhs ] endfunction integrand_multiply_real_scalar","tags":"","loc":"proc/integrand_multiply_real_scalar~2.html","title":"integrand_multiply_real_scalar – FOODIE"},{"text":"private pure function integrand_sub_integrand(lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_sub_integrand Source Code pure function integrand_sub_integrand ( lhs , rhs ) result ( opr ) !< `-` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_lcce ) opr = [ lhs % U - rhs % U ] endselect endfunction integrand_sub_integrand","tags":"","loc":"proc/integrand_sub_integrand~2.html","title":"integrand_sub_integrand – FOODIE"},{"text":"private pure function integrand_sub_real(lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_sub_real Source Code pure function integrand_sub_real ( lhs , rhs ) result ( opr ) !< `- real` operator. class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs % U - rhs ( 1 )] endfunction integrand_sub_real","tags":"","loc":"proc/integrand_sub_real~2.html","title":"integrand_sub_real – FOODIE"},{"text":"private pure function local_error(lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\frac{(lhs\\%U - rhs\\%U)&#94;2}{U&#94;2 } }  Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code local_error Source Code pure function local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\frac{(lhs\\%U - rhs\\%U)&#94;2}{U&#94;2 } }  class ( integrand_lcce ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. select type ( rhs ) class is ( integrand_lcce ) if ( lhs % U /= 0._R_P ) then error = sqrt ((( lhs % U - rhs % U ) ** 2 ) / lhs % U ** 2 ) elseif ( rhs % U /= 0._R_P ) then error = sqrt ((( lhs % U - rhs % U ) ** 2 ) / rhs % U ** 2 ) else error = 0._R_P endif endselect endfunction local_error","tags":"","loc":"proc/local_error~2.html","title":"local_error – FOODIE"},{"text":"private pure function output(self) result(state) Extract integrand state field. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. Return Value real(kind=R_P) State. Source Code output Source Code pure function output ( self ) result ( state ) !< Extract integrand state field. class ( integrand_lcce ), intent ( in ) :: self !< Integrand. real ( R_P ) :: state !< State. state = self % U endfunction output","tags":"","loc":"proc/output~9.html","title":"output – FOODIE"},{"text":"private pure function real_add_integrand(lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_add_integrand Source Code pure function real_add_integrand ( lhs , rhs ) result ( opr ) !< `real +` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_lcce ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs ( 1 ) + rhs % U ] endfunction real_add_integrand","tags":"","loc":"proc/real_add_integrand~2.html","title":"real_add_integrand – FOODIE"},{"text":"private pure function real_multiply_integrand(lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_multiply_integrand Source Code pure function real_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. class ( integrand_lcce ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs ( 1 ) * rhs % U ] endfunction real_multiply_integrand","tags":"","loc":"proc/real_multiply_integrand~2.html","title":"real_multiply_integrand – FOODIE"},{"text":"private pure function real_scalar_multiply_integrand(lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_lcce ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_scalar_multiply_integrand Source Code pure function real_scalar_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( integrand_lcce ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs * rhs % U ] endfunction real_scalar_multiply_integrand","tags":"","loc":"proc/real_scalar_multiply_integrand~2.html","title":"real_scalar_multiply_integrand – FOODIE"},{"text":"private pure function real_sub_integrand(lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_sub_integrand Source Code pure function real_sub_integrand ( lhs , rhs ) result ( opr ) !< `real -` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_lcce ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = [ lhs ( 1 ) - rhs % U ] endfunction real_sub_integrand","tags":"","loc":"proc/real_sub_integrand~2.html","title":"real_sub_integrand – FOODIE"},{"text":"private pure subroutine assign_integrand(lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code assign_integrand Source Code pure subroutine assign_integrand ( lhs , rhs ) !< `=` operator. class ( integrand_lcce ), intent ( inout ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( integrand_lcce ) lhs % a = rhs % a lhs % b = rhs % b lhs % U = rhs % U lhs % U0 = rhs % U0 endselect endsubroutine assign_integrand","tags":"","loc":"proc/assign_integrand~2.html","title":"assign_integrand – FOODIE"},{"text":"private pure subroutine assign_real(lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Source Code assign_real Source Code pure subroutine assign_real ( lhs , rhs ) !< `= real` operator. class ( integrand_lcce ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. lhs % U = rhs ( 1 ) endsubroutine assign_real","tags":"","loc":"proc/assign_real~2.html","title":"assign_real – FOODIE"},{"text":"private subroutine export_tecplot(self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Source Code export_tecplot Source Code subroutine export_tecplot ( self , file_name , t , scheme , close_file , with_exact_solution , U0 ) !< Export integrand to Tecplot file. class ( integrand_lcce ), intent ( in ) :: self !< Advection field. character ( * ), intent ( in ), optional :: file_name !< File name. real ( R_P ), intent ( in ), optional :: t !< Time. character ( * ), intent ( in ), optional :: scheme !< Scheme used to integrate integrand. logical , intent ( in ), optional :: close_file !< Flag for closing file. logical , intent ( in ), optional :: with_exact_solution !< Flag for export also exact solution. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. logical :: with_exact_solution_ !< Flag for export also exact solution, local variable. logical , save :: is_open = . false . !< Flag for checking if file is open. integer ( I_P ), save :: file_unit !< File unit. if ( present ( close_file )) then if ( close_file . and . is_open ) then close ( unit = file_unit ) is_open = . false . endif else with_exact_solution_ = . false . ; if ( present ( with_exact_solution )) with_exact_solution_ = with_exact_solution if ( present ( file_name )) then if ( is_open ) close ( unit = file_unit ) open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) is_open = . true . if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\" \"x_exact\"' else write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\"' endif endif if ( present ( t ) . and . present ( scheme ) . and . is_open ) then write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(3(' // FR_P // ',1X))' ) t , self % U , self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) t , self % U endif elseif ( present ( t ) . and . is_open ) then if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(3(' // FR_P // ',1X))' ) t , self % U , self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(2(' // FR_P // ',1X))' ) t , self % U endif endif endif endsubroutine export_tecplot","tags":"","loc":"proc/export_tecplot~2.html","title":"export_tecplot – FOODIE"},{"text":"private pure subroutine initialize(self, Dt) Initialize integrand. Intentionally empty, all is done in parse_cli method. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. Source Code initialize Source Code pure subroutine initialize ( self , Dt ) !< Initialize integrand. !< !< Intentionally empty, all is done in `parse_cli` method. class ( integrand_lcce ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. endsubroutine initialize","tags":"","loc":"proc/initialize~17.html","title":"initialize – FOODIE"},{"text":"private pure subroutine integrand_add_integrand_fast(opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_add_integrand_fast Source Code pure subroutine integrand_add_integrand_fast ( opr , lhs , rhs ) !< `+` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) select type ( rhs ) class is ( integrand_lcce ) opr % U = lhs % U + rhs % U endselect endselect endsubroutine integrand_add_integrand_fast","tags":"","loc":"proc/integrand_add_integrand_fast~2.html","title":"integrand_add_integrand_fast – FOODIE"},{"text":"private pure subroutine integrand_multiply_integrand_fast(opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_multiply_integrand_fast Source Code pure subroutine integrand_multiply_integrand_fast ( opr , lhs , rhs ) !< `*` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) select type ( rhs ) class is ( integrand_lcce ) opr % U = lhs % U * rhs % U endselect endselect endsubroutine integrand_multiply_integrand_fast","tags":"","loc":"proc/integrand_multiply_integrand_fast~2.html","title":"integrand_multiply_integrand_fast – FOODIE"},{"text":"private pure subroutine integrand_multiply_real_scalar_fast(opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code integrand_multiply_real_scalar_fast Source Code pure subroutine integrand_multiply_real_scalar_fast ( opr , lhs , rhs ) !< `* real_scalar` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) opr % U = lhs % U * rhs endselect endsubroutine integrand_multiply_real_scalar_fast","tags":"","loc":"proc/integrand_multiply_real_scalar_fast~2.html","title":"integrand_multiply_real_scalar_fast – FOODIE"},{"text":"private pure subroutine integrand_subtract_integrand_fast(opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_subtract_integrand_fast Source Code pure subroutine integrand_subtract_integrand_fast ( opr , lhs , rhs ) !< `-` fast operator. class ( integrand_lcce ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_lcce ) select type ( rhs ) class is ( integrand_lcce ) opr % U = lhs % U - rhs % U endselect endselect endsubroutine integrand_subtract_integrand_fast","tags":"","loc":"proc/integrand_subtract_integrand_fast~2.html","title":"integrand_subtract_integrand_fast – FOODIE"},{"text":"private subroutine parse_cli(self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. Source Code parse_cli Source Code subroutine parse_cli ( self , cli ) !< Initialize from command line interface. class ( integrand_lcce ), intent ( inout ) :: self !< Advection field. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % get ( group = 'lcce' , switch = '-a' , val = self % a , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'lcce' , switch = '-b' , val = self % b , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'lcce' , switch = '-U0' , val = self % U0 , error = cli % error ) ; if ( cli % error /= 0 ) stop self % U = self % U0 endsubroutine parse_cli","tags":"","loc":"proc/parse_cli~2.html","title":"parse_cli – FOODIE"},{"text":"private subroutine set_cli(cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. Source Code set_cli Source Code subroutine set_cli ( cli ) !< Set command line interface. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % add_group ( description = 'linear constant coefficient equation test settings' , group = 'lcce' ) call cli % add ( group = 'lcce' , switch = '-a' , help = '\"a\" coeff of \"a * x + b\" equation' , required = . false ., def = '-1.0' , act = 'store' ) call cli % add ( group = 'lcce' , switch = '-b' , help = '\"b\" coeff of \"a * x + b\" equation' , required = . false ., def = '0.0' , act = 'store' ) call cli % add ( group = 'lcce' , switch = '-U0' , help = 'initial state' , required = . false ., def = '1.0' , act = 'store' ) endsubroutine set_cli","tags":"","loc":"proc/set_cli~2.html","title":"set_cli – FOODIE"},{"text":"private subroutine t_fast(self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Source Code t_fast Source Code subroutine t_fast ( self , t ) !< Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. class ( integrand_lcce ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ), optional :: t !< Time. self % U = self % a * self % U + self % b endsubroutine t_fast","tags":"","loc":"proc/t_fast~2.html","title":"t_fast – FOODIE"},{"text":"private function amplitude_phase(self) result(ap) Compute amplitude and phase of the oscillation. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Advection field. Return Value real(kind=R_P)\n  (1:2) Amplitude and phase. Source Code amplitude_phase Source Code function amplitude_phase ( self ) result ( ap ) !< Compute amplitude and phase of the oscillation. class ( integrand_oscillation ), intent ( in ) :: self !< Advection field. real ( R_P ) :: ap ( 1 : 2 ) !< Amplitude and phase. ap ( 1 ) = sqrt ( self % U ( 1 ) ** 2 + self % U ( 2 ) ** 2 ) ap ( 2 ) = atan ( - self % U ( 1 ) / self % U ( 2 )) endfunction amplitude_phase","tags":"","loc":"proc/amplitude_phase.html","title":"amplitude_phase – FOODIE"},{"text":"private pure function dU_dt(self, t) result(dState_dt) Time derivative of integrand_oscillation field. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable,(:) Integrand time derivative. Source Code dU_dt Source Code pure function dU_dt ( self , t ) result ( dState_dt ) !< Time derivative of integrand_oscillation field. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ), allocatable :: dState_dt (:) !< Integrand time derivative. dState_dt = [ - self % f * self % U ( 2 ), & self % f * self % U ( 1 )] endfunction dU_dt","tags":"","loc":"proc/du_dt~3.html","title":"dU_dt – FOODIE"},{"text":"private pure function description(self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return informative integrator description. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix // 'oscillation' endfunction description","tags":"","loc":"proc/description~4.html","title":"description – FOODIE"},{"text":"private pure function error(self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Error. Source Code error Source Code pure function error ( self , t , t0 , U0 ) !< Return error. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: error (:) !< Error. allocate ( error ( 1 : 2 )) error = abs ( self % U - self % exact_solution ( t = t )) endfunction error","tags":"","loc":"proc/error~3.html","title":"error – FOODIE"},{"text":"private pure function exact_solution(self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable,(:) Exact solution. Source Code exact_solution Source Code pure function exact_solution ( self , t , t0 , U0 ) result ( exact ) !< Return exact solution. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ), intent ( in ) :: t !< Time. real ( R_P ), intent ( in ), optional :: t0 !< Initial time. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. real ( R_P ), allocatable :: exact (:) !< Exact solution. exact = [ self % U0 ( 1 ) * cos ( self % f * t ) - self % U0 ( 2 ) * sin ( self % f * t ), & self % U0 ( 1 ) * sin ( self % f * t ) + self % U0 ( 2 ) * cos ( self % f * t )] endfunction exact_solution","tags":"","loc":"proc/exact_solution~3.html","title":"exact_solution – FOODIE"},{"text":"private pure function integrand_add_integrand(lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_add_integrand Source Code pure function integrand_add_integrand ( lhs , rhs ) result ( opr ) !< `+` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_oscillation ) opr = lhs % U + rhs % U endselect endfunction integrand_add_integrand","tags":"","loc":"proc/integrand_add_integrand~3.html","title":"integrand_add_integrand – FOODIE"},{"text":"private pure function integrand_add_real(lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_add_real Source Code pure function integrand_add_real ( lhs , rhs ) result ( opr ) !< `+ real` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U + rhs endfunction integrand_add_real","tags":"","loc":"proc/integrand_add_real~3.html","title":"integrand_add_real – FOODIE"},{"text":"private pure function integrand_dimension(self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. Source Code integrand_dimension Source Code pure function integrand_dimension ( self ) !< return integrand dimension. class ( integrand_oscillation ), intent ( in ) :: self !< integrand. integer ( I_P ) :: integrand_dimension !< integrand dimension. integrand_dimension = size ( self % U , dim = 1 ) endfunction integrand_dimension","tags":"","loc":"proc/integrand_dimension~3.html","title":"integrand_dimension – FOODIE"},{"text":"private pure function integrand_multiply_integrand(lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_integrand Source Code pure function integrand_multiply_integrand ( lhs , rhs ) result ( opr ) !< `*` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_oscillation ) opr = lhs % U * rhs % U endselect endfunction integrand_multiply_integrand","tags":"","loc":"proc/integrand_multiply_integrand~3.html","title":"integrand_multiply_integrand – FOODIE"},{"text":"private pure function integrand_multiply_real(lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_real Source Code pure function integrand_multiply_real ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real","tags":"","loc":"proc/integrand_multiply_real~3.html","title":"integrand_multiply_real – FOODIE"},{"text":"private pure function integrand_multiply_real_scalar(lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_multiply_real_scalar Source Code pure function integrand_multiply_real_scalar ( lhs , rhs ) result ( opr ) !< `* real_scalar` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U * rhs endfunction integrand_multiply_real_scalar","tags":"","loc":"proc/integrand_multiply_real_scalar~3.html","title":"integrand_multiply_real_scalar – FOODIE"},{"text":"private pure function integrand_sub_integrand(lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_sub_integrand Source Code pure function integrand_sub_integrand ( lhs , rhs ) result ( opr ) !< `-` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. select type ( rhs ) class is ( integrand_oscillation ) opr = lhs % U - rhs % U endselect endfunction integrand_sub_integrand","tags":"","loc":"proc/integrand_sub_integrand~3.html","title":"integrand_sub_integrand – FOODIE"},{"text":"private pure function integrand_sub_real(lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code integrand_sub_real Source Code pure function integrand_sub_real ( lhs , rhs ) result ( opr ) !< `- real` operator. class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs % U - rhs endfunction integrand_sub_real","tags":"","loc":"proc/integrand_sub_real~3.html","title":"integrand_sub_real – FOODIE"},{"text":"private pure function local_error(lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. The estimation is done by norm L2 of U:  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. Source Code local_error Source Code pure function local_error ( lhs , rhs ) result ( error ) !< Estimate local truncation error between 2 oscillation approximations. !< !< The estimation is done by norm L2 of U: !< !<  error = \\sqrt{ \\sum_i{ \\frac{(lhs\\%U_i - rhs\\%U_i)&#94;2}{lhs\\%U_i&#94;2} }}  class ( integrand_oscillation ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. real ( R_P ) :: error !< Error estimation. integer ( I_P ) :: i !< Space counter. select type ( rhs ) class is ( integrand_oscillation ) error = 0._R_P do i = 1 , size ( lhs % U , dim = 1 ) error = error + ( lhs % U ( i ) - rhs % U ( i )) ** 2 / lhs % U ( i ) ** 2 enddo error = sqrt ( error ) endselect endfunction local_error","tags":"","loc":"proc/local_error~3.html","title":"local_error – FOODIE"},{"text":"private pure function output(self) result(state) Extract integrand state field. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. Return Value real(kind=R_P)\n  (1:2) State. Source Code output Source Code pure function output ( self ) result ( state ) !< Extract integrand state field. class ( integrand_oscillation ), intent ( in ) :: self !< Integrand. real ( R_P ) :: state ( 1 : 2 ) !< State. state = self % U endfunction output","tags":"","loc":"proc/output~10.html","title":"output – FOODIE"},{"text":"private pure function real_add_integrand(lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_add_integrand Source Code pure function real_add_integrand ( lhs , rhs ) result ( opr ) !< `real +` operator. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. class ( integrand_oscillation ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs + rhs % U endfunction real_add_integrand","tags":"","loc":"proc/real_add_integrand~3.html","title":"real_add_integrand – FOODIE"},{"text":"private pure function real_multiply_integrand(lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_multiply_integrand Source Code pure function real_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. class ( integrand_oscillation ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_multiply_integrand","tags":"","loc":"proc/real_multiply_integrand~3.html","title":"real_multiply_integrand – FOODIE"},{"text":"private pure function real_scalar_multiply_integrand(lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_scalar_multiply_integrand Source Code pure function real_scalar_multiply_integrand ( lhs , rhs ) result ( opr ) !< `real_scalar *` operator. real ( R_P ), intent ( in ) :: lhs !< Left hand side. class ( integrand_oscillation ), intent ( in ) :: rhs !< Right hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs * rhs % U endfunction real_scalar_multiply_integrand","tags":"","loc":"proc/real_scalar_multiply_integrand~3.html","title":"real_scalar_multiply_integrand – FOODIE"},{"text":"private pure function real_sub_integrand(lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable,(:) Operator result. Source Code real_sub_integrand Source Code pure function real_sub_integrand ( lhs , rhs ) result ( opr ) !< `real -` operator. class ( integrand_oscillation ), intent ( in ) :: rhs !< Left hand side. real ( R_P ), intent ( in ) :: lhs ( 1 :) !< Left hand side. real ( R_P ), allocatable :: opr (:) !< Operator result. opr = lhs - rhs % U endfunction real_sub_integrand","tags":"","loc":"proc/real_sub_integrand~3.html","title":"real_sub_integrand – FOODIE"},{"text":"private pure subroutine assign_integrand(lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code assign_integrand Source Code pure subroutine assign_integrand ( lhs , rhs ) !< `=` operator. class ( integrand_oscillation ), intent ( inout ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( integrand_oscillation ) lhs % f = rhs % f lhs % U0 = rhs % U0 lhs % U = rhs % U endselect endsubroutine assign_integrand","tags":"","loc":"proc/assign_integrand~3.html","title":"assign_integrand – FOODIE"},{"text":"private pure subroutine assign_real(lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Source Code assign_real Source Code pure subroutine assign_real ( lhs , rhs ) !< `= real` operator. class ( integrand_oscillation ), intent ( inout ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs ( 1 :) !< Right hand side. lhs % U = rhs endsubroutine assign_real","tags":"","loc":"proc/assign_real~3.html","title":"assign_real – FOODIE"},{"text":"private subroutine export_tecplot(self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Source Code export_tecplot Source Code subroutine export_tecplot ( self , file_name , t , scheme , close_file , with_exact_solution , U0 ) !< Export integrand to Tecplot file. class ( integrand_oscillation ), intent ( in ) :: self !< Advection field. character ( * ), intent ( in ), optional :: file_name !< File name. real ( R_P ), intent ( in ), optional :: t !< Time. character ( * ), intent ( in ), optional :: scheme !< Scheme used to integrate integrand. logical , intent ( in ), optional :: close_file !< Flag for closing file. logical , intent ( in ), optional :: with_exact_solution !< Flag for export also exact solution. class ( integrand_object ), intent ( in ), optional :: U0 !< Initial conditions. logical :: with_exact_solution_ !< Flag for export also exact solution, local variable. logical , save :: is_open = . false . !< Flag for checking if file is open. integer ( I_P ), save :: file_unit !< File unit. if ( present ( close_file )) then if ( close_file . and . is_open ) then close ( unit = file_unit ) is_open = . false . endif else with_exact_solution_ = . false . ; if ( present ( with_exact_solution )) with_exact_solution_ = with_exact_solution if ( present ( file_name )) then if ( is_open ) close ( unit = file_unit ) open ( newunit = file_unit , file = trim ( adjustl ( file_name ))) is_open = . true . if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\" \"x_e\" \"y_e\"' else write ( unit = file_unit , fmt = '(A)' ) 'VARIABLES=\"t\" \"x\" \"y\" \"amplitude\" \"phase\"' endif endif if ( present ( t ) . and . present ( scheme ) . and . is_open ) then write ( unit = file_unit , fmt = '(A)' ) 'ZONE T=\"' // trim ( adjustl ( scheme )) // '\"' if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(7(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase (), self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(5(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase () endif elseif ( present ( t ) . and . is_open ) then if ( with_exact_solution_ ) then write ( unit = file_unit , fmt = '(7(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase (), self % exact_solution ( t = t ) else write ( unit = file_unit , fmt = '(5(' // FR_P // ',1X))' ) t , self % U , self % amplitude_phase () endif endif endif endsubroutine export_tecplot","tags":"","loc":"proc/export_tecplot~3.html","title":"export_tecplot – FOODIE"},{"text":"private pure subroutine initialize(self, Dt) Initialize integrand. Intentionally empty, all is done in parse_cli method. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. Source Code initialize Source Code pure subroutine initialize ( self , Dt ) !< Initialize integrand. !< !< Intentionally empty, all is done in `parse_cli` method. class ( integrand_oscillation ), intent ( inout ) :: self !< Integrand. real ( R_P ), intent ( in ) :: Dt !< Time step. endsubroutine initialize","tags":"","loc":"proc/initialize~18.html","title":"initialize – FOODIE"},{"text":"private pure subroutine integrand_add_integrand_fast(opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_add_integrand_fast Source Code pure subroutine integrand_add_integrand_fast ( opr , lhs , rhs ) !< `+` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) select type ( rhs ) class is ( integrand_oscillation ) opr % U = lhs % U + rhs % U endselect endselect endsubroutine integrand_add_integrand_fast","tags":"","loc":"proc/integrand_add_integrand_fast~3.html","title":"integrand_add_integrand_fast – FOODIE"},{"text":"private pure subroutine integrand_multiply_integrand_fast(opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_multiply_integrand_fast Source Code pure subroutine integrand_multiply_integrand_fast ( opr , lhs , rhs ) !< `*` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) select type ( rhs ) class is ( integrand_oscillation ) opr % U = lhs % U * rhs % U endselect endselect endsubroutine integrand_multiply_integrand_fast","tags":"","loc":"proc/integrand_multiply_integrand_fast~3.html","title":"integrand_multiply_integrand_fast – FOODIE"},{"text":"private pure subroutine integrand_multiply_real_scalar_fast(opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Source Code integrand_multiply_real_scalar_fast Source Code pure subroutine integrand_multiply_real_scalar_fast ( opr , lhs , rhs ) !< `* real_scalar` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. real ( R_P ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) opr % U = lhs % U * rhs endselect endsubroutine integrand_multiply_real_scalar_fast","tags":"","loc":"proc/integrand_multiply_real_scalar_fast~3.html","title":"integrand_multiply_real_scalar_fast – FOODIE"},{"text":"private pure subroutine integrand_subtract_integrand_fast(opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Source Code integrand_subtract_integrand_fast Source Code pure subroutine integrand_subtract_integrand_fast ( opr , lhs , rhs ) !< `-` fast operator. class ( integrand_oscillation ), intent ( inout ) :: opr !< Operator result. class ( integrand_object ), intent ( in ) :: lhs !< Left hand side. class ( integrand_object ), intent ( in ) :: rhs !< Right hand side. select type ( lhs ) class is ( integrand_oscillation ) select type ( rhs ) class is ( integrand_oscillation ) opr % U = lhs % U - rhs % U endselect endselect endsubroutine integrand_subtract_integrand_fast","tags":"","loc":"proc/integrand_subtract_integrand_fast~3.html","title":"integrand_subtract_integrand_fast – FOODIE"},{"text":"private subroutine parse_cli(self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. Source Code parse_cli Source Code subroutine parse_cli ( self , cli ) !< Initialize from command line interface. class ( integrand_oscillation ), intent ( inout ) :: self !< Advection field. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % get ( group = 'oscillation' , switch = '-f' , val = self % f , error = cli % error ) ; if ( cli % error /= 0 ) stop call cli % get ( group = 'oscillation' , switch = '-U0' , val = self % U0 , error = cli % error ) ; if ( cli % error /= 0 ) stop self % U = self % U0 endsubroutine parse_cli","tags":"","loc":"proc/parse_cli~3.html","title":"parse_cli – FOODIE"},{"text":"private subroutine set_cli(cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. Source Code set_cli Source Code subroutine set_cli ( cli ) !< Set command line interface. type ( command_line_interface ), intent ( inout ) :: cli !< Command line interface handler. call cli % add_group ( description = 'oscillation test settings' , group = 'oscillation' ) call cli % add ( group = 'oscillation' , switch = '--frequency' , switch_ab = '-f' , help = 'frequency' , required = . false ., def = '1e-4' , & act = 'store' ) call cli % add ( group = 'oscillation' , switch = '--U0' , switch_ab = '-U0' , nargs = '2' , help = 'initial state' , required = . false ., & def = '0.0 1.0' , act = 'store' ) endsubroutine set_cli","tags":"","loc":"proc/set_cli~3.html","title":"set_cli – FOODIE"},{"text":"private subroutine t_fast(self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time. Source Code t_fast Source Code subroutine t_fast ( self , t ) !< Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. class ( integrand_oscillation ), intent ( inout ) :: self !< Oscillation field. real ( R_P ), intent ( in ), optional :: t !< Time. real ( R_P ) :: buffer !< Temporary buffer. buffer = self % U ( 1 ) self % U ( 1 ) = - self % f * self % U ( 2 ) self % U ( 2 ) = self % f * buffer endsubroutine t_fast","tags":"","loc":"proc/t_fast~3.html","title":"t_fast – FOODIE"},{"text":"private pure function observed_order(error, Dt) Estimate the order of accuracy using 2 subsequent refined numerical solutions. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:,1:) Computed errors. real(kind=R_P), intent(in) :: Dt (1:) Time steps used. Return Value real(kind=R_P)\n  (1:size(error,dim=1)) Estimation of the order of accuracy. Called By proc~~observed_order~3~~CalledByGraph proc~observed_order~3 observed_order proc~execute~3 execute proc~execute~3->proc~observed_order~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code observed_order Source Code pure function observed_order ( error , Dt ) !< Estimate the order of accuracy using 2 subsequent refined numerical solutions. real ( R_P ), intent ( in ) :: error ( 1 :, 1 :) !< Computed errors. real ( R_P ), intent ( in ) :: Dt ( 1 :) !< Time steps used. real ( R_P ) :: observed_order ( 1 : size ( error , dim = 1 )) !< Estimation of the order of accuracy. integer ( I_P ) :: v !< Variables counter. do v = 1 , size ( error , dim = 1 ) observed_order ( v ) = log ( error ( v , 1 ) / error ( v , 2 )) / log ( Dt ( 1 ) / Dt ( 2 )) enddo endfunction observed_order","tags":"","loc":"proc/observed_order~3.html","title":"observed_order – FOODIE"},{"text":"private subroutine check_scheme_has_fast_mode(scheme, integrator) Check if a scheme support fast mode integrate. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Scheme name. class( integrator_object ), intent(in) :: integrator Integrator instance. Called By proc~~check_scheme_has_fast_mode~3~~CalledByGraph proc~check_scheme_has_fast_mode~3 check_scheme_has_fast_mode proc~integrate~16 integrate proc~integrate~16->proc~check_scheme_has_fast_mode~3 proc~execute~3 execute proc~execute~3->proc~integrate~16 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_scheme_has_fast_mode Source Code subroutine check_scheme_has_fast_mode ( scheme , integrator ) !< Check if a scheme support fast mode integrate. character ( * ), intent ( in ) :: scheme !< Scheme name. class ( integrator_object ), intent ( in ) :: integrator !< Integrator instance. if (. not . integrator % has_fast_mode ()) then write ( stderr , '(A)' ) 'error: ' // trim ( adjustl ( scheme )) // ' has not fast integrate mode!' stop endif endsubroutine check_scheme_has_fast_mode","tags":"","loc":"proc/check_scheme_has_fast_mode~3.html","title":"check_scheme_has_fast_mode – FOODIE"},{"text":"private subroutine execute(self) Execute test(s). Arguments Type Intent Optional Attributes Name class( test_object ), intent(inout) :: self Test. Calls proc~~execute~3~~CallsGraph proc~execute~3 execute proc~integrate~16 integrate proc~execute~3->proc~integrate~16 proc~is_available is_available proc~execute~3->proc~is_available str str proc~execute~3->str proc~is_class_available is_class_available proc~execute~3->proc~is_class_available proc~observed_order~3 observed_order proc~execute~3->proc~observed_order~3 proc~foodie_integrator_schemes foodie_integrator_schemes proc~execute~3->proc~foodie_integrator_schemes proc~foodie_integrator_factory foodie_integrator_factory proc~integrate~16->proc~foodie_integrator_factory strz strz proc~integrate~16->strz proc~check_scheme_has_fast_mode~3 check_scheme_has_fast_mode proc~integrate~16->proc~check_scheme_has_fast_mode~3 proc~is_available->proc~is_class_available proc~is_scheme_available is_scheme_available proc~is_available->proc~is_scheme_available proc~foodie_integrator_class_names foodie_integrator_class_names proc~is_class_available->proc~foodie_integrator_class_names supported_schemes supported_schemes proc~foodie_integrator_schemes->supported_schemes proc~is_scheme_available->proc~foodie_integrator_schemes class_name class_name proc~foodie_integrator_class_names->class_name var panprocexecute3CallsGraph = svgPanZoom('#procexecute3CallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code execute Source Code subroutine execute ( self ) !< Execute test(s). class ( test_object ), intent ( inout ) :: self !< Test. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. real ( R_P ), allocatable :: error (:,:) !< Error of integrand integration. real ( R_P ), allocatable :: order (:,:) !< Observed order of accuravy. integer ( I_P ) :: s !< Counter. integer ( I_P ) :: t !< Counter. call self % initialize if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if ( is_class_available ( scheme = self % scheme )) then integrator_schemes = foodie_integrator_schemes ( class_name = self % scheme ) elseif ( is_available ( scheme = self % scheme )) then integrator_schemes = [ trim ( adjustl ( self % scheme ))] endif else integrator_schemes = foodie_integrator_schemes () endif allocate ( error ( 1 : size ( self % integrand_0 % error ( t = 0._R_P ), dim = 1 ), 1 : size ( self % Dt , dim = 1 ))) if ( size ( self % Dt , dim = 1 ) > 1 ) allocate ( order ( 1 : size ( error , dim = 1 ), 1 : size ( error , dim = 2 ) - 1 )) do s = 1 , size ( integrator_schemes , dim = 1 ) print '(A)' , trim ( integrator_schemes ( s )) do t = 1 , size ( self % Dt ) call self % integrand_0 % initialize ( Dt = self % Dt ( t )) print '(A)' , self % integrand_0 % description () call integrate ( scheme = trim ( integrator_schemes ( s )), & integrand_0 = self % integrand_0 , & Dt = self % Dt ( t ), & final_time = self % final_time , & iterations = self % implicit_iterations , & stages = self % stages , & is_fast = self % is_fast , & save_results = self % save_results , & output_base_name = trim ( adjustl ( self % output )), & save_frequency = self % save_frequency , & error = error (:, t )) print * , 'Dt = ' , self % Dt ( t ), ', error = ' , error (:, t ) if ( t > 1 ) then order (:, t - 1 ) = observed_order ( error = error (:, t - 1 : t ), Dt = self % Dt ( t - 1 : t )) print '(A,' // trim ( str ( size ( order , dim = 1 ), no_sign = . true .)) // 'F6.2)' , ' Observed order =' , order (:, t - 1 ) endif enddo enddo endsubroutine execute","tags":"","loc":"proc/execute~3.html","title":"execute – FOODIE"},{"text":"private subroutine initialize(self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( test_object ), intent(inout) :: self Test. Source Code initialize Source Code subroutine initialize ( self ) !< Initialize test: set Command Line Interface, parse it and check its validity. class ( test_object ), intent ( inout ) :: self !< Test. call set_cli call parse_cli contains subroutine set_cli () !< Set Command Line Interface. associate ( cli => self % cli ) call cli % init ( progname = 'foodie_tester' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Tester factory of FOODIE integrators' , & examples = [ \"foodie_tester test --scheme euler_explicit --save_results  \" , & \"foodie_tester test --scheme all -r                         \" ]) call cli % add_group ( description = 'general test settings' , group = 'test' ) call cli % add ( group = 'test' , switch = '--scheme' , switch_ab = '-s' , help = 'integrator scheme used' , required = . false ., def = 'all' , & act = 'store' ) call cli % add ( group = 'test' , switch = '--time_step' , switch_ab = '-Dt' , nargs = '+' , help = 'time step' , required = . false ., & def = '1e2' , act = 'store' ) call cli % add ( group = 'test' , switch = '--fast' , help = 'activate fast solvers' , required = . false ., act = 'store_true' , & def = '.false.' ) call cli % add ( group = 'test' , switch = '--iterations' , help = 'iterations number for implicit schemes' , required = . false ., & act = 'store' , def = '5' ) call cli % add ( group = 'test' , switch = '--stages' , help = 'stages number' , required = . false ., def = '2' , act = 'store' ) call cli % add ( group = 'test' , switch = '--final_time' , switch_ab = '-ft' , help = 'integration time' , required = . false ., def = '1' , & act = 'store' ) call cli % add ( group = 'test' , switch = '--save_results' , switch_ab = '-r' , help = 'save result' , required = . false ., & act = 'store_true' , def = '.false.' ) call cli % add ( group = 'test' , switch = '--output' , help = 'output file basename' , required = . false ., act = 'store' , & def = 'foodie_test' ) call cli % add ( group = 'test' , switch = '--save_frequency' , help = 'save frequency' , required = . false ., act = 'store' , & def = '1' ) endassociate call self % lcce_0 % set_cli ( cli = self % cli ) call self % ladvection_0 % set_cli ( cli = self % cli ) call self % oscillation_0 % set_cli ( cli = self % cli ) endsubroutine set_cli subroutine parse_cli () !< Parse Command Line Interface and check its validity. character ( 99 ), allocatable :: integrator_class_names (:) !< Name of FOODIE integrator classes. character ( 99 ), allocatable :: integrator_schemes (:) !< Name of FOODIE integrator schemes. real ( R_P ), allocatable :: initial_state (:) !< Initial integrand state. integer ( I_P ) :: i !< Counter. call self % cli % parse ( error = self % error ) call self % cli % get ( group = 'test' , switch = '-s' , val = self % scheme , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get_varying ( group = 'test' , switch = '-Dt' , val = self % Dt , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--fast' , val = self % is_fast , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--iterations' , val = self % implicit_iterations , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--stages' , val = self % stages , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '-ft' , val = self % final_time , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '-r' , val = self % save_results , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--output' , val = self % output , error = self % error ) ; if ( self % error /= 0 ) stop call self % cli % get ( group = 'test' , switch = '--save_frequency' , val = self % save_frequency , error = self % error ) ; if ( self % error /= 0 ) stop call self % lcce_0 % parse_cli ( cli = self % cli ) call self % ladvection_0 % parse_cli ( cli = self % cli ) call self % oscillation_0 % parse_cli ( cli = self % cli ) if ( self % cli % run_command ( 'lcce' )) then allocate ( integrand_lcce :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_lcce ) integrand_0 = self % lcce_0 endselect elseif ( self % cli % run_command ( 'linear_advection' )) then allocate ( integrand_ladvection :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_ladvection ) integrand_0 = self % ladvection_0 endselect elseif ( self % cli % run_command ( 'oscillation' )) then allocate ( integrand_oscillation :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_oscillation ) integrand_0 = self % oscillation_0 endselect else allocate ( integrand_oscillation :: self % integrand_0 ) select type ( integrand_0 => self % integrand_0 ) type is ( integrand_oscillation ) integrand_0 = self % oscillation_0 endselect endif if (. not . is_dt_valid ()) then write ( stderr , '(A)' ) 'error: the final integration time must be an exact multiple of the time step used' write ( stderr , '(A)' ) '       and time step must respect CFL condition, if any' write ( stderr , '(A)' ) 'Final integration time: ' // str ( self % final_time , . true .) write ( stderr , '(A)' ) 'Time step: ' // str ( self % Dt , . true .) stop endif if ( trim ( adjustl ( self % scheme )) /= 'all' ) then if (. not . is_available ( scheme = self % scheme )) then integrator_class_names = foodie_integrator_class_names () integrator_schemes = foodie_integrator_schemes () write ( stderr , '(A)' ) 'error: the scheme \"' // trim ( adjustl ( self % scheme )) // '\" is unknown!' write ( stderr , '(A)' ) 'Supported classes of schemes are:' do i = 1 , size ( integrator_class_names , dim = 1 ) write ( stderr , '(A)' ) '  ' // trim ( integrator_class_names ( i )) enddo write ( stderr , '(A)' ) 'Supported schemes are:' do i = 1 , size ( integrator_schemes , dim = 1 ) write ( stderr , '(A)' ) '  ' // trim ( integrator_schemes ( i )) enddo stop endif endif endsubroutine parse_cli function is_dt_valid () !< Verify if the selected time step Dt is valid. logical :: is_dt_valid !< Return true is the selected time step Dt is valid. integer ( I_P ) :: t !< Counter. is_dt_valid = . true . do t = 1 , size ( self % Dt ) is_dt_valid = (( self % final_time - int ( self % final_time / self % Dt ( t ), I_P ) * self % Dt ( t )) == 0 ) ! if (is_dt_valid) then !    select type(integrand=>self%integrand_0) !    type is(integrand_ladvection) !       is_dt_valid = is_dt_valid .and. self%Dt(t) <= integrand%Dt(final_time=self%final_time) !       if (.not.is_dt_valid) then !          write(stderr, '(A)') 'error: Dt violates CFL condition, Dt_max = '//str(integrand%Dt(final_time=self%final_time)) !       endif !    endselect ! endif if (. not . is_dt_valid ) exit enddo endfunction is_dt_valid endsubroutine initialize","tags":"","loc":"proc/initialize~19.html","title":"initialize – FOODIE"},{"text":"private subroutine integrate(scheme, integrand_0, Dt, final_time, iterations, stages, is_fast, save_results, output_base_name, save_frequency, error) Integrate integrand by means of the given scheme. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected scheme. class( integrand_tester_object ), intent(in) :: integrand_0 Initial conditions. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: final_time Final integration time. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. integer(kind=I_P), intent(in) :: stages Number of stages. logical, intent(in) :: is_fast Activate fast mode integration. logical, intent(in) :: save_results Save results. character(len=*), intent(in) :: output_base_name Base name of output results file. integer(kind=I_P), intent(in) :: save_frequency Save frequency. real(kind=R_P), intent(out) :: error (:) Error of integrand integration. Calls proc~~integrate~16~~CallsGraph proc~integrate~16 integrate proc~foodie_integrator_factory foodie_integrator_factory proc~integrate~16->proc~foodie_integrator_factory strz strz proc~integrate~16->strz proc~check_scheme_has_fast_mode~3 check_scheme_has_fast_mode proc~integrate~16->proc~check_scheme_has_fast_mode~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~integrate~16~~CalledByGraph proc~integrate~16 integrate proc~execute~3 execute proc~execute~3->proc~integrate~16 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code integrate Source Code subroutine integrate ( scheme , integrand_0 , Dt , final_time , iterations , stages , is_fast , save_results , output_base_name , & save_frequency , error ) !< Integrate integrand by means of the given scheme. character ( * ), intent ( in ) :: scheme !< Selected scheme. class ( integrand_tester_object ), intent ( in ) :: integrand_0 !< Initial conditions. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( in ) :: final_time !< Final integration time. integer ( I_P ), intent ( in ) :: iterations !< Number of fixed point iterations. integer ( I_P ), intent ( in ) :: stages !< Number of stages. logical , intent ( in ) :: is_fast !< Activate fast mode integration. logical , intent ( in ) :: save_results !< Save results. character ( * ), intent ( in ) :: output_base_name !< Base name of output results file. integer ( I_P ), intent ( in ) :: save_frequency !< Save frequency. real ( R_P ), intent ( out ) :: error (:) !< Error of integrand integration. real ( R_P ), allocatable :: error_ (:) !< Error of integrand integration. class ( integrand_tester_object ) , allocatable :: integrand !< Integrand. class ( integrator_object ), allocatable :: integrator !< The integrator. real ( R_P ) :: time !< Time. integer ( I_P ) :: step !< Time steps counter. allocate ( integrand , mold = integrand_0 ) ; integrand = integrand_0 call foodie_integrator_factory ( scheme = scheme , integrator = integrator , stages = stages , & tolerance = 1 e2_R_P , iterations = iterations , autoupdate = . true ., U = integrand_0 ) if ( is_fast ) call check_scheme_has_fast_mode ( scheme = trim ( adjustl ( scheme )), integrator = integrator ) step = 0 time = 0._R_P if ( save_results ) call integrand % export_tecplot ( file_name = output_base_name // & integrand % description ( prefix = '-' ) // & integrator % description ( prefix = '-' ) // & '-steps_' // trim ( strz ( int ( final_time / Dt ), 10 )) // '.dat' , & t = time , & scheme = scheme , & with_exact_solution = . true ., & U0 = integrand_0 ) select type ( integrator ) class is ( integrator_multistage_object ) do step = step + 1 if ( is_fast ) then call integrator % integrate_fast ( U = integrand , Dt = Dt , t = time ) else call integrator % integrate ( U = integrand , Dt = Dt , t = time ) endif time = time + Dt if (( time >= final_time )) exit call integrand_export_tecplot enddo class is ( integrator_multistep_object ) do step = step + 1 if ( integrator % steps_number () >= step ) then time = time + Dt integrator % Dt ( step ) = Dt integrator % t ( step ) = time integrator % previous ( step ) = integrand % exact_solution ( t = time , U0 = integrand_0 ) integrand = integrator % previous ( step ) else if ( is_fast ) then call integrator % integrate_fast ( U = integrand , Dt = Dt , t = time ) else call integrator % integrate ( U = integrand , Dt = Dt , t = time ) endif time = time + Dt endif if (( time >= final_time )) exit call integrand_export_tecplot enddo class is ( integrator_multistage_multistep_object ) do step = step + 1 if ( integrator % steps_number () >= step ) then time = time + Dt integrator % Dt ( step ) = Dt integrator % t ( step ) = time integrator % previous ( step ) = integrand % exact_solution ( t = time , U0 = integrand_0 ) integrand = integrator % previous ( step ) else if ( is_fast ) then call integrator % integrate_fast ( U = integrand , Dt = Dt , t = time ) else call integrator % integrate ( U = integrand , Dt = Dt , t = time ) endif time = time + Dt endif if (( time >= final_time )) exit call integrand_export_tecplot enddo endselect call integrand_close_tecplot error_ = integrand % error ( t = time , U0 = integrand_0 ) error (:) = error_ (:) contains subroutine integrand_close_tecplot !< Close current integrand tecplot file. select type ( integrand ) type is ( integrand_ladvection ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , scheme = scheme ) type is ( integrand_oscillation ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time ) endselect if ( save_results ) call integrand % export_tecplot ( close_file = . true .) endsubroutine integrand_close_tecplot subroutine integrand_export_tecplot !< Export current integrand solution to tecplot file. select type ( integrand ) type is ( integrand_lcce ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , with_exact_solution = . true .) type is ( integrand_ladvection ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , scheme = scheme ) type is ( integrand_oscillation ) if ( save_results . and . mod ( step , save_frequency ) == 0 ) call integrand % export_tecplot ( t = time , with_exact_solution = . true .) endselect endsubroutine integrand_export_tecplot endsubroutine integrate","tags":"","loc":"proc/integrate~16.html","title":"integrate – FOODIE"},{"text":"Uses: iso_fortran_env foodie_error_codes foodie_integrand_object foodie_integrator_object foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_moulton foodie_integrator_backward_differentiation_formula foodie_integrator_euler_explicit foodie_integrator_leapfrog foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp_vss foodie_integrator_ms_runge_kutta_ssp foodie_integrator_multistage_object foodie_integrator_multistage_multistep_object foodie_integrator_multistep_object foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_ssp penf module~~foodie~~UsesGraph module~foodie foodie module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmodulefoodieUsesGraph = svgPanZoom('#modulefoodieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE, Fortran Object oriented Ordinary Differential Equations integration library. FOODIE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODIE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided:\n see FOODIE home page for more details about available integrators. Usage FOODIE schemes must be applied to only subclass extensions of the abstract class integrand . To use FOODIE you must: extend integrand abstract class provided by FOODIE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand_object ) :: lorenz !< Lorenz equations field. !< !< It is a FOODIE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. ... endtype lorenz use one of the provided FOODIE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : integrator_euler_explicit use type_lorenz , only : lorenz type ( integrator_euler_explicit ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo Used By module~~foodie~~UsedByGraph module~foodie foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodieUsedByGraph = svgPanZoom('#modulefoodieUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions foodie_integrator_class_names foodie_integrator_schemes is_available is_class_available is_scheme_available Subroutines foodie_integrator_factory Functions public pure function foodie_integrator_class_names () result(names) Return the list of available intergrator class of schemes names. Arguments None Return Value character(len=99),\n  allocatable, (:) Available integrator class names. public pure function foodie_integrator_schemes (class_name) result(schemes) Return the list of all available intergrator schemes, or only the schemes belonging to the given class name. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: class_name Return only the schemes belogn to the given class. Return Value character(len=99),\n  allocatable, (:) Available integrators. public pure function is_available (scheme) Return .true. if the given scheme (or class of schemes name) is available in the FOODIE library. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. Return Value logical Availability result. public pure function is_class_available (scheme) Return .true. if the given class of schemes name is available. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. Return Value logical Availability result. public pure function is_scheme_available (scheme) Return .true. if the given scheme (class name) is available in the FOODIE library. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. Return Value logical Availability result. Subroutines public subroutine foodie_integrator_factory (scheme, integrator, stages, tolerance, nu, alpha, iterations, autoupdate, U) Return a concrete instance of integrator_object given a scheme selection. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected integrator given. class( integrator_object ), intent(out), allocatable :: integrator The FOODIE integrator. integer(kind=I_P), intent(in), optional :: stages Stages of multi-stage methods. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate for multistep. class( integrand_object ), intent(in), optional :: U Integrand molding prototype.","tags":"","loc":"module/foodie.html","title":"foodie – FOODIE"},{"text":"Uses: penf module~~foodie_error_codes~~UsesGraph module~foodie_error_codes foodie_error_codes penf penf penf->module~foodie_error_codes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE error codes list. Used By module~~foodie_error_codes~~UsedByGraph module~foodie_error_codes foodie_error_codes module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie foodie module~foodie_error_codes->module~foodie module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_error_codesUsedByGraph = svgPanZoom('#modulefoodie_error_codesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables ERROR_UNSUPPORTED_SCHEME Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, parameter :: ERROR_UNSUPPORTED_SCHEME = 1 Error unsupported scheme.","tags":"","loc":"module/foodie_error_codes.html","title":"foodie_error_codes – FOODIE"},{"text":"Uses: penf module~~foodie_integrand_object~~UsesGraph module~foodie_integrand_object foodie_integrand_object penf penf penf->module~foodie_integrand_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract type integrand for building FOODIE ODE integrators. Used By module~~foodie_integrand_object~~UsedByGraph module~foodie_integrand_object foodie_integrand_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie foodie module~foodie_integrand_object->module~foodie module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrand_objectUsedByGraph = svgPanZoom('#modulefoodie_integrand_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces assignment_integrand assignment_real integrand_dimension_interface integrand_op_real integrand_op_real_scalar local_error_operator real_op_integrand real_scalar_op_integrand symmetric_operator time_derivative Derived Types integrand_object Subroutines integrand_add_integrand_fast integrand_multiply_integrand_fast integrand_multiply_real_scalar_fast integrand_subtract_integrand_fast t_fast Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private subroutine assignment_integrand (lhs, rhs) Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure subroutine assignment_real (lhs, rhs) Symmetric assignment integrand = integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function integrand_dimension_interface (self) result(integrand_dimension) Return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand. Return Value integer(kind=I_P) Integrand dimension. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function integrand_op_real (lhs, rhs) result(operator_result) Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function integrand_op_real_scalar (lhs, rhs) result(operator_result) Asymmetric type operator integrand.op.real . Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private function local_error_operator (lhs, rhs) result(error) Estimate local truncation error between 2 solution approximations. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function real_op_integrand (lhs, rhs) result(operator_result) Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function real_scalar_op_integrand (lhs, rhs) result(operator_result) Asymmetric type operator real.op.integrand . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private pure function symmetric_operator (lhs, rhs) result(operator_result) Symmetric type operator integrand.op.integrand. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of integrand_object . private function time_derivative (self, t) result(dState_dt) Time derivative function of integrand class, i.e. the residuals function. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Result of the time derivative function of integrand field. Derived Types type, public, abstract :: integrand_object Abstract type for building FOODIE ODE integrators. Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. procedure(assignment_integrand), public, pass(lhs) :: assign_integrand = operator. procedure(assignment_real), public, pass(lhs) :: assign_real = real operator. generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. procedure(symmetric_operator), public, pass(lhs) :: integrand_add_integrand + operator. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. procedure(integrand_op_real), public, pass(lhs) :: integrand_add_real + real operator. procedure(integrand_dimension_interface), public, pass(self) :: integrand_dimension Return integrand dimension. procedure(symmetric_operator), public, pass(lhs) :: integrand_multiply_integrand * operator. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. procedure(integrand_op_real), public, pass(lhs) :: integrand_multiply_real * real operator. procedure(integrand_op_real_scalar), public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. procedure(symmetric_operator), public, pass(lhs) :: integrand_sub_integrand - operator. procedure(integrand_op_real), public, pass(lhs) :: integrand_sub_real - real operator. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. procedure(local_error_operator), public, pass(lhs) :: local_error ||integrand - integrand|| operator. generic, public :: multiply_fast => integrand_multiply_integrand_fast, integrand_multiply_real_scalar_fast Overloading multiply_fast method. generic, public :: operator(*) => integrand_multiply_integrand, integrand_multiply_real, real_multiply_integrand, integrand_multiply_real_scalar, real_scalar_multiply_integrand Overloading * operator. generic, public :: operator(+) => integrand_add_integrand, integrand_add_real, real_add_integrand Overloading + operator. generic, public :: operator(-) => integrand_sub_integrand, integrand_sub_real, real_sub_integrand Overloading - operator. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. procedure(real_op_integrand), public, pass(rhs) :: real_add_integrand real + operator. procedure(real_op_integrand), public, pass(rhs) :: real_multiply_integrand real * operator. procedure(real_scalar_op_integrand), public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. procedure(real_op_integrand), public, pass(rhs) :: real_sub_integrand real - operator. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. procedure(time_derivative), public, pass(self) :: t Time derivative, residuals. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. Subroutines private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(inout) :: self Integrand field. real(kind=R_P), intent(in), optional :: t Time.","tags":"","loc":"module/foodie_integrand_object.html","title":"foodie_integrand_object – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistep_object foodie_integrator_object penf module~~foodie_integrator_adams_bashforth~~UsesGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth penf penf penf->module~foodie_integrator_adams_bashforth penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistep_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistep_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistep_object var panmodulefoodie_integrator_adams_bashforthUsesGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforthUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s}{ b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [1, 16] . Note that the scheme using only 1 step reverts\n to Explicit Forward Euler. The formal order of accuracy varies consistently in [1st, 16th] order. Bibliography [1] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr.,\n G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [2] Linear multistep method , wikipedia article . Used By module~~foodie_integrator_adams_bashforth~~UsedByGraph module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_bashforthUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforthUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_adams_bashforth Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'adams_bashforth' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:16) = [trim(class_name_)//'_1 ', trim(class_name_)//'_2 ', trim(class_name_)//'_3 ', trim(class_name_)//'_4 ', trim(class_name_)//'_5 ', trim(class_name_)//'_6 ', trim(class_name_)//'_7 ', trim(class_name_)//'_8 ', trim(class_name_)//'_9 ', trim(class_name_)//'_10', trim(class_name_)//'_11', trim(class_name_)//'_12', trim(class_name_)//'_13', trim(class_name_)//'_14', trim(class_name_)//'_15', trim(class_name_)//'_16'] List of supported schemes. Derived Types type, public, extends( integrator_multistep_object ) :: integrator_adams_bashforth FOODIE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 16th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private, allocatable :: b (:) b coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, autoupdate, U, stop_on_fail) Create the actual Adams-Bashforth integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with Adams-Bashforth class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_fast (self, U, Dt, t) Integrate field with Adams-Bashforth class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_adams_bashforth.html","title":"foodie_integrator_adams_bashforth – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_adams_bashforth foodie_integrator_adams_moulton foodie_integrator_multistep_object foodie_integrator_object penf module~~foodie_integrator_adams_bashforth_moulton~~UsesGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton penf penf penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrand_object module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistep_object module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistep_object var panmodulefoodie_integrator_adams_bashforth_moultonUsesGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide a predictor-corrector class of Adams-Bashforth-Moutlon multi-step schemes, from 1st to 4rd order\n accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth-Moulton class scheme implemented is: predictor  U&#94;{n+N_s&#94;p} = U&#94;{n+N_s&#94;p-1} +\\Delta t \\left[ \\sum_{s=1}&#94;{N_s&#94;p}{ b_s&#94;p \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) } \\right]  corrector  U&#94;{n+N_s&#94;c} = U&#94;{n+N_s&#94;c-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s&#94;c}{ b_s&#94;c \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } \\right]  where N_s&#94;p is the number of previous steps considered for the predictor and N_s&#94;c is the number of previous steps\nconsidered for the corrector. Note The value of \\Delta t must be provided, it not being computed by the integrator. The coefficients b_s&#94;{p,c} define the actual scheme, that is selected accordingly to the number of steps used. The predictor and corrector schemes should have the same formal order of accuracy, thus N_s&#94;p=N_s&#94;c+1\n should hold. Currently, the following schemes are available: P=AB(1)-C=AM(0) step, Explicit/Implicit Farward/Backward Euler, 1st order This scheme is TVD and reverts to Explicit/Implicit Farward/Backward Euler, it being 1st order.\n The b coefficient is:\n b&#94;p = \\left[b_1\\right] = \\left[1\\right]\n b&#94;c = \\left[b_0\\right] = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1,p} = U&#94;{n} + \\Delta t R(t&#94;{n},U&#94;{n}) \n  U&#94;{n+1,c} = U&#94;{n} + \\Delta t R(t&#94;{n+1},U&#94;{n+1,p})  P=AB(2)-C=AM(1) steps This scheme is 2nd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2} & \\frac{1}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2,p} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+2,c} = U&#94;{n+1} +\\Delta t \\left[ \\frac{1}{2} R(t&#94;{n+2,p}, U&#94;{n+2})+\\frac{1}{2} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  P=AB(3)-C=AM(2) steps This scheme is 3rd order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{12} & \\frac{2}{3} & \\frac{5}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3,p} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right] \n  U&#94;{n+3,c} = U&#94;{n+2} +\\Delta t \\left[ \\frac{5}{12}R(t&#94;{n+3}, U&#94;{n+3,p}) + \\frac{2}{3}R(t&#94;{n+2}, U&#94;{n+2})\n -\\frac{1}{12} R(t&#94;{n+1}, U&#94;{n+1})  \\right]  P=AB(4)-C=AM(3) steps This scheme is 4th order.\n The b coefficients are:\n b&#94;p = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 & b_4 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} -\\frac{9}{24} & \\frac{37}{24} & -\\frac{59}{24} & \\frac{55}{24} \\end{array}} \\right]\n b&#94;c = \\left[ {\\begin{array}{*{20}{c}} b_0 & b_1 & b_2 & b_3 \\end{array}} \\right] =\n         \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{24} & -\\frac{5}{24} & \\frac{19}{24} & \\frac{9}{24} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+4,p} = U&#94;{n+3} +\\Delta t \\left[ \\frac{55}{24}R(t&#94;{n+3}, U&#94;{n+3}) - \\frac{59}{24}R(t&#94;{n+2}, U&#94;{n+2})\n +\\frac{37}{24} R(t&#94;{n+1}, U&#94;{n+1}) - \\frac{9}{24} R(t&#94;{n}, U&#94;{n}) \\right] \n  U&#94;{n+4,c} = U&#94;{n+3} +\\Delta t \\left[ \\frac{9}{24}R(t&#94;{n+4}, U&#94;{n+4,p}) + \\frac{19}{24}R(t&#94;{n+3}, U&#94;{n+3})\n -\\frac{5}{24} R(t&#94;{n+2}, U&#94;{n+2}) + \\frac{1}{24} R(t&#94;{n+1}, U&#94;{n+1}) \\right]  Bibliography Used By module~~foodie_integrator_adams_bashforth_moulton~~UsedByGraph module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_bashforth_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_bashforth_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_adams_bashforth_moulton Functions class_name has_fast_mode is_supported scheme_number supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'adams_bashforth_moulton' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:16) = [trim(class_name_)//'_1 ', trim(class_name_)//'_2 ', trim(class_name_)//'_3 ', trim(class_name_)//'_4 ', trim(class_name_)//'_5 ', trim(class_name_)//'_6 ', trim(class_name_)//'_7 ', trim(class_name_)//'_8 ', trim(class_name_)//'_9 ', trim(class_name_)//'_10', trim(class_name_)//'_11', trim(class_name_)//'_12', trim(class_name_)//'_13', trim(class_name_)//'_14', trim(class_name_)//'_15', trim(class_name_)//'_16'] List of supported schemes. Derived Types type, public, extends( integrator_multistep_object ) :: integrator_adams_bashforth_moulton FOODIE integrator: provide an explicit class of Adams-Bashforth-Moulton multi-step schemes, from 1st to 4rd order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. type( integrator_adams_moulton ), private :: corrector Corrector solver. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. type( integrator_adams_bashforth ), private :: predictor Predictor solver. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: scheme_number Return the scheme number in the list of supported schemes. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private elemental function scheme_number (self, scheme) Return the scheme number in the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value integer(kind=I_P) Scheme number in the list of supported schemes. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual Adams-Bashforth-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with Adams-Bashforth-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. private subroutine integrate_fast (self, U, Dt, t) Integrate field with Adams-Bashforth-Moulton class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_bashforth_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times.","tags":"","loc":"module/foodie_integrator_adams_bashforth_moulton.html","title":"foodie_integrator_adams_bashforth_moulton – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistep_object foodie_integrator_object penf module~~foodie_integrator_adams_moulton~~UsesGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton penf penf penf->module~foodie_integrator_adams_moulton penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistep_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_multistep_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistep_object var panmodulefoodie_integrator_adams_moultonUsesGraph = svgPanZoom('#modulefoodie_integrator_adams_moultonUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an implicit class of Adams-Moutlon multi-step schemes, from 1st to 16th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Moulton class scheme implemented is:  U&#94;{n+N_s} = U&#94;{n+N_s-1} +\\Delta t \\left[ \\sum_{s=0}&#94;{N_s-1}{ b_s \\cdot R(t&#94;{n+s}, U&#94;{n+s}) } +\n b_{N_S}\\cdot R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [0, 15] . Note that the scheme using only 1 step reverts\n to Implciti Backwarad Euler. The formal order of accuracy varies consistently in [1st, 16th] order. Bibliography [1] Cowell Type Numerical Integration As Applied to Satellite Orbit Computation , J. L. Maury Jr.,\n G. P. Segal, X-553-69-46, April 1969, NASA-TM-X-63542 . [2] Linear multistep method , wikipedia article . Used By module~~foodie_integrator_adams_moulton~~UsedByGraph module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_adams_moultonUsedByGraph = svgPanZoom('#modulefoodie_integrator_adams_moultonUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_adams_moulton Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'adams_moulton' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:16) = [trim(class_name_)//'_0 ', trim(class_name_)//'_1 ', trim(class_name_)//'_2 ', trim(class_name_)//'_3 ', trim(class_name_)//'_4 ', trim(class_name_)//'_5 ', trim(class_name_)//'_6 ', trim(class_name_)//'_7 ', trim(class_name_)//'_8 ', trim(class_name_)//'_9 ', trim(class_name_)//'_10', trim(class_name_)//'_11', trim(class_name_)//'_12', trim(class_name_)//'_13', trim(class_name_)//'_14', trim(class_name_)//'_15'] List of supported schemes. Derived Types type, public, extends( integrator_multistep_object ) :: integrator_adams_moulton FOODIE integrator: provide an explicit class of Adams-Moulton multi-step schemes, from 1st to 16th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private, allocatable :: b (:) b coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual Adams-Moulton integrator: initialize the b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with Adams-Moulton class scheme. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_fast (self, U, Dt, t) Integrate field with Adams-Moulton class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_adams_moulton ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_adams_moulton.html","title":"foodie_integrator_adams_moulton – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistep_object foodie_integrator_object penf module~~foodie_integrator_backward_differentiation_formula~~UsesGraph module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula penf penf penf->module~foodie_integrator_backward_differentiation_formula penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistep_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistep_object var panmodulefoodie_integrator_backward_differentiation_formulaUsesGraph = svgPanZoom('#modulefoodie_integrator_backward_differentiation_formulaUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an implicit class of Backward Differentiation Formula schemes, from 1st to 6th order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Backward Differentiation Formula class scheme implemented is:  U&#94;{n+N_s} + \\sum_{s=1}&#94;{N_s} \\alpha_s U&#94;{n+N_s-s} = \\Delta t \\left[ \\beta R(t&#94;{n+N_s}, U&#94;{n+N_s}) \\right]  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are implicit. The coefficients \\alpha_s and \\beta define the actual scheme, that is selected accordingly\n to the number of steps used. Currently, the following schemes are available: Step beta alpha 1 alpha 2 alpha 3 alpha 4 alpha 5 alpha 6 1 1 -1 2 2/3 -4/3 1/3 3 6/11 -18/11 9/11 -2/11 4 12/25 -48/25 36/25 -16/25 3/25 5 60/137 -300/137 300/137 -200/137 75/137 -12/137 6 60/147 -360/147 450/147 -400/147 225/147 -72/147 10/147 Bibliography Used By module~~foodie_integrator_backward_differentiation_formula~~UsedByGraph module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_backward_differentiation_formulaUsedByGraph = svgPanZoom('#modulefoodie_integrator_backward_differentiation_formulaUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_back_df Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'back_df' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:6) = [trim(class_name_)//'_1', trim(class_name_)//'_2', trim(class_name_)//'_3', trim(class_name_)//'_4', trim(class_name_)//'_5', trim(class_name_)//'_6'] List of supported schemes. Derived Types type, public, extends( integrator_multistep_object ) :: integrator_back_df FOODIE integrator: provide an implicit class of Backward-Differentiation-Formula multi-step schemes, from 1st to 6th order\n accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private, allocatable :: a (:) \\alpha coefficients. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private :: b = 0.0_R_P \\beta coefficient. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual BDF integrator: initialize the alpha and beta coefficients. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_fast (self, U, Dt, t) Integrate field with BDF class scheme. Arguments Type Intent Optional Attributes Name class( integrator_back_df ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_backward_differentiation_formula.html","title":"foodie_integrator_backward_differentiation_formula – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistage_object foodie_integrator_object penf module~~foodie_integrator_euler_explicit~~UsesGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit penf penf penf->module~foodie_integrator_euler_explicit penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistage_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_multistage_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object var panmodulefoodie_integrator_euler_explicitUsesGraph = svgPanZoom('#modulefoodie_integrator_euler_explicitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Used By module~~foodie_integrator_euler_explicit~~UsedByGraph module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_euler_explicitUsedByGraph = svgPanZoom('#modulefoodie_integrator_euler_explicitUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_euler_explicit Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'euler_explicit' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:1) = [trim(class_name_)] List of supported schemes. Derived Types type, public, extends( integrator_multistage_object ) :: integrator_euler_explicit FOODIE integrator: provide explicit Euler scheme, it being 1st order accurate. Components Type Visibility Attributes Name Initial class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit Euler scheme, 1st order. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit Euler scheme, 1st order, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_euler_explicit ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistep_object foodie_integrator_object penf module~~foodie_integrator_leapfrog~~UsesGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog penf penf penf->module~foodie_integrator_leapfrog penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistep_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_multistep_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistep_object var panmodulefoodie_integrator_leapfrogUsesGraph = svgPanZoom('#modulefoodie_integrator_leapfrogUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is:  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps:\n  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2}) \n  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha \n  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1) \n Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme.\n The filter coefficients should be taken as \\nu \\in (0,1] and \\alpha \\in (0.5,1]. The default values are \\nu=0.01 \\alpha=0.53 Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. Bibliography [1] The integration of a low order spectral form of the primitive meteorological equations , Robert, A. J., J. Meteor. Soc.\n Japan,vol. 44, pages 237–245, 1966. [2] Frequency filter for time integrations , Asselin, R., Monthly Weather Review, vol. 100, pages 487–490, 1972. [3] The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations , Williams, P.D., Monthly\n Weather Review, vol. 139(6), pages 1996–2007, June 2011. Used By module~~foodie_integrator_leapfrog~~UsedByGraph module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_leapfrogUsedByGraph = svgPanZoom('#modulefoodie_integrator_leapfrogUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_leapfrog Functions class_name has_fast_mode is_supported supported_schemes Subroutines allocate_integrand_members destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'leapfrog' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:2) = [trim(class_name_)//'    ', trim(class_name_)//'_raw'] List of supported schemes. Derived Types type, public, extends( integrator_multistep_object ) :: integrator_leapfrog FOODIE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private :: alpha Robert-Asselin-Williams filter coefficient. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. class( integrand_object ), private, allocatable :: filter Filter field displacement. logical, private :: is_filtered Flag to check if the integration if RAW filtered. integer(kind=I_P), public :: iterations Implicit iterations. real(kind=R_P), private :: nu Robert-Asselin filter coefficient. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, nu, alpha, autoupdate, U, stop_on_fail) Create the actual leapfrog integrator: initialize the filter coefficient. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with leapfrog class scheme. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_fast (self, U, Dt, t) Integrate field with leapfrog class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_leapfrog ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_leapfrog.html","title":"foodie_integrator_leapfrog – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistep_object foodie_integrator_object penf module~~foodie_integrator_lmm_ssp~~UsesGraph module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp penf penf penf->module~foodie_integrator_lmm_ssp penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistep_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_multistep_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistep_object var panmodulefoodie_integrator_lmm_sspUsesGraph = svgPanZoom('#modulefoodie_integrator_lmm_sspUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property, from\n 2nd to 3rd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the LMM-SSP class scheme implemented is:  U&#94;{n+N_s} = \\sum_{s=1}&#94;{N_s}{\\left[a_s U&#94;{n+s-1} + \\Delta t b_s \\cdot R(t&#94;{n+s-1}, U&#94;{n+s-1}) \\right]}  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients a,b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [3, 5] . The formal order of accuracy varies\n consistently in [2nd, 3rd] order. Bibliography [1] Strong Stability Preserving Runge-Kutta and Multistep Time Discretizations , S. Gottlieb, D. Ketcheson, C.W. Shu,\n 2011, 978-981-4289-26-9, doi:10.1142/7498, World Scientific Publishing Co. Pte. Ltd. Used By module~~foodie_integrator_lmm_ssp~~UsedByGraph module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_lmm_sspUsedByGraph = svgPanZoom('#modulefoodie_integrator_lmm_sspUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_lmm_ssp Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'lmm_ssp' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:3) = [trim(class_name_)//'_steps_3_order_2', trim(class_name_)//'_steps_4_order_3', trim(class_name_)//'_steps_5_order_3'] List of supported schemes. Derived Types type, public, extends( integrator_multistep_object ) :: integrator_lmm_ssp FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property,\n from 2nd to 3rd order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private, allocatable :: a (:) a coefficients. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. real(kind=R_P), private, allocatable :: b (:) b coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, autoupdate, U, stop_on_fail) Create the actual LMM-SSP integrator: initialize the a,b coefficients. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_fast (self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_lmm_ssp.html","title":"foodie_integrator_lmm_ssp – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistep_object foodie_integrator_object penf module~~foodie_integrator_lmm_ssp_vss~~UsesGraph module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss penf penf penf->module~foodie_integrator_lmm_ssp_vss penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistep_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_multistep_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistep_object var panmodulefoodie_integrator_lmm_ssp_vssUsesGraph = svgPanZoom('#modulefoodie_integrator_lmm_ssp_vssUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and\n variable stepsize (VSS), from 2nd to 3rd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the LMM-SSP class scheme implemented is: Second order formula  U&#94;{n+N_s} = \\frac{1}{\\Omega_{N_s-1}&#94;2} U&#94;n + \\frac{\\Omega_{N_s-1}&#94;2 - 1}{\\Omega_{N_s-1}&#94;2} U&#94;{n+N_s-1} +\n    \\frac{\\Omega_{N_s-1} + 1}{\\Omega_{N_s-1}} \\Delta t&#94;{n+N_s} R(U&#94;{n+N_s-1})  Third order formula  U&#94;{n+N_s} = \\frac{3 \\Omega_{N_s-1} + 2}{\\Omega_{N_s-1}&#94;3} U&#94;n +\n                \\frac{(\\Omega_{N_s-1} + 1)&#94;2(\\Omega_{N_s-1} - 2)}{\\Omega_{N_s-1}&#94;3} U&#94;{n+N_s-1} +\n                \\frac{\\Omega_{N_s-1} + 1}{\\Omega_{N_s-1}&#94;2} \\Delta t&#94;{n+N_s} R(U&#94;n) +\n                \\frac{(\\Omega_{N_s-1} + 1)&#94;2}{\\Omega_{N_s-1}&#94;2} \\Delta t&#94;{n+N_s} R(U&#94;{n+N_s-1})  where N_s is the number of previous steps considered and  \\Omega_s = \\sum_{i=1}&#94;s { \\omega_i }\\quad 1 \\leq s \\leq N_s \n  \\omega_i = \\frac{\\Delta t&#94;{n + s}}{\\Delta t&#94;{n + N_s}}  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. Bibliography [1] Strong Stability Preserving Explicit Linear Multistep Methods with Variable Step Size , Y. Hadjmichael, D. Ketcheson,\n L. Loczi, A. Nemeth, 2016, SIAM, Vol. 54, N. 5, pp. 2799-2832. Used By module~~foodie_integrator_lmm_ssp_vss~~UsedByGraph module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie foodie module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_lmm_ssp_vssUsedByGraph = svgPanZoom('#modulefoodie_integrator_lmm_ssp_vssUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Abstract Interfaces integrate_fast_interface integrate_interface Derived Types integrator_lmm_ssp_vss Functions class_name dt_ratio has_fast_mode is_supported omega supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast integrate_order_2 integrate_order_2_fast integrate_order_3 integrate_order_3_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'lmm_ssp_vss' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:5) = [trim(class_name_)//'_steps_2_order_2', trim(class_name_)//'_steps_3_order_2', trim(class_name_)//'_steps_3_order_3', trim(class_name_)//'_steps_4_order_3', trim(class_name_)//'_steps_5_order_3'] List of supported schemes. Abstract Interfaces abstract interface Abstract interfaces of integrator_lmm_ssp_vss methods. private subroutine integrate_fast_interface (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. abstract interface Abstract interfaces of integrator_lmm_ssp_vss methods. private subroutine integrate_interface (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Derived Types type, public, extends( integrator_multistep_object ) :: integrator_lmm_ssp_vss FOODIE integrator: provide an explicit class of Linear Multi-step Methods (LLM) with Strong Stability Preserving property and\n variable stepsize (VSS), from 2nd to 3rd order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. procedure( integrate_interface ), private, pointer :: integrate_ => integrate_order_2 Integrate integrand field. procedure( integrate_fast_interface ), private, pointer :: integrate_fast_ => integrate_order_2_fast Integrate integrand field, fast. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, private, pass(self) :: integrate_order_2 Integrate integrand field by 2nd order formula. procedure, private, pass(self) :: integrate_order_2_fast Integrate integrand field by 2nd order formula, fast mode. procedure, private, pass(self) :: integrate_order_3 Integrate integrand field by 3rd order formula. procedure, private, pass(self) :: integrate_order_3_fast Integrate integrand field by 3rd order formula, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private pure function dt_ratio (Dt, s) result(ratio) Return Dt(n+s)/Dt(n+Ns) ratio. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: Dt (:) Time steps. integer(kind=I_P), intent(in) :: s Step index. Return Value real(kind=R_P) Time steps ratio. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function omega (Dt, s) Return omega=sum(dt_ratio(i)), i=1, s . Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: Dt (:) Time steps. integer(kind=I_P), intent(in) :: s Step index. Return Value real(kind=R_P) Omega sum. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, autoupdate, U, stop_on_fail) Create the actual LMM-SSP-VSS integrator. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_fast (self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_order_2 (self, U, Dt, t) Integrate field with LMM-SSP-VSS 2nd order class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_order_2_fast (self, U, Dt, t) Integrate field with LMM-SSP-VSS 2nd order class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_order_3 (self, U, Dt, t) Integrate field with LMM-SSP-VSS 3rd order class scheme. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_order_3_fast (self, U, Dt, t) Integrate field with LMM-SSP-VSS 3rd order class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_lmm_ssp_vss ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_lmm_ssp_vss.html","title":"foodie_integrator_lmm_ssp_vss – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistage_multistep_object foodie_integrator_object penf module~~foodie_integrator_ms_runge_kutta_ssp~~UsesGraph module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp penf penf penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object var panmodulefoodie_integrator_ms_runge_kutta_sspUsesGraph = svgPanZoom('#modulefoodie_integrator_ms_runge_kutta_sspUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property, from\n 2nd to 3rd order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the LMM-SSP class scheme implemented is: \n \\begin{align}\n y_1&#94;n & = u&#94;n \\\\\n y_i&#94;n & = \\sum_{l=1}&#94;{k} d_{il} u&#94;{n-k+l} + \\Delta{t}\\sum_{l=1}&#94;{k-1} \\hat{a}_{il} F(u&#94;{n-k+l}) +\n                                             \\Delta{t}\\sum_{j=1}&#94;{i-1} a_{ij} F(y_j&#94;n) \\; \\; \\; \\;  2 \\leq i \\leq s \\\\\n u&#94;{n+1} & = \\sum_{l=1}&#94;{k} \\theta_l u&#94;{n-k+l} + \\Delta{t}\\sum_{l=1}&#94;{k-1} \\hat{b}_{l} F(u&#94;{n-k+l}) +\n                                                  \\Delta{t}\\sum_{j=1}&#94;s b_j F(y_j&#94;n).\n \\end{align}\n  where N_s is the number of previous steps considered. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients a,b define the actual scheme, that is selected accordingly to the number of steps used. Currently, the schemes provided have steps number in [3, 5] . The formal order of accuracy varies\n consistently in [2nd, 3rd] order. Bibliography [1] Explicit Strong Stability Preserving Multistep Runge-Kutta Methods , C. Bresten, S. Gottlieb, Z. Grant, D. Higgs,\n D. Ketcheson, A. Németh, 2016, Mathematics of Computations, Used By module~~foodie_integrator_ms_runge_kutta_ssp~~UsedByGraph module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_ms_runge_kutta_sspUsedByGraph = svgPanZoom('#modulefoodie_integrator_ms_runge_kutta_sspUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_ms_runge_kutta_ssp Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'ms_runge_kutta_ssp' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:3) = [trim(class_name_)//'_steps_2_stages_2_order_3', trim(class_name_)//'_steps_3_stages_2_order_3', trim(class_name_)//'_steps_4_stages_5_order_8'] List of supported\n schemes. Derived Types type, public, extends( integrator_multistage_multistep_object ) :: integrator_ms_runge_kutta_ssp FOODIE integrator: provide an explicit class of Multi-step Runge-Kutta Methods with Strong Stability Preserving property,\n from 3rd to 8th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: A (:,:) A coefficients. real(kind=R_P), private, allocatable :: Ahat (:,:) Ahat coefficients. real(kind=R_P), private, allocatable :: B (:) B coefficients. real(kind=R_P), private, allocatable :: Bhat (:) Bhat coefficients. real(kind=R_P), private, allocatable :: D (:,:) D coefficients. real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. real(kind=R_P), private, allocatable :: Q (:) T coefficients. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers_stages Number of registers used for stages. integer(kind=I_P), public :: registers_steps Number of registers used for steps. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage_multistep Assign members of integrator_multistage_multistep_object . generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage_multistep Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, iterations, autoupdate, U, stop_on_fail) Create the actual MS-RK-SSP integrator: initialize the A,Ahat,B,Bhat,D,T coefficients. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. integer(kind=I_P), intent(in), optional :: iterations Implicit iterations. logical, intent(in), optional :: autoupdate Enable cyclic autoupdate of previous time steps. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t) Integrate field with LMM-SSP class scheme. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_fast (self, U, Dt, t) Integrate field with LMM-SSP class scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_ms_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_ms_runge_kutta_ssp.html","title":"foodie_integrator_ms_runge_kutta_ssp – FOODIE"},{"text":"Uses: iso_fortran_env foodie_integrand_object foodie_integrator_object penf module~~foodie_integrator_multistage_multistep_object~~UsesGraph module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrand_object module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_multistage_multistep_object iso_fortran_env->module~foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract type integrator_multistage_multistep_object of FOODIE ODE integrators. Used By module~~foodie_integrator_multistage_multistep_object~~UsedByGraph module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie foodie module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_multistage_multistep_objectUsedByGraph = svgPanZoom('#modulefoodie_integrator_multistage_multistep_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces integrate_fast_interface integrate_interface Derived Types integrator_multistage_multistep_object Functions is_multistage is_multistep stages_number steps_number Subroutines allocate_integrand_members assign_multistage_multistep destroy_multistage_multistep update_previous Abstract Interfaces abstract interface Abstract interfaces of deferred methods of integrator_multistage_multistep_object . private subroutine integrate_fast_interface (self, U, Dt, t) Integrate integrand field, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. abstract interface Abstract interfaces of deferred methods of integrator_multistage_multistep_object . private subroutine integrate_interface (self, U, Dt, t) Integrate integrand field. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Derived Types type, public, abstract, extends( integrator_object ) :: integrator_multistage_multistep_object Abstract type of FOODIE ODE integrators of the multistage/multistep family. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers_stages Number of registers used for stages. integer(kind=I_P), public :: registers_steps Number of registers used for steps. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage_multistep Assign members of integrator_multistage_multistep_object . generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure(class_name_interface), public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage_multistep Destroy the integrator. procedure(has_fast_mode_interface), public, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. procedure(assignment_interface), public, pass(lhs) :: integr_assign_integr Operator = . procedure(integrate_interface), public, pass(self) :: integrate Integrate integrand field. procedure(integrate_fast_interface), public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure(is_supported_interface), public, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure(supported_schemes_interface), public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. Subroutines private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. private subroutine assign_multistage_multistep (lhs, rhs) Assign members of integrator_multistage_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private elemental subroutine destroy_multistage_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_multistep_object ), intent(inout) :: self Integrator. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time.","tags":"","loc":"module/foodie_integrator_multistage_multistep_object.html","title":"foodie_integrator_multistage_multistep_object – FOODIE"},{"text":"Uses: iso_fortran_env foodie_integrand_object foodie_integrator_object penf module~~foodie_integrator_multistage_object~~UsesGraph module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_multistage_object penf penf penf->module~foodie_integrator_multistage_object penf->module~foodie_integrand_object module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_multistage_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract type integrator_multistage_object of FOODIE ODE integrators. Used By module~~foodie_integrator_multistage_object~~UsedByGraph module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie foodie module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_multistage_objectUsedByGraph = svgPanZoom('#modulefoodie_integrator_multistage_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces integrate_fast_interface integrate_interface Derived Types integrator_multistage_object Functions is_multistage is_multistep stages_number steps_number Subroutines allocate_integrand_members assign_multistage destroy_multistage Abstract Interfaces abstract interface Abstract interfaces of deferred methods of integrator_multistage_object . private subroutine integrate_fast_interface (self, U, Dt, t, new_Dt) Integrate integrand field, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. abstract interface Abstract interfaces of deferred methods of integrator_multistage_object . private subroutine integrate_interface (self, U, Dt, t, new_Dt) Integrate integrand field. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. Derived Types type, public, abstract, extends( integrator_object ) :: integrator_multistage_object Abstract type of FOODIE ODE integrators of the multistage family. Components Type Visibility Attributes Name Initial class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure(class_name_interface), public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. procedure(has_fast_mode_interface), public, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. procedure(assignment_interface), public, pass(lhs) :: integr_assign_integr Operator = . procedure(integrate_interface), public, pass(self) :: integrate Integrate integrand field. procedure(integrate_fast_interface), public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure(is_supported_interface), public, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure(supported_schemes_interface), public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. Functions private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. Subroutines private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. private subroutine assign_multistage (lhs, rhs) Assign members of integrator_multistage_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private elemental subroutine destroy_multistage (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistage_object ), intent(inout) :: self Integrator.","tags":"","loc":"module/foodie_integrator_multistage_object.html","title":"foodie_integrator_multistage_object – FOODIE"},{"text":"Uses: iso_fortran_env foodie_integrand_object foodie_integrator_object penf module~~foodie_integrator_multistep_object~~UsesGraph module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_multistep_object penf penf penf->module~foodie_integrator_multistep_object penf->module~foodie_integrand_object module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_multistep_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract type integrator_multistep_object of FOODIE ODE integrators. Used By module~~foodie_integrator_multistep_object~~UsedByGraph module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie foodie module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_adams_moulton->module~foodie module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_multistep_objectUsedByGraph = svgPanZoom('#modulefoodie_integrator_multistep_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces integrate_fast_interface integrate_interface Derived Types integrator_multistep_object Functions is_multistage is_multistep stages_number steps_number Subroutines allocate_integrand_members assign_multistep destroy_multistep update_previous Abstract Interfaces abstract interface Abstract interfaces of deferred methods of integrator_multistep_object . private subroutine integrate_fast_interface (self, U, Dt, t) Integrate integrand field, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. abstract interface Abstract interfaces of deferred methods of integrator_multistep_object . private subroutine integrate_interface (self, U, Dt, t) Integrate integrand field. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Integrand. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Derived Types type, public, abstract, extends( integrator_object ) :: integrator_multistep_object Abstract type of FOODIE ODE integrators of the multistep-implicit family. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: Dt (:) Previous time steps. logical, public :: autoupdate Perform cyclic autoupdate of previous time steps buffers. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: iterations Implicit iterations. class( integrand_object ), public, allocatable :: previous (:) Previous steps. integer(kind=I_P), public :: registers Number of registers used for steps. integer(kind=I_P), public :: steps Number of time steps. real(kind=R_P), public, allocatable :: t (:) Previous times. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistep Assign members of integrator_multistep_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure(class_name_interface), public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistep Destroy the integrator. procedure(has_fast_mode_interface), public, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. procedure(assignment_interface), public, pass(lhs) :: integr_assign_integr Operator = . procedure(integrate_interface), public, pass(self) :: integrate Integrate integrand field. procedure(integrate_fast_interface), public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure(is_supported_interface), public, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure(supported_schemes_interface), public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. procedure, public, nopass :: update_previous Cyclic update previous time steps. Functions private elemental function is_multistage (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_multistep (self) Return .true. for multistage integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function stages_number (self) Return number of stages used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of stages used. private elemental function steps_number (self) Return number of steps used. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Number of steps used. Subroutines private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. private subroutine assign_multistep (lhs, rhs) Assign members of integrator_multistep_object and parents. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private elemental subroutine destroy_multistep (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_multistep_object ), intent(inout) :: self Integrator. private subroutine update_previous (U, previous, Dt, t, previous_Dt, previous_t) Cyclic update previous time steps. Arguments Type Intent Optional Attributes Name class( integrand_object ), intent(in) :: U Field to be integrated. class( integrand_object ), intent(inout) :: previous (1:) Previous time steps solutions of integrand. real(kind=R_P), intent(in), optional :: Dt Time step. real(kind=R_P), intent(in), optional :: t Time. real(kind=R_P), intent(inout), optional :: previous_Dt (1:) Time step. real(kind=R_P), intent(inout), optional :: previous_t (1:) Time.","tags":"","loc":"module/foodie_integrator_multistep_object.html","title":"foodie_integrator_multistep_object – FOODIE"},{"text":"Uses: iso_fortran_env penf module~~foodie_integrator_object~~UsesGraph module~foodie_integrator_object foodie_integrator_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object penf penf penf->module~foodie_integrator_object Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define the abstract type integrator_object of FOODIE ODE integrators. Used By module~~foodie_integrator_object~~UsedByGraph module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_objectUsedByGraph = svgPanZoom('#modulefoodie_integrator_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces assignment_interface class_name_interface description_interface has_fast_mode_interface is_multistagestep_interface is_supported_interface stagesteps_number_interface supported_schemes_interface Derived Types integrator_object Functions description Subroutines assign_abstract check_error destroy_abstract trigger_error Abstract Interfaces abstract interface Abstract interfaces of deferred methods of integrator_object . private subroutine assignment_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of integrator_object . private pure function class_name_interface (self) result(class_name) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99) Class name. abstract interface Abstract interfaces of deferred methods of integrator_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function has_fast_mode_interface (self) result(has_fast_mode) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function is_multistagestep_interface (self) result(is_multistagestep) Return .true. for multistage or multistep integrator. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value logical Inquire result. abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function is_supported_interface (self, scheme) result(is_supported) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Queried scheme. Return Value logical Inquire result. abstract interface Abstract interfaces of deferred methods of integrator_object . private elemental function stagesteps_number_interface (self) result(stagesteps_number) Return number of stages/steps used. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value integer(kind=I_P) Inquire result. abstract interface Abstract interfaces of deferred methods of integrator_object . private pure function supported_schemes_interface (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Derived Types type, public, abstract :: integrator_object Abstract type of FOODIE ODE integrators. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. Type-Bound Procedures procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure(class_name_interface), public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure(has_fast_mode_interface), public, pass(self) :: has_fast_mode Return .true. if the integrator class\n has fast mode integrate. procedure(assignment_interface), public, pass(lhs) :: integr_assign_integr Operator = . procedure(is_multistagestep_interface), public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure(is_multistagestep_interface), public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure(is_supported_interface), public, pass(self) :: is_supported Return .true. if the integrator class\n support the given scheme. procedure(stagesteps_number_interface), public, pass(self) :: stages_number Return number of stages used. procedure(stagesteps_number_interface), public, pass(self) :: steps_number Return number of steps used. procedure(supported_schemes_interface), public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. Functions private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Subroutines private subroutine assign_abstract (lhs, rhs) Assign ony members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine check_error (self, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(in) :: self Integrator. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop. private elemental subroutine destroy_abstract (self) Destroy only members of abstract integrator_object type. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. private subroutine trigger_error (self, error, error_message, is_severe) Check for error occurencies. Arguments Type Intent Optional Attributes Name class( integrator_object ), intent(inout) :: self Integrator. integer(kind=I_P), intent(in) :: error Error status code. character(len=*), intent(in), optional :: error_message Error message, hopefully meaningful. logical, intent(in), optional :: is_severe Flag to activate severe faliure, namely errors trigger a stop.","tags":"","loc":"module/foodie_integrator_object.html","title":"foodie_integrator_object – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistage_object foodie_integrator_object penf module~~foodie_integrator_runge_kutta_emd~~UsesGraph module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd penf penf penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistage_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_multistage_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object var panmodulefoodie_integrator_runge_kutta_emdUsesGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_emdUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. The integrators provided have the embedded pairs property allowing for automatic step size control.\n The schemes are explicit and defined through the extended Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U_p&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_p&#94;s K&#94;s \n  U_{p+1}&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta_{p+1}&#94;s K&#94;s  p is the lower accuracy order scheme and p+1 is the higher one; Ns is the number of stages used and K&#94;s is\n the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the extended Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta_{p+1}&#94;1      beta_{p+1}&#94;2      ...        beta_{p+1}&#94;{Ns}\n             | beta_p&#94;1          beta_p&#94;2          ...        beta_p&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: Bug Presently, the 2 stages Heun-Euler seems to not work, do not use it . 2 stages, 2th order This scheme is due to Heun-Euler. 0  | 0\n  1  | 1     0\n ----------------\n     | 1/2   1/2\n     | 1      0 6 stages, 5th order This scheme is due to Cash and Karp, see [3]. 0    | 0\n  1/5    | 1/5\n  3/10 | 3/40            9/40\n  3/5    | 3/10          -9/10        6/5\n  1    | -11/54        5/2          -70/27      35/27\n  7/8    | 1631/55296    175/512      575/13824   44275/110592     253/4096     0\n ----------------------------------------------------------------------------------------\n       | 37/378        0           250/621      125/594          0            512/1771\n       | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4 7 stages, 4th order This scheme is due to Dormand and Prince, see [1]. 0    | 0\n  1/5  | 1/5\n  3/10 | 3/40          9/40\n  4/5  | 44/45        -56/15        32/9\n  8/9  | 19372/6561   -25360/2187   64448/6561   -212/729\n  1    | 9017/3168    -355/33       46732/5247    49/176      -5103/18656\n  1    | 35/384        0            500/1113      125/192     -2187/6784      11/84      0\n --------------------------------------------------------------------------------------------\n       | 5179/57600    0            7571/16695    393/640     -92097/339200   187/2100   1/40\n       | 35/384        0            500/1113      125/192     -2187/6784      11/84      0 9 stages, 6th order This scheme is due to Calvo et al., see [2]. 0                 | 0\n  2/15              | 2/15\n  1/5               | 1/20                  3/20\n  3/10              | 3/40                  0                      9/40\n  14/25             | 86727015/196851553    -60129073/52624712     957436434/1378352377    83886832/147842441\n  19/25             | -86860849/45628967    111022885/25716487     108046682/101167669     -141756746/36005461\n  35226607/35688279 | 77759591/16096467     -49252809/6452555      -381680111/51572984     879269579/66788831\n  1                 | 237564263/39280295    -100523239/10677940    -265574846/27330247     317978411/18988713\n  1                 | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n --------------------------------------------------------------------------------------------------------------\n                    | 17572349/289262523    0                      57513011/201864250      15587306/354501571\n                    | 15231665/510830334    0                      59452991/116050448      -28398517/122437738\n ...continued...\n  0                 |\n  2/15              |\n  1/5               |\n  3/10              |\n  14/25             |\n  19/25             | 73139862/60170633\n  35226607/35688279 | -90453121/33722162     111179552/157155827\n  1                 | -124494385/35453627    86822444/100138635     -12873523/724232625\n  1                 | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n -----------------------------------------------------------------------------------------------------------------------\n                    | 71783021/234982865     29672000/180480167     65567621/127060952     -79074570/210557597    0\n                    | 56673824/137010559     68003849/426673583     7097631/37564021       -71226429/583093742    1/20 17 stages, 10th order This scheme is due to Feagin, see [4]. 0                        |  0\n  0.1                      |  0.1\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052\n  0.809036761204472681298  |  0.202259190301118170324  0                        0.606777570903354510974\n  0.309036761204472681298  |  0.184024714708643575149  0                        0.197966831227192369068\n  0.981074190219795268254  |  0.087900734020668133731  0                        0\n  0.833333333333333333333  |  0.085970050490246030218  0                        0\n  0.354017365856802376329  |  0.120930449125333720660  0                        0\n  0.882527661964732346425  |  0.110854379580391483508  0                        0\n  0.642615758240322548157  |  0.112054414752879004829  0                        0\n  0.357384241759677451842  |  0.113976783964185986138  0                        0\n  0.117472338035267653574  |  0.079831452828019604635  0                        0\n  0.833333333333333333333  |  0.985115610164857280120  0                        0\n  0.309036761204472681298  |  0.895080295771632891049  0                        0.197966831227192369068\n  0.539357840802981787532  | -0.915176561375291440520  1.454534402178273228052  0\n  0.1                      |  0.1                      0                       -0.157178665799771163367\n  1                        |  0.181781300700095283888  0.675                    0.342758159847189839942\n ------------------------------------------------------------------------------------------------------\n                           |  0.033333333333333333333  0.025                    0.033333333333333333333\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  | -0.072954784731363262918\n  0.981074190219795268254  |  0.410459702520260645318  0.482713753678866489204\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -0.073185637507085073678\n  0.354017365856802376329  |  0                        0.260124675758295622809  0.032540262154909133015\n  0.882527661964732346425  |  0                        0                       -0.060576148825500558762\n  0.642615758240322548157  |  0                        0                       -0.144942775902865915672\n  0.357384241759677451842  |  0                        0                       -0.076881336420335693858\n  0.117472338035267653574  |  0                        0                       -0.052032968680060307651\n  0.833333333333333333333  |  0.330885963040722183948  0.489662957309450192844 -1.378964865748435675821\n  0.309036761204472681298  | -0.072954784731363262918  0                       -0.851236239662007619739\n  0.539357840802981787532  |  0                       -0.777333643644968233538  0\n  0.1                      |  0                        0                        0\n  1                        |  0                        0.259111214548322744512 -0.358278966717952089048\n ------------------------------------------------------------------------------------------------------\n                           |  0                        0.05                     0\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  | -0.059578021181736100156\n  0.882527661964732346425  |  0.321763705601778390100  0.510485725608063031577\n  0.642615758240322548157  | -0.333269719096256706589  0.499269229556880061353  0.509504608929686104236\n  0.357384241759677451842  |  0.239527360324390649107  0.397774662368094639047  0.010755895687360745555\n  0.117472338035267653574  | -0.057695414616854888173  0.194781915712104164976  0.145384923188325069727\n  0.833333333333333333333  | -0.861164195027635666673  5.784288136375372200229  3.288077619851035668904\n  0.309036761204472681298  |  0.398320112318533301719  3.639372631810356060294  1.548228770398303223653\n  0.539357840802981787532  | -0.091089566215517606959  0                        0\n  0.1                      |  0                        0                        0\n  1                        | -1.045948959408833060950  0.930327845415626983292  1.779509594317081024461\n ------------------------------------------------------------------------------------------------------\n                           |  0.04                     0                        0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  | -0.327769124164018874147\n  0.117472338035267653574  | -0.078294271035167077755 -0.114503299361098912184\n  0.833333333333333333333  | -2.386339050931363840134 -3.254793424836439186545 -2.163435416864229823539\n  0.309036761204472681298  | -2.122217147040537160260 -1.583503985453261727133 -1.715616082859362649220\n  0.539357840802981787532  |  0                        0                        0\n  0.1                      |  0                        0                        0\n  1                        |  0.1                     -0.282547569539044081612 -0.159327350119972549169\n ------------------------------------------------------------------------------------------------------\n                           |  0.277429188517743176508  0.277429188517743176508  0.189237478148923490158\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  | -0.024403640575012745213\n  0.539357840802981787532  |  0.091089566215517606959  0.777333643644968233538\n  0.1                      |  0                        0                        0.157178665799771163367\n  1                        | -0.145515894647001510860 -0.259111214548322744512 -0.342758159847189839942 -0.675\n -------------------------------------------------------------------------------------------------------------\n                           | -0.04                    -0.05                    -0.033333333333333333333 -0.025\n ...continued...\n  0                        |\n  0.1                      |\n  0.539357840802981787532  |\n  0.809036761204472681298  |\n  0.309036761204472681298  |\n  0.981074190219795268254  |\n  0.833333333333333333333  |\n  0.354017365856802376329  |\n  0.882527661964732346425  |\n  0.642615758240322548157  |\n  0.357384241759677451842  |\n  0.117472338035267653574  |\n  0.833333333333333333333  |\n  0.309036761204472681298  |\n  0.539357840802981787532  |\n  0.1                      |\n  1                        |\n ---------------------------------------------------\n                           | 0.033333333333333333333 Bibliography [1] A family of embedded Runge-Kutta formulae , Dormand, J. R., Prince, P. J. (1980), Journal of Computational and\n Applied Mathematics 6 (1): 19–26, doi:10.1016/0771-050X(80)90013-3. [2] A New Embedded Pair of Runge-Kutta Formulas of orders 5 and 6 , M. Calvo, J.I. Montijano, L. Randez, Computers & Mathematics\n with Applications, Volume 20, Issue 1, 1990, Pages 15–24, ISSN 0898-1221, http://dx.doi.org/10.1016/0898-1221(90)90064-Q. [3] A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides , J. R. Cash,\n A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201–222, 1990, doi:10.1145/79505.79507. [4] A tenth-order Runge-Kutta method with error estimate , Feagin, T., Proceedings of the IAENG Conf. on Scientific\n Computing. 2007. Used By module~~foodie_integrator_runge_kutta_emd~~UsedByGraph module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie foodie module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_runge_kutta_emdUsedByGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_emdUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_runge_kutta_emd Functions class_name has_fast_mode is_supported supported_schemes Subroutines allocate_integrand_members destroy initialize integr_assign_integr integrate integrate_fast new_Dt Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'runge_kutta_emd' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:4) = [trim(class_name_)//'_stages_6_order_5  ', trim(class_name_)//'_stages_7_order_4  ', trim(class_name_)//'_stages_9_order_6  ', trim(class_name_)//'_stages_17_order_10'] List of supported schemes. Derived Types type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_emd FOODIE integrator: provide an explicit class of embedded Runge-Kutta schemes, from 2nd to 10th order accurate. Components Type Visibility Attributes Name Initial class( integrand_object ), private, allocatable :: U1 First U evaluation. class( integrand_object ), private, allocatable :: U2 Second U evaluation. real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:,:) \\beta Butcher's coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. real(kind=R_P), private :: pp1_inv 1/(p+1) where p is the accuracy order of the lower accurate scheme. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. real(kind=R_P), private :: tolerance Tolerance on the local truncation error. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, private, pass(self) :: new_Dt Compute new estimation of the time step Dt. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private subroutine allocate_integrand_members (self, U) Allocate members of interpolator being of integrand_object class. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(in) :: U Integrand. private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, U, tolerance, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. real(kind=R_P), intent(in), optional :: tolerance Tolerance on the local truncation error (default 0.01). logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit embedded Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit embedded Runge-Kutta scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. private elemental subroutine new_Dt (self, error, Dt) Compute new estimation of the time step Dt. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_emd ), intent(in) :: self Integrator. real(kind=R_P), intent(in) :: error Local truncation error estimation. real(kind=R_P), intent(inout) :: Dt Time step.","tags":"","loc":"module/foodie_integrator_runge_kutta_emd.html","title":"foodie_integrator_runge_kutta_emd – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistage_object foodie_integrator_object penf module~~foodie_integrator_runge_kutta_low_storage~~UsesGraph module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage penf penf penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistage_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_multistage_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object var panmodulefoodie_integrator_runge_kutta_low_storageUsesGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_low_storageUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the low storage property allowing for an efficient use of the memory.\n Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form: \\begin{matrix}\n K_1 = U&#94;n \\\\\n K_2 = 0 \\\\\n\\left.\\begin{matrix}\n K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\\n K_1 = K_1 + B_s K_2\n\\end{matrix}\\right\\} s=1,2,...N_s\\\\\nU&#94;{n+1} = K_1\n\\end{matrix} where Ns is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table\n form. The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being\n meaningless for a first order scheme. However it is added for safety reason. Stage A B C 1 0 1 0 5 stages, SSP, 4th order This scheme is a low storage RK(5, 4), based on the solution 3 proposed in [2]. Stage A B C 1 0 1432997174477/9575080441755 0 2 -567301805773 /1357537059087 5161836677717/13612068292357 1432997174477/9575080441755 3 -2404267990393/2016746695238 1720146321549/2090206949498 2526269341429/6820363962896 4 -3550918686646/2091501179385 3134564353537/4481467310338 2006345519317/3224310063776 5 -1275806237668/842570457699 2277821191437/14882151754819 2802321613138/2924317926251 6 stages, 4th order This scheme is a low storage RK(6, 4), by [3]. Stage A B C 1 0 0.122000000000 0 2 -0.691750960670 0.477263056358 0.122000000000 3 -1.727127405211 0.381941220320 0.269115878630 4 -0.694890150986 0.447757195744 0.447717183551 5 -1.039942756197 0.498614246822 0.749979795490 6 -1.531977447611 0.186648570846 0.898555413085 7 stages, 4th order This scheme is a low storage RK(7, 4), by [3]. Stage A B C 1 0 0.117322146869 0 2 -0.647900745934 0.503270262127 0.117322146869 3 -2.704760863204 0.233663281658 0.294523230758 4 -0.460080550118 0.283419634625 0.305658622131 5 -0.500581787785 0.540367414023 0.582864148403 6 -1.906532255913 0.371499414620 0.858664273599 7 -1.450000000000 0.136670099385 0.868664273599 12 stages, 4th order This scheme is a low storage RK(12, 4), by [4]. Stage A B C 1 0 0.0650008435125904 0 2 -0.0923311242368072 0.0161459902249842 0.0650008435125904 3 -0.9441056581158819 0.5758627178358159 0.0796560563081853 4 -4.3271273247576394 0.1649758848361671 0.1620416710085376 5 -2.1557771329026072 0.3934619494248182 0.2248877362907778 6 -0.9770727190189062 0.0443509641602719 0.2952293985641261 7 -0.7581835342571139 0.2074504268408778 0.3318332506149405 8 -1.7977525470825499 0.6914247433015102 0.4094724050198658 9 -2.6915667972700770 0.3766646883450449 0.6356954475753369 10 -4.6466798960268143 0.0757190350155483 0.6806551557645497 11 -0.1539613783825189 0.2027862031054088 0.7143773712418350 12 -0.5943293901830616 0.2167029365631842 0.9032588871651854 13 stages, 4th order This scheme is a low storage RK(13, 4), by [4]. Stage A B C 1 0 0.0271990297818803 0 2 -0.6160178650170565 0.1772488819905108 0.0271990297818803 3 -0.4449487060774118 0.0378528418949694 0.0952594339119365 4 -1.0952033345276178 0.6086431830142991 0.1266450286591127 5 -1.2256030785959187 0.2154313974316100 0.1825883045699772 6 -0.2740182222332805 0.2066152563885843 0.3737511439063931 7 -0.0411952089052647 0.0415864076069797 0.5301279418422206 8 -0.1797084899153560 0.0219891884310925 0.5704177433952291 9 -1.1771530652064288 0.9893081222650993 0.5885784947099155 10 -0.4078831463120878 0.0063199019859826 0.6160769826246714 11 -0.8295636426191777 0.3749640721105318 0.6223252334314046 12 -4.7895970584252288 1.6080235151003195 0.6897593128753419 13 -0.6606671432964504 0.0961209123818189 0.9126827615920843 14 stages, 4th order This scheme is a low storage RK(14, 4), by [4]. Stage A B C 1 0 0.0367762454319673 0 2 -0.7188012108672410 0.3136296607553959 0.0367762454319673 3 -0.7785331173421570 0.1531848691869027 0.1249685262725025 4 -0.0053282796654044 0.0030097086818182 0.2446177702277698 5 -0.8552979934029281 0.3326293790646110 0.2476149531070420 6 -3.9564138245774565 0.2440251405350864 0.2969311120382472 7 -1.5780575380587385 0.3718879239592277 0.3978149645802642 8 -2.0837094552574054 0.6204126221582444 0.5270854589440328 9 -0.7483334182761610 0.1524043173028741 0.6981269994175695 10 -0.7032861106563359 0.0760894927419266 0.8190890835352128 11 0.0013917096117681 0.0077604214040978 0.8527059887098624 12 -0.0932075369637460 0.0024647284755382 0.8604711817462826 13 -0.9514200470875948 0.0780348340049386 0.8627060376969976 14 -7.1151571693922548 5.5059777270269628 0.8734213127600976 Bibliography [1] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [2] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112,\n June 1994. [3] High-accuracy large-step explicit Runge–Kutta (HALE-RK) schemes for computational aeroacoustics , Vasanth Allampalli and\n Ray Hixon and M. Nallasamy and Scott D. Sawyer, Journal of Computational Physics, vol. 228, 2009, pp. 3837–3850. [4] Efficient low-storage Runge–Kutta schemes with optimized stability regions , Jens Niegemann and Richard Diehl and Kurt\n Busch, Journal of Computational Physics, vol. 231, 2012, pp. 364–372. Used By module~~foodie_integrator_runge_kutta_low_storage~~UsedByGraph module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_runge_kutta_low_storageUsedByGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_low_storageUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ registers supported_schemes_ Derived Types integrator_runge_kutta_ls Functions class_name has_fast_mode is_supported registers_number supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'runge_kutta_ls' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. integer(kind=I_P), private, parameter :: registers = 2 Registers used (2N schemes). character(len=99), private, parameter :: supported_schemes_ (1:7) = [trim(class_name_)//'_stages_1_order_1 ', trim(class_name_)//'_stages_5_order_4 ', trim(class_name_)//'_stages_6_order_4 ', trim(class_name_)//'_stages_7_order_4 ', trim(class_name_)//'_stages_12_order_4', trim(class_name_)//'_stages_13_order_4', trim(class_name_)//'_stages_14_order_4'] List of supported schemes. Derived Types type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_ls FOODIE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), private, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), private, allocatable :: C (:) Low storage C coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, nopass :: registers_number Return the number of registers used. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function registers_number () Return the number of registers used. Arguments None Return Value integer(kind=I_P) Number of registers used. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit low storage Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit low storage Runge-Kutta scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ls ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step.","tags":"","loc":"module/foodie_integrator_runge_kutta_low_storage.html","title":"foodie_integrator_runge_kutta_low_storage – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistage_object foodie_integrator_object penf module~~foodie_integrator_runge_kutta_lssp~~UsesGraph module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp penf penf penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistage_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_multistage_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object var panmodulefoodie_integrator_runge_kutta_lsspUsesGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_lsspUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the following 2 forms: Ns stages, Ns-1 order  U&#94;0 = U&#94;n \n  U&#94;k = U&#94;{k-1} + \\frac{1}{2} \\Delta t R(U&#94;{k-1}) \\quad k=1,..,Ns \n  U&#94;{Ns} = U&#94;{Ns} + \\frac{1}{2} \\Delta t R(U&#94;{Ns}) \n  U&#94;{n+1} = \\sum_{k=1}&#94;{Ns}\\alpha_k U&#94;k  where Ns is the number of stages used and U&#94;k is the k&#94;{th} stage. The minimum number of stages is 2. The\n coefficients \\alpha are computed by means of the following recursive algorith: Computation of coefficients allocate coefficients array, allocate(alpha(1:Ns)) ; initialize the first 2 elements with the coefficients of the two stages first order methods, alpha(1)=0, alpha(2)=1 ; for i in [3,Ns] do: alpha(i) = (2 / i) * alpha(i-1) for j in [i-1,2,-1] do: alpha(j) = (2 / (j-1)) * alpha(j-1) for j in [2,i] do: alpha(1) = 1 - alpha(j) Ns stages, Ns order  U&#94;0 = U&#94;n \n  U&#94;k = U&#94;{k-1} + \\Delta t R(U&#94;{k-1}) \\quad k=1,..,Ns \n  U&#94;{Ns} = U&#94;{Ns} +\\Delta t R(U&#94;{Ns}) \n  U&#94;{n+1} = \\sum_{k=1}&#94;{Ns}\\alpha_k U&#94;k  where Ns is the number of stages used and U&#94;k is the k&#94;{th} stage. The minimum number of stages is 1. The\n coefficients \\alpha are computed by means of the following recursive algorith: Computation of coefficients allocate coefficients array, allocate(alpha(1:Ns)) ; initialize the first element with the coefficient of the one stage first order method, alpha(1)=1 ; for i in [2,Ns] do: alpha(i) = 1 / i! for j in [i-1,2,-1] do: alpha(j) = (1 / (j-1)) * alpha(j-1) for j in [2,i] do: alpha(1) = 1 - alpha(j) Note The value of \\Delta t must be provided, it not being computed by the integrator. Bibliography [2] Strong Stability Preserving Runge-Kutta and Multistep Time Discretizations , S. Gottlieb, D. Ketcheson, C.W. Shu,\n 2011, 978-981-4289-26-9, doi:10.1142/7498, World Scientific Publishing Co. Pte. Ltd. Used By module~~foodie_integrator_runge_kutta_lssp~~UsedByGraph module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie foodie module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_runge_kutta_lsspUsedByGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_lsspUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Abstract Interfaces integrate_fast_interface integrate_interface Derived Types integrator_runge_kutta_lssp Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize initialize_order_s initialize_order_s_1 integr_assign_integr integrate integrate_fast integrate_order_s integrate_order_s_1 integrate_order_s_1_fast integrate_order_s_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'runge_kutta_lssp' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:2) = [trim(class_name_)//'_stages_s_order_s_1', trim(class_name_)//'_stages_s_order_s  '] List of supported schemes. Abstract Interfaces abstract interface Abstract interfaces of integrator_runge_kutta_lssp methods. private subroutine integrate_fast_interface (self, U, Dt, t) Integrate field with Linear SSP Runge-Kutta scheme, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. abstract interface Abstract interfaces of integrator_runge_kutta_lssp methods. private subroutine integrate_interface (self, U, Dt, t) Integrate field with Linear SSP Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t Times. Derived Types type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_lssp FOODIE integrator: provide an explicit class of Linear SSP Runge-Kutta schemes, from 1st to s-th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alpha (:) \\alpha coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. procedure( integrate_interface ), private, pointer :: integrate_ => integrate_order_s_1 Integrate integrand field. procedure( integrate_fast_interface ), private, pointer :: integrate_fast_ => integrate_order_s_1_fast Integrate integrand field, fast. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, private, pass(self) :: initialize_order_s Integrate integrator for s-th order formula. procedure, private, pass(self) :: initialize_order_s_1 Integrate integrator for (s-1)-th order formula. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, private, pass(self) :: integrate_order_s Integrate integrand field by s-th order formula. procedure, private, pass(self) :: integrate_order_s_1 Integrate integrand field by (s-1)-th order formula. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, U, stages, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. integer(kind=I_P), intent(in), optional :: stages Stages number. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private elemental subroutine initialize_order_s (self) Initialize integrator for s-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. private elemental subroutine initialize_order_s_1 (self) Initialize integrator for (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate integrand field by Linear SSP Runge-Kutta methods. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate integrand field by Linear SSP Runge-Kutta methods. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. private subroutine integrate_order_s (self, U, Dt, t) Integrate integrand field by s-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_order_s_1 (self, U, Dt, t) Integrate integrand field by (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_order_s_1_fast (self, U, Dt, t) Integrate integrand field by (s-1)-th order formula. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine integrate_order_s_fast (self, U, Dt, t) Integrate integrand field by s-th order formula, fast mode. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_lssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time.","tags":"","loc":"module/foodie_integrator_runge_kutta_lssp.html","title":"foodie_integrator_runge_kutta_lssp – FOODIE"},{"text":"Uses: foodie_error_codes foodie_integrand_object foodie_integrator_multistage_object foodie_integrator_object penf module~~foodie_integrator_runge_kutta_ssp~~UsesGraph module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_error_codes foodie_error_codes module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp penf penf penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_error_codes penf->module~foodie_integrator_object penf->module~foodie_integrator_multistage_object module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_multistage_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object var panmodulefoodie_integrator_runge_kutta_sspUsesGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_sspUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. The integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: gamma&#94;1    | alpha&#94;{1,1}       alpha&#94;{1,2}       ...        alpha&#94;{1,Ns}\n  gamma&#94;2    | alpha&#94;{2,1}       alpha&#94;{2,2}       ...        alpha&#94;{2,Ns}\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        alpha&#94;{Ns,Ns}\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: gamma&#94;1    | 0                 0                 ...        0\n  gamma&#94;2    | alpha&#94;{2,1}       0                 ...        0\n  .          | .                 .                 .          .\n  .          | .                 .                  .         .\n  .          | .                 .                   .        .\n  gamma&#94;{Ns} | alpha&#94;{Ns,1}      alpha&#94;{Ns,2}      ...        0\n ------------|-------------------------------------------------------------\n             | beta&#94;1            beta&#94;2            ...        beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. 0 | 0\n ---|---\n    | 1 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. 0 | 0     0\n  1 | 1     0\n ---|-----------\n    | 1/2   1/2 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. 0   | 0     0     0\n  1   | 1     0     0\n  1/2 | 1/4   1/4   0\n -----|-----------------\n      | 1/6   1/6   1/3 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. 0                | 0                  0                  0                  0                  0\n  0.39175222700392 | 0.39175222700392   0                  0                  0                  0\n  0.58607968896780 | 0.21766909633821   0.36841059262959   0                  0                  0\n  0.47454236302687 | 0.08269208670950   0.13995850206999   0.25189177424738   0                  0\n  0.93501063100924 | 0.06796628370320   0.11503469844438   0.20703489864929   0.54497475021237   0\n ------------------|---------------------------------------------------------------------------------------------\n                   | 0.14681187618661   0.24848290924556   0.10425883036650   0.27443890091960   0.22600748319395 Bibliography [1] Coefficients for the study of Runge-Kutta integration processes , Butcher, J.C., J. Austral. Math. Soc., Vol. 3,\n pages: 185–201, 1963. [2] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of\n Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. Used By module~~foodie_integrator_runge_kutta_ssp~~UsedByGraph module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce program~integrate_euler_1d integrate_euler_1D module~foodie->program~integrate_euler_1d module~type_euler_1d_openmp type_euler_1D_openmp module~foodie->module~type_euler_1d_openmp program~integrate_burgers integrate_burgers module~foodie->program~integrate_burgers module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~foodie->program~integrate_euler_1d_caf~2 module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~foodie->program~integrate_euler_1d_openmp module~type_burgers type_burgers module~foodie->module~type_burgers module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_ladvection module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf program~integrate_lorenz integrate_lorenz module~foodie->program~integrate_lorenz module~foodie_test_lcce_test foodie_test_lcce_test module~foodie->module~foodie_test_lcce_test module~foodie_test_object foodie_test_object module~foodie->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie->module~foodie_test_oscillation_test module~type_lorenz type_lorenz module~foodie->module~type_lorenz module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_object module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~type_burgers->program~integrate_burgers module~foodie_test_integrand_ladvection->module~foodie_test_object module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation module~type_lorenz->program~integrate_lorenz module~type_euler_1d->program~integrate_euler_1d var panmodulefoodie_integrator_runge_kutta_sspUsedByGraph = svgPanZoom('#modulefoodie_integrator_runge_kutta_sspUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables class_name_ has_fast_mode_ supported_schemes_ Derived Types integrator_runge_kutta_ssp Functions class_name has_fast_mode is_supported supported_schemes Subroutines destroy initialize integr_assign_integr integrate integrate_fast Variables Type Visibility Attributes Name Initial character(len=99), private, parameter :: class_name_ = 'runge_kutta_ssp' Name of the class of schemes. logical, private, parameter :: has_fast_mode_ = .true. Flag to check if integrator provides fast mode integrate. character(len=99), private, parameter :: supported_schemes_ (1:4) = [trim(class_name_)//'_stages_1_order_1', trim(class_name_)//'_stages_2_order_2', trim(class_name_)//'_stages_3_order_3', trim(class_name_)//'_stages_5_order_4'] List of supported schemes. Derived Types type, public, extends( integrator_multistage_object ) :: integrator_runge_kutta_ssp FOODIE integrator: provide an explicit class of SSP Runge-Kutta schemes, from 1st to 4th order accurate. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), private, allocatable :: beta (:) \\beta Butcher's coefficients. class( integrand_object ), public, allocatable :: buffer Buffer used for fast integration. character(len=:), public, allocatable :: description_ Informative description of the integrator. integer(kind=I_P), public :: error = 0 Error status code. character(len=:), public, allocatable :: error_message Error message, hopefully meaningful. real(kind=R_P), private, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), public :: registers Number of registers used for stages. class( integrand_object ), public, allocatable :: stage (:) Stages. integer(kind=I_P), public :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: allocate_integrand_members Allocate integrand members. procedure, public, pass(lhs) :: assign_abstract Assign ony members of abstract integrator_object type. procedure, public, pass(lhs) :: assign_multistage Assign members of integrator_multistage_object and parents. generic, public :: assignment(=) => integr_assign_integr Overload = . procedure, public, pass(self) :: check_error Check for error occurrencies. procedure, public, pass(self) :: class_name Return the class name of schemes. procedure, public, pass(self) :: description Return informative integrator description. procedure, public, pass(self) :: destroy Destroy the integrator. procedure, public, pass(self) :: destroy_abstract Destroy only members of abstract integrator_object type. procedure, public, pass(self) :: destroy_multistage Destroy the integrator. procedure, public, pass(self) :: has_fast_mode Return .true. if the integrator class has fast mode integrate. procedure, public, pass(self) :: initialize Initialize (create) the integrator. procedure, public, pass(lhs) :: integr_assign_integr Operator = . procedure, public, pass(self) :: integrate Integrate integrand field. procedure, public, pass(self) :: integrate_fast Integrate integrand field, fast mode. procedure, public, pass(self) :: is_multistage Return .true. for multistage integrator. procedure, public, pass(self) :: is_multistep Return .true. for multistep integrator. procedure, public, pass(self) :: is_supported Return .true. if the integrator class support the given scheme. procedure, public, pass(self) :: stages_number Return number of stages used. procedure, public, pass(self) :: steps_number Return number of steps used. procedure, public, pass(self) :: supported_schemes Return the list of supported schemes. procedure, public, pass(self) :: trigger_error Trigger an error. Functions private pure function class_name (self) Return the class name of schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99) Class name. private elemental function has_fast_mode (self) Return .true. if the integrator class has fast mode integrate. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value logical Inquire result. private elemental function is_supported (self, scheme) Return .true. if the integrator class support the given scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. Return Value logical Inquire result. private pure function supported_schemes (self) result(schemes) Return the list of supported schemes. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(in) :: self Integrator. Return Value character(len=99),\n  allocatable, (:) Queried scheme. Subroutines private elemental subroutine destroy (self) Destroy the integrator. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. private subroutine initialize (self, scheme, U, stop_on_fail) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. character(len=*), intent(in) :: scheme Selected scheme. class( integrand_object ), intent(in), optional :: U Integrand molding prototype. logical, intent(in), optional :: stop_on_fail Stop execution if initialization fail. private subroutine integr_assign_integr (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: lhs Left hand side. class( integrator_object ), intent(in) :: rhs Right hand side. private subroutine integrate (self, U, Dt, t, new_Dt) Integrate field with explicit SSP Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step. private subroutine integrate_fast (self, U, Dt, t, new_Dt) Integrate field with explicit SSP Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( integrator_runge_kutta_ssp ), intent(inout) :: self Integrator. class( integrand_object ), intent(inout) :: U Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(out), optional :: new_Dt New adapted time step.","tags":"","loc":"module/foodie_integrator_runge_kutta_ssp.html","title":"foodie_integrator_runge_kutta_ssp – FOODIE"},{"text":"Uses: penf module~~foodie_utils~~UsesGraph module~foodie_utils foodie_utils penf penf penf->module~foodie_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FOODIE utils: module of (possible) unrelated utilities of FOODIE library. Functions is_admissible Subroutines tokenize Functions public elemental function is_admissible (n, adm_range) Check if the queried number n is admitted by the admissible range list adm_range . Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: n Number queried. character(len=*), intent(in) :: adm_range Admissible range string. Return Value logical Is true is the number is in adm_range . Subroutines private pure subroutine tokenize (string, delimiter, toks, Nt) Tokenize a string in order to parse it. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string String to be tokenized. character(len=*), intent(in) :: delimiter Delimiter of tokens. character(len=len(string)), intent(out), allocatable :: toks (:) Tokens. integer(kind=I_P), intent(out), optional :: Nt Number of tokens.","tags":"","loc":"module/foodie_utils.html","title":"foodie_utils – FOODIE"},{"text":"Uses: iso_fortran_env flap foodie foodie_test_integrand_lcce penf module~~foodie_test_lcce_test~~UsesGraph module~foodie_test_lcce_test foodie_test_lcce_test module~foodie foodie module~foodie->module~foodie_test_lcce_test module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_lcce_test penf->module~foodie penf->module~foodie_test_integrand_lcce module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss penf->module~foodie_test_integrand_tester_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_test_lcce_test iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_test_integrand_lcce->module~foodie_test_lcce_test flap flap flap->module~foodie_test_lcce_test flap->module~foodie_test_integrand_lcce flap->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce var panmodulefoodie_test_lcce_testUsesGraph = svgPanZoom('#modulefoodie_test_lcce_testUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Linear constant coefficients test handler definition. Used By module~~foodie_test_lcce_test~~UsedByGraph module~foodie_test_lcce_test foodie_test_lcce_test program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types lcce_test Functions observed_order Subroutines check_scheme_has_fast_mode execute initialize integrate save_results test Derived Types type, public :: lcce_test Class to handle linear constant coefficients equation test(s). Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. real(kind=R_P), private :: U0 = 0._R_P Initial conditions. real(kind=R_P), private :: a = 0._R_P a coefficient. real(kind=R_P), private :: b = 0._R_P b coefficient. type(command_line_interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error = 0 Error handler. logical, private :: errors_analysis = .false. Flag for activating errors analysis. logical, private :: exact_solution = .false. Flag for activating exact solution saving. real(kind=R_P), private :: final_time = 0.0_R_P Final integration time. integer(kind=I_P), private :: implicit_iterations = 0 Number of iterations (implicit solvers). logical, private :: is_fast = .false. Flag for activating fast schemes. character(len=99), private :: output = '' Output files basename. logical, private :: results = .false. Flag for activating results saving. character(len=99), private :: scheme = '' Scheme used. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). procedure, private, pass(self) :: initialize Initialize test: set Command Line Interface, parse it and check its validity. procedure, private, pass(self) :: test Perform the test. Functions private pure function observed_order (error, Dt) Estimate the order of accuracy using 2 subsequent refined numerical solutions. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:2) Computed errors. real(kind=R_P), intent(in) :: Dt (1:2) Time steps used. Return Value real(kind=R_P) Estimation of the order of accuracy. Subroutines private subroutine check_scheme_has_fast_mode (scheme, integrator) Check if a scheme support fast mode integrate. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Scheme name. class( integrator_object ), intent(in) :: integrator Integrator instance. private subroutine execute (self) Execute selected test(s). Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(inout) :: self Test. private subroutine initialize (self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(inout) :: self Test. private subroutine integrate (scheme, a, b, U0, final_time, Dt, iterations, stages, is_fast, solution, error, last_step) Integrate domain by means of the given scheme. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected scheme. real(kind=R_P), intent(in) :: a a coefficient. real(kind=R_P), intent(in) :: b b coefficient. real(kind=R_P), intent(in) :: U0 Initial state. real(kind=R_P), intent(in) :: final_time Final integration time. real(kind=R_P), intent(in) :: Dt Time step. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. integer(kind=I_P), intent(in) :: stages Number of stages. logical, intent(in) :: is_fast Activate fast mode integration. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step, X-Y. real(kind=R_P), intent(out) :: error Error (norm L2) with respect the exact solution. integer(kind=I_P), intent(out) :: last_step Last time step computed. private subroutine save_results (results, output, scheme, a, b, U0, save_exact_solution, solution) Save results (and plots). Arguments Type Intent Optional Attributes Name logical, intent(in) :: results Flag for activating results saving. character(len=*), intent(in) :: output Output files basename coming from CLI. character(len=*), intent(in) :: scheme Selected scheme: must be defined into solvers . real(kind=R_P), intent(in) :: a a coefficient. real(kind=R_P), intent(in) :: b b coefficient. real(kind=R_P), intent(in) :: U0 Initial state. logical, intent(in) :: save_exact_solution Flag for saving exact solution. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. private subroutine test (self, scheme) Perform the test. Arguments Type Intent Optional Attributes Name class( lcce_test ), intent(in) :: self Test. character(len=*), intent(in) :: scheme Selected scheme.","tags":"","loc":"module/foodie_test_lcce_test.html","title":"foodie_test_lcce_test – FOODIE"},{"text":"Uses: iso_fortran_env flap foodie foodie_test_integrand_oscillation penf module~~foodie_test_oscillation_test~~UsesGraph module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie foodie module~foodie->module~foodie_test_oscillation_test module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_oscillation_test penf->module~foodie penf->module~foodie_test_integrand_oscillation module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss penf->module~foodie_test_integrand_tester_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_test_oscillation_test iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test flap flap flap->module~foodie_test_oscillation_test flap->module~foodie_test_integrand_oscillation flap->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation var panmodulefoodie_test_oscillation_testUsesGraph = svgPanZoom('#modulefoodie_test_oscillation_testUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Oscillation test handler definition. Used By module~~foodie_test_oscillation_test~~UsedByGraph module~foodie_test_oscillation_test foodie_test_oscillation_test program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types oscillation_test Functions observed_order Subroutines check_scheme_has_fast_mode execute initialize integrate save_results test Derived Types type, public :: oscillation_test Class to handle oscillation test(s). Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. real(kind=R_P), private :: U0 (1:2) = [0._R_P, 0._R_P] Initial conditions. type(command_line_interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error = 0 Error handler. logical, private :: errors_analysis = .false. Flag for activating errors analysis. logical, private :: exact_solution = .false. Flag for activating exact solution saving. real(kind=R_P), private :: final_time = 0.0_R_P Final integration time. real(kind=R_P), private :: frequency = 0.0_R_P Oscillation frequency. integer(kind=I_P), private :: implicit_iterations = 0 Number of iterations (implicit solvers). logical, private :: is_fast = .false. Flag for activating fast schemes. character(len=99), private :: output = '' Output files basename. logical, private :: results = .false. Flag for activating results saving. character(len=99), private :: scheme = '' Scheme used. integer(kind=I_P), private :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). procedure, private, pass(self) :: initialize Initialize test: set Command Line Interface, parse it and check its validity. procedure, private, pass(self) :: test Perform the test. Functions private pure function observed_order (error, Dt) Estimate the order of accuracy using 2 subsequent refined numerical solutions. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:,1:) Computed errors. real(kind=R_P), intent(in) :: Dt (1:) Time steps used. Return Value real(kind=R_P)\n  (1:size(error,dim=1)) Estimation of the order of accuracy. Subroutines private subroutine check_scheme_has_fast_mode (scheme, integrator) Check if a scheme support fast mode integrate. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Scheme name. class( integrator_object ), intent(in) :: integrator Integrator instance. private subroutine execute (self) Execute test(s). Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. private subroutine initialize (self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(inout) :: self Test. private subroutine integrate (scheme, frequency, U0, final_time, Dt, iterations, stages, is_fast, solution, error, last_step) Integrate domain by means of the given scheme. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected scheme. real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: U0 (1:) Initial state. real(kind=R_P), intent(in) :: final_time Final integration time. real(kind=R_P), intent(in) :: Dt Time step. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. integer(kind=I_P), intent(in) :: stages Number of stages. logical, intent(in) :: is_fast Activate fast mode integration. real(kind=R_P), intent(out), allocatable :: solution (:,:) Solution at each time step, X-Y. real(kind=R_P), intent(out) :: error (1:) Error (norm L2) with respect the exact solution. integer(kind=I_P), intent(out) :: last_step Last time step computed. private subroutine save_results (results, output, scheme, frequency, U0, save_exact_solution, solution) Save results (and plots). Arguments Type Intent Optional Attributes Name logical, intent(in) :: results Flag for activating results saving. character(len=*), intent(in) :: output Output files basename coming from CLI. character(len=*), intent(in) :: scheme Selected scheme: must be defined into solvers . real(kind=R_P), intent(in) :: frequency Oscillation frequency. real(kind=R_P), intent(in) :: U0 (1:) Initial state. logical, intent(in) :: save_exact_solution Flag for saving exact solution. real(kind=R_P), intent(in) :: solution (0:,0:) Solution at each time step. private subroutine test (self, scheme) Perform the test. Arguments Type Intent Optional Attributes Name class( oscillation_test ), intent(in) :: self Test. character(len=*), intent(in) :: scheme Selected scheme.","tags":"","loc":"module/foodie_test_oscillation_test.html","title":"foodie_test_oscillation_test – FOODIE"},{"text":"Uses: IR_Precision wenoof module~~type_euler_1d_caf_no_foodie~~UsesGraph module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie wenoof wenoof wenoof->module~type_euler_1d_caf_no_foodie IR_Precision IR_Precision IR_Precision->module~type_euler_1d_caf_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define Euler 1D (CAF enabled) field without extending FOODIE integrand. Used By module~~type_euler_1d_caf_no_foodie~~UsedByGraph module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie program~integrate_euler_1d_caf integrate_euler_1D_caf module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables U_L U_R remote_U remote_U Derived Types euler_1D_caf_nf tvd_runge_kutta_integrator Functions E H a compute_dt conservative2primitive dEuler_dt output p primitive2conservative r Subroutines compute_inter_states destroy destroy_rk euler_assign_euler impose_boundary_conditions init init_rk integrate_rk reconstruct_interfaces_states riemann_solver synchronize Variables Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: U_L (:,:) Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real(kind=R_P), private, allocatable :: U_R (:,:) Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. real(kind=R_P), private, allocatable :: remote_U (:,:)[:] CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: remote_U (:,:) CAF buffer for sharing remote conservative variables. Derived Types type, public :: euler_1D_caf_nf Euler 1D (CAF enabled) PDEs system field. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: we = 0 Number of CAF images used. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. generic, public :: assignment(=) => assign_integrand Overloading = assignament. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. procedure, private, pass(self) :: synchronize Synchronize CAF images. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. type, public :: tvd_runge_kutta_integrator TVD RK integrator. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), public :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. Functions private elemental function E (p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). private elemental function H (p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). private elemental function a (p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. private function dEuler_dt (self) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_caf_nf ) Euler field time derivative. private pure function output (self, conservative) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. private elemental function p (r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. private elemental function r (p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Subroutines private pure subroutine compute_inter_states (r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. private subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. private elemental subroutine destroy_rk (self) Destoy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_caf_nf ), intent(in) :: rhs Right hand side. private subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. private elemental subroutine init_rk (self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. private subroutine integrate_rk (self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_caf_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_caf_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. private subroutine synchronize (self) Synchronize CAF images. Arguments Type Intent Optional Attributes Name class( euler_1D_caf_nf ), intent(in) :: self Euler field.","tags":"","loc":"module/type_euler_1d_caf_no_foodie.html","title":"type_euler_1D_caf_no_foodie – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d_caf~~UsesGraph module~type_euler_1d_caf type_euler_1D_caf module~foodie foodie module~foodie->module~type_euler_1d_caf IR_Precision IR_Precision IR_Precision->module~type_euler_1d_caf wenoof wenoof wenoof->module~type_euler_1d_caf module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmoduletype_euler_1d_cafUsesGraph = svgPanZoom('#moduletype_euler_1d_cafUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define Euler 1D (CAF enabled) field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d_caf~~UsedByGraph module~type_euler_1d_caf type_euler_1D_caf program~integrate_euler_1d_caf~2 integrate_euler_1D_caf module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables U_L U_R remote_U remote_U Derived Types euler_1D_caf Functions E H a add_euler compute_dt conservative2primitive dEuler_dt euler_local_error euler_multiply_euler euler_multiply_real output p primitive2conservative r real_multiply_euler sub_euler Subroutines compute_inter_states destroy euler_assign_euler euler_assign_real impose_boundary_conditions init reconstruct_interfaces_states riemann_solver synchronize Variables Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: U_L (:,:) Integrand (state) variables, left ghost cells [1:Nc,1:Ng]. real(kind=R_P), private, allocatable :: U_R (:,:) Integrand (state) variables, right ghost cells [1:Nc,Ni-Ng+1:Ni]. real(kind=R_P), private, allocatable :: remote_U (:,:)[:] CAF buffer for sharing remote conservative variables. real(kind=R_P), private, allocatable :: remote_U (:,:) CAF buffer for sharing remote conservative variables. Derived Types type, public, extends(integrand) :: euler_1D_caf Euler 1D PDEs system field. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: me = 0 ID of this_image(). integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: we = 0 Number of CAF images used. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: init Init field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. procedure, public, pass(self) :: output Extract Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. procedure, private, pass(self) :: synchronize Synchronize CAF images. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. Functions private elemental function E (p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). private elemental function H (p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). private elemental function a (p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function output (self, conservative) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. logical, intent(in), optional :: conservative Output conservative variables instead of primitive. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. private elemental function p (r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. private elemental function r (p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_caf ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Subroutines private pure subroutine compute_inter_states (r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. private subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, me, we, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension (local image). integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in) :: me ID of this_image(). integer(kind=I_P), intent(in) :: we Number of CAF images used. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. private subroutine synchronize (self) Synchronize CAF images. Arguments Type Intent Optional Attributes Name class( euler_1D_caf ), intent(in) :: self Euler field.","tags":"","loc":"module/type_euler_1d_caf.html","title":"type_euler_1D_caf – FOODIE"},{"text":"Uses: IR_Precision wenoof module~~type_euler_1d_openmp_no_foodie~~UsesGraph module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie wenoof wenoof wenoof->module~type_euler_1d_openmp_no_foodie IR_Precision IR_Precision IR_Precision->module~type_euler_1d_openmp_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define Euler 1D (OpenMP enabled) field without extending FOODIE integrand. Used By module~~type_euler_1d_openmp_no_foodie~~UsedByGraph module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types euler_1D_omp_nf tvd_runge_kutta_integrator Functions E H a compute_dt conservative2primitive dEuler_dt output p primitive2conservative r Subroutines compute_inter_states destroy destroy_rk euler_assign_euler impose_boundary_conditions init init_rk integrate_rk reconstruct_interfaces_states riemann_solver Derived Types type, public :: euler_1D_omp_nf Euler 1D (OpenMP enabled) PDEs system field. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, private, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. generic, public :: assignment(=) => assign_integrand Overloading = assignament. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. procedure, private, pass(self) :: t => dEuler_dt Time derivative, residuals function. type, public :: tvd_runge_kutta_integrator TVD RK integrator. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. integer(kind=I_P), public :: stages = 0 Number of stages. Type-Bound Procedures procedure, public, pass(self) :: destroy => destroy_rk Destroy the integrator. procedure, public, pass(self) :: init => init_rk Initialize (create) the integrator. procedure, public, pass(self) :: integrate => integrate_rk Integrate integrand field. Functions private elemental function E (p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). private elemental function H (p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). private elemental function a (p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. private function dEuler_dt (self) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value type( euler_1D_omp_nf ) Euler field time derivative. private pure function output (self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. private elemental function p (r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. private elemental function r (p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Subroutines private pure subroutine compute_inter_states (r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. private elemental subroutine destroy_rk (self) Destoy the integrator. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: lhs Left hand side. class( euler_1D_omp_nf ), intent(in) :: rhs Right hand side. private pure subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. private elemental subroutine init_rk (self, stages) Create the actual RK integrator: initialize the Butcher' table coefficients. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. private subroutine integrate_rk (self, U, stage, Dt, t) Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( euler_1D_omp_nf ), intent(inout) :: U Field to be integrated. class( euler_1D_omp_nf ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_omp_nf ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes.","tags":"","loc":"module/type_euler_1d_openmp_no_foodie.html","title":"type_euler_1D_openmp_no_foodie – FOODIE"},{"text":"Uses: IR_Precision foodie wenoof module~~type_euler_1d_openmp~~UsesGraph module~type_euler_1d_openmp type_euler_1D_openmp module~foodie foodie module~foodie->module~type_euler_1d_openmp IR_Precision IR_Precision IR_Precision->module~type_euler_1d_openmp wenoof wenoof wenoof->module~type_euler_1d_openmp module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmoduletype_euler_1d_openmpUsesGraph = svgPanZoom('#moduletype_euler_1d_openmpUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d_openmp~~UsedByGraph module~type_euler_1d_openmp type_euler_1D_openmp program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types euler_1D_openmp Functions E H a add_euler compute_dt conservative2primitive dEuler_dt euler_local_error euler_multiply_euler euler_multiply_real output p primitive2conservative r real_multiply_euler sub_euler Subroutines compute_inter_states destroy euler_assign_euler euler_assign_real impose_boundary_conditions init reconstruct_interfaces_states riemann_solver Derived Types type, public, extends(integrand) :: euler_1D_openmp Euler 1D (OpenMP enabled) PDEs system field. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1:Ni]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: init Init field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. procedure, public, pass(lhs) :: local_error => euler_local_error ||euler-euler||. procedure, public, pass(self) :: output Extract Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. Functions private elemental function E (p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). private elemental function H (p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). private elemental function a (p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function output (self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. private elemental function p (r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. private elemental function r (p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D_openmp ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Subroutines private pure subroutine compute_inter_states (r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private pure subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D_openmp ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes.","tags":"","loc":"module/type_euler_1d_openmp.html","title":"type_euler_1D_openmp – FOODIE"},{"text":"Uses: IR_Precision foodie module~~type_burgers~~UsesGraph module~type_burgers type_burgers module~foodie foodie module~foodie->module~type_burgers IR_Precision IR_Precision IR_Precision->module~type_burgers module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmoduletype_burgersUsesGraph = svgPanZoom('#moduletype_burgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define Burgers field that is a concrete extension of the abstract integrand type. Used By module~~type_burgers~~UsedByGraph module~type_burgers type_burgers program~integrate_burgers integrate_burgers module~type_burgers->program~integrate_burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types burgers Functions add_burgers burgers_local_error burgers_multiply_burgers burgers_multiply_real compute_dt d2Burgers_dx2 dBurgers_dt dBurgers_dx output previous_step real_multiply_burgers sub_burgers Subroutines burgers_assign_burgers burgers_assign_real init update_previous_steps Derived Types type, public, extends(integrand) :: burgers Burgers equations field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: Ni = 0 Number of grid nodes. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. integer(kind=I_P), private :: steps = 0 Number of time steps stored. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: init Init field. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. procedure, public, pass(lhs) :: local_error => burgers_local_error Local error. procedure, public, pass(self) :: output Extract Burgers field. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. Functions private function add_burgers (lhs, rhs) result(opr) Add two Burgers fields. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function burgers_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 burgers approximations. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private function burgers_multiply_burgers (lhs, rhs) result(opr) Multiply a Burgers field by another one. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function burgers_multiply_real (lhs, rhs) result(opr) Multiply a Burgers field by a real scalar. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function compute_dt (self, CFL) result(dt) Compute the current time step, by means of CFL condition. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. private function d2Burgers_dx2 (self) result(derivative) Compute the second order spatial derivative of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. private function dBurgers_dt (self, t) result(dState_dt) Time derivative of Burgers field, residuals function. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Burgers field time derivative. private function dBurgers_dx (self) result(derivative) Compute the first order spatial derivative of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value type( burgers ) Burgers field derivative. private pure function output (self) result(state) Output the Burgers field state. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:), allocatable Burgers state variable. private function previous_step (self, n) result(previous) Extract previous time solution of Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Burgers field. private function real_multiply_burgers (lhs, rhs) result(opr) Multiply a real scalar by a Burgers field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function sub_burgers (lhs, rhs) result(opr) Subtract two Burgers fields. Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Subroutines private subroutine burgers_assign_burgers (lhs, rhs) Assign one Burgers field to another. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. private subroutine burgers_assign_real (lhs, rhs) Assign one real to a Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private subroutine init (self, initial_state, Ni, h, nu, steps) Construct an initialized Burgers field. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. private subroutine update_previous_steps (self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps.","tags":"","loc":"module/type_burgers.html","title":"type_burgers – FOODIE"},{"text":"Uses: foodie penf wenoof module~~type_euler_1d~~UsesGraph module~type_euler_1d type_euler_1D module~foodie foodie module~foodie->module~type_euler_1d penf penf penf->module~type_euler_1d penf->module~foodie module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss wenoof wenoof wenoof->module~type_euler_1d module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmoduletype_euler_1dUsesGraph = svgPanZoom('#moduletype_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define Euler 1D field that is a concrete extension of the abstract integrand type. Used By module~~type_euler_1d~~UsedByGraph module~type_euler_1d type_euler_1D program~integrate_euler_1d integrate_euler_1D module~type_euler_1d->program~integrate_euler_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types euler_1D Functions E H a add_euler compute_dt conservative2primitive dEuler_dt euler_local_error euler_multiply_euler euler_multiply_real output p previous_step primitive2conservative r real_multiply_euler sub_euler Subroutines compute_inter_states destroy euler_assign_euler euler_assign_real impose_boundary_conditions init reconstruct_interfaces_states riemann_solver update_previous_steps Derived Types type, public, extends(integrand) :: euler_1D Euler 1D PDEs system field. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. real(kind=R_P), private :: Dx = 0._R_P Space step. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. integer(kind=I_P), private :: Ns = 0 Number of initial species. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. integer(kind=I_P), private :: steps = 0 Number of time steps stored. type(weno_interpolator_upwind), private :: weno WENO interpolator. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: init Init field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. procedure, public, pass(lhs) :: local_error => euler_local_error Local error. procedure, public, pass(self) :: output Extract Euler field. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. Functions private elemental function E (p, r, u, g) result(energy) Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). private elemental function H (p, r, u, g) result(entalpy) Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). private elemental function a (p, r, g) result(ss) Compute the speed of sound for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. private function add_euler (lhs, rhs) result(opr) Add two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. private pure function conservative2primitive (self, conservative) result(primitive) Convert conservative variables to primitive variables. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. private function dEuler_dt (self, t) result(dState_dt) Time derivative of Euler field, the residuals function. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Euler field time derivative. private function euler_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 euler approximations. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private function euler_multiply_euler (lhs, rhs) result(opr) Multiply an Euler field by another one. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function euler_multiply_real (lhs, rhs) result(opr) Multiply an Euler field by a real scalar. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function output (self) result(state) Output the Euler field state (primitive variables). Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:), allocatable Euler state vector. private elemental function p (r, a, g) result(pressure) Compute the pressure for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. private function previous_step (self, n) result(previous) Extract previous time solution of Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Euler field. private pure function primitive2conservative (self, primitive) result(conservative) Convert primitive variables to conservative variables. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. private elemental function r (p, a, g) result(density) Compute the density for an ideal calorically perfect gas. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. private function real_multiply_euler (lhs, rhs) result(opr) Multiply a real scalar by an Euler field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( euler_1D ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function sub_euler (lhs, rhs) result(opr) Subtract two Euler fields. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Subroutines private pure subroutine compute_inter_states (r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Compute inter states (23*-states) from state1 and state4. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. private pure subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. private subroutine euler_assign_euler (lhs, rhs) Assign one Euler field to another. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. private subroutine euler_assign_real (lhs, rhs) Assign one real to an Euler field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private pure subroutine impose_boundary_conditions (self, primitive) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Init field. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. private pure subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. private pure subroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. private subroutine update_previous_steps (self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( euler_1D ), intent(inout) :: self Euler field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps.","tags":"","loc":"module/type_euler_1d.html","title":"type_euler_1D – FOODIE"},{"text":"Uses: IR_Precision foodie module~~type_lorenz~~UsesGraph module~type_lorenz type_lorenz module~foodie foodie module~foodie->module~type_lorenz IR_Precision IR_Precision IR_Precision->module~type_lorenz module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmoduletype_lorenzUsesGraph = svgPanZoom('#moduletype_lorenzUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define Lorenz field that is a concrete extension of the abstract integrand type. Used By module~~type_lorenz~~UsedByGraph module~type_lorenz type_lorenz program~integrate_lorenz integrate_lorenz module~type_lorenz->program~integrate_lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types lorenz Functions add_lorenz dLorenz_dt lorenz_local_error lorenz_multiply_lorenz lorenz_multiply_real output previous_step real_multiply_lorenz sub_lorenz Subroutines init lorenz_assign_lorenz lorenz_assign_real update_previous_steps Derived Types type, public, extends(integrand) :: lorenz Lorenz equations field. Components Type Visibility Attributes Name Initial real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. integer(kind=I_P), private :: dims = 0 Space dimensions. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. integer(kind=I_P), private :: steps = 0 Number of time steps stored. Type-Bound Procedures procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. procedure, public, pass(self) :: init Init field. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. procedure, public, pass(lhs) :: local_error => lorenz_local_error Local error. procedure, public, pass(self) :: output Extract Lorenz field. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. Functions private function add_lorenz (lhs, rhs) result(opr) Add two Lorenz fields. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function dLorenz_dt (self, t) result(dState_dt) Time derivative of Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. real(kind=R_P), intent(in), optional :: t Time. Return Value class(integrand),\n  allocatable Lorenz field time derivative. private function lorenz_local_error (lhs, rhs) result(error) Estimate local truncation error between 2 lorenz approximations. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Multiply a lorenz field by another one. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function lorenz_multiply_real (lhs, rhs) result(opr) Multiply a Lorenz field by a real scalar. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private pure function output (self) result(state) Output the Lorenz field state. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:), allocatable Lorenz state vector. private function previous_step (self, n) result(previous) Extract previous time solution of Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class(integrand),\n  allocatable Previous time solution of Lorenz field. private function real_multiply_lorenz (lhs, rhs) result(opr) Multiply a real scalar by a Lorenz field. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. private function sub_lorenz (lhs, rhs) result(opr) Subtract two Lorenz fields. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. Return Value class(integrand),\n  allocatable Operator result. Subroutines private subroutine init (self, initial_state, sigma, rho, beta, steps) Construct an initialized Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. private subroutine lorenz_assign_lorenz (lhs, rhs) Assign one Lorenz field to another. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class(integrand), intent(in) :: rhs Right hand side. private subroutine lorenz_assign_real (lhs, rhs) Assign one real to a Lorenz field. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private subroutine update_previous_steps (self, filter, weights) Update previous time steps. Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class(integrand), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps.","tags":"","loc":"module/type_lorenz.html","title":"type_lorenz – FOODIE"},{"text":"Uses: iso_fortran_env flap foodie foodie_test_integrand_tester_object penf wenoof module~~foodie_test_integrand_ladvection~~UsesGraph module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection penf penf penf->module~foodie_test_integrand_ladvection module~foodie foodie penf->module~foodie module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object penf->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss module~foodie->module~foodie_test_integrand_ladvection module~foodie->module~foodie_test_integrand_tester_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_test_integrand_ladvection iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection wenoof wenoof wenoof->module~foodie_test_integrand_ladvection flap flap flap->module~foodie_test_integrand_ladvection flap->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmodulefoodie_test_integrand_ladvectionUsesGraph = svgPanZoom('#modulefoodie_test_integrand_ladvectionUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define integrand_ladvection , the 1D linear advection PDE test field that is a concrete extension of the\n abstract integrand type. Used By module~~foodie_test_integrand_ladvection~~UsedByGraph module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie_test_object foodie_test_object module~foodie_test_integrand_ladvection->module~foodie_test_object program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types integrand_ladvection Functions compute_dt compute_dx dU_dt description error exact_solution integrand_add_integrand integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_real integrand_multiply_real_scalar integrand_sub_integrand integrand_sub_real local_error output real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand Subroutines assign_integrand assign_real destroy export_tecplot impose_boundary_conditions initialize parse_cli reconstruct_interfaces set_cli set_sin_wave_initial_state set_square_wave_initial_state Derived Types type, public, extends( integrand_tester_object ) :: integrand_ladvection 1D linear advection field. Components Type Visibility Attributes Name Initial real(kind=R_P), public :: CFL = 0._R_P CFL value. real(kind=R_P), public :: Dx = 0._R_P Space step. integer(kind=I_P), public :: Ng = 0 Ghost cells number. integer(kind=I_P), public :: Ni = 0 Space dimension. real(kind=R_P), public :: a = 0._R_P Advection coefficient. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. character(len=99), public :: initial_state Initial state. class(interpolator_object), public, allocatable :: interpolator WENO interpolator. real(kind=R_P), public :: length = 0._R_P Domain length. real(kind=R_P), public, allocatable :: u (:) Integrand (state) variable. character(len=99), public :: w_scheme = '' WENO Scheme used. real(kind=R_P), public :: weno_eps = 0._R_P WENO epsilon to avoid division by zero, default value. integer(kind=I_P), public :: weno_order = 0 WENO reconstruction order. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. procedure, public, pass(lhs) :: assign_integrand = operator. procedure, public, pass(lhs) :: assign_real = real operator. generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. procedure, public, pass(self) :: compute_dx Compute the space step by means of CFL condition. procedure, public, pass(self) :: description Return an informative description of the test. procedure, public, pass(self) :: destroy Destroy field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step by means of CFL condition. procedure, public, pass(self) :: error Return error. procedure, public, pass(self) :: exact_solution Return exact solution. procedure, public, pass(self) :: export_tecplot Export integrand to Tecplot file. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. procedure, public, pass(self) :: initialize Initialize integrand. procedure, public, pass(lhs) :: integrand_add_integrand + operator. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. procedure, public, pass(lhs) :: integrand_add_real + real operator. procedure, public, pass(self) :: integrand_dimension Return integrand dimension. procedure, public, pass(lhs) :: integrand_multiply_integrand * operator. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. procedure, public, pass(lhs) :: integrand_multiply_real * real operator. procedure, public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. procedure, public, pass(lhs) :: integrand_sub_integrand - operator. procedure, public, pass(lhs) :: integrand_sub_real - real operator. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. procedure, public, pass(lhs) :: local_error ||integrand_ladvection - integrand_ladvection|| operator. generic, public :: multiply_fast => integrand_multiply_integrand_fast, integrand_multiply_real_scalar_fast Overloading multiply_fast method. generic, public :: operator(*) => integrand_multiply_integrand, integrand_multiply_real, real_multiply_integrand, integrand_multiply_real_scalar, real_scalar_multiply_integrand Overloading * operator. generic, public :: operator(+) => integrand_add_integrand, integrand_add_real, real_add_integrand Overloading + operator. generic, public :: operator(-) => integrand_sub_integrand, integrand_sub_real, real_sub_integrand Overloading - operator. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. procedure, public, pass(self) :: output Extract integrand state field. procedure, public, pass(self) :: parse_cli Initialize from command line interface. procedure, public, pass(rhs) :: real_add_integrand real + operator. procedure, public, pass(rhs) :: real_multiply_integrand real * operator. procedure, public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. procedure, public, pass(rhs) :: real_sub_integrand real - operator. procedure, private, pass(self) :: reconstruct_interfaces Reconstruct interface states. procedure, public, nopass :: set_cli Set command line interface. procedure, private, pass(self) :: set_sin_wave_initial_state Set initial state as a sin wave. procedure, private, pass(self) :: set_square_wave_initial_state Set initial state as a square wave. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. procedure, public, pass(self) :: t => dU_dt Time derivative, residuals. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. Functions private pure function compute_dt (self, final_time, t) result(Dt) Compute the current time step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: final_time Maximum integration time. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P) Time step. private pure function compute_dx (self, Dt) result(Dx) Compute the space step step by means of CFL condition. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: Dt Time step. Return Value real(kind=R_P) Space step. private function dU_dt (self, t) result(dState_dt) Time derivative of advection field, the residuals function. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Advection field time derivative. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private pure function error (self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. private pure function exact_solution (self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_dimension (self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 advection approximations. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private pure function output (self) result(state) Output the advection field state. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. Return Value real(kind=R_P),\n  allocatable, (:) Advection state private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_ladvection ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_ladvection ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. Subroutines private subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) Assign one real to an advection field. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. private subroutine destroy (self) Destroy field. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. private subroutine export_tecplot (self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. private pure subroutine impose_boundary_conditions (self, u) Impose boundary conditions. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(inout) :: u (1-self%Ng:) Conservative variables. private subroutine initialize (self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. private subroutine parse_cli (self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. private subroutine reconstruct_interfaces (self, conservative, r_conservative) Reconstruct interfaces states. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(in) :: self Advection field. real(kind=R_P), intent(in) :: conservative (1-self%Ng:) Conservative variables. real(kind=R_P), intent(inout) :: r_conservative (1:,0:) Reconstructed conservative vars. private subroutine set_cli (cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. private subroutine set_sin_wave_initial_state (self) Set initial state as a sin wave. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field. private subroutine set_square_wave_initial_state (self) Set initial state as a square wave. Arguments Type Intent Optional Attributes Name class( integrand_ladvection ), intent(inout) :: self Advection field.","tags":"","loc":"module/foodie_test_integrand_ladvection.html","title":"foodie_test_integrand_ladvection – FOODIE"},{"text":"Uses: flap foodie foodie_test_integrand_tester_object penf module~~foodie_test_integrand_lcce~~UsesGraph module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie foodie module~foodie->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_integrand_lcce penf->module~foodie penf->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss flap flap flap->module~foodie_test_integrand_lcce flap->module~foodie_test_integrand_tester_object module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmodulefoodie_test_integrand_lcceUsesGraph = svgPanZoom('#modulefoodie_test_integrand_lcceUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define integrand_lcce , the linear constant coefficients equation test field that is a concrete extension of the\n abstract integrand type. Used By module~~foodie_test_integrand_lcce~~UsedByGraph module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie_test_object foodie_test_object module~foodie_test_integrand_lcce->module~foodie_test_object module~foodie_test_lcce_test foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_lcce_test program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types integrand_lcce Functions dU_dt description error exact_solution integrand_add_integrand integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_real integrand_multiply_real_scalar integrand_sub_integrand integrand_sub_real local_error output real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand Subroutines assign_integrand assign_real export_tecplot initialize integrand_add_integrand_fast integrand_multiply_integrand_fast integrand_multiply_real_scalar_fast integrand_subtract_integrand_fast parse_cli set_cli t_fast Derived Types type, public, extends( integrand_tester_object ) :: integrand_lcce The linear constant coefficient equation field. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: U = 0._R_P Integrand (state) variable. real(kind=R_P), private :: U0 = 0._R_P Integrand initial state. real(kind=R_P), private :: a = 0._R_P a constant. real(kind=R_P), private :: b = 0._R_P b constant. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. procedure, public, pass(lhs) :: assign_integrand = operator. procedure, public, pass(lhs) :: assign_real = real operator. generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. procedure, public, pass(self) :: description Return an informative description of the test. procedure, public, pass(self) :: error Return error. procedure, public, pass(self) :: exact_solution Return exact solution. procedure, public, pass(self) :: export_tecplot Export integrand to Tecplot file. procedure, public, pass(self) :: initialize Initialize field. procedure, public, pass(lhs) :: integrand_add_integrand + operator. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. procedure, public, pass(lhs) :: integrand_add_real + real operator. procedure, public, pass(self) :: integrand_dimension Return integrand dimension. procedure, public, pass(lhs) :: integrand_multiply_integrand * operator. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. procedure, public, pass(lhs) :: integrand_multiply_real * real operator. procedure, public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. procedure, public, pass(lhs) :: integrand_sub_integrand - operator. procedure, public, pass(lhs) :: integrand_sub_real - real operator. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. procedure, public, pass(lhs) :: local_error ||integrand_lcce - integrand_lcce|| operator. generic, public :: multiply_fast => integrand_multiply_integrand_fast, integrand_multiply_real_scalar_fast Overloading multiply_fast method. generic, public :: operator(*) => integrand_multiply_integrand, integrand_multiply_real, real_multiply_integrand, integrand_multiply_real_scalar, real_scalar_multiply_integrand Overloading * operator. generic, public :: operator(+) => integrand_add_integrand, integrand_add_real, real_add_integrand Overloading + operator. generic, public :: operator(-) => integrand_sub_integrand, integrand_sub_real, real_sub_integrand Overloading - operator. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. procedure, public, pass(self) :: output Extract integrand state field. procedure, public, pass(self) :: parse_cli Initialize from command line interface. procedure, public, pass(rhs) :: real_add_integrand real + operator. procedure, public, pass(rhs) :: real_multiply_integrand real * operator. procedure, public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. procedure, public, pass(rhs) :: real_sub_integrand real - operator. procedure, public, nopass :: set_cli Set command line interface. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. procedure, public, pass(self) :: t => dU_dt Time derivative, residuals. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. Functions private pure function dU_dt (self, t) result(dState_dt) Time derivative of field. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Integrand time derivative. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private pure function error (self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. private pure function exact_solution (self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_dimension (self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private pure function output (self) result(state) Extract integrand state field. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Integrand. Return Value real(kind=R_P) State. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_lcce ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_lcce ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. Subroutines private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. private subroutine export_tecplot (self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. private pure subroutine initialize (self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private subroutine parse_cli (self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. private subroutine set_cli (cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_lcce ), intent(inout) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time.","tags":"","loc":"module/foodie_test_integrand_lcce.html","title":"foodie_test_integrand_lcce – FOODIE"},{"text":"Uses: flap foodie foodie_test_integrand_tester_object penf module~~foodie_test_integrand_oscillation~~UsesGraph module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie foodie module~foodie->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_integrand_oscillation penf->module~foodie penf->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss flap flap flap->module~foodie_test_integrand_oscillation flap->module~foodie_test_integrand_tester_object module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmodulefoodie_test_integrand_oscillationUsesGraph = svgPanZoom('#modulefoodie_test_integrand_oscillationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define integrand_oscillation , the Oscillation test field that is a concrete extension of the abstract integrand type. Used By module~~foodie_test_integrand_oscillation~~UsedByGraph module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~foodie_test_object foodie_test_object module~foodie_test_integrand_oscillation->module~foodie_test_object program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types integrand_oscillation Functions amplitude_phase dU_dt description error exact_solution integrand_add_integrand integrand_add_real integrand_dimension integrand_multiply_integrand integrand_multiply_real integrand_multiply_real_scalar integrand_sub_integrand integrand_sub_real local_error output real_add_integrand real_multiply_integrand real_scalar_multiply_integrand real_sub_integrand Subroutines assign_integrand assign_real export_tecplot initialize integrand_add_integrand_fast integrand_multiply_integrand_fast integrand_multiply_real_scalar_fast integrand_subtract_integrand_fast parse_cli set_cli t_fast Derived Types type, public, extends( integrand_tester_object ) :: integrand_oscillation The oscillation equations field. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: U (1:2) = [0._R_P, 0._R_P] Integrand (state) variables. real(kind=R_P), private :: U0 (1:2) = [0._R_P, 0._R_P] Initial state. class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. procedure, public, pass(self) :: amplitude_phase Return amplitude and phase of the oscillation. procedure, public, pass(lhs) :: assign_integrand = operator. procedure, public, pass(lhs) :: assign_real = real operator. generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. procedure, public, pass(self) :: description Return an informative description of the test. procedure, public, pass(self) :: error Return error. procedure, public, pass(self) :: exact_solution Return exact solution. procedure, public, pass(self) :: export_tecplot Export integrand to Tecplot file. procedure, public, pass(self) :: initialize Initialize field. procedure, public, pass(lhs) :: integrand_add_integrand + operator. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. procedure, public, pass(lhs) :: integrand_add_real + real operator. procedure, public, pass(self) :: integrand_dimension Return integrand dimension. procedure, public, pass(lhs) :: integrand_multiply_integrand * operator. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. procedure, public, pass(lhs) :: integrand_multiply_real * real operator. procedure, public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. procedure, public, pass(lhs) :: integrand_sub_integrand - operator. procedure, public, pass(lhs) :: integrand_sub_real - real operator. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. procedure, public, pass(lhs) :: local_error ||integrand_oscillation - integrand_oscillation|| operator. generic, public :: multiply_fast => integrand_multiply_integrand_fast, integrand_multiply_real_scalar_fast Overloading multiply_fast method. generic, public :: operator(*) => integrand_multiply_integrand, integrand_multiply_real, real_multiply_integrand, integrand_multiply_real_scalar, real_scalar_multiply_integrand Overloading * operator. generic, public :: operator(+) => integrand_add_integrand, integrand_add_real, real_add_integrand Overloading + operator. generic, public :: operator(-) => integrand_sub_integrand, integrand_sub_real, real_sub_integrand Overloading - operator. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. procedure, public, pass(self) :: output Extract integrand state field. procedure, public, pass(self) :: parse_cli Initialize from command line interface. procedure, public, pass(rhs) :: real_add_integrand real + operator. procedure, public, pass(rhs) :: real_multiply_integrand real * operator. procedure, public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. procedure, public, pass(rhs) :: real_sub_integrand real - operator. procedure, public, nopass :: set_cli Set command line interface. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. procedure, public, pass(self) :: t => dU_dt Time derivative, residuals. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode. Functions private function amplitude_phase (self) result(ap) Compute amplitude and phase of the oscillation. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Advection field. Return Value real(kind=R_P)\n  (1:2) Amplitude and phase. private pure function dU_dt (self, t) result(dState_dt) Time derivative of integrand_oscillation field. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in), optional :: t Time. Return Value real(kind=R_P),\n  allocatable, (:) Integrand time derivative. private pure function description (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private pure function error (self, t, t0, U0) Return error. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. private pure function exact_solution (self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. private pure function integrand_add_integrand (lhs, rhs) result(opr) + operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_add_real (lhs, rhs) result(opr) + real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_dimension (self) return integrand dimension. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self integrand. Return Value integer(kind=I_P) integrand dimension. private pure function integrand_multiply_integrand (lhs, rhs) result(opr) * operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_multiply_real_scalar (lhs, rhs) result(opr) * real_scalar operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_integrand (lhs, rhs) result(opr) - operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function integrand_sub_real (lhs, rhs) result(opr) - real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function local_error (lhs, rhs) result(error) Estimate local truncation error between 2 oscillation approximations. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P) Error estimation. private pure function output (self) result(state) Extract integrand state field. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Integrand. Return Value real(kind=R_P)\n  (1:2) State. private pure function real_add_integrand (lhs, rhs) result(opr) real + operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_scalar_multiply_integrand (lhs, rhs) result(opr) real_scalar * operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand_oscillation ), intent(in) :: rhs Right hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. private pure function real_sub_integrand (lhs, rhs) result(opr) real - operator. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs (1:) Left hand side. class( integrand_oscillation ), intent(in) :: rhs Left hand side. Return Value real(kind=R_P),\n  allocatable, (:) Operator result. Subroutines private pure subroutine assign_integrand (lhs, rhs) = operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine assign_real (lhs, rhs) = real operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs (1:) Right hand side. private subroutine export_tecplot (self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(in) :: self Advection field. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. private pure subroutine initialize (self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. private pure subroutine integrand_add_integrand_fast (opr, lhs, rhs) + fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_integrand_fast (opr, lhs, rhs) * fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private pure subroutine integrand_multiply_real_scalar_fast (opr, lhs, rhs) * real_scalar fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. private pure subroutine integrand_subtract_integrand_fast (opr, lhs, rhs) - fast operator. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: opr Operator result. class( integrand_object ), intent(in) :: lhs Left hand side. class( integrand_object ), intent(in) :: rhs Right hand side. private subroutine parse_cli (self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Advection field. type(command_line_interface), intent(inout) :: cli Command line interface handler. private subroutine set_cli (cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. private subroutine t_fast (self, t) Time derivative function of integrand class, i.e. the residuals function. Fast mode acting directly on self. Arguments Type Intent Optional Attributes Name class( integrand_oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), optional :: t Time.","tags":"","loc":"module/foodie_test_integrand_oscillation.html","title":"foodie_test_integrand_oscillation – FOODIE"},{"text":"Uses: flap foodie penf module~~foodie_test_integrand_tester_object~~UsesGraph module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie foodie module~foodie->module~foodie_test_integrand_tester_object flap flap flap->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_integrand_tester_object penf->module~foodie module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmodulefoodie_test_integrand_tester_objectUsesGraph = svgPanZoom('#modulefoodie_test_integrand_tester_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Define integrand_tester_object , the abstract tester integrand. Used By module~~foodie_test_integrand_tester_object~~UsedByGraph module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie_test_object foodie_test_object module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester module~foodie_test_integrand_lcce->module~foodie_test_object module~foodie_test_lcce_test foodie_test_lcce_test module~foodie_test_integrand_lcce->module~foodie_test_lcce_test module~foodie_test_integrand_oscillation->module~foodie_test_object module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test module~foodie_test_integrand_ladvection->module~foodie_test_object program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test->program~foodie_test_lcce program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test->program~foodie_test_oscillation var panmodulefoodie_test_integrand_tester_objectUsedByGraph = svgPanZoom('#modulefoodie_test_integrand_tester_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces description_interface error_interface exact_solution_interface export_tecplot_interface initialize_interface parse_cli_interface set_cli_interface Derived Types integrand_tester_object Abstract Interfaces abstract interface Abstract interfaces of integrand_tester_object class. private pure function description_interface (self, prefix) result(desc) Return informative integrator description. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of integrand_tester_object class. private pure function error_interface (self, t, t0, U0) result(error) Return error. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Error. abstract interface Abstract interfaces of integrand_tester_object class. private pure function exact_solution_interface (self, t, t0, U0) result(exact) Return exact solution. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in), optional :: t0 Initial time. class( integrand_object ), intent(in), optional :: U0 Initial conditions. Return Value real(kind=R_P),\n  allocatable, (:) Exact solution. abstract interface Abstract interfaces of integrand_tester_object class. private subroutine export_tecplot_interface (self, file_name, t, scheme, close_file, with_exact_solution, U0) Export integrand to Tecplot file. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(in) :: self Integrand. character(len=*), intent(in), optional :: file_name File name. real(kind=R_P), intent(in), optional :: t Time. character(len=*), intent(in), optional :: scheme Scheme used to integrate integrand. logical, intent(in), optional :: close_file Flag for closing file. logical, intent(in), optional :: with_exact_solution Flag for export also exact solution. class( integrand_object ), intent(in), optional :: U0 Initial conditions. abstract interface Abstract interfaces of integrand_tester_object class. private subroutine initialize_interface (self, Dt) Initialize integrand. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(inout) :: self Integrand. real(kind=R_P), intent(in) :: Dt Time step. abstract interface Abstract interfaces of integrand_tester_object class. private subroutine parse_cli_interface (self, cli) Initialize from command line interface. Arguments Type Intent Optional Attributes Name class( integrand_tester_object ), intent(inout) :: self Integrand. type(command_line_interface), intent(inout) :: cli Command line interface handler. abstract interface Abstract interfaces of integrand_tester_object class. private subroutine set_cli_interface (cli) Set command line interface. Arguments Type Intent Optional Attributes Name type(command_line_interface), intent(inout) :: cli Command line interface handler. Derived Types type, public, abstract, extends( integrand_object ) :: integrand_tester_object The abstract tester integrand. Components Type Visibility Attributes Name Initial class(*), public, allocatable :: dummy_to_allow_extensions [:] Dummy member to allow concrete extensions with coarray members. Type-Bound Procedures generic, public :: add_fast => integrand_add_integrand_fast Overloading add_fast method. procedure(assignment_integrand), public, pass(lhs) :: assign_integrand = operator. procedure(assignment_real), public, pass(lhs) :: assign_real = real operator. generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. procedure(description_interface), public, pass(self) :: description Return an informative description of the test. procedure(error_interface), public, pass(self) :: error Return error. procedure(exact_solution_interface), public, pass(self) :: exact_solution Return exact solution. procedure(export_tecplot_interface), public, pass(self) :: export_tecplot Export integrand to Tecplot file. procedure(initialize_interface), public, pass(self) :: initialize Initialize integrand. procedure(symmetric_operator), public, pass(lhs) :: integrand_add_integrand + operator. procedure, public, pass(opr) :: integrand_add_integrand_fast + fast operator. procedure(integrand_op_real), public, pass(lhs) :: integrand_add_real + real operator. procedure(integrand_dimension_interface), public, pass(self) :: integrand_dimension Return integrand dimension. procedure(symmetric_operator), public, pass(lhs) :: integrand_multiply_integrand * operator. procedure, public, pass(opr) :: integrand_multiply_integrand_fast * fast operator. procedure(integrand_op_real), public, pass(lhs) :: integrand_multiply_real * real operator. procedure(integrand_op_real_scalar), public, pass(lhs) :: integrand_multiply_real_scalar * real_scalar operator. procedure, public, pass(opr) :: integrand_multiply_real_scalar_fast * real_scalar fast operator. procedure(symmetric_operator), public, pass(lhs) :: integrand_sub_integrand - operator. procedure(integrand_op_real), public, pass(lhs) :: integrand_sub_real - real operator. procedure, public, pass(opr) :: integrand_subtract_integrand_fast - fast operator. procedure(local_error_operator), public, pass(lhs) :: local_error ||integrand - integrand|| operator. generic, public :: multiply_fast => integrand_multiply_integrand_fast, integrand_multiply_real_scalar_fast Overloading multiply_fast method. generic, public :: operator(*) => integrand_multiply_integrand, integrand_multiply_real, real_multiply_integrand, integrand_multiply_real_scalar, real_scalar_multiply_integrand Overloading * operator. generic, public :: operator(+) => integrand_add_integrand, integrand_add_real, real_add_integrand Overloading + operator. generic, public :: operator(-) => integrand_sub_integrand, integrand_sub_real, real_sub_integrand Overloading - operator. generic, public :: operator(.lterror.) => local_error Estimate local truncation error. procedure(parse_cli_interface), public, pass(self) :: parse_cli Initialize from command line interface. procedure(real_op_integrand), public, pass(rhs) :: real_add_integrand real + operator. procedure(real_op_integrand), public, pass(rhs) :: real_multiply_integrand real * operator. procedure(real_scalar_op_integrand), public, pass(rhs) :: real_scalar_multiply_integrand real_scalar * operator. procedure(real_op_integrand), public, pass(rhs) :: real_sub_integrand real - operator. procedure(set_cli_interface), public, nopass :: set_cli Set command line interface. generic, public :: subtract_fast => integrand_subtract_integrand_fast Overloading subtract_fast method. procedure(time_derivative), public, pass(self) :: t Time derivative, residuals. procedure, public, pass(self) :: t_fast Time derivative, residuals, fast mode.","tags":"","loc":"module/foodie_test_integrand_tester_object.html","title":"foodie_test_integrand_tester_object – FOODIE"},{"text":"Uses: iso_fortran_env flap foodie foodie_test_integrand_ladvection foodie_test_integrand_lcce foodie_test_integrand_oscillation foodie_test_integrand_tester_object penf module~~foodie_test_object~~UsesGraph module~foodie_test_object foodie_test_object module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie_test_integrand_lcce->module~foodie_test_object module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie_test_integrand_ladvection->module~foodie_test_object module~foodie foodie module~foodie->module~foodie_test_object module~foodie->module~foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_ladvection module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object module~foodie_test_integrand_oscillation->module~foodie_test_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_test_object iso_fortran_env->module~foodie_test_integrand_ladvection iso_fortran_env->module~foodie module~foodie_integrator_object foodie_integrator_object iso_fortran_env->module~foodie_integrator_object module~foodie_integrator_multistage_object foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistage_object module~foodie_integrator_multistep_object foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation flap flap flap->module~foodie_test_object flap->module~foodie_test_integrand_lcce flap->module~foodie_test_integrand_ladvection flap->module~foodie_test_integrand_oscillation flap->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_object penf->module~foodie_test_integrand_lcce penf->module~foodie_test_integrand_ladvection penf->module~foodie penf->module~foodie_test_integrand_oscillation penf->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss wenoof wenoof wenoof->module~foodie_test_integrand_ladvection module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panmodulefoodie_test_objectUsesGraph = svgPanZoom('#modulefoodie_test_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Definition of test_object for FOODIE tester factory. Used By module~~foodie_test_object~~UsedByGraph module~foodie_test_object foodie_test_object program~foodie_tester foodie_tester module~foodie_test_object->program~foodie_tester Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types test_object Functions observed_order Subroutines check_scheme_has_fast_mode execute initialize integrate Derived Types type, public :: test_object Generic FOODIE test object. Components Type Visibility Attributes Name Initial real(kind=R_P), private, allocatable :: Dt (:) Time step(s) exercised. type(command_line_interface), private :: cli Command line interface handler. integer(kind=I_P), private :: error Error handler. real(kind=R_P), private :: final_time Final integration time. integer(kind=I_P), private :: implicit_iterations Number of iterations (implicit solvers). class( integrand_tester_object ), private, allocatable :: integrand_0 Initial conditions. logical, private :: is_fast Flag for activating fast schemes. type( integrand_ladvection ), private :: ladvection_0 Initial conditions for linear advection test. type( integrand_lcce ), private :: lcce_0 Initial conditions for linear constant coefficients eq. type( integrand_oscillation ), private :: oscillation_0 Initial conditions for oscillation test. character(len=99), private :: output Output files basename. integer(kind=I_P), private :: save_frequency Save frequency. logical, private :: save_results Flag for activating results saving. character(len=99), private :: scheme Scheme used. integer(kind=I_P), private :: stages Number of stages. Type-Bound Procedures procedure, public, pass(self) :: execute Execute selected test(s). procedure, private, pass(self) :: initialize Initialize test: set Command Line Interface, parse it and check its validity. Functions private pure function observed_order (error, Dt) Estimate the order of accuracy using 2 subsequent refined numerical solutions. Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: error (1:,1:) Computed errors. real(kind=R_P), intent(in) :: Dt (1:) Time steps used. Return Value real(kind=R_P)\n  (1:size(error,dim=1)) Estimation of the order of accuracy. Subroutines private subroutine check_scheme_has_fast_mode (scheme, integrator) Check if a scheme support fast mode integrate. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Scheme name. class( integrator_object ), intent(in) :: integrator Integrator instance. private subroutine execute (self) Execute test(s). Arguments Type Intent Optional Attributes Name class( test_object ), intent(inout) :: self Test. private subroutine initialize (self) Initialize test: set Command Line Interface, parse it and check its validity. Arguments Type Intent Optional Attributes Name class( test_object ), intent(inout) :: self Test. private subroutine integrate (scheme, integrand_0, Dt, final_time, iterations, stages, is_fast, save_results, output_base_name, save_frequency, error) Integrate integrand by means of the given scheme. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: scheme Selected scheme. class( integrand_tester_object ), intent(in) :: integrand_0 Initial conditions. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: final_time Final integration time. integer(kind=I_P), intent(in) :: iterations Number of fixed point iterations. integer(kind=I_P), intent(in) :: stages Number of stages. logical, intent(in) :: is_fast Activate fast mode integration. logical, intent(in) :: save_results Save results. character(len=*), intent(in) :: output_base_name Base name of output results file. integer(kind=I_P), intent(in) :: save_frequency Save frequency. real(kind=R_P), intent(out) :: error (:) Error of integrand integration.","tags":"","loc":"module/foodie_test_object.html","title":"foodie_test_object – FOODIE"},{"text":"Uses: foodie_test_lcce_test program~~foodie_test_lcce~~UsesGraph program~foodie_test_lcce foodie_test_lcce module~foodie_test_lcce_test foodie_test_lcce_test module~foodie_test_lcce_test->program~foodie_test_lcce module~foodie foodie module~foodie->module~foodie_test_lcce_test module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_lcce_test penf->module~foodie penf->module~foodie_test_integrand_lcce module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss penf->module~foodie_test_integrand_tester_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_test_lcce_test iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_test_integrand_lcce->module~foodie_test_lcce_test flap flap flap->module~foodie_test_lcce_test flap->module~foodie_test_integrand_lcce flap->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce var panprogramfoodie_test_lcceUsesGraph = svgPanZoom('#programfoodie_test_lcceUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FOODIE with the integration of linear constant coefficients equation. Variables test Source Code foodie_test_lcce Variables Type Attributes Name Initial type( lcce_test ) :: test Linear constant coefficients equation test. Source Code program foodie_test_lcce !< Test FOODIE with the integration of linear constant coefficients equation. use foodie_test_lcce_test , only : lcce_test implicit none type ( lcce_test ) :: test !< Linear constant coefficients equation test. call test % execute endprogram foodie_test_lcce","tags":"","loc":"program/foodie_test_lcce.html","title":"foodie_test_lcce – FOODIE"},{"text":"Uses: foodie_test_oscillation_test program~~foodie_test_oscillation~~UsesGraph program~foodie_test_oscillation foodie_test_oscillation module~foodie_test_oscillation_test foodie_test_oscillation_test module~foodie_test_oscillation_test->program~foodie_test_oscillation module~foodie foodie module~foodie->module~foodie_test_oscillation_test module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_oscillation_test penf->module~foodie penf->module~foodie_test_integrand_oscillation module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss penf->module~foodie_test_integrand_tester_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_test_oscillation_test iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_test_integrand_oscillation->module~foodie_test_oscillation_test flap flap flap->module~foodie_test_oscillation_test flap->module~foodie_test_integrand_oscillation flap->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation var panprogramfoodie_test_oscillationUsesGraph = svgPanZoom('#programfoodie_test_oscillationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FOODIE with the integration of Oscillation equations. Variables test Source Code foodie_test_oscillation Variables Type Attributes Name Initial type( oscillation_test ) :: test Oscillation test. Source Code program foodie_test_oscillation !< Test FOODIE with the integration of Oscillation equations. use foodie_test_oscillation_test , only : oscillation_test implicit none type ( oscillation_test ) :: test !< Oscillation test. call test % execute endprogram foodie_test_oscillation","tags":"","loc":"program/foodie_test_oscillation.html","title":"foodie_test_oscillation – FOODIE"},{"text":"Uses: flap IR_Precision pyplot_module type_euler_1D_caf_no_foodie program~~integrate_euler_1d_caf~~UsesGraph program~integrate_euler_1d_caf integrate_euler_1D_caf pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_caf flap flap flap->program~integrate_euler_1d_caf module~type_euler_1d_caf_no_foodie type_euler_1D_caf_no_foodie module~type_euler_1d_caf_no_foodie->program~integrate_euler_1d_caf IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_caf IR_Precision->module~type_euler_1d_caf_no_foodie wenoof wenoof wenoof->module~type_euler_1d_caf_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. Calls program~~integrate_euler_1d_caf~~CallsGraph program~integrate_euler_1d_caf integrate_euler_1D_caf proc~save_time_serie save_time_serie program~integrate_euler_1d_caf->proc~save_time_serie str str program~integrate_euler_1d_caf->str proc~init init program~integrate_euler_1d_caf->proc~init proc~synchronize synchronize program~integrate_euler_1d_caf->proc~synchronize strz strz program~integrate_euler_1d_caf->strz proc~save_results~3 save_results program~integrate_euler_1d_caf->proc~save_results~3 proc~save_time_serie->str proc~init->proc~save_time_serie proc~init->str proc~init->strz proc~save_results~3->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables BC_L BC_R CFL Dt Dt Dx Nc Ni Ni Ni_image Np Ns cli count_rate cp0 cv0 domain error final_state id initial_state me ord plots plots profiling results results rk_integrator rk_stage rk_stages steps steps_max steps_max system_clocks t time_serie time_serie verbose verbose we x Subroutines init save_results save_time_serie synchronize Source Code integrate_euler_1D_caf Variables Type Attributes Name Initial character(len=:), allocatable :: BC_L Left boundary condition type. character(len=:), allocatable :: BC_R Right boundary condition type. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. real(kind=R_P), allocatable :: Dt (:)[:] Time step. real(kind=R_P), allocatable :: Dt (:) Time step. real(kind=R_P) :: Dx Space step discretization. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P) :: Ni [*] Number of grid cells. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P) :: Ni_image Space dimension of local image. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. type(command_line_interface) :: cli Command line interface handler. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. type(euler_1D_caf_nf) :: domain Domain of Euler equations. integer(kind=I_P) :: error Error handler. real(kind=R_P), allocatable :: final_state (:,:) Final state. character(len=:), allocatable :: id My ID. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. integer(kind=I_P) :: me ID of this_image() integer, parameter :: ord = 7 Space reconstruciton order, logical :: plots [*] Flag for activating plots saving. logical :: plots Flag for activating plots saving. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. logical :: results [*] Flag for activating results saving. logical :: results Flag for activating results saving. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. type(euler_1D_caf_nf) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. integer(kind=I_P) :: steps Time steps counter. integer(kind=I_P) :: steps_max [*] Maximum number of time steps. integer(kind=I_P) :: steps_max Maximum number of time steps. real(kind=R_P) :: system_clocks Profiling result. real(kind=R_P) :: t Time. logical :: time_serie [*] Flag for activating time serie-results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose [*] Flag for activating more verbose output. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: we Number of CAF images used. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. Subroutines subroutine init () Initialize the simulation. Arguments None subroutine save_results (title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. subroutine save_time_serie (title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. subroutine synchronize () Synchronize CAF images. Arguments None Source Code program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by CAF paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use IR_Precision , only : R_P , I_P , FR_P , str , strz use pyplot_module , only : pyplot use type_euler_1D_caf_no_foodie , only : euler_1D_caf_nf , tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf_nf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, CAF enabled' , & examples = [ \"euler-1D-caf-no-foodie --results  \" , & \"euler-1D-caf-no-foodie -r -t -v -p\" , & \"euler-1D-caf-no-foodie            \" , & \"euler-1D-caf-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"program/integrate_euler_1d_caf.html","title":"integrate_euler_1D_caf – FOODIE"},{"text":"Uses: flap foodie IR_Precision pyplot_module type_euler_1D_caf program~~integrate_euler_1d_caf~2~~UsesGraph program~integrate_euler_1d_caf~2 integrate_euler_1D_caf pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_caf~2 module~foodie foodie module~foodie->program~integrate_euler_1d_caf~2 module~type_euler_1d_caf type_euler_1D_caf module~foodie->module~type_euler_1d_caf flap flap flap->program~integrate_euler_1d_caf~2 module~type_euler_1d_caf->program~integrate_euler_1d_caf~2 IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_caf~2 IR_Precision->module~type_euler_1d_caf module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie wenoof wenoof wenoof->module~type_euler_1d_caf var panprogramintegrate_euler_1d_caf2UsesGraph = svgPanZoom('#programintegrate_euler_1d_caf2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d_caf~2~~CallsGraph program~integrate_euler_1d_caf~2 integrate_euler_1D_caf str str program~integrate_euler_1d_caf~2->str proc~init~3 init program~integrate_euler_1d_caf~2->proc~init~3 proc~save_time_serie~2 save_time_serie program~integrate_euler_1d_caf~2->proc~save_time_serie~2 strz strz program~integrate_euler_1d_caf~2->strz proc~synchronize~3 synchronize program~integrate_euler_1d_caf~2->proc~synchronize~3 proc~save_results~4 save_results program~integrate_euler_1d_caf~2->proc~save_results~4 proc~init~3->str proc~init~3->proc~save_time_serie~2 proc~init~3->strz proc~save_time_serie~2->str proc~save_results~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables BC_L BC_R CFL Dt Dt Dx Nc Ni Ni Ni_image Np Ns cli count_rate cp0 cv0 domain error final_state id initial_state me ord plots plots profiling results results rk_integrator rk_stage rk_stages steps steps_max steps_max system_clocks t time_serie time_serie verbose verbose we x Subroutines init save_results save_time_serie synchronize Source Code integrate_euler_1D_caf Variables Type Attributes Name Initial character(len=:), allocatable :: BC_L Left boundary condition type. character(len=:), allocatable :: BC_R Right boundary condition type. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. real(kind=R_P), allocatable :: Dt (:)[:] Time step. real(kind=R_P), allocatable :: Dt (:) Time step. real(kind=R_P) :: Dx Space step discretization. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P) :: Ni [*] Number of grid cells. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P) :: Ni_image Space dimension of local image. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. type(command_line_interface) :: cli Command line interface handler. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. type(euler_1D_caf) :: domain Domain of Euler equations. integer(kind=I_P) :: error Error handler. real(kind=R_P), allocatable :: final_state (:,:) Final state. character(len=:), allocatable :: id My ID. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. integer(kind=I_P) :: me ID of this_image() integer, parameter :: ord = 7 Space reconstruciton order, logical :: plots [*] Flag for activating plots saving. logical :: plots Flag for activating plots saving. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. logical :: results [*] Flag for activating results saving. logical :: results Flag for activating results saving. type(integrator_runge_kutta_tvd) :: rk_integrator Runge-Kutta integrator. type(euler_1D_caf) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. integer(kind=I_P) :: steps Time steps counter. integer(kind=I_P) :: steps_max [*] Maximum number of time steps. integer(kind=I_P) :: steps_max Maximum number of time steps. real(kind=R_P) :: system_clocks Profiling result. real(kind=R_P) :: t Time. logical :: time_serie [*] Flag for activating time serie-results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose [*] Flag for activating more verbose output. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: we Number of CAF images used. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. Subroutines subroutine init () Initialize the simulation. Arguments None subroutine save_results (title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. subroutine save_time_serie (title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. subroutine synchronize () Synchronize CAF images. Arguments None Source Code program integrate_euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str , strz use pyplot_module , only : pyplot use type_euler_1D_caf , only : euler_1D_caf !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_caf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer , parameter :: ord = 7 !< Space reconstruciton order, real ( R_P ) :: t !< Time. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( len = :), allocatable :: BC_L !< Left boundary condition type. character ( len = :), allocatable :: BC_R !< Right boundary condition type. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. type ( euler_1D_caf ) :: domain !< Domain of Euler equations. ! coarrays-related variables integer ( I_P ) :: Ni_image !< Space dimension of local image. #ifdef CAF integer ( I_P ) :: Ni [ * ] !< Number of grid cells. integer ( I_P ) :: steps_max [ * ] !< Maximum number of time steps. logical :: results [ * ] !< Flag for activating results saving. logical :: plots [ * ] !< Flag for activating plots saving. logical :: time_serie [ * ] !< Flag for activating time serie-results saving. logical :: verbose [ * ] !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:)[:] !< Time step. #else integer ( I_P ) :: Ni !< Number of grid cells. integer ( I_P ) :: steps_max !< Maximum number of time steps. logical :: results !< Flag for activating results saving. logical :: plots !< Flag for activating plots saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. real ( R_P ), allocatable :: Dt (:) !< Time step. #endif integer ( I_P ) :: me !< ID of this_image() integer ( I_P ) :: we !< Number of CAF images used. character ( len = :), allocatable :: id !< My ID. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF me = this_image () we = num_images () #else me = 1 we = 1 #endif id = trim ( strz ( 3 , me )) // '> ' ! setting Command Line Interface call cli % init ( progname = 'euler-1D-caf' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, CAF enabled' , & examples = [ \"euler-1D-caf --results  \" , & \"euler-1D-caf -r -t -v -p\" , & \"euler-1D-caf            \" , & \"euler-1D-caf --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface if ( me == 1 ) then ! only master image do CLI stuffs call cli % parse ( error = error ) call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop endif call init () system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) Dt ( me ) = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call synchronize call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , Dt = Dt ( me ), t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + Dt ( me ) call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , id // '    Time step: ' // str ( n = Dt ( me )) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-image-' // trim ( strz ( 3 , me ))) print \"(A,I5,A,F23.15)\" , id , we , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the simulation. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. real ( R_P ) :: x_L !< Left abscissa of local image. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF ! CAF images comunications sync all if ( me /= 1 ) then Ni = Ni [ 1 ] steps_max = steps_max [ 1 ] results = results [ 1 ] plots = plots [ 1 ] time_serie = time_serie [ 1 ] verbose = verbose [ 1 ] endif #endif ! init simulation if ( mod ( Ni , we ) /= 0 ) error stop 'error: the number of cells Ni must be a multiple of the number of CAF images used!' Ni_image = Ni / we allocate ( x ( 1 : Ni_image )) allocate ( initial_state ( 1 : Np , 1 : Ni_image )) Dx = 1._R_P / Ni ! Sod's problem cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P if ( we == 1 ) then BC_L = 'TRA' BC_R = 'TRA' else if ( me == 1 ) then BC_L = 'TRA' BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) elseif ( me == we ) then BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'TRA' else BC_L = 'CON-' // trim ( strz ( 2 , me - 1 )) BC_R = 'CON-' // trim ( strz ( 2 , me + 1 )) endif endif if ( me > 1 ) then x_L = Ni_image * Dx * ( me - 1 ) else x_L = 0._R_P endif do i = 1 , Ni_image x ( i ) = x_L + Dx * i - 0.5_R_P * Dx if ( x ( i ) <= 0.5_R_P ) then initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv else initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv endif enddo if ( verbose ) then print '(A)' , id // 'image ' // trim ( str (. true ., me )) // ' of ' // trim ( str (. true ., we )) print '(A)' , id // 'Number of total cells: ' // trim ( str (. true ., Ni )) print '(A)' , id // 'Number of time steps: ' // trim ( str (. true ., steps_max )) print '(A)' , id // 'Save final results: ' // trim ( str ( results )) print '(A)' , id // 'Save plots of results: ' // trim ( str ( plots )) print '(A)' , id // 'Save time serie of results: ' // trim ( str ( time_serie )) print '(A)' , id // 'Left BC: ' // BC_L print '(A)' , id // 'Right BC: ' // BC_R print '(A)' , id // 'Space resolution: ' // trim ( str (. true ., Dx )) print '(A)' , id // 'X(1) X(N): ' // trim ( str (. true ., x ( 1 ))) // ' ' // trim ( str (. true ., x ( Ni_image ))) print '(A)' , id // 'Density value: ' // trim ( str ( n = initial_state ( 1 , 1 ))) // ' ' // trim ( str ( n = initial_state ( 1 , Ni_image ))) endif ! initialize integrator and domain call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni_image , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , & me = me , we = we , ord = ord ) #ifdef CAF allocate ( Dt ( 1 : we )[ * ]) #else allocate ( Dt ( 1 : we )) #endif ! initialize time serie file call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_caf_integration-tvdrk-' // & trim ( str (. true ., rk_stages )) // '-image-' // & trim ( strz ( 3 , me )) // & '-time_serie.dat' , & t = t ) ! initialize time variables t = 0._R_P Dt = 0._R_P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine synchronize () !--------------------------------------------------------------------------------------------------------------------------------- !< Synchronize CAF images. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Images counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- #ifdef CAF if ( we > 1 ) then sync all ! reduction on minumum value of Dt do i = 1 , we if ( i /= me ) Dt ( i ) = Dt ( i )[ i ] Dt ( me ) = min ( Dt ( me ), Dt ( i )) enddo endif #endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine synchronize subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( rawfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) 'VARIABLES=\"x\" \"rho(1)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\"' do i = 1 , Ni_image write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_caf","tags":"","loc":"program/integrate_euler_1d_caf~2.html","title":"integrate_euler_1D_caf – FOODIE"},{"text":"Uses: flap IR_Precision omp_lib pyplot_module type_euler_1D_openmp_no_foodie program~~integrate_euler_1d_openmp_no_foodie~~UsesGraph program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_openmp_no_foodie omp_lib omp_lib omp_lib->program~integrate_euler_1d_openmp_no_foodie flap flap flap->program~integrate_euler_1d_openmp_no_foodie module~type_euler_1d_openmp_no_foodie type_euler_1D_openmp_no_foodie module~type_euler_1d_openmp_no_foodie->program~integrate_euler_1d_openmp_no_foodie IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_openmp_no_foodie IR_Precision->module~type_euler_1d_openmp_no_foodie wenoof wenoof wenoof->module~type_euler_1d_openmp_no_foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. Calls program~~integrate_euler_1d_openmp_no_foodie~~CallsGraph program~integrate_euler_1d_openmp_no_foodie integrate_euler_1D_openmp_no_foodie omp_set_dynamic omp_set_dynamic program~integrate_euler_1d_openmp_no_foodie->omp_set_dynamic omp_set_num_threads omp_set_num_threads program~integrate_euler_1d_openmp_no_foodie->omp_set_num_threads proc~save_time_serie~3 save_time_serie program~integrate_euler_1d_openmp_no_foodie->proc~save_time_serie~3 omp_get_num_threads omp_get_num_threads program~integrate_euler_1d_openmp_no_foodie->omp_get_num_threads proc~init~5 init program~integrate_euler_1d_openmp_no_foodie->proc~init~5 str str program~integrate_euler_1d_openmp_no_foodie->str proc~save_results~5 save_results program~integrate_euler_1d_openmp_no_foodie->proc~save_results~5 proc~save_time_serie~3->str proc~save_results~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables BC_L BC_R CFL Dx Nc Ni Np Ns cli count_rate cp0 cv0 domain dt error final_state initial_state omp_threads plots profiling results rk_integrator rk_stage rk_stages steps steps_max system_clocks t time_serie verbose x Subroutines init save_results save_time_serie Source Code integrate_euler_1D_openmp_no_foodie Variables Type Attributes Name Initial character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. real(kind=R_P) :: Dx Space step discretization. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. type(command_line_interface) :: cli Command line interface handler. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. type(euler_1D_omp_nf) :: domain Domain of Euler equations. real(kind=R_P) :: dt Time step. integer(kind=I_P) :: error Error handler. real(kind=R_P), allocatable :: final_state (:,:) Final state. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. integer(kind=I_P) :: omp_threads Number of OpenMP threads. logical :: plots Flag for activating plots saving. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. logical :: results Flag for activating results saving. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. type(euler_1D_omp_nf) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. integer(kind=I_P) :: steps Time steps counter. integer(kind=I_P) :: steps_max Maximum number of time steps. real(kind=R_P) :: system_clocks Profiling result. real(kind=R_P) :: t Time. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. Subroutines subroutine init () Initialize the field. Arguments None subroutine save_results (title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. subroutine save_time_serie (title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Source Code program integrate_euler_1D_openmp_no_foodie !----------------------------------------------------------------------------------------------------------------------------------- !< Test without FOODIE with the integration of Euler 1D PDEs system by OpenMP paradigm. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use IR_Precision , only : R_P , I_P , FR_P , str #ifdef OPENMP use OMP_LIB #endif use pyplot_module , only : pyplot use type_euler_1D_openmp_no_foodie , only : euler_1D_omp_nf , tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_omp_nf ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_omp_nf ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp-no-foodie' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test 1D Euler equations integration without FOODIE, OpenMP enabled' , & examples = [ \"euler-1D-openmp-no-foodie --results  \" , & \"euler-1D-openmp-no-foodie -r -t -v -p\" , & \"euler-1D-openmp-no-foodie            \" , & \"euler-1D-openmp-no-foodie --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_omp_nf_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp_no_foodie","tags":"","loc":"program/integrate_euler_1d_openmp_no_foodie.html","title":"integrate_euler_1D_openmp_no_foodie – FOODIE"},{"text":"Uses: flap foodie IR_Precision omp_lib pyplot_module type_euler_1D_openmp program~~integrate_euler_1d_openmp~~UsesGraph program~integrate_euler_1d_openmp integrate_euler_1D_openmp module~type_euler_1d_openmp type_euler_1D_openmp module~type_euler_1d_openmp->program~integrate_euler_1d_openmp module~foodie foodie module~foodie->program~integrate_euler_1d_openmp module~foodie->module~type_euler_1d_openmp pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d_openmp flap flap flap->program~integrate_euler_1d_openmp IR_Precision IR_Precision IR_Precision->program~integrate_euler_1d_openmp IR_Precision->module~type_euler_1d_openmp omp_lib omp_lib omp_lib->program~integrate_euler_1d_openmp wenoof wenoof wenoof->module~type_euler_1d_openmp module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panprogramintegrate_euler_1d_openmpUsesGraph = svgPanZoom('#programintegrate_euler_1d_openmpUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d_openmp~~CallsGraph program~integrate_euler_1d_openmp integrate_euler_1D_openmp omp_set_dynamic omp_set_dynamic program~integrate_euler_1d_openmp->omp_set_dynamic omp_set_num_threads omp_set_num_threads program~integrate_euler_1d_openmp->omp_set_num_threads str str program~integrate_euler_1d_openmp->str proc~save_results~6 save_results program~integrate_euler_1d_openmp->proc~save_results~6 proc~save_time_serie~4 save_time_serie program~integrate_euler_1d_openmp->proc~save_time_serie~4 omp_get_thread_num omp_get_thread_num program~integrate_euler_1d_openmp->omp_get_thread_num omp_get_num_threads omp_get_num_threads program~integrate_euler_1d_openmp->omp_get_num_threads proc~init~7 init program~integrate_euler_1d_openmp->proc~init~7 proc~save_results~6->str proc~save_time_serie~4->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables BC_L BC_R CFL Dx Nc Ni Np Ns cli count_rate cp0 cv0 domain dt error final_state initial_state omp_threads plots profiling results rk_integrator rk_stage rk_stages steps steps_max system_clocks t time_serie verbose x Subroutines init save_results save_time_serie Source Code integrate_euler_1D_openmp Variables Type Attributes Name Initial character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. real(kind=R_P) :: Dx Space step discretization. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. type(command_line_interface) :: cli Command line interface handler. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. type(euler_1D_openmp) :: domain Domain of Euler equations. real(kind=R_P) :: dt Time step. integer(kind=I_P) :: error Error handler. real(kind=R_P), allocatable :: final_state (:,:) Final state. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. integer(kind=I_P) :: omp_threads Number of OpenMP threads. logical :: plots Flag for activating plots saving. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. logical :: results Flag for activating results saving. type(integrator_runge_kutta_tvd) :: rk_integrator Runge-Kutta integrator. type(euler_1D_openmp) :: rk_stage (1:rk_stages) Runge-Kutta stages. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. integer(kind=I_P) :: steps Time steps counter. integer(kind=I_P) :: steps_max Maximum number of time steps. real(kind=R_P) :: system_clocks Profiling result. real(kind=R_P) :: t Time. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. Subroutines subroutine init () Initialize the field. Arguments None subroutine save_results (title, filename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. subroutine save_time_serie (title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Source Code program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str #ifdef OPENMP use OMP_LIB #endif use pyplot_module , only : pyplot use type_euler_1D_openmp , only : euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: steps_max !< Maximum number of time steps. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D-openmp --results  \" , & \"euler-1D-openmp -r -t -v -p\" , & \"euler-1D-openmp            \" , & \"euler-1D-openmp --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--steps' , help = 'Number time steps performed' , required = . false ., act = 'store' , def = '30' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--steps' , val = steps_max , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads, verbose) omp_threads = omp_get_num_threads () if ( verbose ) print \"(A)\" , ' Thread ' // trim ( str (. true ., omp_get_thread_num ())) // ' of: ' // trim ( str (. true ., omp_threads )) // ' is alive!' !$OMP END PARALLEL #endif call init () call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P call save_time_serie ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do steps = 1 , steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = steps_max , Tmax = 0._R_P , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps_max if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODIE test: 1D Euler equations integration, explicit TVD Runge-Kutta' // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(I5,A,F23.15)\" , omp_threads , ' ' , system_clocks stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"program/integrate_euler_1d_openmp.html","title":"integrate_euler_1D_openmp – FOODIE"},{"text":"Uses: flap foodie IR_Precision pyplot_module type_burgers program~~integrate_burgers~~UsesGraph program~integrate_burgers integrate_burgers pyplot_module pyplot_module pyplot_module->program~integrate_burgers module~foodie foodie module~foodie->program~integrate_burgers module~type_burgers type_burgers module~foodie->module~type_burgers flap flap flap->program~integrate_burgers module~type_burgers->program~integrate_burgers IR_Precision IR_Precision IR_Precision->program~integrate_burgers IR_Precision->module~type_burgers module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panprogramintegrate_burgersUsesGraph = svgPanZoom('#programintegrate_burgersUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FOODIE with the integration of Burgers equation. Calls program~~integrate_burgers~~CallsGraph program~integrate_burgers integrate_burgers proc~test_ab test_ab program~integrate_burgers->proc~test_ab proc~init~9 init program~integrate_burgers->proc~init~9 proc~test_tvd_rk test_tvd_rk program~integrate_burgers->proc~test_tvd_rk proc~test_leapfrog test_leapfrog program~integrate_burgers->proc~test_leapfrog proc~test_ls_rk test_ls_rk program~integrate_burgers->proc~test_ls_rk proc~test_euler test_euler program~integrate_burgers->proc~test_euler str str proc~test_ab->str proc~save_results~7 save_results proc~test_ab->proc~save_results~7 proc~test_tvd_rk->str proc~test_tvd_rk->proc~save_results~7 proc~test_leapfrog->str proc~test_leapfrog->proc~save_results~7 proc~test_ls_rk->str proc~test_ls_rk->proc~save_results~7 proc~test_euler->str proc~test_euler->proc~save_results~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables CFL Ni cli domain error final_state h initial_state nu plots results solver t_final x Subroutines init save_results test_ab test_euler test_leapfrog test_ls_rk test_tvd_rk Source Code integrate_burgers Variables Type Attributes Name Initial real(kind=R_P), parameter :: CFL = 0.1_R_P CFL value. integer(kind=I_P), parameter :: Ni = 100 Number of grid nodes. type(command_line_interface) :: cli Command line interface handler. type( burgers ) :: domain Burgers field domain. integer(kind=I_P) :: error Error handler. real(kind=R_P), allocatable :: final_state (:) Final state. real(kind=R_P) :: h Space step discretization. real(kind=R_P) :: initial_state (1:Ni) Initial state. real(kind=R_P), parameter :: nu = 1._R_P Viscosity. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. character(len=99) :: solver Solver used. real(kind=R_P), parameter :: t_final = 0.6_R_P Final time. real(kind=R_P) :: x (1:Ni) Nodes values. Subroutines subroutine init () Initialize the field. Arguments None subroutine save_results (title, filename) Save plots of results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. subroutine test_ab () Test explicit Adams-Bashforth class of ODE solvers. Arguments None subroutine test_euler () Test explicit forward Euler ODE solver. Arguments None subroutine test_leapfrog () Test explicit leapfrog class of ODE solvers. Arguments None subroutine test_ls_rk () Test explicit low storage Runge-Kutta class of ODE solvers. Arguments None subroutine test_tvd_rk () Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Arguments None Source Code program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_adams_bashforth , & integrator_euler_explicit , & integrator_leapfrog , & integrator_runge_kutta_ls , & integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str use pyplot_module , only : pyplot use type_burgers , only : burgers !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results  \" , & \"burgers --solver ls-runge-kutta -r\" , & \"burgers --solver adams-bashforth  \" , & \"burgers --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( burgers ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), Dt = Dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( burgers ) :: previous ( 1 : 2 ) !< Previous time steps solutions. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODIE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"program/integrate_burgers.html","title":"integrate_burgers – FOODIE"},{"text":"Uses: flap foodie penf pyplot_module type_euler_1D program~~integrate_euler_1d~~UsesGraph program~integrate_euler_1d integrate_euler_1D pyplot_module pyplot_module pyplot_module->program~integrate_euler_1d module~foodie foodie module~foodie->program~integrate_euler_1d module~type_euler_1d type_euler_1D module~foodie->module~type_euler_1d flap flap flap->program~integrate_euler_1d module~type_euler_1d->program~integrate_euler_1d penf penf penf->program~integrate_euler_1d penf->module~foodie penf->module~type_euler_1d module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object foodie_integrator_object penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes module~foodie_integrator_multistep_object foodie_integrator_multistep_object penf->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie wenoof wenoof wenoof->module~type_euler_1d var panprogramintegrate_euler_1dUsesGraph = svgPanZoom('#programintegrate_euler_1dUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FOODIE with the integration of Euler 1D PDEs system. Calls program~~integrate_euler_1d~~CallsGraph program~integrate_euler_1d integrate_euler_1D proc~test_euler~2 test_euler program~integrate_euler_1d->proc~test_euler~2 proc~test_tvd_rk~2 test_tvd_rk program~integrate_euler_1d->proc~test_tvd_rk~2 proc~test_leapfrog~2 test_leapfrog program~integrate_euler_1d->proc~test_leapfrog~2 proc~test_ab~2 test_ab program~integrate_euler_1d->proc~test_ab~2 proc~test_ls_rk~2 test_ls_rk program~integrate_euler_1d->proc~test_ls_rk~2 proc~init~11 init program~integrate_euler_1d->proc~init~11 str str proc~test_euler~2->str proc~save_results~8 save_results proc~test_euler~2->proc~save_results~8 proc~save_time_serie~5 save_time_serie proc~test_euler~2->proc~save_time_serie~5 proc~test_tvd_rk~2->str proc~test_tvd_rk~2->proc~save_results~8 proc~test_tvd_rk~2->proc~save_time_serie~5 proc~test_leapfrog~2->str proc~test_leapfrog~2->proc~save_results~8 proc~test_leapfrog~2->proc~save_time_serie~5 proc~test_ab~2->str proc~test_ab~2->proc~save_results~8 proc~test_ab~2->proc~save_time_serie~5 proc~test_ls_rk~2->str proc~test_ls_rk~2->proc~save_results~8 proc~test_ls_rk~2->proc~save_time_serie~5 proc~init~11->str proc~save_results~8->str proc~average_solution average_solution proc~save_results~8->proc~average_solution proc~save_time_serie~5->str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables BC_L BC_R CFL Dx Nc Ni Np Ns av_Ni av_state av_xnode cli cp0 cv0 domain error final_state initial_state output output_cli plots problem results solver stages_steps t_final time_serie variables verbose xcenter xnode Subroutines average_solution init save_results save_time_serie test_ab test_euler test_leapfrog test_ls_rk test_tvd_rk Source Code integrate_euler_1D Variables Type Attributes Name Initial character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R_P) :: CFL CFL value. real(kind=R_P) :: Dx Space step discretization. integer(kind=I_P) :: Nc Number of conservative variables, Nc=Ns+2. integer(kind=I_P) :: Ni Number of grid cells. integer(kind=I_P) :: Np Number of primitive variables, Np=Ns+4. integer(kind=I_P) :: Ns Number of differnt initial gas species. integer(kind=I_P) :: av_Ni Average the solution over an average-grid. real(kind=R_P), allocatable :: av_state (:,:) Average-grid final state. real(kind=R_P), allocatable :: av_xnode (:) Average-grid cell node x-abscissa values, [0:Ni]. type(command_line_interface) :: cli Command line interface handler. real(kind=R_P), allocatable :: cp0 (:) Specific heat at constant pressure [1:Ns]. real(kind=R_P), allocatable :: cv0 (:) Specific heat at constant volume [1:Ns]. type(euler_1D) :: domain Domain of Euler equations. integer(kind=I_P) :: error Error handler. real(kind=R_P), allocatable :: final_state (:,:) Final state. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables [1:Np,1:Ni]. character(len=:), allocatable :: output Output files basename. character(len=99) :: output_cli Output files basename. logical :: plots Flag for activating plots saving. character(len=99) :: problem Problem solved. logical :: results Flag for activating results saving. character(len=99) :: solver Solver used. integer(kind=I_P) :: stages_steps Number of stages/steps used. real(kind=R_P) :: t_final Final time. logical :: time_serie Flag for activating time serie-results saving. character(len=:), allocatable :: variables Variables names list. logical :: verbose Flag for activating more verbose output. real(kind=R_P), allocatable :: xcenter (:) Cell center x-abscissa values, [1:Ni]. real(kind=R_P), allocatable :: xnode (:) Cell node x-abscissa values, [0:Ni]. Subroutines subroutine average_solution () Average the solution over an average grid. Arguments None subroutine init () Initialize the field. Arguments None subroutine save_results (title, basename) Save results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: basename Output basename. subroutine save_time_serie (title, filename, finish, t) Save time-serie results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. subroutine test_ab () Test explicit Adams-Bashforth class of ODE solvers. Arguments None subroutine test_euler () Test explicit forward Euler ODE solver. Arguments None subroutine test_leapfrog () Test explicit leapfrog class of ODE solvers. Arguments None subroutine test_ls_rk () Test explicit low storage Runge-Kutta class of ODE solvers. Arguments None subroutine test_tvd_rk () Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Arguments None Source Code program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_adams_bashforth , & integrator_euler_explicit , & integrator_leapfrog , & integrator_runge_kutta_ls , & integrator_runge_kutta_tvd use penf , only : R_P , I_P , FR_P , str use pyplot_module , only : pyplot use type_euler_1D , only : euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. integer ( I_P ) :: Ns !< Number of differnt initial gas species. integer ( I_P ) :: Nc !< Number of conservative variables, Nc=Ns+2. integer ( I_P ) :: Np !< Number of primitive variables, Np=Ns+4. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: CFL !< CFL value. real ( R_P ) :: t_final !< Final time. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ), allocatable :: cp0 (:) !< Specific heat at constant pressure [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat at constant volume [1:Ns]. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables [1:Np,1:Ni]. real ( R_P ), allocatable :: xcenter (:) !< Cell center x-abscissa values, [1:Ni]. real ( R_P ), allocatable :: xnode (:) !< Cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: av_xnode (:) !< Average-grid cell node x-abscissa values, [0:Ni]. real ( R_P ), allocatable :: final_state (:,:) !< Final state. real ( R_P ), allocatable :: av_state (:,:) !< Average-grid final state. character ( len = :), allocatable :: variables !< Variables names list. character ( len = :), allocatable :: output !< Output files basename. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: stages_steps !< Number of stages/steps used. character ( 99 ) :: solver !< Solver used. character ( 99 ) :: problem !< Problem solved. character ( 99 ) :: output_cli !< Output files basename. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: av_Ni !< Average the solution over an average-grid. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results  \" , & \"euler-1D --solver ls-runge-kutta -r\" , & \"euler-1D --solver adams-bashforth  \" , & \"euler-1D --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver' , required = . true ., act = 'store' ) call cli % add ( switch = '--problem' , help = 'Problem solved' , required = . false ., def = 'sod' , act = 'store' , choices = 'sod,smooth' ) call cli % add ( switch = '--Ni' , help = 'Number finite volumes' , required = . false ., act = 'store' , def = '100' ) call cli % add ( switch = '--av_Ni' , help = 'Number finite volumes over average the solution' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--ss' , help = 'Stages/steps used' , required = . false ., act = 'store' , def = '-1' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--output' , help = 'Output files basename' , required = . false ., act = 'store' , def = 'unset' ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '--solver' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--problem' , val = problem , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--av_Ni' , val = av_Ni , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--ss' , val = stages_steps , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--results' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--plots' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--tserie' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--output' , val = output_cli , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Species counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( xcenter ( 1 : Ni )) allocate ( xnode ( 0 : Ni )) Dx = 1._R_P / Ni do i = 1 , Ni xcenter ( i ) = Dx * i - 0.5_R_P * Dx enddo do i = 0 , Ni xnode ( i ) = Dx * i enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then allocate ( av_xnode ( 0 : av_Ni )) do i = 0 , av_Ni av_xnode ( i ) = 1._R_P / av_Ni * i enddo endif select case ( trim ( adjustl ( problem ))) case ( 'sod' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.2_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str ( s ,. true .)) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case ( 'smooth' ) print \"(A)\" , 'Solving \"' // trim ( adjustl ( problem )) // '\" problem' t_final = 0.1_R_P CFL = 0.7_R_P Ns = 1 Nc = Ns + 2 Np = Ns + 4 allocate ( initial_state ( 1 : Np , 1 : Ni )) allocate ( cp0 ( 1 : Ns )) allocate ( cv0 ( 1 : Ns )) variables = 'VARIABLES=\"x\"' do s = 1 , Ns variables = variables // ' \"rho(' // trim ( str ( s ,. true .)) // ')\"' enddo variables = variables // '  \"u\" \"p\" \"rho\" \"gamma\"' BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni initial_state (:, i ) = [ 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! rho(s) 0.5_R_P * ( xcenter ( i ) - 0.5_R_P ) ** 4 , & ! u 1 0._R_P + 2._R_P * xcenter ( i ) ** 4 , & ! p 1._R_P + 4._R_P / 5._R_P * sin ( pi * xcenter ( i ) * 0.5_R_P ) + & 1._R_P / 1 0._R_P * sin ( 5._R_P * pi * xcenter ( i ) * 0.5_R_P ), & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo case default print \"(A)\" , 'Error: unknown problem \"' // trim ( adjustl ( problem )) // '\"' print \"(A)\" , 'Valid problem names are:' print \"(A)\" , '  + sod' print \"(A)\" , '  + smooth' stop endselect if ( trim ( adjustl ( output_cli )) /= 'unset' ) then output = trim ( adjustl ( output_cli )) // '-' // trim ( adjustl ( solver )) else output = 'euler_1D_integration-' // trim ( adjustl ( solver )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine average_solution () !--------------------------------------------------------------------------------------------------------------------------------- !< Average the solution over an average grid. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i , ii , i1 , i2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then if ( allocated ( av_state )) deallocate ( av_state ) ; allocate ( av_state ( 1 : Np , 1 : av_Ni )) do i = 1 , av_Ni i1 = minloc ( array = xcenter , dim = 1 , mask = ( xcenter >= av_xnode ( i - 1 ))) i2 = maxloc ( array = xcenter , dim = 1 , mask = ( xcenter <= av_xnode ( i ))) av_state (:, i ) = 0._R_P do ii = i1 , i2 av_state (:, i ) = av_state (:, i ) + final_state (:, ii ) enddo av_state (:, i ) = av_state (:, i ) / ( i2 - i1 + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine average_solution subroutine save_results ( title , basename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: basename !< Output basename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = basename // '-' // trim ( str ( Ni ,. true .)) // '_cells.dat' ) write ( rawfile , '(A)' ) 'TITLE=\"' // title // '\"' write ( rawfile , '(A)' ) variables write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str ( Ni ,. true .)) // ' cells\", I=' // trim ( str ( Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 1 ,. true .)) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str ( Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( rawfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo if (( av_Ni > 0 ). and .( av_Ni /= Ni )) then print \"(A)\" , ' Average solution from Ni: ' // trim ( str ( Ni ,. true .)) // ' to av_Ni: ' // trim ( str ( av_Ni ,. true .)) call average_solution write ( rawfile , '(A)' ) 'ZONE T=\"FOODIE: ' // trim ( str ( Ni ,. true .)) // ' cells averaged over ' // trim ( str ( av_Ni ,. true .)) // & ' cells\", I=' // trim ( str ( av_Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 1 ,. true .)) // ']=CELLCENTERED)' write ( rawfile , '(' // trim ( str ( av_Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) av_xnode do v = 1 , Np write ( rawfile , '(' // trim ( str ( av_Ni ,. true .)) // '(' // FR_P // ',1X))' ) av_state ( v , :) enddo endif close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = xcenter , y = final_state ( v , :), label = 'rho(' // trim ( str ( v ,. true .)) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = xcenter , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = xcenter , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( basename // '-' // trim ( str ( Ni ,. true .)) // '_cells.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) 'TITLE=\"' // title // '\"' endif write ( tsfile , '(A)' ) variables // ' \"t\"' write ( tsfile , '(A)' ) 'ZONE T=\"' // str ( n = t ) // '\", I=' // trim ( str ( Ni + 1 ,. true .)) // & ', J=1, K=1, DATAPACKING=BLOCK, VARLOCATION=([1]=NODAL,[2-' // trim ( str ( Np + 2 ,. true .)) // ']=CELLCENTERED)' write ( tsfile , '(' // trim ( str ( Ni + 1 ,. true .)) // '(' // FR_P // ',1X))' ) xnode do v = 1 , Np write ( tsfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' ) final_state ( v , :) enddo write ( tsfile , '(' // trim ( str ( Ni ,. true .)) // '(' // FR_P // ',1X))' )( t , v = 1 , Ni ) if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( euler_1D ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. integer ( I_P ) :: steps_range ( 1 : 2 ) !< Steps used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' steps_range = [ 1 , ab_steps ] ; if ( stages_steps > 0 ) steps_range = [ stages_steps , stages_steps ] do s = steps_range ( 1 ), steps_range ( 2 ) print \"(A)\" , ' AB-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' steps' call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) call rk_integrator % init ( stages = s ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) call rk_integrator % init ( stages = s ) case ( 4 , 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) call rk_integrator % init ( stages = 5 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ( s )) previous ( step ) = domain if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( U = domain , previous = previous ( 1 : s ), dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' title = '1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( U = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( euler_1D ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' title = '1D Euler equations integration, explicit leapfrog (RAW filtered), t=' // str ( n = t_final ) call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = title , filename = output // '-time_serie.dat' , t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) previous ( step ) = domain else call lf_integrator % integrate ( U = domain , previous = previous , dt = dt , t = t , filter = filter ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: stages_range ( 1 : 2 ) !< Stages used. character ( len = :), allocatable :: title !< Output files title. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' stages_range = [ 1 , rk_stages ] ; if ( stages_steps > 0 ) stages_range = [ stages_steps , stages_steps ] do s = stages_range ( 1 ), stages_range ( 2 ) if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str ( s ,. true .)) title = '1D Euler equations integration, explicit TVD/SSP Runge-Kutta, t=' // str ( n = t_final ) // trim ( str ( s ,. true .)) // ' stages' call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = title , filename = output // '-' // trim ( str ( s ,. true .)) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( U = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = title , basename = output // '-' // trim ( str ( s ,. true .))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"program/integrate_euler_1d.html","title":"integrate_euler_1D – FOODIE"},{"text":"Uses: flap foodie IR_Precision pyplot_module type_lorenz program~~integrate_lorenz~~UsesGraph program~integrate_lorenz integrate_lorenz pyplot_module pyplot_module pyplot_module->program~integrate_lorenz module~foodie foodie module~foodie->program~integrate_lorenz module~type_lorenz type_lorenz module~foodie->module~type_lorenz flap flap flap->program~integrate_lorenz module~type_lorenz->program~integrate_lorenz IR_Precision IR_Precision IR_Precision->program~integrate_lorenz IR_Precision->module~type_lorenz module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object foodie_integrand_object module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_leapfrog foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistage_object foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object foodie_integrator_object module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie iso_fortran_env->module~foodie_integrator_object iso_fortran_env->module~foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object penf penf penf->module~foodie penf->module~foodie_integrator_runge_kutta_emd penf->module~foodie_integrand_object penf->module~foodie_integrator_leapfrog penf->module~foodie_integrator_euler_explicit penf->module~foodie_integrator_lmm_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object penf->module~foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object penf->module~foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object penf->module~foodie_integrator_adams_moulton penf->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panprogramintegrate_lorenzUsesGraph = svgPanZoom('#programintegrate_lorenzUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test FOODIE with the integration of Lorenz equations. Calls program~~integrate_lorenz~~CallsGraph program~integrate_lorenz integrate_lorenz proc~test_ab~3 test_ab program~integrate_lorenz->proc~test_ab~3 proc~test_tvd_rk~3 test_tvd_rk program~integrate_lorenz->proc~test_tvd_rk~3 proc~test_leapfrog~3 test_leapfrog program~integrate_lorenz->proc~test_leapfrog~3 proc~test_ls_rk~3 test_ls_rk program~integrate_lorenz->proc~test_ls_rk~3 proc~test_euler~3 test_euler program~integrate_lorenz->proc~test_euler~3 str str proc~test_ab~3->str proc~save_results~9 save_results proc~test_ab~3->proc~save_results~9 proc~test_tvd_rk~3->str proc~test_tvd_rk~3->proc~save_results~9 proc~test_leapfrog~3->proc~save_results~9 proc~test_ls_rk~3->str proc~test_ls_rk~3->proc~save_results~9 proc~test_euler~3->proc~save_results~9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables attractor beta cli dt error initial_state num_steps plots results rho sigma solution solver space_dimension Subroutines save_results test_ab test_euler test_leapfrog test_ls_rk test_tvd_rk Source Code integrate_lorenz Variables Type Attributes Name Initial type( lorenz ) :: attractor Lorenz field. real(kind=R_P), parameter :: beta = 8._R_P/3._R_P Lorenz' \\beta. type(command_line_interface) :: cli Command line interface handler. real(kind=R_P), parameter :: dt = 0.01_R_P Time step. integer(kind=I_P) :: error Error handler. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [1., 1., 1.] Initial state. integer, parameter :: num_steps = 2000 Maximum time steps. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. real(kind=R_P), parameter :: rho = 28._R_P Lorenz' \\rho. real(kind=R_P), parameter :: sigma = 10._R_P Lorenz' \\sigma. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. character(len=99) :: solver Solver used. integer, parameter :: space_dimension = 3 Space dimensions. Subroutines subroutine save_results (title, filename) Save plots of results. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. subroutine test_ab () Test explicit Adams-Bashforth class of ODE solvers. Arguments None subroutine test_euler () Test explicit forward Euler ODE solver. Arguments None subroutine test_leapfrog () Test explicit leapfrog class of ODE solvers. Arguments None subroutine test_ls_rk () Test explicit low storage Runge-Kutta class of ODE solvers. Arguments None subroutine test_tvd_rk () Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Arguments None Source Code program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODIE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use flap , only : command_line_interface use foodie , only : integrator_adams_bashforth , & integrator_euler_explicit , & integrator_leapfrog , & integrator_runge_kutta_ls , & integrator_runge_kutta_tvd use IR_Precision , only : R_P , I_P , FR_P , str use pyplot_module , only : pyplot use type_lorenz , only : lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( command_line_interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODIE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results  \" , & \"lorenz --solver ls-runge-kutta -r\" , & \"lorenz --solver adams-bashforth  \" , & \"lorenz --solver all --plots -r   \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( integrator_adams_bashforth ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 4 !< Adams-Bashforth steps number. type ( lorenz ) :: previous ( 1 : ab_steps ) !< Previous time steps solutions. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) select case ( s ) case ( 1 , 2 , 3 ) call rk_integrator % init ( stages = s ) case ( 4 ) call rk_integrator % init ( stages = 5 ) endselect call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call ab_integrator % integrate ( U = attractor , previous = previous ( 1 : s ), dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_euler_explicit ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( U = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( integrator_leapfrog ) :: lf_integrator !< Leapfrog integrator. type ( lorenz ) :: previous ( 1 : 2 ) !< Previous time steps solutions. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) previous ( step ) = attractor else call lf_integrator % integrate ( U = attractor , previous = previous , dt = dt , t = solution ( 0 , step ), filter = filter ) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_ls ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( integrator_runge_kutta_tvd ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( U = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODIE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"program/integrate_lorenz.html","title":"integrate_lorenz – FOODIE"},{"text":"Uses: foodie_test_object program~~foodie_tester~~UsesGraph program~foodie_tester foodie_tester module~foodie_test_object foodie_test_object module~foodie_test_object->program~foodie_tester module~foodie_test_integrand_lcce foodie_test_integrand_lcce module~foodie_test_integrand_lcce->module~foodie_test_object module~foodie_test_integrand_ladvection foodie_test_integrand_ladvection module~foodie_test_integrand_ladvection->module~foodie_test_object module~foodie foodie module~foodie->module~foodie_test_object module~foodie->module~foodie_test_integrand_lcce module~foodie->module~foodie_test_integrand_ladvection module~foodie_test_integrand_oscillation foodie_test_integrand_oscillation module~foodie->module~foodie_test_integrand_oscillation module~foodie_test_integrand_tester_object foodie_test_integrand_tester_object module~foodie->module~foodie_test_integrand_tester_object module~foodie_test_integrand_oscillation->module~foodie_test_object iso_fortran_env iso_fortran_env iso_fortran_env->module~foodie_test_object iso_fortran_env->module~foodie_test_integrand_ladvection iso_fortran_env->module~foodie module~foodie_integrator_object foodie_integrator_object iso_fortran_env->module~foodie_integrator_object module~foodie_integrator_multistage_object foodie_integrator_multistage_object iso_fortran_env->module~foodie_integrator_multistage_object module~foodie_integrator_multistep_object foodie_integrator_multistep_object iso_fortran_env->module~foodie_integrator_multistep_object module~foodie_integrator_multistage_multistep_object foodie_integrator_multistage_multistep_object iso_fortran_env->module~foodie_integrator_multistage_multistep_object module~foodie_test_integrand_tester_object->module~foodie_test_object module~foodie_test_integrand_tester_object->module~foodie_test_integrand_lcce module~foodie_test_integrand_tester_object->module~foodie_test_integrand_ladvection module~foodie_test_integrand_tester_object->module~foodie_test_integrand_oscillation flap flap flap->module~foodie_test_object flap->module~foodie_test_integrand_lcce flap->module~foodie_test_integrand_ladvection flap->module~foodie_test_integrand_oscillation flap->module~foodie_test_integrand_tester_object penf penf penf->module~foodie_test_object penf->module~foodie_test_integrand_lcce penf->module~foodie_test_integrand_ladvection penf->module~foodie penf->module~foodie_test_integrand_oscillation penf->module~foodie_test_integrand_tester_object module~foodie_integrator_runge_kutta_emd foodie_integrator_runge_kutta_emd penf->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object foodie_integrand_object penf->module~foodie_integrand_object module~foodie_integrator_leapfrog foodie_integrator_leapfrog penf->module~foodie_integrator_leapfrog module~foodie_integrator_euler_explicit foodie_integrator_euler_explicit penf->module~foodie_integrator_euler_explicit module~foodie_integrator_lmm_ssp foodie_integrator_lmm_ssp penf->module~foodie_integrator_lmm_ssp module~foodie_integrator_ms_runge_kutta_ssp foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_ms_runge_kutta_ssp penf->module~foodie_integrator_object module~foodie_integrator_runge_kutta_lssp foodie_integrator_runge_kutta_lssp penf->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_adams_bashforth foodie_integrator_adams_bashforth penf->module~foodie_integrator_adams_bashforth penf->module~foodie_integrator_multistage_object module~foodie_integrator_adams_bashforth_moulton foodie_integrator_adams_bashforth_moulton penf->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_runge_kutta_ssp foodie_integrator_runge_kutta_ssp penf->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_runge_kutta_low_storage foodie_integrator_runge_kutta_low_storage penf->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_backward_differentiation_formula foodie_integrator_backward_differentiation_formula penf->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes foodie_error_codes penf->module~foodie_error_codes penf->module~foodie_integrator_multistep_object penf->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_adams_moulton foodie_integrator_adams_moulton penf->module~foodie_integrator_adams_moulton module~foodie_integrator_lmm_ssp_vss foodie_integrator_lmm_ssp_vss penf->module~foodie_integrator_lmm_ssp_vss wenoof wenoof wenoof->module~foodie_test_integrand_ladvection module~foodie_integrator_runge_kutta_emd->module~foodie module~foodie_integrand_object->module~foodie module~foodie_integrand_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrand_object->module~foodie_integrator_leapfrog module~foodie_integrand_object->module~foodie_integrator_euler_explicit module~foodie_integrand_object->module~foodie_integrator_lmm_ssp module~foodie_integrand_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrand_object->module~foodie_integrator_adams_bashforth module~foodie_integrand_object->module~foodie_integrator_multistage_object module~foodie_integrand_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrand_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrand_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrand_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrand_object->module~foodie_integrator_multistep_object module~foodie_integrand_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrand_object->module~foodie_integrator_adams_moulton module~foodie_integrand_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_leapfrog->module~foodie module~foodie_integrator_euler_explicit->module~foodie module~foodie_integrator_lmm_ssp->module~foodie module~foodie_integrator_ms_runge_kutta_ssp->module~foodie module~foodie_integrator_object->module~foodie module~foodie_integrator_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_object->module~foodie_integrator_leapfrog module~foodie_integrator_object->module~foodie_integrator_euler_explicit module~foodie_integrator_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_object->module~foodie_integrator_multistage_object module~foodie_integrator_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_object->module~foodie_integrator_multistep_object module~foodie_integrator_object->module~foodie_integrator_multistage_multistep_object module~foodie_integrator_object->module~foodie_integrator_adams_moulton module~foodie_integrator_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_runge_kutta_lssp->module~foodie module~foodie_integrator_adams_bashforth->module~foodie module~foodie_integrator_adams_bashforth->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistage_object->module~foodie module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_emd module~foodie_integrator_multistage_object->module~foodie_integrator_euler_explicit module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_lssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_ssp module~foodie_integrator_multistage_object->module~foodie_integrator_runge_kutta_low_storage module~foodie_integrator_adams_bashforth_moulton->module~foodie module~foodie_integrator_runge_kutta_ssp->module~foodie module~foodie_integrator_runge_kutta_low_storage->module~foodie module~foodie_integrator_backward_differentiation_formula->module~foodie module~foodie_error_codes->module~foodie module~foodie_error_codes->module~foodie_integrator_runge_kutta_emd module~foodie_error_codes->module~foodie_integrator_leapfrog module~foodie_error_codes->module~foodie_integrator_euler_explicit module~foodie_error_codes->module~foodie_integrator_lmm_ssp module~foodie_error_codes->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_lssp module~foodie_error_codes->module~foodie_integrator_adams_bashforth module~foodie_error_codes->module~foodie_integrator_adams_bashforth_moulton module~foodie_error_codes->module~foodie_integrator_runge_kutta_ssp module~foodie_error_codes->module~foodie_integrator_runge_kutta_low_storage module~foodie_error_codes->module~foodie_integrator_backward_differentiation_formula module~foodie_error_codes->module~foodie_integrator_adams_moulton module~foodie_error_codes->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistep_object->module~foodie module~foodie_integrator_multistep_object->module~foodie_integrator_leapfrog module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth module~foodie_integrator_multistep_object->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_backward_differentiation_formula module~foodie_integrator_multistep_object->module~foodie_integrator_adams_moulton module~foodie_integrator_multistep_object->module~foodie_integrator_lmm_ssp_vss module~foodie_integrator_multistage_multistep_object->module~foodie module~foodie_integrator_multistage_multistep_object->module~foodie_integrator_ms_runge_kutta_ssp module~foodie_integrator_adams_moulton->module~foodie module~foodie_integrator_adams_moulton->module~foodie_integrator_adams_bashforth_moulton module~foodie_integrator_lmm_ssp_vss->module~foodie var panprogramfoodie_testerUsesGraph = svgPanZoom('#programfoodie_testerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Tester factory of FOODIE integrators. Variables test Source Code foodie_tester Variables Type Attributes Name Initial type( test_object ) :: test FOODIE test. Source Code program foodie_tester !< Tester factory of FOODIE integrators. use foodie_test_object , only : test_object implicit none type ( test_object ) :: test !< FOODIE test. call test % execute endprogram foodie_tester","tags":"","loc":"program/foodie_tester.html","title":"foodie_tester – FOODIE"}]}