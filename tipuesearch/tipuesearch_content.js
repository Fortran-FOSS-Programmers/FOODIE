var tipuesearch = {"pages":[{"text":"FOODiE FOODiE FOODiE, Fortran Object oriented Ordinary Differential Equations integration library FOODiE is a pure Fortran (KISS) library for integrating Ordinary Differential Equations (ODE); FOODiE is Fortran 2003+ standard compliant; FOODiE is OOP designed; FOODiE is a Free, Open Source Project. Table of Contents What is FOODiE? Main features Status Copyrights Documentation What is FOODiE? Modern Fortran standards (2003+) have introduced support for Object Oriented Programming. Exploiting new features like Abstract Data Type (ADT) is now possible to develop a KISS library for integrating Ordinary Differential Equations on ADT making the development of new numerical schemes faster, easier and clearer. Go to Top Main features FOODiE is aimed to be a KISS-pure-Fortran library for integrating Ordinary Differential Equations (ODE), it being: Pure Fortran implementation; KISS and user-friendly: simple API; easy building and porting on heterogeneous architectures; comprehensive: Runge-Kutta schemes: predictor-corrector schemes; explicit; implicit; efficient: high scalability on parallel architectures: support for shared memory multi/many cores architecture; support for distributed memory cluster; support for GPGPU/accelerators device; well documented: clear documentation of schemes implementations; complete API reference; comprehensive wiki: collaborative developed; FOSS licensed; Any feature request is welcome. Go to Top Status FOODiE project is just started. Nothing has been done. We are searching for Fortraners enthusiast joining our team. Copyrights FOODiE is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FOODiE is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FOODiE documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"home","loc":"index.html","title":" FOODiE "},{"text":"FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. Source Code !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. module foodie_integrator_tvd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< The class of integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax (see Butcher, J.C., *Coefficients for the study of !< Runge-Kutta integration processes*, J. Austral. Math. Soc., Vol. 3, pages: 185--201, 1963). !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !< |                 |                   |                   |            |                    | !< |-----------------|-------------------|-------------------|------------|--------------------| !< | \\gamma&#94;1    | \\alpha&#94;{1,1}  | \\alpha&#94;{1,2}  | \\cdots | \\alpha&#94;{1,Ns}  | !< | \\gamma&#94;2    | \\alpha&#94;{2,1}  | \\alpha&#94;{2,2}  | \\cdots | \\alpha&#94;{2,Ns}  | !< | \\vdots      | \\vdots        | \\vdots        | \\ddots | \\vdots         | !< | \\gamma&#94;{Ns} | \\alpha&#94;{Ns,1} | \\alpha&#94;{Ns,2} | \\cdots | \\alpha&#94;{Ns,Ns} | !< |                 | \\beta&#94;1       | \\beta&#94;2       | \\cdots | \\beta&#94;{Ns}     | !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !< |                 |                   |                   |            |                    | !< |-----------------|-------------------|-------------------|------------|--------------------| !< | \\gamma&#94;1    |       0       |       0       | \\cdots |         0      | !< | \\gamma&#94;2    | \\alpha&#94;{2,1}  | \\alpha&#94;{2,2}  | \\cdots | \\alpha&#94;{2,Ns}  | !< | \\vdots      | \\vdots        | \\vdots        | \\ddots | \\vdots         | !< | \\gamma&#94;{Ns} | \\alpha&#94;{Ns,1} | \\alpha&#94;{Ns,2} | \\cdots |         0      | !< |                 | \\beta&#94;1       | \\beta&#94;2       | \\cdots | \\beta&#94;{Ns}     | !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !< \\beta = \\left[1\\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0 \\end{array}} \\right] !< \\gamma = \\left[0\\right] !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm. See *High Order Strong Stability Preserving Time !< Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, !< pp. 251-289. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2}&\\frac{1}{2} \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0\\\\ 1&0 \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\end{array}} \\right] !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm. See *High Order Strong Stability Preserving Time !< Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, !< pp. 251-289. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{6}&\\frac{1}{6}&\\frac{1}{3}  \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0&0\\\\ 1&0&0\\\\ \\frac{1}{4}&\\frac{1}{4}&0 \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\\\ \\frac{1}{2} \\end{array}} \\right] !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm. See *High Order Strong Stability Preserving Time !< Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, !< pp. 251-289. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} 0.14681187618661&0.24848290924556&0.10425883036650&0.27443890091960& !< 0.22600748319395 \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} !< 0&0&0&0&0 \\\\ 0.39175222700392&0&0&0&0 \\\\ 0.21766909633821&0.36841059262959&0&0&0 \\\\ 0.08269208670950& !< 0.13995850206999&0.25189177424738&0&0 \\\\ 0.06796628370320&0.11503469844438&0.20703489864929&0.54497475021237&0 !< \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0\\\\0.39175222700392\\\\0.58607968896780\\\\0.47454236302687\\\\0.93501063100924 !<           \\end{array}} \\right] !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: tvd_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator interface tvd_runge_kutta_integrator !< Overload tvd_runge_kutta_integrator name with the constructor function *create*. module procedure create endinterface tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function create ( stages ) result ( rk ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrators: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. type ( tvd_runge_kutta_integrator ) :: rk !< Actual RK integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk % init ( stages = stages ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction create ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrators: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , field , stage , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , size ( stage ) stage ( s ) = field do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , size ( stage ) field = field + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_tvd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_tvd_runge_kutta.f90.html","title":"foodie_integrator_tvd_runge_kutta.f90 – FOODiE"},{"text":"Pure Fortran (2003+) library for ensuring codes portability Source Code !< Pure Fortran (2003+) library for ensuring codes portability module IR_Precision !----------------------------------------------------------------------------------------------------------------------------------- !< Pure Fortran (2003+) library for ensuring codes portability !<{!README-IR_Precision.md!} !----------------------------------------------------------------------------------------------------------------------------------- USE , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT ! Standard output/error logical units. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: endianL , endianB , endian public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: NRknd , RPl , FRl public :: NIknd , RIl , FIl public :: check_endian public :: bit_size , byte_size public :: str , strz , cton , bstr , bcton public :: digit public :: ir_initialized , IR_Init public :: IR_Print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: ir_initialized = . false . !< Flag for chcecking the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). ! The following are the portable kind parameters available. ! Real precision definitions: #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. ! Integer precision definitions: integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. ! Format parameters useful for writing in a well-ascii-format numeric variables. ! Real output formats: character ( 10 ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P variable. character ( 10 ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P variable. character ( 9 ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P variable. character ( 10 ), parameter :: FR_P = FR8P !< Output format for kind=R_P variable. ! Real number of digits of output formats: integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. ! Integer output formats: character ( 5 ), parameter :: FI8P = '(I20)' !< Output format                     for kind=I8P variable. character ( 8 ), parameter :: FI8PZP = '(I20.19)' !< Output format with zero prefixing for kind=I8P variable. character ( 5 ), parameter :: FI4P = '(I11)' !< Output format                     for kind=I4P variable. character ( 8 ), parameter :: FI4PZP = '(I11.10)' !< Output format with zero prefixing for kind=I4P variable. character ( 4 ), parameter :: FI2P = '(I6)' !< Output format                     for kind=I2P variable. character ( 6 ), parameter :: FI2PZP = '(I6.5)' !< Output format with zero prefixing for kind=I2P variable. character ( 4 ), parameter :: FI1P = '(I4)' !< Output format                     for kind=I1P variable. character ( 6 ), parameter :: FI1PZP = '(I4.3)' !< Output format with zero prefixing for kind=I1P variable. character ( 5 ), parameter :: FI_P = FI4P !< Output format                     for kind=I_P variable. character ( 8 ), parameter :: FI_PZP = FI4PZP !< Output format with zero prefixing for kind=I_P variable. ! Integer number of digits of output formats: integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. ! List of kinds integer , parameter :: NRknd = 4 !< Number of defined real kinds. integer , parameter :: RPl ( 1 : NRknd ) = [ R16P , R8P , R4P , R_P ] !< List of defined real kinds. character ( 10 ), parameter :: FRl ( 1 : NRknd ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of defined real kinds output format. integer , parameter :: NIknd = 5 !< Number of defined integer kinds. integer , parameter :: RIl ( 1 : NIknd ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of defined integer kinds. character ( 5 ), parameter :: FIl ( 1 : NIknd ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of defined integer kinds output format. ! Useful parameters for handling numbers ranges. ! Real min and max values: real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P variable. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P variable. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P variable. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P variable. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P variable. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P variable. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P variable. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P variable. ! Real number of bits/bytes integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P variable. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P variable. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P variable. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P variable. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P variable. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P variable. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P variable. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P variable. ! Real smallest values: real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest (module) representable value of kind=R16P variable. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest (module) representable value of kind=R8P variable. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest (module) representable value of kind=R4P variable. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest (module) representable value of kind=R_P variable. ! Integer min and max values: integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P variable. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P variable. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P variable. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P variable. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P variable. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P variable. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P variable. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P variable. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P variable. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P variable. ! Integer number of bits/bytes: integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P variable. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P variable. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P variable. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P variable. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P variable. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P variable. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P variable. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P variable. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P variable. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P variable. ! Smallest real representable difference by the running calculator. real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P variable. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P variable. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P variable. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P variable. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16p , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface interface byte_size !< Overloading of the *byte_size* function for computing the number of bytes. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface interface str !< Procedure for converting number, real and integer, to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P ,& #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P ,& #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface interface strz !< Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type !< casting with zero padding). module procedure strz_I8P , & strz_I4P , & strz_I2P , & strz_I1P endinterface interface cton !< Procedure for converting string to number, real or initeger, (string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface interface bstr !< Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P ,& #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface interface bcton !< Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface interface digit !< Procedure for computing the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for checking if the type of the bit ordering of the running architecture is little endian. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_endian elemental function bit_size_R16P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( c ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( c , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( c ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( c ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting logical to string. This function achieves casting of logical to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R16P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R8P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R4P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I8P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I4P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I2P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I1P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R16P ), intent ( IN ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine IR_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initilizing module's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! checking the bit ordering architecture call check_endian ! computing the bits/bytes sizes of real variables BIR8P = bit_size ( r = MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( r = MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( r = MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( r = MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif ir_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_init subroutine IR_Print ( pref , iostat , iomsg , unit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . ir_initialized ) call IR_init prefd = '' ; if ( present ( pref )) prefd = pref ! printing informations if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str (. true ., ZeroR16 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str (. true ., ZeroR8 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str (. true ., ZeroR4 ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_Print endmodule IR_Precision","tags":"","loc":"sourcefile/ir_precision.f90.html","title":"IR_Precision.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Source Code !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_explicit_integrator !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine integrate ( field , dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field + field % t () * dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – FOODiE"},{"text":"Source Code module foodie !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODiE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODiE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< !<+ *forward explicit Euler* scheme, a 1st order accurate scheme; !<+ *TVD or SSP Runge-Kutta* class schemes: !<    + TVD(1,1): 1 stage, 1st order scheme, namely the forward explicit Euler one; !<    + SSP(2,2): 2 stages, 2nd order scheme; !<    + SSP(3,3): 3 stages, 3rd order scheme; !<    + SSP(5,4): 5 stages, 4th order scheme; !< !<### Usage !< !< FOODiE schemes must be applied to only subclass extensions of the abstract class *type_integrand*. !< !< To use FOODiE you must: !< !<#### extend type_integrand abstract class provided by FOODiE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODiE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: output                                          !< Extract Lorenz field. !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !< endtype lorenz !<``` !< !<#### use one of the provided FOODiE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : euler_explicit_integrator !< use type_lorenz, only : lorenz !< type(euler_explicit_integrator) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use type_integrand , only : integrand use foodie_integrator_euler_explicit , only : euler_explicit_integrator use foodie_integrator_tvd_runge_kutta , only : tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand public :: euler_explicit_integrator public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – FOODiE"},{"text":"Define the abstract type integrand for building FOODiE ODE integrators. Source Code !< Define the abstract type *integrand* for building FOODiE ODE integrators. module type_integrand !----------------------------------------------------------------------------------------------------------------------------------- !< Define the abstract type *integrand* for building FOODiE ODE integrators. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: integrand !< Abstract type for building FOODiE ODE integrators. contains ! public deferred procedures that concrete interpolators must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals function. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand oprator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< Integrand = real. ! operators overloading generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( * ) => real_multiply_integrand , integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading = assignament. endtype integrand abstract interface !< Abstract type bound procedures necessary for implementing the class(integrand). pure function time_derivative ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative function of integrand class, i.e. the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: self !< Integrand field. class ( integrand ), allocatable :: dState_dt !< Result of the time derivative function of integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction time_derivative pure function integrand_op_real ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator integrand.op.real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction integrand_op_real pure function real_op_integrand ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator real.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_op_integrand pure function symmetric_operator ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric type operator integrand.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction symmetric_operator pure subroutine assignment_integrand ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric assignment integrand = integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_integrand pure subroutine assignment_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric assignment integrand = real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_real endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule type_integrand","tags":"","loc":"sourcefile/type_integrand.f90.html","title":"type_integrand.f90 – FOODiE"},{"text":"Source Code !***************************************************************************************** module pyplot_module !***************************************************************************************** !****h* pyplotfortran/pyplot_module ! !  NAME !    pyplot_module ! !  DESCRIPTION !    For making simple x-y plots from Fortran. !    It works by generating a Python script and executing it. ! !  SEE ALSO !    Inspired by these: !    * http://pypi.python.org/pypi/EasyPlot/1.0.0 !    * http://nbviewer.ipython.org/github/HamsterHuey/easyplot/blob/master/docs/easyplot_docs.ipynb ! !  AUTHOR !    Jacob Williams ! !  HISTORY !    * Jacob Williams : Created : 4/14/2015 ! !***************************************************************************************** !********************************************************* !****d* pyplot_module/wp ! !  NAME !    wp ! !  DESCRIPTION !    Default real kind [8 bytes]. ! !  SOURCE use , intrinsic :: iso_fortran_env , only : wp => real64 !********************************************************* implicit none !********************************************************* !****d* pyplot_module/tmp_file ! !  NAME !    tmp_file ! !  DESCRIPTION !    Default name of the temporary file !    (this can also be user-specified). ! !  SOURCE character ( len =* ), parameter :: tmp_file = 'pyplot_module_temp_1234567890.py' !********************************************************* !********************************************************* !****d* pyplot_module/python_exe ! !  NAME !    python_exe ! !  DESCRIPTION !    The python executable name. ! !  SOURCE character ( len =* ), parameter :: python_exe = 'python' !********************************************************* character ( len =* ), parameter :: int_fmt = '(I10)' !integer format string integer , parameter :: max_int_len = 10 !max string length for integers character ( len =* ), parameter :: real_fmt = '(E30.16)' !real number format string integer , parameter :: max_real_len = 30 !max string length for reals !********************************************************* !****c* pyplot_module/pyplot ! !  NAME !    pyplot ! !  DESCRIPTION !    The main class. ! !  SOURCE type , public :: pyplot private character ( len = :), allocatable :: str !string buffer logical :: show_legend = . false . logical :: use_numpy = . true . contains procedure , public :: initialize procedure , public :: add_plot procedure , public :: add_bar procedure , public :: savefig procedure , public :: destroy procedure :: execute procedure :: add_str end type pyplot !********************************************************* contains !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/destroy ! !  NAME !    destroy ! !  DESCRIPTION !    Destructor ! !  SOURCE subroutine destroy ( me ) implicit none class ( pyplot ), intent ( inout ) :: me if ( allocated ( me % str )) deallocate ( me % str ) end subroutine destroy !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/add_str ! !  NAME !    add_str ! !  DESCRIPTION !    Add a string to the buffer. ! !  SOURCE subroutine add_str ( me , str ) implicit none class ( pyplot ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: str me % str = me % str // str // new_line ( ' ' ) end subroutine add_str !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/initialize ! !  NAME !    initialize ! !  DESCRIPTION !    initialize a plot ! !  SOURCE subroutine initialize ( me , grid , xlabel , ylabel , title , legend , use_numpy , figsize ,& font_size , axes_labelsize , xtick_labelsize , ytick_labelsize , legend_fontsize ) implicit none class ( pyplot ), intent ( inout ) :: me logical , intent ( in ), optional :: grid character ( len =* ), intent ( in ), optional :: xlabel character ( len =* ), intent ( in ), optional :: ylabel character ( len =* ), intent ( in ), optional :: title logical , intent ( in ), optional :: legend logical , intent ( in ), optional :: use_numpy integer , dimension ( 2 ), intent ( in ), optional :: figsize integer , intent ( in ), optional :: font_size integer , intent ( in ), optional :: axes_labelsize integer , intent ( in ), optional :: xtick_labelsize integer , intent ( in ), optional :: ytick_labelsize integer , intent ( in ), optional :: legend_fontsize character ( len = max_int_len ) :: width_str , height_str , font_size_str ,& axes_labelsize_str , xtick_labelsize_str ,& ytick_labelsize_str , legend_fontsize_str character ( len =* ), parameter :: default_font_size_str = '10' !the default font size for plots call me % destroy () if ( present ( legend )) then me % show_legend = legend else me % show_legend = . false . end if if ( present ( use_numpy )) then me % use_numpy = use_numpy else me % use_numpy = . true . end if if ( present ( figsize )) then call integer_to_string ( figsize ( 1 ), width_str ) call integer_to_string ( figsize ( 2 ), height_str ) end if call optional_int_to_string ( font_size , font_size_str , default_font_size_str ) call optional_int_to_string ( axes_labelsize , axes_labelsize_str , default_font_size_str ) call optional_int_to_string ( xtick_labelsize , xtick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ytick_labelsize , ytick_labelsize_str , default_font_size_str ) call optional_int_to_string ( legend_fontsize , legend_fontsize_str , default_font_size_str ) me % str = '' call me % add_str ( '#!/usr/bin/python' ) call me % add_str ( '' ) call me % add_str ( 'import matplotlib' ) call me % add_str ( 'import matplotlib.pyplot as plt' ) if ( me % use_numpy ) call me % add_str ( 'import numpy as np' ) call me % add_str ( '' ) call me % add_str ( 'matplotlib.rcParams[\"font.family\"] = \"Serif\"' ) call me % add_str ( 'matplotlib.rcParams[\"font.size\"] = ' // trim ( font_size_str )) call me % add_str ( 'matplotlib.rcParams[\"axes.labelsize\"] = ' // trim ( axes_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"xtick.labelsize\"] = ' // trim ( xtick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"ytick.labelsize\"] = ' // trim ( ytick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"legend.fontsize\"] = ' // trim ( legend_fontsize_str )) call me % add_str ( '' ) if ( present ( figsize )) then !if specifying the figure size call me % add_str ( 'fig = plt.figure(figsize=(' // trim ( width_str ) // ',' // trim ( height_str ) // '))' ) else call me % add_str ( 'fig = plt.figure()' ) end if call me % add_str ( 'ax = fig.gca()' ) if ( present ( grid )) then if ( grid ) call me % add_str ( 'ax.grid()' ) end if if ( present ( xlabel )) call me % add_str ( 'ax.set_xlabel(\"' // trim ( xlabel ) // '\")' ) if ( present ( ylabel )) call me % add_str ( 'ax.set_ylabel(\"' // trim ( ylabel ) // '\")' ) if ( present ( title )) call me % add_str ( 'ax.set_title(\"' // trim ( title ) // '\")' ) call me % add_str ( '' ) end subroutine initialize !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/add_plot ! !  NAME !    add_plot ! !  DESCRIPTION !    Add an x,y plot. ! !  SOURCE subroutine add_plot ( me , x , y , label , linestyle , markersize , linewidth ) implicit none class ( pyplot ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: linestyle integer , intent ( in ), optional :: markersize integer , intent ( in ), optional :: linewidth character ( len = :), allocatable :: xstr , ystr character ( len = max_int_len ) :: imark , iline character ( len =* ), parameter :: xname = 'x' !variable names for script character ( len =* ), parameter :: yname = 'y' ! if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , xstr , me % use_numpy ) call vec_to_string ( y , ystr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_plot !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/add_bar ! !  NAME !    add_bar ! !  DESCRIPTION !    Add a bar plot. ! !  SOURCE subroutine add_bar ( me , left , height , label , width , bottom , color ) implicit none class ( pyplot ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: left real ( wp ), dimension (:), intent ( in ) :: height character ( len =* ), intent ( in ) :: label real ( wp ), dimension (:), intent ( in ), optional :: width real ( wp ), dimension (:), intent ( in ), optional :: bottom character ( len =* ), intent ( in ), optional :: color character ( len = :), allocatable :: xstr , ystr , wstr , bstr , plt_str character ( len =* ), parameter :: xname = 'x' !variable names for script character ( len =* ), parameter :: yname = 'y' ! character ( len =* ), parameter :: wname = 'w' ! character ( len =* ), parameter :: bname = 'b' ! if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( left , xstr , me % use_numpy ) call vec_to_string ( height , ystr , me % use_numpy ) if ( present ( width )) call vec_to_string ( width , wstr , me % use_numpy ) if ( present ( bottom )) call vec_to_string ( bottom , bstr , me % use_numpy ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) if ( present ( width )) call me % add_str ( trim ( wname ) // ' = ' // wstr ) if ( present ( bottom )) call me % add_str ( trim ( bname ) // ' = ' // bstr ) call me % add_str ( '' ) !create the plot string: plt_str = 'ax.bar(' // & 'left=' // trim ( xname ) // ',' // & 'height=' // trim ( yname ) // ',' if ( present ( width )) plt_str = plt_str // 'width=' // trim ( wname ) // ',' if ( present ( bottom )) plt_str = plt_str // 'bottom=' // trim ( bstr ) // ',' if ( present ( color )) plt_str = plt_str // 'color=\"' // trim ( color ) // '\",' plt_str = plt_str // 'label=\"' // trim ( label ) // '\")' !write the plot statement: call me % add_str ( plt_str ) call me % add_str ( '' ) else error stop 'Error in add_bar: pyplot class not properly initialized.' end if end subroutine add_bar !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/optional_int_to_string ! !  NAME !    optional_int_to_string ! !  DESCRIPTION !    Integer to string, specifying the default value if !    the optional argument is not present. ! !  SOURCE subroutine optional_int_to_string ( int_value , string_value , default_value ) implicit none integer , intent ( in ), optional :: int_value character ( len =* ), intent ( out ) :: string_value character ( len =* ), intent ( in ) :: default_value if ( present ( int_value )) then call integer_to_string ( int_value , string_value ) else string_value = default_value end if end subroutine optional_int_to_string !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/integer_to_string ! !  NAME !    integer_to_string ! !  DESCRIPTION !    Integer to string conversion. ! !  SOURCE subroutine integer_to_string ( i , s ) implicit none integer , intent ( in ), optional :: i character ( len =* ), intent ( out ) :: s integer :: istat write ( s , int_fmt , iostat = istat ) i if ( istat /= 0 ) then error stop 'Error converting integer to string' else s = adjustl ( s ) end if end subroutine integer_to_string !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/vec_to_string ! !  NAME !    vec_to_string ! !  DESCRIPTION !    Real vector to string. ! !  SOURCE subroutine vec_to_string ( v , str , use_numpy ) implicit none real ( wp ), dimension (:), intent ( in ) :: v character ( len = :), allocatable , intent ( out ) :: str logical , intent ( in ) :: use_numpy integer :: i , istat character ( len = max_real_len ) :: tmp str = '[' do i = 1 , size ( v ) write ( tmp , real_fmt , iostat = istat ) v ( i ) if ( istat /= 0 ) error stop 'Error in vec_to_string' str = str // trim ( adjustl ( tmp )) if ( i < size ( v )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine vec_to_string !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/execute ! !  NAME !    execute ! !  DESCRIPTION !    Write the buffer to a file, and then execute it with Python. ! !  SOURCE subroutine execute ( me , pyfile ) implicit none class ( pyplot ), intent ( inout ) :: me character ( len =* ), intent ( in ), optional :: pyfile !name of the python script to generate integer :: istat , iunit character ( len = :), allocatable :: file if ( allocated ( me % str )) then !file name for python script: if ( present ( pyfile )) then file = trim ( pyfile ) !use the user-specified name else file = trim ( tmp_file ) !use the default end if !generate the file: open ( newunit = iunit , file = file , status = 'REPLACE' , iostat = istat ) if ( istat /= 0 ) error stop 'Error creating python script.' write ( iunit , '(A)' ) me % str close ( iunit , iostat = istat ) !run the file using python: call execute_command_line ( python_exe // ' ' // file ) !cleanup: deallocate ( file ) end if end subroutine execute !***************************************************************************************** !***************************************************************************************** !****f* pyplot_module/savefig ! !  NAME !    savefig ! !  DESCRIPTION !    Save the figure. ! !  SOURCE subroutine savefig ( me , figfile , pyfile ) implicit none class ( pyplot ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: figfile !file name for the figure character ( len =* ), intent ( in ), optional :: pyfile !name of the python script to generate if ( allocated ( me % str )) then !finish up the string: if ( me % show_legend ) then call me % add_str ( 'ax.legend(loc=\"best\")' ) call me % add_str ( '' ) end if call me % add_str ( 'plt.savefig(\"' // trim ( figfile ) // '\")' ) !run it: call me % execute ( pyfile ) else error stop 'error in savefig: pyplot class not properly initialized.' end if end subroutine savefig !***************************************************************************************** !***************************************************************************************** end module pyplot_module !*****************************************************************************************","tags":"","loc":"sourcefile/pyplot_module.f90.html","title":"pyplot_module.f90 – FOODiE"},{"text":"Define Lorenz field that is a concrete extension of the abstract integrand type. Source Code !< Define Lorenz field that is a concrete extension of the abstract integrand type. module type_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Define Lorenz field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: output !< Extract Lorenz field. procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz interface lorenz !< Overload lorenz name adding the constructor function. module procedure constructor_lorenz endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains function constructor_lorenz ( initial_state , sigma , rho , beta ) result ( concrete ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Intial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. type ( lorenz ) :: concrete !< Concrete instance of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concrete % state = initial_state concrete % sigma = sigma concrete % rho = rho concrete % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endfunction constructor_lorenz function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function dLorenz_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. type ( lorenz ), allocatable :: delta !< Delta state used as temporary variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary delta allocate ( delta ) allocate ( delta % state ( size ( self % state ))) ! Lorenz equations delta % state ( 1 ) = self % sigma * ( self % state ( 2 ) - self % state ( 1 )) delta % state ( 2 ) = self % state ( 1 ) * ( self % rho - self % state ( 3 )) - self % state ( 2 ) delta % state ( 3 ) = self % state ( 1 ) * self % state ( 2 ) - self % beta * self % state ( 3 ) ! hold Lorenz parameters constant over time delta % sigma = 0. delta % rho = 0. delta % beta = 0. call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt pure function lorenz_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % state = lhs % state * rhs local_product % sigma = lhs % sigma * rhs local_product % rho = lhs % rho * rhs local_product % beta = lhs % beta * rhs call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real pure function real_multiply_lorenz ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % state = rhs % state * lhs local_product % sigma = rhs % sigma * lhs local_product % rho = rhs % rho * lhs local_product % beta = rhs % beta * lhs call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz pure function add_lorenz ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( lorenz ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: local_sum ) select type ( rhs ) class is ( lorenz ) local_sum % state = lhs % state + rhs % state local_sum % sigma = lhs % sigma + rhs % sigma local_sum % rho = lhs % rho + rhs % rho local_sum % beta = lhs % beta + rhs % beta class default ! stop 'add_Lorenz: rhs argument type not supported' endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz pure subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) if ( allocated ( rhs % state )) lhs % state = rhs % state lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz pure subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs lhs % sigma = rhs lhs % rho = rhs lhs % beta = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real endmodule type_lorenz","tags":"","loc":"sourcefile/type_lorenz.f90.html","title":"type_lorenz.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Lorenz equations. Source Code !< Test FOODiE with the integration of Lorenz equations. program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , str use type_lorenz , only : lorenz use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: attractor !< Lorenz field. integer :: step !< Time steps counter. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: s !< RK stages counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! solve Lorenz equations by means of the Forward Explicit Euler scheme ! initialize field attractor = lorenz ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0. solution ( 1 : 3 , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : 3 , step ) = attractor % output () enddo ! save plot of results call plt % initialize ( grid = . true ., xlabel = 'time' , title = 'FOODiE test: Lorenz equation integration, explicit Euler' , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'sigma' , linestyle = 'g-' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'rho' , linestyle = 'b-x' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'beta' , linestyle = 'r-o' , linewidth = 1 , markersize = 4 ) call plt % savefig ( 'lorenz_integration-euler.png' ) ! solve Lorenz equations by means of the TVD/SSP RK schemes (testing all available schemes) do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field attractor = lorenz ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0. solution ( 1 : 3 , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : 3 , step ) = attractor % output () enddo ! save plot of results call plt % initialize ( grid = . true ., xlabel = 'time' , title = 'FOODiE test: Lorenz equation integration, explicit Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'sigma' , linestyle = 'g-' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'rho' , linestyle = 'b-x' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'beta' , linestyle = 'r-o' , linewidth = 1 , markersize = 4 ) call plt % savefig ( 'lorenz_integration-rk-' // trim ( str (. true ., s )) // '.png' ) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram integrate_lorenz","tags":"","loc":"sourcefile/lorenz.f90.html","title":"lorenz.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Constructor public interface tvd_runge_kutta_integrator Overload tvd_runge_kutta_integrator name with the constructor function create . private elemental function create (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type( tvd_runge_kutta_integrator ) Actual RK integrator. Description Create the actual RK integrators: initialize the Butcher' table coefficients. Finalization Procedures final :: finalize private elemental subroutine finalize (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elemental subroutine destroy (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elemental subroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrators: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private  subroutine integrate (self, field, stage, Dt) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODiE "},{"text":"FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Note The integrator can be used directly without any initialization. Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. private  subroutine integrate (field, dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: dt Time step. Description Integrate field with explicit Euler scheme, 1st order. Source Code type :: euler_explicit_integrator !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator","tags":"","loc":"type/euler_explicit_integrator.html","title":"euler_explicit_integrator – FOODiE "},{"text":"Abstract type for building FOODiE ODE integrators. Type-Bound Procedures procedure, public, pass(self), deferred :: t => t Time derivative, residuals function. t() Arguments None procedure, public, pass(lhs), deferred :: integrand_multiply_real => integrand_multiply_real Integrand * real operator. integrand_multiply_real() Arguments None procedure, public, pass(rhs), deferred :: real_multiply_integrand => real_multiply_integrand Real * integrand operator. real_multiply_integrand() Arguments None procedure, public, pass(lhs), deferred :: add => add Integrand + integrand oprator. add() Arguments None procedure, public, pass(lhs), deferred :: assign_integrand => assign_integrand Integrand = integrand. assign_integrand() Arguments None procedure, public, pass(lhs), deferred :: assign_real => assign_real Integrand = real. assign_real() Arguments None generic, public :: operator(+) => add Overloading + operator. add() Arguments None generic, public :: operator(*) => real_multiply_integrand, integrand_multiply_real Overloading * operator. real_multiply_integrand() Arguments None integrand_multiply_real() Arguments None generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. assign_integrand() Arguments None assign_real() Arguments None Source Code type , abstract :: integrand !< Abstract type for building FOODiE ODE integrators. contains ! public deferred procedures that concrete interpolators must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals function. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand oprator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< Integrand = real. ! operators overloading generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( * ) => real_multiply_integrand , integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading = assignament. endtype integrand","tags":"","loc":"type/integrand.html","title":"integrand – FOODiE "},{"text":"Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: str logical, private :: show_legend = .false. logical, private :: use_numpy = .true. Type-Bound Procedures procedure, public :: initialize public  subroutine initialize (me, grid, xlabel, ylabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, legend_fontsize) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: legend_fontsize procedure, public :: add_plot public  subroutine add_plot (me, x, y, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth procedure, public :: add_bar public  subroutine add_bar (me, left, height, label, width, bottom, color) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color procedure, public :: savefig public  subroutine savefig (me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile procedure, public :: destroy public  subroutine destroy (me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me procedure, public :: execute public  subroutine execute (me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile procedure, public :: add_str public  subroutine add_str (me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Source Code type , public :: pyplot private character ( len = :), allocatable :: str !string buffer logical :: show_legend = . false . logical :: use_numpy = . true . contains procedure , public :: initialize procedure , public :: add_plot procedure , public :: add_bar procedure , public :: savefig procedure , public :: destroy procedure :: execute procedure :: add_str end type pyplot","tags":"","loc":"type/pyplot.html","title":"pyplot – FOODiE "},{"text":"Lorenz equations field. It is a FOODiE integrand class. Components Type Visibility Attributes Name Initial real(kind=R_P), private, dimension(:), allocatable :: state Solution vector. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Constructor public interface lorenz Overload lorenz name adding the constructor function. private  function constructor_lorenz (initial_state, sigma, rho, beta) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. Return Value type( lorenz ) Concrete instance of Lorenz field. Description Construct an initialized Lorenz field. Type-Bound Procedures procedure, public, pass(self) :: output Extract Lorenz field. private  function output (self) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. procedure, public, pass(self) :: t => dLorenz_dt Time derivate, resiuduals function. private pure function dLorenz_dt (self) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real lorenz * real operator. private pure function lorenz_multiply_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a Lorenz field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. private pure function real_multiply_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Product. Description Multiply a real scalar by a Lorenz field. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz oprator. private pure function add_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Sum. Description Add two Lorenz fields. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. private pure subroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. private pure subroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: output !< Extract Lorenz field. procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz","tags":"","loc":"type/lorenz.html","title":"lorenz – FOODiE "},{"text":"abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure subroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure subroutine assignment_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real.","tags":"","loc":"interface/assignment_real.html","title":"assignment_real – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function time_derivative(self) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. Return Value class([ , '']),\n    allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function integrand_op_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class([ , '']),\n    allocatable Operator result. Description Asymmetric type operator integrand.op.real.","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function real_op_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class([ , '']),\n    allocatable Operator result. Description Asymmetric type operator real.op.integrand.","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function symmetric_operator(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class([ , '']),\n    allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FOODiE"},{"text":"private elemental function create(stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type([ , '']) Actual RK integrator. Description Create the actual RK integrators: initialize the Butcher' table coefficients. Source Code elemental function create ( stages ) result ( rk ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrators: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. type ( tvd_runge_kutta_integrator ) :: rk !< Actual RK integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call rk % init ( stages = stages ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction create","tags":"","loc":"proc/create.html","title":"create – FOODiE"},{"text":"private elemental subroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrators: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrators: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FOODiE"},{"text":"private elemental subroutine destroy(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOODiE"},{"text":"private  subroutine integrate(self, field, stage, Dt) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , field , stage , Dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , size ( stage ) stage ( s ) = field do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t () enddo ! computing new time step do s = 1 , size ( stage ) field = field + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FOODiE"},{"text":"private elemental subroutine finalize(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FOODiE"},{"text":"public interface tvd_runge_kutta_integrator Overload tvd_runge_kutta_integrator name with the constructor function create . Module Procedures private elemental function create (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type( tvd_runge_kutta_integrator ) Actual RK integrator. Description Create the actual RK integrators: initialize the Butcher' table coefficients.","tags":"","loc":"interface/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODiE"},{"text":"private pure function is_little_endian() Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Procedure for checking if the type of the bit ordering of the running architecture is little endian. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: int1 (1:4) One byte integer array for casting 4 bytes integer. Source Code pure function is_little_endian () result ( is_little ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for checking if the type of the bit ordering of the running architecture is little endian. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian","tags":"","loc":"proc/is_little_endian.html","title":"is_little_endian – FOODiE"},{"text":"private elemental function bit_size_R16P(r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – FOODiE"},{"text":"private elemental function bit_size_R8P(r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – FOODiE"},{"text":"private elemental function bit_size_R4P(r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( r ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( r , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – FOODiE"},{"text":"private elemental function bit_size_chr(c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( c ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( c , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – FOODiE"},{"text":"private elemental function byte_size_I8P(i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – FOODiE"},{"text":"private elemental function byte_size_I4P(i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – FOODiE"},{"text":"private elemental function byte_size_I2P(i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – FOODiE"},{"text":"private elemental function byte_size_I1P(i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – FOODiE"},{"text":"private elemental function byte_size_R16P(r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R16P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – FOODiE"},{"text":"private elemental function byte_size_R8P(r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. Source Code elemental function byte_size_R8P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – FOODiE"},{"text":"private elemental function byte_size_R4P(r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. Source Code elemental function byte_size_R4P ( r ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: r !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( r ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – FOODiE"},{"text":"private elemental function byte_size_chr(c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable. Source Code elemental function byte_size_chr ( c ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: c !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( c ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – FOODiE"},{"text":"private elemental function strf_R16P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – FOODiE"},{"text":"private elemental function strf_R8P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – FOODiE"},{"text":"private elemental function strf_R4P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – FOODiE"},{"text":"private elemental function strf_I8P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – FOODiE"},{"text":"private elemental function strf_I4P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – FOODiE"},{"text":"private elemental function strf_I2P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – FOODiE"},{"text":"private elemental function strf_I1P(fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n ! Casting of n to string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – FOODiE"},{"text":"private elemental function str_R16P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function str_R16P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R16P ), intent ( IN ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – FOODiE"},{"text":"private elemental function str_R8P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function str_R8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – FOODiE"},{"text":"private elemental function str_R4P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. Source Code elemental function str_R4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – FOODiE"},{"text":"private elemental function str_I8P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I8P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – FOODiE"},{"text":"private elemental function str_I4P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I4P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – FOODiE"},{"text":"private elemental function str_I2P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I2P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – FOODiE"},{"text":"private elemental function str_I1P(no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. Source Code elemental function str_I1P ( no_sign , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – FOODiE"},{"text":"private elemental function str_bol(n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting logical to string. This function achieves casting of logical to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – FOODiE"},{"text":"private pure function str_a_R16P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R16P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – FOODiE"},{"text":"private pure function str_a_R8P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R8P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – FOODiE"},{"text":"private pure function str_a_R4P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real (array) to string. This function achieves casting of real to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. real ( R4P ), intent ( IN ) :: n (:) !< Real array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – FOODiE"},{"text":"private pure function str_a_I8P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I8P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – FOODiE"},{"text":"private pure function str_a_I4P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I4P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – FOODiE"},{"text":"private pure function str_a_I2P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I2P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – FOODiE"},{"text":"private pure function str_a_I1P(no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n    allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( no_sign , delimiters , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer (array) to string. This function achieves casting of integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none logical , intent ( IN ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( IN ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. integer ( I1P ), intent ( IN ) :: n (:) !< Integer array to be converted. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – FOODiE"},{"text":"private elemental function strz_I8P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I8P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I8P ), intent ( IN ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – FOODiE"},{"text":"private elemental function strz_I4P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I4P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I4P ), intent ( IN ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – FOODiE"},{"text":"private elemental function strz_I2P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I2P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I2P ), intent ( IN ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – FOODiE"},{"text":"private elemental function strz_I1P(nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. Source Code elemental function strz_I1P ( nz_pad , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of !< integer to string. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ), optional :: nz_pad !< Number of zeros padding. integer ( I1P ), intent ( IN ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – FOODiE"},{"text":"private  function ctor_R16P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R16P ), intent ( IN ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – FOODiE"},{"text":"private  function ctor_R8P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – FOODiE"},{"text":"private  function ctor_R4P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to real. This function achieves casting of string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – FOODiE"},{"text":"private  function ctoi_I8P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – FOODiE"},{"text":"private  function ctoi_I4P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – FOODiE"},{"text":"private  function ctoi_I2P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – FOODiE"},{"text":"private  function ctoi_I1P(pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( pref , error , str , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting string to integer. This function achieves casting of string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. character ( * ), intent ( IN ) :: str !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – FOODiE"},{"text":"private elemental function bstr_R16P(n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – FOODiE"},{"text":"private elemental function bstr_R8P(n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – FOODiE"},{"text":"private elemental function bstr_R4P(n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string of bits. This function achieves casting of real to bit-string. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none real ( R4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – FOODiE"},{"text":"private elemental function bstr_I8P(n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – FOODiE"},{"text":"private elemental function bstr_I4P(n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – FOODiE"},{"text":"private elemental function bstr_I2P(n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – FOODiE"},{"text":"private elemental function bstr_I1P(n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n ! Casting of n to bit-string. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – FOODiE"},{"text":"private elemental function bctor_R8P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R8P ), intent ( IN ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – FOODiE"},{"text":"private elemental function bctor_R4P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to real. This function achieves casting of bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. real ( R4P ), intent ( IN ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – FOODiE"},{"text":"private elemental function bctoi_I8P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I8P ), intent ( IN ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – FOODiE"},{"text":"private elemental function bctoi_I4P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I4P ), intent ( IN ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – FOODiE"},{"text":"private elemental function bctoi_I2P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I2P ), intent ( IN ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – FOODiE"},{"text":"private elemental function bctoi_I1P(bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), intent ( IN ) :: bstr !< String containing input number. integer ( I1P ), intent ( IN ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str (. true ., bit_size ( knd ))) // '.' // trim ( str (. true ., bit_size ( knd ))) // ')' ) n ! Casting of bstr to n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – FOODiE"},{"text":"private elemental function digit_I8(n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I8P ), intent ( IN ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – FOODiE"},{"text":"private elemental function digit_I4(n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I4P ), intent ( IN ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – FOODiE"},{"text":"private elemental function digit_I2(n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I2P ), intent ( IN ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – FOODiE"},{"text":"private elemental function digit_I1(n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for computing the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- implicit none integer ( I1P ), intent ( IN ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – FOODiE"},{"text":"public  subroutine check_endian() Arguments None Description Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Subroutine for checking the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – FOODiE"},{"text":"public  subroutine IR_init() Arguments None Description Procedure for initilizing module's variables that are not initialized into the definition specification. Source Code subroutine IR_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for initilizing module's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- implicit none !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! checking the bit ordering architecture call check_endian ! computing the bits/bytes sizes of real variables BIR8P = bit_size ( r = MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( r = MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( r = MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( r = MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif ir_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_init","tags":"","loc":"proc/ir_init.html","title":"IR_init – FOODiE"},{"text":"public  subroutine IR_Print(pref, iostat, iomsg, unit) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. integer(kind=I4P), intent(in) :: unit Logic unit. Description Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine IR_Print ( pref , iostat , iomsg , unit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for printing to the standard output the kind definition of reals and integers and the utility variables. !--------------------------------------------------------------------------------------------------------------------------------- implicit none character ( * ), optional , intent ( IN ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . ir_initialized ) call IR_init prefd = '' ; if ( present ( pref )) prefd = pref ! printing informations if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str (. true ., ZeroR16 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str (. true ., ZeroR8 ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str (. true ., ZeroR4 ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine IR_Print","tags":"","loc":"proc/ir_print.html","title":"IR_Print – FOODiE"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Module Procedures private elemental function bit_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable.","tags":"","loc":"interface/bit_size.html","title":"bit_size – FOODiE"},{"text":"public interface byte_size Overloading of the byte_size function for computing the number of bytes. Module Procedures private elemental function byte_size_I8P (i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I4P (i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I2P (i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I1P (i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable.","tags":"","loc":"interface/byte_size.html","title":"byte_size – FOODiE"},{"text":"public interface str Procedure for converting number, real and integer, to string (number to string type casting). Module Procedures private elemental function strf_R16P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R16P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_I8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I2P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I2P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I1P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I1P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_bol (n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. private pure function str_a_R16P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_I8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I2P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I1P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string.","tags":"","loc":"interface/str.html","title":"str – FOODiE"},{"text":"public interface strz Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type\n casting with zero padding). Module Procedures private elemental function strz_I8P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I4P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I2P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I1P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string.","tags":"","loc":"interface/strz.html","title":"strz – FOODiE"},{"text":"public interface cton Procedure for converting string to number, real or initeger, (string to number type casting). Module Procedures private  function ctor_R16P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctoi_I8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I2P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I1P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer.","tags":"","loc":"interface/cton.html","title":"cton – FOODiE"},{"text":"public interface bstr Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). Module Procedures private elemental function bstr_R16P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R8P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R4P (n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_I8P (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I4P (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I2P (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I1P (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string.","tags":"","loc":"interface/bstr.html","title":"bstr – FOODiE"},{"text":"public interface bcton Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). Module Procedures None() Arguments None private elemental function bctor_R8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctor_R4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctoi_I8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I2P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I1P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer.","tags":"","loc":"interface/bcton.html","title":"bcton – FOODiE"},{"text":"public interface digit Procedure for computing the number of digits in decimal base of the input integer. Module Procedures private elemental function digit_I8 (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit.html","title":"digit – FOODiE"},{"text":"private  subroutine integrate(field, dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: dt Time step. Description Integrate field with explicit Euler scheme, 1st order. Source Code subroutine integrate ( field , dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: dt !< Time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field + field % t () * dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FOODiE"},{"text":"public  subroutine destroy(me) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me Source Code subroutine destroy ( me ) implicit none class ( pyplot ), intent ( inout ) :: me if ( allocated ( me % str )) deallocate ( me % str ) end subroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOODiE"},{"text":"public  subroutine add_str(me, str) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: str Source Code subroutine add_str ( me , str ) implicit none class ( pyplot ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: str me % str = me % str // str // new_line ( ' ' ) end subroutine add_str","tags":"","loc":"proc/add_str.html","title":"add_str – FOODiE"},{"text":"public  subroutine initialize(me, grid, xlabel, ylabel, title, legend, use_numpy, figsize, font_size, axes_labelsize, xtick_labelsize, ytick_labelsize, legend_fontsize) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me logical, intent(in), optional :: grid character(len=*), intent(in), optional :: xlabel character(len=*), intent(in), optional :: ylabel character(len=*), intent(in), optional :: title logical, intent(in), optional :: legend logical, intent(in), optional :: use_numpy integer, intent(in), optional dimension(2) :: figsize integer, intent(in), optional :: font_size integer, intent(in), optional :: axes_labelsize integer, intent(in), optional :: xtick_labelsize integer, intent(in), optional :: ytick_labelsize integer, intent(in), optional :: legend_fontsize Variables Type Visibility Attributes Name Initial character(len=max_int_len), public :: width_str character(len=max_int_len), public :: height_str character(len=max_int_len), public :: font_size_str character(len=max_int_len), public :: axes_labelsize_str character(len=max_int_len), public :: xtick_labelsize_str character(len=max_int_len), public :: ytick_labelsize_str character(len=max_int_len), public :: legend_fontsize_str character(len=*), public, parameter :: default_font_size_str = '10' Source Code subroutine initialize ( me , grid , xlabel , ylabel , title , legend , use_numpy , figsize ,& font_size , axes_labelsize , xtick_labelsize , ytick_labelsize , legend_fontsize ) implicit none class ( pyplot ), intent ( inout ) :: me logical , intent ( in ), optional :: grid character ( len =* ), intent ( in ), optional :: xlabel character ( len =* ), intent ( in ), optional :: ylabel character ( len =* ), intent ( in ), optional :: title logical , intent ( in ), optional :: legend logical , intent ( in ), optional :: use_numpy integer , dimension ( 2 ), intent ( in ), optional :: figsize integer , intent ( in ), optional :: font_size integer , intent ( in ), optional :: axes_labelsize integer , intent ( in ), optional :: xtick_labelsize integer , intent ( in ), optional :: ytick_labelsize integer , intent ( in ), optional :: legend_fontsize character ( len = max_int_len ) :: width_str , height_str , font_size_str ,& axes_labelsize_str , xtick_labelsize_str ,& ytick_labelsize_str , legend_fontsize_str character ( len =* ), parameter :: default_font_size_str = '10' !the default font size for plots call me % destroy () if ( present ( legend )) then me % show_legend = legend else me % show_legend = . false . end if if ( present ( use_numpy )) then me % use_numpy = use_numpy else me % use_numpy = . true . end if if ( present ( figsize )) then call integer_to_string ( figsize ( 1 ), width_str ) call integer_to_string ( figsize ( 2 ), height_str ) end if call optional_int_to_string ( font_size , font_size_str , default_font_size_str ) call optional_int_to_string ( axes_labelsize , axes_labelsize_str , default_font_size_str ) call optional_int_to_string ( xtick_labelsize , xtick_labelsize_str , default_font_size_str ) call optional_int_to_string ( ytick_labelsize , ytick_labelsize_str , default_font_size_str ) call optional_int_to_string ( legend_fontsize , legend_fontsize_str , default_font_size_str ) me % str = '' call me % add_str ( '#!/usr/bin/python' ) call me % add_str ( '' ) call me % add_str ( 'import matplotlib' ) call me % add_str ( 'import matplotlib.pyplot as plt' ) if ( me % use_numpy ) call me % add_str ( 'import numpy as np' ) call me % add_str ( '' ) call me % add_str ( 'matplotlib.rcParams[\"font.family\"] = \"Serif\"' ) call me % add_str ( 'matplotlib.rcParams[\"font.size\"] = ' // trim ( font_size_str )) call me % add_str ( 'matplotlib.rcParams[\"axes.labelsize\"] = ' // trim ( axes_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"xtick.labelsize\"] = ' // trim ( xtick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"ytick.labelsize\"] = ' // trim ( ytick_labelsize_str )) call me % add_str ( 'matplotlib.rcParams[\"legend.fontsize\"] = ' // trim ( legend_fontsize_str )) call me % add_str ( '' ) if ( present ( figsize )) then !if specifying the figure size call me % add_str ( 'fig = plt.figure(figsize=(' // trim ( width_str ) // ',' // trim ( height_str ) // '))' ) else call me % add_str ( 'fig = plt.figure()' ) end if call me % add_str ( 'ax = fig.gca()' ) if ( present ( grid )) then if ( grid ) call me % add_str ( 'ax.grid()' ) end if if ( present ( xlabel )) call me % add_str ( 'ax.set_xlabel(\"' // trim ( xlabel ) // '\")' ) if ( present ( ylabel )) call me % add_str ( 'ax.set_ylabel(\"' // trim ( ylabel ) // '\")' ) if ( present ( title )) call me % add_str ( 'ax.set_title(\"' // trim ( title ) // '\")' ) call me % add_str ( '' ) end subroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – FOODiE"},{"text":"public  subroutine add_plot(me, x, y, label, linestyle, markersize, linewidth) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: y character(len=*), intent(in) :: label character(len=*), intent(in) :: linestyle integer, intent(in), optional :: markersize integer, intent(in), optional :: linewidth Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=max_int_len), public :: imark character(len=max_int_len), public :: iline character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' Source Code subroutine add_plot ( me , x , y , label , linestyle , markersize , linewidth ) implicit none class ( pyplot ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: linestyle integer , intent ( in ), optional :: markersize integer , intent ( in ), optional :: linewidth character ( len = :), allocatable :: xstr , ystr character ( len = max_int_len ) :: imark , iline character ( len =* ), parameter :: xname = 'x' !variable names for script character ( len =* ), parameter :: yname = 'y' ! if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( x , xstr , me % use_numpy ) call vec_to_string ( y , ystr , me % use_numpy ) !get optional inputs (if not present, set default value): call optional_int_to_string ( markersize , imark , '3' ) call optional_int_to_string ( linewidth , iline , '3' ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) call me % add_str ( '' ) !write the plot statement: call me % add_str ( 'ax.plot(' // & trim ( xname ) // ',' // & trim ( yname ) // ',' // & '\"' // trim ( linestyle ) // '\",' // & 'linewidth=' // trim ( adjustl ( iline )) // ',' // & 'markersize=' // trim ( adjustl ( imark )) // ',' // & 'label=\"' // trim ( label ) // '\")' ) call me % add_str ( '' ) else error stop 'Error in add_plot: pyplot class not properly initialized.' end if end subroutine add_plot","tags":"","loc":"proc/add_plot.html","title":"add_plot – FOODiE"},{"text":"public  subroutine add_bar(me, left, height, label, width, bottom, color) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: left real(kind=wp), intent(in), dimension(:) :: height character(len=*), intent(in) :: label real(kind=wp), intent(in), optional dimension(:) :: width real(kind=wp), intent(in), optional dimension(:) :: bottom character(len=*), intent(in), optional :: color Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: xstr character(len=:), public, allocatable :: ystr character(len=:), public, allocatable :: wstr character(len=:), public, allocatable :: bstr character(len=:), public, allocatable :: plt_str character(len=*), public, parameter :: xname = 'x' character(len=*), public, parameter :: yname = 'y' character(len=*), public, parameter :: wname = 'w' character(len=*), public, parameter :: bname = 'b' Source Code subroutine add_bar ( me , left , height , label , width , bottom , color ) implicit none class ( pyplot ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: left real ( wp ), dimension (:), intent ( in ) :: height character ( len =* ), intent ( in ) :: label real ( wp ), dimension (:), intent ( in ), optional :: width real ( wp ), dimension (:), intent ( in ), optional :: bottom character ( len =* ), intent ( in ), optional :: color character ( len = :), allocatable :: xstr , ystr , wstr , bstr , plt_str character ( len =* ), parameter :: xname = 'x' !variable names for script character ( len =* ), parameter :: yname = 'y' ! character ( len =* ), parameter :: wname = 'w' ! character ( len =* ), parameter :: bname = 'b' ! if ( allocated ( me % str )) then !convert the arrays to strings: call vec_to_string ( left , xstr , me % use_numpy ) call vec_to_string ( height , ystr , me % use_numpy ) if ( present ( width )) call vec_to_string ( width , wstr , me % use_numpy ) if ( present ( bottom )) call vec_to_string ( bottom , bstr , me % use_numpy ) !write the arrays: call me % add_str ( trim ( xname ) // ' = ' // xstr ) call me % add_str ( trim ( yname ) // ' = ' // ystr ) if ( present ( width )) call me % add_str ( trim ( wname ) // ' = ' // wstr ) if ( present ( bottom )) call me % add_str ( trim ( bname ) // ' = ' // bstr ) call me % add_str ( '' ) !create the plot string: plt_str = 'ax.bar(' // & 'left=' // trim ( xname ) // ',' // & 'height=' // trim ( yname ) // ',' if ( present ( width )) plt_str = plt_str // 'width=' // trim ( wname ) // ',' if ( present ( bottom )) plt_str = plt_str // 'bottom=' // trim ( bstr ) // ',' if ( present ( color )) plt_str = plt_str // 'color=\"' // trim ( color ) // '\",' plt_str = plt_str // 'label=\"' // trim ( label ) // '\")' !write the plot statement: call me % add_str ( plt_str ) call me % add_str ( '' ) else error stop 'Error in add_bar: pyplot class not properly initialized.' end if end subroutine add_bar","tags":"","loc":"proc/add_bar.html","title":"add_bar – FOODiE"},{"text":"public  subroutine optional_int_to_string(int_value, string_value, default_value) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: int_value character(len=*), intent(out) :: string_value character(len=*), intent(in) :: default_value Source Code subroutine optional_int_to_string ( int_value , string_value , default_value ) implicit none integer , intent ( in ), optional :: int_value character ( len =* ), intent ( out ) :: string_value character ( len =* ), intent ( in ) :: default_value if ( present ( int_value )) then call integer_to_string ( int_value , string_value ) else string_value = default_value end if end subroutine optional_int_to_string","tags":"","loc":"proc/optional_int_to_string.html","title":"optional_int_to_string – FOODiE"},{"text":"public  subroutine integer_to_string(i, s) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: i character(len=*), intent(out) :: s Variables Type Visibility Attributes Name Initial integer, public :: istat Source Code subroutine integer_to_string ( i , s ) implicit none integer , intent ( in ), optional :: i character ( len =* ), intent ( out ) :: s integer :: istat write ( s , int_fmt , iostat = istat ) i if ( istat /= 0 ) then error stop 'Error converting integer to string' else s = adjustl ( s ) end if end subroutine integer_to_string","tags":"","loc":"proc/integer_to_string.html","title":"integer_to_string – FOODiE"},{"text":"public  subroutine vec_to_string(v, str, use_numpy) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: v character(len=:), intent(out), allocatable :: str logical, intent(in) :: use_numpy Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: istat character(len=max_real_len), public :: tmp Source Code subroutine vec_to_string ( v , str , use_numpy ) implicit none real ( wp ), dimension (:), intent ( in ) :: v character ( len = :), allocatable , intent ( out ) :: str logical , intent ( in ) :: use_numpy integer :: i , istat character ( len = max_real_len ) :: tmp str = '[' do i = 1 , size ( v ) write ( tmp , real_fmt , iostat = istat ) v ( i ) if ( istat /= 0 ) error stop 'Error in vec_to_string' str = str // trim ( adjustl ( tmp )) if ( i < size ( v )) str = str // ',' end do str = str // ']' !convert to numpy array if necessary: if ( use_numpy ) str = 'np.array(' // str // ')' end subroutine vec_to_string","tags":"","loc":"proc/vec_to_string.html","title":"vec_to_string – FOODiE"},{"text":"public  subroutine execute(me, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in), optional :: pyfile Variables Type Visibility Attributes Name Initial integer, public :: istat integer, public :: iunit character(len=:), public, allocatable :: file Source Code subroutine execute ( me , pyfile ) implicit none class ( pyplot ), intent ( inout ) :: me character ( len =* ), intent ( in ), optional :: pyfile !name of the python script to generate integer :: istat , iunit character ( len = :), allocatable :: file if ( allocated ( me % str )) then !file name for python script: if ( present ( pyfile )) then file = trim ( pyfile ) !use the user-specified name else file = trim ( tmp_file ) !use the default end if !generate the file: open ( newunit = iunit , file = file , status = 'REPLACE' , iostat = istat ) if ( istat /= 0 ) error stop 'Error creating python script.' write ( iunit , '(A)' ) me % str close ( iunit , iostat = istat ) !run the file using python: call execute_command_line ( python_exe // ' ' // file ) !cleanup: deallocate ( file ) end if end subroutine execute","tags":"","loc":"proc/execute.html","title":"execute – FOODiE"},{"text":"public  subroutine savefig(me, figfile, pyfile) Arguments Type Intent Optional Attributes Name class( pyplot ), intent(inout) :: me character(len=*), intent(in) :: figfile character(len=*), intent(in), optional :: pyfile Source Code subroutine savefig ( me , figfile , pyfile ) implicit none class ( pyplot ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: figfile !file name for the figure character ( len =* ), intent ( in ), optional :: pyfile !name of the python script to generate if ( allocated ( me % str )) then !finish up the string: if ( me % show_legend ) then call me % add_str ( 'ax.legend(loc=\"best\")' ) call me % add_str ( '' ) end if call me % add_str ( 'plt.savefig(\"' // trim ( figfile ) // '\")' ) !run it: call me % execute ( pyfile ) else error stop 'error in savefig: pyplot class not properly initialized.' end if end subroutine savefig","tags":"","loc":"proc/savefig.html","title":"savefig – FOODiE"},{"text":"private  function constructor_lorenz(initial_state, sigma, rho, beta) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. Return Value type([ , '']) Concrete instance of Lorenz field. Description Construct an initialized Lorenz field. Source Code function constructor_lorenz ( initial_state , sigma , rho , beta ) result ( concrete ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Intial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. type ( lorenz ) :: concrete !< Concrete instance of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concrete % state = initial_state concrete % sigma = sigma concrete % rho = rho concrete % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endfunction constructor_lorenz","tags":"","loc":"proc/constructor_lorenz.html","title":"constructor_lorenz – FOODiE"},{"text":"private  function output(self) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n    dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. Source Code function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % state return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output.html","title":"output – FOODiE"},{"text":"private pure function dLorenz_dt(self) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value class([ , '']),\n    allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: delta Delta state used as temporary variables. Source Code pure function dLorenz_dt ( self ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. type ( lorenz ), allocatable :: delta !< Delta state used as temporary variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! preparing temporary delta allocate ( delta ) allocate ( delta % state ( size ( self % state ))) ! Lorenz equations delta % state ( 1 ) = self % sigma * ( self % state ( 2 ) - self % state ( 1 )) delta % state ( 2 ) = self % state ( 1 ) * ( self % rho - self % state ( 3 )) - self % state ( 2 ) delta % state ( 3 ) = self % state ( 1 ) * self % state ( 2 ) - self % beta * self % state ( 3 ) ! hold Lorenz parameters constant over time delta % sigma = 0. delta % rho = 0. delta % beta = 0. call move_alloc ( delta , dState_dt ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt","tags":"","loc":"proc/dlorenz_dt.html","title":"dLorenz_dt – FOODiE"},{"text":"private pure function lorenz_multiply_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class([ , '']),\n    allocatable Product. Description Multiply a Lorenz field by a real scalar. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: local_product Temporary produtc. Source Code pure function lorenz_multiply_real ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % state = lhs % state * rhs local_product % sigma = lhs % sigma * rhs local_product % rho = lhs % rho * rhs local_product % beta = lhs % beta * rhs call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real","tags":"","loc":"proc/lorenz_multiply_real.html","title":"lorenz_multiply_real – FOODiE"},{"text":"private pure function real_multiply_lorenz(lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class([ , '']),\n    allocatable Product. Description Multiply a real scalar by a Lorenz field. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: local_product Temporary produtc. Source Code pure function real_multiply_lorenz ( lhs , rhs ) result ( product ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: product !< Product. type ( lorenz ), allocatable :: local_product !< Temporary produtc. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( local_product ) local_product % state = rhs % state * lhs local_product % sigma = rhs % sigma * lhs local_product % rho = rhs % rho * lhs local_product % beta = rhs % beta * lhs call move_alloc ( local_product , product ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz","tags":"","loc":"proc/real_multiply_lorenz.html","title":"real_multiply_lorenz – FOODiE"},{"text":"private pure function add_lorenz(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class([ , '']),\n    allocatable Sum. Description Add two Lorenz fields. Variables Type Visibility Attributes Name Initial type( lorenz ), public, allocatable :: local_sum Temporary sum. Source Code pure function add_lorenz ( lhs , rhs ) result ( sum ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: sum !< Sum. type ( lorenz ), allocatable :: local_sum !< Temporary sum. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: local_sum ) select type ( rhs ) class is ( lorenz ) local_sum % state = lhs % state + rhs % state local_sum % sigma = lhs % sigma + rhs % sigma local_sum % rho = lhs % rho + rhs % rho local_sum % beta = lhs % beta + rhs % beta class default ! stop 'add_Lorenz: rhs argument type not supported' endselect call move_alloc ( local_sum , sum ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz","tags":"","loc":"proc/add_lorenz.html","title":"add_lorenz – FOODiE"},{"text":"private pure subroutine lorenz_assign_lorenz(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. Source Code pure subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) if ( allocated ( rhs % state )) lhs % state = rhs % state lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz","tags":"","loc":"proc/lorenz_assign_lorenz.html","title":"lorenz_assign_lorenz – FOODiE"},{"text":"private pure subroutine lorenz_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code pure subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % state )) lhs % state = rhs lhs % sigma = rhs lhs % rho = rhs lhs % beta = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real","tags":"","loc":"proc/lorenz_assign_real.html","title":"lorenz_assign_real – FOODiE"},{"text":"public interface lorenz Overload lorenz name adding the constructor function. Module Procedures private  function constructor_lorenz (initial_state, sigma, rho, beta) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. Return Value type( lorenz ) Concrete instance of Lorenz field. Description Construct an initialized Lorenz field.","tags":"","loc":"interface/lorenz.html","title":"lorenz – FOODiE"},{"text":"Uses: IR_Precision type_integrand FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. The class of integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax (see Butcher, J.C., Coefficients for the study of\n Runge-Kutta integration processes , J. Austral. Math. Soc., Vol. 3, pages: 185–201, 1963). Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: \\gamma&#94;1 \\alpha&#94;{1,1} \\alpha&#94;{1,2} \\cdots \\alpha&#94;{1,Ns} \\gamma&#94;2 \\alpha&#94;{2,1} \\alpha&#94;{2,2} \\cdots \\alpha&#94;{2,Ns} \\vdots \\vdots \\vdots \\ddots \\vdots \\gamma&#94;{Ns} \\alpha&#94;{Ns,1} \\alpha&#94;{Ns,2} \\cdots \\alpha&#94;{Ns,Ns} \\beta&#94;1 \\beta&#94;2 \\cdots \\beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: \\gamma&#94;1       0            0      \\cdots         0     \\gamma&#94;2 \\alpha&#94;{2,1} \\alpha&#94;{2,2} \\cdots \\alpha&#94;{2,Ns} \\vdots \\vdots \\vdots \\ddots \\vdots \\gamma&#94;{Ns} \\alpha&#94;{Ns,1} \\alpha&#94;{Ns,2} \\cdots         0      \\beta&#94;1 \\beta&#94;2 \\cdots \\beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order.\n \\beta = \\left[1\\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0 \\end{array}} \\right]\n \\gamma = \\left[0\\right] 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm. See High Order Strong Stability Preserving Time\n Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009,\n pp. 251-289.\n \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2}&\\frac{1}{2} \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0\\\\ 1&0 \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\end{array}} \\right] 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm. See High Order Strong Stability Preserving Time\n Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009,\n pp. 251-289.\n \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{6}&\\frac{1}{6}&\\frac{1}{3}  \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0&0\\\\ 1&0&0\\\\ \\frac{1}{4}&\\frac{1}{4}&0 \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\\\ \\frac{1}{2} \\end{array}} \\right] 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm. See High Order Strong Stability Preserving Time\n Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009,\n pp. 251-289.\n \\beta = \\left[ {\\begin{array}{*{20}{c}} 0.14681187618661&0.24848290924556&0.10425883036650&0.27443890091960&\n 0.22600748319395 \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}}\n 0&0&0&0&0 \\\\ 0.39175222700392&0&0&0&0 \\\\ 0.21766909633821&0.36841059262959&0&0&0 \\\\ 0.08269208670950&\n 0.13995850206999&0.25189177424738&0&0 \\\\ 0.06796628370320&0.11503469844438&0.20703489864929&0.54497475021237&0\n \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0\\\\0.39175222700392\\\\0.58607968896780\\\\0.47454236302687\\\\0.93501063100924\n           \\end{array}} \\right] Interfaces public interface tvd_runge_kutta_integrator Overload tvd_runge_kutta_integrator name with the constructor function create . private elemental function create (stages) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: stages Number of stages used. Return Value type( tvd_runge_kutta_integrator ) Actual RK integrator. Description Create the actual RK integrators: initialize the Butcher' table coefficients.","tags":"","loc":"module/foodie_integrator_tvd_runge_kutta.html","title":"foodie_integrator_tvd_runge_kutta – FOODiE"},{"text":"Uses: iso_fortran_env Pure Fortran (2003+) library for ensuring codes portability IR_Precision IR_Precision, Fortran (standard 2003+) module for achieving portable codes A KISS library for exploiting codes portability for modern (2003+) Fortran projects. IR_Precision is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; IR_Precision provides many number-to-string and viceversa facilities; IR_Precision is Fortran 2003+ standard compliant; IR_Precision is a Free, Open Source Project. Table of Contents What is IR_Precision? Main features Copyrights Documentation A Taste of IR_Precision Issues Compiler Support What is IR_Precision? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. IR_Precision module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights IR_Precision is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to IR_Precision is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the IR_Precision documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of IR_Precision To be written. Go to Top Variables Type Visibility Attributes Name Initial logical, public :: ir_initialized = .false. Flag for chcecking the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(33,4931) 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. integer, public, parameter :: R16P = selected_real_kind(15,307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15,307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6,37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=10), public, parameter :: FR16P = '(E42.33E4)' Output format for kind=R16P variable. character(len=10), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P variable. character(len=9), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P variable. character(len=10), public, parameter :: FR_P = FR8P Output format for kind=R_P variable. integer, public, parameter :: DR16P = 42 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. character(len=5), public, parameter :: FI8P = '(I20)' Output format                     for kind=I8P variable. character(len=8), private, parameter :: FI8PZP = '(I20.19)' Output format with zero prefixing for kind=I8P variable. character(len=5), public, parameter :: FI4P = '(I11)' Output format                     for kind=I4P variable. character(len=8), private, parameter :: FI4PZP = '(I11.10)' Output format with zero prefixing for kind=I4P variable. character(len=4), public, parameter :: FI2P = '(I6)' Output format                     for kind=I2P variable. character(len=6), private, parameter :: FI2PZP = '(I6.5)' Output format with zero prefixing for kind=I2P variable. character(len=4), public, parameter :: FI1P = '(I4)' Output format                     for kind=I1P variable. character(len=6), private, parameter :: FI1PZP = '(I4.3)' Output format with zero prefixing for kind=I1P variable. character(len=5), public, parameter :: FI_P = FI4P Output format                     for kind=I_P variable. character(len=8), private, parameter :: FI_PZP = FI4PZP Output format with zero prefixing for kind=I_P variable. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: NRknd = 4 Number of defined real kinds. integer, public, parameter :: RPl (1:NRknd) = [R16P,R8P,R4P,R_P] List of defined real kinds. character(len=10), public, parameter :: FRl (1:NRknd) = [FR16P,FR8P,FR4P//' ',FR_P] List of defined real kinds output format. integer, public, parameter :: NIknd = 5 Number of defined integer kinds. integer, public, parameter :: RIl (1:NIknd) = [I8P,I4P,I2P,I1P,I_P] List of defined integer kinds. character(len=5), public, parameter :: FIl (1:NIknd) = [FI8P,FI4P,FI2P//' ',FI1P//' ',FI_P] List of defined integer kinds output format. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P variable. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P variable. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P variable. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P variable. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P variable. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P variable. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P variable. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P variable. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P variable. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P variable. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P variable. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P variable. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P variable. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P variable. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P variable. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P variable. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest (module) representable value of kind=R16P variable. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest (module) representable value of kind=R8P variable. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest (module) representable value of kind=R4P variable. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest (module) representable value of kind=R_P variable. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P variable. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P variable. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P variable. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P variable. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P variable. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P variable. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P variable. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P variable. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P variable. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P variable. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P variable. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P variable. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P variable. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P variable. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P variable. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P variable. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P variable. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P variable. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P variable. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P variable. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P,1._R16P)-nearest(1._R16P,-1._R16P) Smallest representable difference of kind=R16P variable. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P,1._R8P)-nearest(1._R8P,-1._R8P) Smallest representable difference of kind=R8P variable. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P,1._R4P)-nearest(1._R4P,-1._R4P) Smallest representable difference of kind=R4P variable. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P variable. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Procedure for computing the number of bits of a real variable. private elemental function bit_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Procedure for computing the number of bits of a character variable. public interface byte_size Overloading of the byte_size function for computing the number of bytes. private elemental function byte_size_I8P (i) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I4P (i) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I2P (i) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_I1P (i) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Procedure for computing the number of bytes of an integer variable. private elemental function byte_size_R16P (r) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R8P (r) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_R4P (r) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: r Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Procedure for computing the number of bytes of a real variable. private elemental function byte_size_chr (c) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Procedure for computing the number of bytes of a character variable. public interface str Procedure for converting number, real and integer, to string (number to string type casting). private elemental function strf_R16P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R16P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_R4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function str_R4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Procedure for converting real to string. This function achieves casting of real to string. private elemental function strf_I8P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I8P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I4P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I4P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I2P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I2P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function strf_I1P (fm, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_I1P (no_sign, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string. This function achieves casting of integer to string. private elemental function str_bol (n) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Procedure for converting logical to string. This function achieves casting of logical to string. private pure function str_a_R16P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R16P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R8P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_R4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. real(kind=R4P), intent(in) :: n (:) Real array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting real (array) to string. This function achieves casting of real to string. private pure function str_a_I8P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I4P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I2P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. private pure function str_a_I1P (no_sign, delimiters, n) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Procedure for converting integer (array) to string. This function achieves casting of integer to string. public interface strz Procedure for converting number, integer, to string, prefixing with the right number of zeros (number to string type\n casting with zero padding). private elemental function strz_I8P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I4P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I2P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. private elemental function strz_I1P (nz_pad, n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Procedure for converting integer to string, prefixing with the right number of zeros. This function achieves casting of\n integer to string. public interface cton Procedure for converting string to number, real or initeger, (string to number type casting). private  function ctor_R16P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctor_R4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting string to real. This function achieves casting of string to real. private  function ctoi_I8P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I4P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I2P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. private  function ctoi_I1P (pref, error, str, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting string to integer. This function achieves casting of string to integer. public interface bstr Procedure for converting number, real and integer, to bit-string (number to bit-string type casting). private elemental function bstr_R16P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R8P (n) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_R4P (n) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting real to string of bits. This function achieves casting of real to bit-string. private elemental function bstr_I8P (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I4P (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I2P (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. private elemental function bstr_I1P (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Procedure for converting integer to string of bits. This function achieves casting of integer to bit-string. public interface bcton Procedure for converting bit-string to number, real or initeger, (bit-string to number type casting). None() Arguments None private elemental function bctor_R8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctor_R4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Procedure for converting bit-string to real. This function achieves casting of bit-string to real. private elemental function bctoi_I8P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I4P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I2P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. private elemental function bctoi_I1P (bstr, knd) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Procedure for converting bit-string to integer. This function achieves casting of bit-string to integer. public interface digit Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Procedure for computing the number of digits in decimal base of the input integer.","tags":"","loc":"module/ir_precision.html","title":"IR_Precision – FOODiE"},{"text":"Uses: IR_Precision type_integrand FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Derived Types type, public :: euler_explicit_integrator Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. Description FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – FOODiE"},{"text":"Uses: type_integrand foodie_integrator_euler_explicit foodie_integrator_tvd_runge_kutta FOODiE, Fortran Object oriented Ordinary Differential Equations integration library. FOODiE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODiE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: forward explicit Euler scheme, a 1st order accurate scheme; TVD or SSP Runge-Kutta class schemes: TVD(1,1): 1 stage, 1st order scheme, namely the forward explicit Euler one; SSP(2,2): 2 stages, 2nd order scheme; SSP(3,3): 3 stages, 3rd order scheme; SSP(5,4): 5 stages, 4th order scheme; Usage FOODiE schemes must be applied to only subclass extensions of the abstract class type_integrand . To use FOODiE you must: extend type_integrand abstract class provided by FOODiE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: output !< Extract Lorenz field. procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz use one of the provided FOODiE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : euler_explicit_integrator use type_lorenz , only : lorenz type ( euler_explicit_integrator ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo","tags":"","loc":"module/foodie.html","title":"foodie – FOODiE"},{"text":"Uses: IR_Precision Define the abstract type integrand for building FOODiE ODE integrators. Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure subroutine assignment_integrand (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure subroutine assignment_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real. abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function time_derivative (self) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function integrand_op_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function real_op_integrand (lhs, rhs) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. abstract interface Abstract type bound procedures necessary for implementing the class(integrand). private pure function symmetric_operator (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"module/type_integrand.html","title":"type_integrand – FOODiE"},{"text":"Uses: iso_fortran_env ** h pyplotfortran/pyplot_module NAME\n    pyplot_module DESCRIPTION\n    For making simple x-y plots from Fortran.\n    It works by generating a Python script and executing it. SEE ALSO\n    Inspired by these:\n    * http://pypi.python.org/pypi/EasyPlot/1.0.0\n    * http://nbviewer.ipython.org/github/HamsterHuey/easyplot/blob/master/docs/easyplot_docs.ipynb AUTHOR\n    Jacob Williams HISTORY\n    * Jacob Williams : Created : 4/14/2015 ** d pyplot_module/wp NAME\n    wp DESCRIPTION\n    Default real kind [8 bytes]. SOURCE ** d pyplot_module/tmp_file NAME\n    tmp_file DESCRIPTION\n    Default name of the temporary file \n    (this can also be user-specified). SOURCE ** f pyplot_module/destroy NAME destroy DESCRIPTION\n    Destructor SOURCE ** f pyplot_module/add_str NAME add_str DESCRIPTION\n    Add a string to the buffer. SOURCE ** f pyplot_module/initialize NAME initialize DESCRIPTION\n    initialize a plot SOURCE ** f pyplot_module/add_plot NAME add_plot DESCRIPTION\n    Add an x,y plot. SOURCE ** f pyplot_module/add_bar NAME add_bar DESCRIPTION\n    Add a bar plot. SOURCE ** f pyplot_module/optional_int_to_string NAME optional_int_to_string DESCRIPTION\n    Integer to string, specifying the default value if \n    the optional argument is not present. SOURCE ** f pyplot_module/integer_to_string NAME integer_to_string DESCRIPTION\n    Integer to string conversion. SOURCE ** f pyplot_module/vec_to_string NAME vec_to_string DESCRIPTION\n    Real vector to string. SOURCE ** f pyplot_module/execute NAME execute DESCRIPTION\n    Write the buffer to a file, and then execute it with Python. SOURCE ** f pyplot_module/savefig NAME savefig DESCRIPTION\n    Save the figure. SOURCE Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: tmp_file = 'pyplot_module_temp_1234567890.py' ** d pyplot_module/python_exe NAME\n    python_exe DESCRIPTION\n    The python executable name. SOURCE character(len=*), public, parameter :: python_exe = 'python' character(len=*), public, parameter :: int_fmt = '(I10)' integer, public, parameter :: max_int_len = 10 character(len=*), public, parameter :: real_fmt = '(E30.16)' integer, public, parameter :: max_real_len = 30 ** c pyplot_module/pyplot NAME\n    pyplot DESCRIPTION\n    The main class. SOURCE Derived Types type, public :: pyplot Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: str logical, private :: show_legend = .false. logical, private :: use_numpy = .true. Type-Bound Procedures procedure, public :: initialize procedure, public :: add_plot procedure, public :: add_bar procedure, public :: savefig procedure, public :: destroy procedure, public :: execute procedure, public :: add_str","tags":"","loc":"module/pyplot_module.html","title":"pyplot_module – FOODiE"},{"text":"Uses: IR_Precision foodie Define Lorenz field that is a concrete extension of the abstract integrand type. Interfaces public interface lorenz Overload lorenz name adding the constructor function. private  function constructor_lorenz (initial_state, sigma, rho, beta) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in), dimension(:) :: initial_state Intial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. Return Value type( lorenz ) Concrete instance of Lorenz field. Description Construct an initialized Lorenz field.","tags":"","loc":"module/type_lorenz.html","title":"type_lorenz – FOODiE"},{"text":"Uses: IR_Precision type_lorenz foodie pyplot_module Test FOODiE with the integration of Lorenz equations. Variables Type Attributes Name Initial type( euler_explicit_integrator ) :: euler_integrator Euler integrator. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ) :: rk_stage (1:rk_stages) Runge-Kutta stages. type( lorenz ) :: attractor Lorenz field. integer :: step Time steps counter. integer, parameter :: num_steps = 2000 Maximum time steps. integer, parameter :: space_dimension = 3 Space dimensions. real(kind=R_P), parameter :: sigma = 10._R_P Lorenz' \\sigma. real(kind=R_P), parameter :: rho = 28._R_P Lorenz' \\rho. real(kind=R_P), parameter :: beta = 8._R_P/3._R_P Lorenz' \\beta. real(kind=R_P), parameter :: dt = 0.01_R_P Time step. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [1.,1.,1.] Initial state. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. type( pyplot ) :: plt Plot file handler. integer(kind=I_P) :: s RK stages counter. Source Code program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , str use type_lorenz , only : lorenz use foodie , only : euler_explicit_integrator , tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: attractor !< Lorenz field. integer :: step !< Time steps counter. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: s !< RK stages counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! solve Lorenz equations by means of the Forward Explicit Euler scheme ! initialize field attractor = lorenz ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0. solution ( 1 : 3 , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : 3 , step ) = attractor % output () enddo ! save plot of results call plt % initialize ( grid = . true ., xlabel = 'time' , title = 'FOODiE test: Lorenz equation integration, explicit Euler' , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'sigma' , linestyle = 'g-' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'rho' , linestyle = 'b-x' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'beta' , linestyle = 'r-o' , linewidth = 1 , markersize = 4 ) call plt % savefig ( 'lorenz_integration-euler.png' ) ! solve Lorenz equations by means of the TVD/SSP RK schemes (testing all available schemes) do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented ! initialize the RK integrator accordingly to the number of stages used rk_integrator = tvd_runge_kutta_integrator ( stages = s ) ! initialize field attractor = lorenz ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0. solution ( 1 : 3 , 0 ) = attractor % output () ! integrate field do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt ) solution ( 0 , step ) = step * dt solution ( 1 : 3 , step ) = attractor % output () enddo ! save plot of results call plt % initialize ( grid = . true ., xlabel = 'time' , title = 'FOODiE test: Lorenz equation integration, explicit Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'sigma' , linestyle = 'g-' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'rho' , linestyle = 'b-x' , linewidth = 1 , markersize = 4 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'beta' , linestyle = 'r-o' , linewidth = 1 , markersize = 4 ) call plt % savefig ( 'lorenz_integration-rk-' // trim ( str (. true ., s )) // '.png' ) enddo stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram integrate_lorenz","tags":"","loc":"program/integrate_lorenz.html","title":"integrate_lorenz – FOODiE"}]}