var tipuesearch = {"pages":[{"text":"FOODiE FOODiE FOODiE, Fortran Object oriented Ordinary Differential Equations integration library FOODiE is a pure Fortran (KISS) library for integrating Ordinary Differential Equations (ODE); FOODiE is Fortran 2003+ standard compliant; FOODiE is OOP designed; FOODiE is a Free, Open Source Project. Table of Contents What is FOODiE? Main features Status Copyrights Documentation What is FOODiE? Modern Fortran standards (2003+) have introduced support for Object Oriented Programming. Exploiting new features like Abstract Data Type (ADT) is now possible to develop a KISS library for integrating Ordinary Differential Equations on ADT making the development of new numerical schemes faster, easier and clearer. Go to Top Main features FOODiE is aimed to be a KISS-pure-Fortran library for integrating Ordinary Differential Equations (ODE), it being: Pure Fortran implementation; KISS and user-friendly: simple API, presently based on the Rouson's Abstract Data Type Pattern [8]; easy building and porting on heterogeneous architectures; comprehensive solvers set out-of-the-box: explicit schemes: Adams-Bashforth schemes see [7]: 1 step, namely the forward explicit Euler scheme, 1st order accurate; 2 steps, 2nd accurate; 3 steps, 3rd accurate; Euler scheme, 1st order accurate; Leapfrog , 2nd order accurate: unfiltered leapfrog, 2nd order accurate, mostly unstable, see [4]; Robert-Asselin filtered leapfrog, 1st order accurate, see [4, 5, 6]; Robert-Asselin-Williams filtered leapfrog, 3rd order accurate, see [5, 6]; Runge-Kutta schemes: low-storage schemes, see [1, 2, 3]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages; 3 stages; 4 stages; 5 stages, 4th order accurate, 2N registers, see [3]; TVD/SSP schemes, see [1]: 1 stage, namely the forward explicit Euler scheme, 1st order accurate; 2 stages, 2nd order accurate; 3 stages, 3rd order accurate; 4 stages; 5 stages, 4th order accurate; implicit schemes: Runge-Kutta schemes; efficient: high scalability on parallel architectures: support for shared memory multi/many cores architecture; support for distributed memory cluster; support for GPGPU/accelerators device; Tests-Driven Developed ( TDD ): well documented: clear documentation of schemes implementations, e.g. see Adams-Bashforth API documentation ; complete API reference; comprehensive wiki : collaborative developed on GitHub ; FOSS licensed ; Any feature request is welcome. Bibliography [1] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of Scientific Computing, vol. 38, N. 3, 2009, pp. 251–289. [2] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [3] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, June 1994. [4] Numerical methods used in atmospheric models , Mesinger F. and A. Arakawa, Global Atmospheric Research Programme (GARP), Technical Report , 1976. [5] A Proposed Modification to the Robert-Asselin Time Filter , Williams, P. D., Mon. Wea. Rev., vol. 137, pp. 2538–2546, 2009, doi: http://dx.doi.org/10.1175/2009MWR2724.1. [6] The RAW filter: An improvement to the Robert-Asselin filter in semi-implicit integrations , Williams, P.D., Monthly Weather Review, vol. 139(6), pages 1996–2007, June 2011. [7] Linear multistep method , wikipedia article . [8] Scientific Software Design: The Object-Oriented Way , Rouson, Damian and Xia, Jim and Xu, Xiaofeng, 2011, ISBN 9780521888134, Cambridge University Press, New York, NY, USA. Go to Top Status FOODiE project is young, but developed with love. A bunch of integrators have been implemented using the Rouson's Abstract Data Type Pattern and tested with complex problems, but the library API is not yet stable. Nevertheless, FOODiE is already proven to be able to integrate a wide range of different ODE problems, from pure ODEs (Lorenz and inertial oscillations equations) to complex PDEs (Burgers and Euler equations), see the documentation. We are searching for Fortraners enthusiast joining our team! Copyrights FOODiE is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to FOODiE is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the FOODiE documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Fortran-FOSS-Programmers Group","tags":"","loc":"index.html","title":" FOODiE "},{"text":"Source Code module foodie !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE, Fortran Object oriented Ordinary Differential Equations integration library. !< !< FOODiE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP) !< contest. The mathematical formulation of the problem is: !< !< U_t = R(t,U) !< U_0 = F(0) !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function and *F* is the (vectorial) initial conditions function. !< !< FOODiE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: !< !<+ *explicit Adams-Bashforth* class of schemes: !<    + 1 step, namely the forward explicit Euler scheme, 1st order accurate; !<    + 2 steps, 2nd accurate; !<    + 3 steps, 3rd accurate; !<+ *forward explicit Euler* scheme, a 1st order accurate; !<+ *explicit Leapfrog*: !<    + Unfiltered, 2st order accurate, (mostly) unstable; !<    + Robert-Asselin filtered, 1st order accurate; !<    + Robert-Asselin-Williams filter, 3rd order accurate; !<+ *explicit low storage Runge-Kutta 2N* class schemes: !<    + LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + LS(5,4): 5 stages, 4th order accurate; !<+ *explicit TVD or SSP Runge-Kutta* class schemes: !<    + TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; !<    + SSP(2,2): 2 stages, 2nd order accurate; !<    + SSP(3,3): 3 stages, 3rd order accurate; !<    + SSP(5,4): 5 stages, 4th order accurate; !< !<### Usage !< !< FOODiE schemes must be applied to only subclass extensions of the abstract class *type_integrand*. !< !< To use FOODiE you must: !< !<#### extend type_integrand abstract class provided by FOODiE implementing your concrete integrand field !< !< For example for the Lorenz' ODE system !< !<```fortran !< type, extends(integrand) :: lorenz !<   !< Lorenz equations field. !<   !< !<   !< It is a FOODiE integrand class. !<   private !<   real(R_P), dimension(:), allocatable :: state        !< Solution vector. !<   real(R_P)                            :: sigma=0._R_P !< Lorenz \\sigma. !<   real(R_P)                            :: rho=0._R_P   !< Lorenz \\rho. !<   real(R_P)                            :: beta=0._R_P  !< Lorenz \\beta. !<   contains !<     procedure, pass(self), public :: t => dLorenz_dt                                 !< Time derivate, resiuduals function. !<     procedure, pass(lhs),  public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. !<     procedure, pass(rhs),  public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. !<     procedure, pass(lhs),  public :: add => add_lorenz                               !< Lorenz + Lorenz oprator. !<     procedure, pass(lhs),  public :: assign_integrand => lorenz_assign_lorenz        !< Lorenz = Lorenz. !<     procedure, pass(lhs),  public :: assign_real => lorenz_assign_real               !< Lorenz = real. !<     ... !< endtype lorenz !<``` !< !<#### use one of the provided FOODiE integrator !< !< For example using the forward explicit Euler scheme to the above Lorenz' ODE system !< !<```fortran !< use foodie, only : euler_explicit_integrator !< use type_lorenz, only : lorenz !< type(euler_explicit_integrator) :: euler_integrator !< type(lorenz)                    :: attractor !< real                            :: dt=0.01 !< do step = 1, num_steps !<   call euler_integrator%integrate(field=attractor, dt=dt) !< enddo !<``` !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use type_integrand , only : integrand use foodie_integrator_adams_bashforth , only : adams_bashforth_integrator use foodie_integrator_euler_explicit , only : euler_explicit_integrator use foodie_integrator_leapfrog , only : leapfrog_integrator use foodie_integrator_low_storage_runge_kutta , only : ls_runge_kutta_integrator use foodie_integrator_tvd_runge_kutta , only : tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand public :: adams_bashforth_integrator public :: euler_explicit_integrator public :: leapfrog_integrator public :: ls_runge_kutta_integrator public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- endmodule foodie","tags":"","loc":"sourcefile/foodie.f90.html","title":"foodie.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. Source Code !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. module foodie_integrator_adams_bashforth !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is: !< !<  U&#94;{n+s} = U&#94;{n+s-1} +\\Delta t \\left[ \\sum_{i=1}&#94;{n+s}{ b_i \\cdot R(t&#94;{n+i-1}, U&#94;{n+i-1}) } \\right]  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The coefficients \\b define the actual scheme, that is selected accordingly to the number of !< **steps** used. !< !< Currently the following schemes are available: !<##### 1 step, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !< The *b* coefficient is: !< b = \\left[1\\right] !< The scheme is: !<  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  !< !<##### 2 steps !< This scheme is 2nd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<##### 3 steps !< This scheme is 3rd order. !< The *b* coefficients are: !< b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] = !<       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right] !< The scheme is: !<  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1}) !< +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  !< !<#### Bibliography !< !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: adams_bashforth_integrator !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. !< !< @note The integrator must be created or initialized (initialize the *b* coeficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , field , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps field = field + field % t ( n = s , t = t ( s )) * ( Dt * self % b ( s )) enddo call field % update_previous_steps return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_adams_bashforth","tags":"","loc":"sourcefile/foodie_integrator_adams_bashforth.f90.html","title":"foodie_integrator_adams_bashforth.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Source Code !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. module foodie_integrator_euler_explicit !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: euler_explicit_integrator !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine integrate ( field , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field + field % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_euler_explicit","tags":"","loc":"sourcefile/foodie_integrator_euler_explicit.f90.html","title":"foodie_integrator_euler_explicit.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. Source Code !< FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. module foodie_integrator_leapfrog !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is: !< !<  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  !< !< Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps: !<  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2})  !<  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha  !<  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1)  !< Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme. !< The filter coefficients should be taken as \\nu \\in [0,1] and \\alpha \\in [0.5,1]. The default values are !<+ \\nu=0.01) !<+ \\alpha=0.5) !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. !< !<#### Bibliography !< !< [1] *The integration of a low order spectral form of the primitive meteorological equations*, Robert, A. J., J. Meteor. Soc. !< Japan,vol. 44, pages 237--245, 1966. !< !< [2] *Frequency filter for time integrations*, Asselin, R., Monthly Weather Review, vol. 100, pages 487--490, 1972. !< !< [3] *The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations*, Williams, P.D., Monthly !< Weather Review, vol. 139(6), pages 1996--2007, June 2011. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: leapfrog_integrator !< FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.5_R_P !< Robert-Asselin-Williams filter coefficient. contains procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. endtype leapfrog_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.5_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine integrate ( self , field , filter , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field % previous_step ( n = 1 ) + field % t ( n = 2 , t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( field % previous_step ( n = 1 ) - field % previous_step ( n = 2 ) * 2._R_P + field ) * self % nu * 0.5_R_P endif call field % update_previous_steps ( filter = filter , weights = [ self % alpha , self % alpha - 1._R_P ]) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate endmodule foodie_integrator_leapfrog","tags":"","loc":"sourcefile/foodie_integrator_leapfrog.f90.html","title":"foodie_integrator_leapfrog.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Source Code !< FOODiE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. module foodie_integrator_low_storage_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< The class of integrators provided have the low storage property allowing for an efficient use of the memory. !< Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<\\begin{matrix} !< K_1 = U&#94;n \\\\ !< K_2 = 0 \\\\ !<\\left.\\begin{matrix} !< K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\ !< K_1 = K_1 + B_s K_2 !<\\end{matrix}\\right\\} s=1,2,...N_s\\\\ !<U&#94;{n+1} = K_1 !<\\end{matrix} !< !< where *Ns* is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table !< form. !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being !< meaningless for a first order scheme. However it is added for safety reason. !< A = \\left[ 0 \\right] !< B = \\left[ 1 \\right] !< C = \\left[ 0 \\right] !< !<##### 5 stages, SSP, 4th order !< This scheme is a low storage RK(5, 4), based on the *solution 3* proposed in [2]. !<A = \\left[ {\\begin{matrix} !< 0                                   \\\\ !<-\\frac{567301805773 }{1357537059087} \\\\ !<-\\frac{2404267990393}{2016746695238} \\\\ !<-\\frac{3550918686646}{2091501179385} \\\\ !<-\\frac{1275806237668}{842570457699 } !<\\end{matrix}} \\right] !<B = \\left[ {\\begin{matrix} !<\\frac{1432997174477}{9575080441755 } \\\\ !<\\frac{5161836677717}{13612068292357} \\\\ !<\\frac{1720146321549}{2090206949498 } \\\\ !<\\frac{3134564353537}{4481467310338 } \\\\ !<\\frac{2277821191437}{14882151754819} !<\\end{matrix}} \\right] !<C = \\left[ {\\begin{matrix} !< 0                                  \\\\ !<\\frac{1432997174477}{9575080441755} \\\\ !<\\frac{2526269341429}{6820363962896} \\\\ !<\\frac{2006345519317}{3224310063776} \\\\ !<\\frac{2802321613138}{2924317926251} !<\\end{matrix}} \\right] !< !<#### Bibliography !< !< [1] *Low-Storage Runge-Kutta Schemes*, J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48--56. !< !< [2] *Fourth-Order 2N-Storage Runge-Kutta Schemes*, Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112, !< June 1994. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , I8P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: ls_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , field , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : 2 ) !< Runge-Kutta registers [1:2]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = field stage ( 2 ) = field * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo field = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_low_storage_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_low_storage_runge_kutta.f90.html","title":"foodie_integrator_low_storage_runge_kutta.f90 – FOODiE"},{"text":"FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. Source Code !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. module foodie_integrator_tvd_runge_kutta !----------------------------------------------------------------------------------------------------------------------------------- !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< The class of integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP) !< one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . !< !< Considering the following ODE system: !< !<  U_t = R(t,U)  !< !< where U_t = \\frac{dU}{dt}, *U* is the vector of *state* variables being a function of the time-like independent variable !< *t*, *R* is the (vectorial) residual function, the class of schemes implemented are written in the form: !< !<  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  !< !< where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as: !< !<  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  !< !< @note The value of \\Delta t must be provided, it not being computed by the integrator. !< !< The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are !< given in the Butcher table form: !< !< |                 |                   |                   |            |                    | !< |-----------------|-------------------|-------------------|------------|--------------------| !< | \\gamma&#94;1    | \\alpha&#94;{1,1}  | \\alpha&#94;{1,2}  | \\cdots | \\alpha&#94;{1,Ns}  | !< | \\gamma&#94;2    | \\alpha&#94;{2,1}  | \\alpha&#94;{2,2}  | \\cdots | \\alpha&#94;{2,Ns}  | !< | \\vdots      | \\vdots        | \\vdots        | \\ddots | \\vdots         | !< | \\gamma&#94;{Ns} | \\alpha&#94;{Ns,1} | \\alpha&#94;{Ns,2} | \\cdots | \\alpha&#94;{Ns,Ns} | !< |                 | \\beta&#94;1       | \\beta&#94;2       | \\cdots | \\beta&#94;{Ns}     | !< !< Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: !< !< |                 |                   |                   |            |                    | !< |-----------------|-------------------|-------------------|------------|--------------------| !< | \\gamma&#94;1    |       0       |       0       | \\cdots |         0      | !< | \\gamma&#94;2    | \\alpha&#94;{2,1}  | \\alpha&#94;{2,2}  | \\cdots | \\alpha&#94;{2,Ns}  | !< | \\vdots      | \\vdots        | \\vdots        | \\ddots | \\vdots         | !< | \\gamma&#94;{Ns} | \\alpha&#94;{Ns,1} | \\alpha&#94;{Ns,2} | \\cdots |         0      | !< |                 | \\beta&#94;1       | \\beta&#94;2       | \\cdots | \\beta&#94;{Ns}     | !< !< Moreover the following relation always holds: !<  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  !< !< The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: !< !<##### 1 stage, Explicit Forward Euler, 1st order !< This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. !< \\beta = \\left[1\\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0 \\end{array}} \\right] !< \\gamma = \\left[0\\right] !< !<##### 2 stages, SSP, 2nd order !< This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2]. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2}&\\frac{1}{2} \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0\\\\ 1&0 \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\end{array}} \\right] !< !<##### 3 stages, SSP, 3rd order !< This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2]. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{6}&\\frac{1}{6}&\\frac{1}{3}  \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0&0\\\\ 1&0&0\\\\ \\frac{1}{4}&\\frac{1}{4}&0 \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\\\ \\frac{1}{2} \\end{array}} \\right] !< !<##### 5 stages, SSP, 4th order !< This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2]. !< \\beta = \\left[ {\\begin{array}{*{20}{c}} 0.14681187618661&0.24848290924556&0.10425883036650&0.27443890091960& !< 0.22600748319395 \\end{array}} \\right] !< \\alpha = \\left[ {\\begin{array}{*{20}{c}} !< 0&0&0&0&0 \\\\ 0.39175222700392&0&0&0&0 \\\\ 0.21766909633821&0.36841059262959&0&0&0 \\\\ 0.08269208670950& !< 0.13995850206999&0.25189177424738&0&0 \\\\ 0.06796628370320&0.11503469844438&0.20703489864929&0.54497475021237&0 !< \\end{array}} \\right] !< \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0\\\\0.39175222700392\\\\0.58607968896780\\\\0.47454236302687\\\\0.93501063100924 !<           \\end{array}} \\right] !< !<#### Bibliography !< !< [1] *Coefficients for the study of Runge-Kutta integration processes*, Butcher, J.C., J. Austral. Math. Soc., Vol. 3, !< pages: 185--201, 1963. !< !< [2] *High Order Strong Stability Preserving Time Discretizations*, Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of !< Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use type_integrand , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type :: tvd_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy subroutine integrate ( self , field , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = field do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages field = field + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate ! private methods elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize endmodule foodie_integrator_tvd_runge_kutta","tags":"","loc":"sourcefile/foodie_integrator_tvd_runge_kutta.f90.html","title":"foodie_integrator_tvd_runge_kutta.f90 – FOODiE"},{"text":"Define the abstract type integrand for building FOODiE ODE integrators. Source Code !< Define the abstract type *integrand* for building FOODiE ODE integrators. module type_integrand !----------------------------------------------------------------------------------------------------------------------------------- !< Define the abstract type *integrand* for building FOODiE ODE integrators. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , abstract :: integrand !< Abstract type for building FOODiE ODE integrators. contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. procedure ( update_previous_steps ), pass ( self ), deferred , public :: update_previous_steps !< Update the previous time steps. procedure ( previous_step ), pass ( self ), deferred , public :: previous_step !< Get a previous time step. ! operators procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand oprator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand oprator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< Integrand = real. ! operators overloading generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading = assignament. endtype integrand abstract interface !< Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). function time_derivative ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative function of integrand class, i.e. the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P , I_P class ( integrand ), intent ( IN ) :: self !< Integrand field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Result of the time derivative function of integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction time_derivative subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update the previous time steps (of integrand field) for multi-step(level) ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( INOUT ) :: self !< Integrand field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get a previous time steps (of integrand field) for multi-step(level) ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , I_P class ( integrand ), intent ( IN ) :: self !< Integrand field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Selected previous time integrand field. !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function integrand_op_real ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator integrand.op.real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction integrand_op_real function real_op_integrand ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric type operator real.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_op_integrand function symmetric_operator ( lhs , rhs ) result ( operator_result ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric type operator integrand.op.integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: operator_result !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- endfunction symmetric_operator subroutine assignment_integrand ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Symmetric assignment integrand = integrand. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_integrand subroutine assignment_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Asymmetric assignment integrand = real. !--------------------------------------------------------------------------------------------------------------------------------- import :: integrand , R_P class ( integrand ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assignment_real endinterface !----------------------------------------------------------------------------------------------------------------------------------- endmodule type_integrand","tags":"","loc":"sourcefile/type_integrand.f90.html","title":"type_integrand.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Burgers equation. Source Code !< Test FOODiE with the integration of Burgers equation. program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results\" , & \"burgers --solver runge-kutta -r \" , & \"burgers --solver adams-bashforth\" , & \"burgers --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ( s )) if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( field = domain , dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( field = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) else call lf_integrator % integrate ( field = domain , filter = filter , dt = dt , t = t ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"sourcefile/burgers.f90.html","title":"burgers.f90 – FOODiE"},{"text":"Define Burgers field that is a concrete extension of the abstract integrand type. Source Code !< Define Burgers field that is a concrete extension of the abstract integrand type. module type_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Define Burgers field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: burgers !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODiE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! type_integrand deferred methods function dBurgers_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx ( n = n ) * self % nu dState_dt = dState_dt - self * self % x ( n = n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real ! private methods function dBurgers_dx ( self , n ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the first order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer , optional , intent ( IN ) :: n !< Time level. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. integer :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % previous ( i + 1 , dn ) - self % previous ( i - 1 , dn )) / ( 2._R_P * self % h ) enddo derivative % U ( 1 ) = ( self % previous ( 2 , dn ) - self % previous ( self % Ni , dn )) / ( 2._R_P * self % h ) derivative % U ( self % Ni ) = ( self % previous ( 1 , dn ) - self % previous ( self % Ni - 1 , dn )) / ( 2._R_P * self % h ) else ! self%previous should not be used, use directly self%U do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - self % U ( i - 1 )) / ( 2._R_P * self % h ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - self % U ( self % Ni )) / ( 2._R_P * self % h ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - self % U ( self % Ni - 1 )) / ( 2._R_P * self % h ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction function d2Burgers_dx2 ( self , n ) result ( derivative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the second order spatial derivative of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer , optional , intent ( IN ) :: n !< Time level. type ( burgers ) :: derivative !< Burgers field derivative. integer ( I_P ) :: i !< Counter. integer :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- derivative = self if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % previous ( i + 1 , dn ) - 2._R_P * self % previous ( i , dn ) + self % previous ( i - 1 , dn )) / ( self % h ** 2 ) enddo derivative % U ( 1 ) = ( self % previous ( 2 , dn ) - 2._R_P * self % previous ( 1 , dn ) + self % previous ( self % Ni , dn )) / ( self % h ** 2 ) derivative % U ( self % Ni ) = ( self % previous ( 1 , dn ) - 2._R_P * self % previous ( self % Ni , dn ) + self % previous ( self % Ni - 1 , dn )) / & ( self % h ** 2 ) else ! self%previous should not be used, use directly self%U do i = 2 , self % Ni - 1 derivative % U ( i ) = ( self % U ( i + 1 ) - 2._R_P * self % U ( i ) + self % U ( i - 1 )) / ( self % h ** 2 ) enddo derivative % U ( 1 ) = ( self % U ( 2 ) - 2._R_P * self % U ( 1 ) + self % U ( self % Ni )) / ( self % h ** 2 ) derivative % U ( self % Ni ) = ( self % U ( 1 ) - 2._R_P * self % U ( self % Ni ) + self % U ( self % Ni - 1 )) / ( self % h ** 2 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction endmodule type_burgers","tags":"","loc":"sourcefile/type_burgers.f90.html","title":"type_burgers.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Euler 1D PDEs system. Source Code !< Test FOODiE with the integration of Euler 1D PDEs system. program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp , only : euler_1D_openmp use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.15_R_P !< Final time. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D --results  \" , & \"euler-1D -r -t -v -p\" , & \"euler-1D            \" , & \"euler-1D --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL print \"(A)\" , 'Testing FOODiE with ' // trim ( str (. true ., omp_threads )) // ' OpenMP threads for Ni: ' // trim ( str (. true ., Ni )) // ' cells' #endif ! create Euler field initial state call init () print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P steps = 0 call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt steps = steps + 1 call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(A)\" , 'Finish! Average system seconds spent for 1 step integration: ' // trim ( str (. true ., system_clocks )) stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"sourcefile/euler-1d-openmp.f90.html","title":"euler-1D-openmp.f90 – FOODiE"},{"text":"Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. module type_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODiE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! type_integrand deferred methods function dEuler_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: dn !< Time level, dummy variable. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) ; F = 0._R_P allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) ; P = 0._R_P allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) ; PR = 0._R_P !$OMP PARALLEL DEFAULT(NONE) & !$OMP PRIVATE(i, dn, n) & !$OMP SHARED(self, P) ! compute primitive variables if ( self % steps >= 2 ) then ! self%previous should be used, multi-step time integration dn = self % steps ; if ( present ( n )) dn = n !$OMP DO do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % previous (:, i , dn )) enddo else ! self%U should be used, single-step time integration !$OMP DO do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif !$OMP END PARALLEL call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DEFAULT(NONE) & !$OMP PRIVATE(i) & !$OMP SHARED(self, F, PR) !$OMP DO do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo !$OMP END PARALLEL ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self !!$OMP PARALLEL DEFAULT(PRIVATE) & !!$OMP SHARED(self, dState_dt, F) !!$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !!$OMP END PARALLEL endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D_openmp ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: previous ) select type ( previous ) class is ( euler_1D_openmp ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs select type ( rhs ) class is ( euler_1D_openmp ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs select type ( rhs ) class is ( euler_1D_openmp ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs select type ( rhs ) class is ( euler_1D_openmp ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP PARALLEL DEFAULT(NONE) & !$OMP PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) & !$OMP SHARED(self, primitive, r_primitive) !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo !$OMP END PARALLEL case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo !$OMP END PARALLEL endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D_openmp","tags":"","loc":"sourcefile/type_euler-1d-openmp.f90.html","title":"type_euler-1D-openmp.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Euler 1D PDEs system. Source Code !< Test FOODiE with the integration of Euler 1D PDEs system. program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.15_R_P !< Final time. integer ( I_P ), parameter :: Ni = 100 !< Number of grid cells. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. real ( R_P ) :: Dx = 1._R_P / Ni !< Space step discretization. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ) :: initial_state ( 1 : Np , 1 : Ni ) !< Initial state of primitive variables. real ( R_P ) :: x ( 1 : Ni ) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results\" , & \"euler-1D --solver runge-kutta -r \" , & \"euler-1D --solver adams-bashforth\" , & \"euler-1D --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ( s )) if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( field = domain , dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( field = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit leapfrog, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-lf-RAW-filter-time_serie.dat' , & t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) else call lf_integrator % integrate ( field = domain , filter = filter , dt = dt , t = t ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit leapfrog, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit low storage Runge-Kutta, t=' // & str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-lsrk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-tvdrk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"sourcefile/euler-1d.f90.html","title":"euler-1D.f90 – FOODiE"},{"text":"Define Euler 1D field that is a concrete extension of the abstract integrand type. Source Code !< Define Euler 1D field that is a concrete extension of the abstract integrand type. module type_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Define Euler 1D field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand use wenoof , only : weno_factory , weno_constructor_upwind , weno_interpolator , weno_interpolator_upwind !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODiE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt ! type_integrand deferred methods function dEuler_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: dn !< Time level, dummy variable. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables if ( self % steps >= 2 ) then ! self%previous should be used, multi-step time integration dn = self % steps ; if ( present ( n )) dn = n do i = 1 , Ni P (:, i ) = self % conservative2primitive ( previous (:, i , dn )) enddo else ! self%U should be used, single-step time integration do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo endif call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real ! private methods pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H endmodule type_euler_1D","tags":"","loc":"sourcefile/type_euler-1d.f90.html","title":"type_euler-1D.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Lorenz equations. Source Code !< Test FOODiE with the integration of Lorenz equations. program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results\" , & \"lorenz --solver runge-kutta -r \" , & \"lorenz --solver adams-bashforth\" , & \"lorenz --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) else call ab_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) else call lf_integrator % integrate ( field = attractor , filter = filter , dt = dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"sourcefile/lorenz.f90.html","title":"lorenz.f90 – FOODiE"},{"text":"Define Lorenz field that is a concrete extension of the abstract integrand type. Source Code !< Define Lorenz field that is a concrete extension of the abstract integrand type. module type_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Define Lorenz field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: lorenz !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODiE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODiE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output ! type_integrand deferred methods function dLorenz_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n dState_dt % U ( 1 ) = self % sigma * ( self % previous ( 2 , dn ) - self % previous ( 1 , dn )) dState_dt % U ( 2 ) = self % previous ( 1 , dn ) * ( self % rho - self % previous ( 3 , dn )) - self % previous ( 2 , dn ) dState_dt % U ( 3 ) = self % previous ( 1 , dn ) * self % previous ( 2 , dn ) - self % beta * self % previous ( 3 , dn ) else ! self%previous should not be used, use directly self%U dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endif endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real endmodule type_lorenz","tags":"","loc":"sourcefile/type_lorenz.f90.html","title":"type_lorenz.f90 – FOODiE"},{"text":"Test FOODiE with the integration of Oscillation equations. Source Code !< Test FOODiE with the integration of Oscillation equations. program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_oscillation , only : oscillation use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( oscillation ) :: attractor !< Oscillation field. integer , parameter :: num_steps = 1 e4 !< Maximum time steps. integer , parameter :: space_dimension = 2 !< Space dimensions. real ( R_P ), parameter :: f = 1 e - 4_R_P !< Frequency. real ( R_P ), parameter :: dt = 10 0._R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 0._R_P , 1._R_P ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results\" , & \"oscillation --solver runge-kutta -r \" , & \"oscillation --solver adams-bashforth\" , & \"oscillation --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Oscillation equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 2 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 3 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) else call ab_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit ' // 'Adams-Bashforth ' // & trim ( str (. true ., s )) // ' steps' , & filename = 'oscillation_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integrations, explicit Euler' , & filename = 'oscillation_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( oscillation ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init () call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , f = f , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) else call lf_integrator % integrate ( field = attractor , filter = filter , dt = dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit leapfrog scheme' ,& filename = 'oscillation_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : registers ) !< Runge-Kutta registers. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , filename = 'oscillation_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'oscillation_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_oscillation","tags":"","loc":"sourcefile/oscillation.f90.html","title":"oscillation.f90 – FOODiE"},{"text":"Define Oscillation field that is a concrete extension of the abstract integrand type. Source Code !< Define Oscillation field that is a concrete extension of the abstract integrand type. module type_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Define Oscillation field that is a concrete extension of the abstract integrand type. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P use foodie , only : integrand !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: oscillation !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODiE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 2 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: sub => sub_oscillation !< Oscillation - Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. procedure , pass ( lhs ), public :: assign_real => oscillation_assign_real !< Oscillation = real. endtype oscillation !----------------------------------------------------------------------------------------------------------------------------------- contains ! auxiliary methods subroutine init ( self , initial_state , f , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: f !< Frequency. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % f = f return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output ! type_integrand deferred methods function dOscillation_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: dState_dt ) select type ( dState_dt ) class is ( oscillation ) dState_dt = self if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n dState_dt % U ( 1 ) = - self % f * self % previous ( 2 , dn ) dState_dt % U ( 2 ) = self % f * self % previous ( 1 , dn ) else ! self%previous should not be used, use directly self%U dState_dt % U ( 1 ) = - self % f * self % U ( 2 ) dState_dt % U ( 2 ) = self % f * self % U ( 1 ) endif endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( oscillation ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: previous ) select type ( previous ) class is ( oscillation ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation function oscillation_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real function real_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation function add_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation function sub_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_Oscillation subroutine oscillation_assign_oscillation ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % f = rhs % f endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation subroutine oscillation_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_real endmodule type_oscillation","tags":"","loc":"sourcefile/type_oscillation.f90.html","title":"type_oscillation.f90 – FOODiE"},{"text":"type, public :: adams_bashforth_integrator FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. Note The integrator must be created or initialized (initialize the b coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destoy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, field, Dt, t) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. Description Integrate field with Adams-Bashforth class scheme. Source Code type :: adams_bashforth_integrator !< FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. !< !< @note The integrator must be created or initialized (initialize the *b* coeficients) before used. private integer ( I_P ) :: steps = 0 !< Number of time steps. real ( R_P ), allocatable :: b (:) !< b coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype adams_bashforth_integrator","tags":"","loc":"type/adams_bashforth_integrator.html","title":"adams_bashforth_integrator – FOODiE "},{"text":"type, public :: euler_explicit_integrator FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Note The integrator can be used directly without any initialization. Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. private subroutine integrate (field, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit Euler scheme, 1st order. Source Code type :: euler_explicit_integrator !< FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. !< !< @note The integrator can be used directly without any initialization. contains procedure , nopass , public :: integrate !< Integrate integrand field. endtype euler_explicit_integrator","tags":"","loc":"type/euler_explicit_integrator.html","title":"euler_explicit_integrator – FOODiE "},{"text":"type, public :: leapfrog_integrator FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. Note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values\n are suitable for the problem. Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.5_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, field, filter, Dt, t) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout), optional :: filter Filter field displacement. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with leapfrog class scheme. Source Code type :: leapfrog_integrator !< FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. !< !< @note The integrator could be used without initialialization (initialize the time filter coefficients) if the defulat values !< are suitable for the problem. private real ( R_P ) :: nu = 0.01_R_P !< Robert-Asselin filter coefficient. real ( R_P ) :: alpha = 0.5_R_P !< Robert-Asselin-Williams filter coefficient. contains procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. endtype leapfrog_integrator","tags":"","loc":"type/leapfrog_integrator.html","title":"leapfrog_integrator – FOODiE "},{"text":"type, public :: ls_runge_kutta_integrator FOODiE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), public, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), public, allocatable :: C (:) Low storage C coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, field, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:2) Runge-Kutta registers [1:2]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. Source Code type :: ls_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: A (:) !< Low storage *A* coefficients. real ( R_P ), allocatable :: B (:) !< Low storage *B* coefficients. real ( R_P ), allocatable :: C (:) !< Low storage *C* coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype ls_runge_kutta_integrator","tags":"","loc":"type/ls_runge_kutta_integrator.html","title":"ls_runge_kutta_integrator – FOODiE "},{"text":"type, public :: tvd_runge_kutta_integrator FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. Note The integrator must be created or initialized (initialize the RK coeficients) before used.\n Finalize object. Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalization Procedures final :: finalize private elementalsubroutine finalize (self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Type-Bound Procedures procedure, public, pass(self) :: destroy Destroy the integrator. private elementalsubroutine destroy (self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. procedure, public, pass(self) :: init Initialize (create) the integrator. private elementalsubroutine init (self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. procedure, public, pass(self) :: integrate Integrate integrand field. private subroutine integrate (self, field, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Source Code type :: tvd_runge_kutta_integrator !< FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. !< !< @note The integrator must be created or initialized (initialize the RK coeficients) before used. integer ( I_P ) :: stages = 0 !< Number of stages. real ( R_P ), allocatable :: alph (:,:) !< \\alpha Butcher's coefficients. real ( R_P ), allocatable :: beta (:) !< \\beta Butcher's coefficients. real ( R_P ), allocatable :: gamm (:) !< \\gamma Butcher's coefficients. contains procedure , pass ( self ), public :: destroy !< Destroy the integrator. procedure , pass ( self ), public :: init !< Initialize (create) the integrator. procedure , pass ( self ), public :: integrate !< Integrate integrand field. final :: finalize !< Finalize object. endtype tvd_runge_kutta_integrator","tags":"","loc":"type/tvd_runge_kutta_integrator.html","title":"tvd_runge_kutta_integrator – FOODiE "},{"text":"type, public, abstract :: integrand Abstract type for building FOODiE ODE integrators. Type-Bound Procedures procedure( time_derivative ), public, pass(self), deferred :: t Time derivative, residuals. function time_derivative (self, n, t) result(dState_dt) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. procedure( update_previous_steps ), public, pass(self), deferred :: update_previous_steps Update the previous time steps. subroutine update_previous_steps (self, filter, weights) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: self Integrand field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update the previous time steps (of integrand field) for multi-step(level) ODE solvers. procedure( previous_step ), public, pass(self), deferred :: previous_step Get a previous time step. function previous_step (self, n) result(previous) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Selected previous time integrand field. Description Get a previous time steps (of integrand field) for multi-step(level) ODE solvers. procedure( symmetric_operator ), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( integrand_op_real ), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. function integrand_op_real (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. procedure( real_op_integrand ), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. function real_op_integrand (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: add Integrand + integrand oprator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( symmetric_operator ), public, pass(lhs), deferred :: sub Integrand - integrand oprator. function symmetric_operator (lhs, rhs) result(operator_result) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. procedure( assignment_integrand ), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. subroutine assignment_integrand (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. procedure( assignment_real ), public, pass(lhs), deferred :: assign_real Integrand = real. subroutine assignment_real (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real. generic, public :: operator(+) => add Overloading + operator. pass(lhs) deferred add () Arguments None Description Integrand + integrand oprator. generic, public :: operator(-) => sub Overloading - operator. pass(lhs) deferred sub () Arguments None Description Integrand - integrand oprator. generic, public :: operator(*) => integrand_multiply_integrand , real_multiply_integrand , integrand_multiply_real Overloading * operator. pass(lhs) deferred integrand_multiply_integrand () Arguments None Description Integrand * integrand operator. pass(rhs) deferred real_multiply_integrand () Arguments None Description Real * integrand operator. pass(lhs) deferred integrand_multiply_real () Arguments None Description Integrand * real operator. generic, public :: assignment(=) => assign_integrand , assign_real Overloading = assignament. pass(lhs) deferred assign_integrand () Arguments None Description Integrand = integrand. pass(lhs) deferred assign_real () Arguments None Description Integrand = real. Source Code type , abstract :: integrand !< Abstract type for building FOODiE ODE integrators. contains ! public deferred procedures that concrete integrand-field must implement procedure ( time_derivative ), pass ( self ), deferred , public :: t !< Time derivative, residuals. procedure ( update_previous_steps ), pass ( self ), deferred , public :: update_previous_steps !< Update the previous time steps. procedure ( previous_step ), pass ( self ), deferred , public :: previous_step !< Get a previous time step. ! operators procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: integrand_multiply_integrand !< Integrand * integrand operator. procedure ( integrand_op_real ), pass ( lhs ), deferred , public :: integrand_multiply_real !< Integrand * real operator. procedure ( real_op_integrand ), pass ( rhs ), deferred , public :: real_multiply_integrand !< Real * integrand operator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: add !< Integrand + integrand oprator. procedure ( symmetric_operator ), pass ( lhs ), deferred , public :: sub !< Integrand - integrand oprator. procedure ( assignment_integrand ), pass ( lhs ), deferred , public :: assign_integrand !< Integrand = integrand. procedure ( assignment_real ), pass ( lhs ), deferred , public :: assign_real !< Integrand = real. ! operators overloading generic , public :: operator ( + ) => add !< Overloading + operator. generic , public :: operator ( - ) => sub !< Overloading - operator. generic , public :: operator ( * ) => integrand_multiply_integrand , & real_multiply_integrand , & integrand_multiply_real !< Overloading * operator. generic , public :: assignment ( = ) => assign_integrand , assign_real !< Overloading = assignament. endtype integrand","tags":"","loc":"type/integrand.html","title":"integrand – FOODiE "},{"text":"type, public, extends(integrand) :: burgers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Burgers equations field. It is a FOODiE integrand class concrete extension. Burgers PDE equation The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe\na wide range of different problems, from fluid dynamics to traffic flows, see [1]. \n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = [u]\\;\\;\\;\nF(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x]\n\\end{matrix}\n This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains\ncomplex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature\nof the viscous term. Bibliography [1] The partial differential equation ut + uux = nuxx , Hopf, Eberhard, Communications on Pure and Applied Mathematics,\n vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201–230, 1950. State variables organization State variable is organized as an array (rank 1) for whole physical domain. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. procedure, public, pass(self) :: output Extract Burgers field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. private function dBurgers_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. private function burgers_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. private function burgers_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. private function real_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. private function add_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. private function sub_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. private subroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. private subroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. private function dBurgers_dx (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. private function d2Burgers_dx2 (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Source Code type , extends ( integrand ) :: burgers !< Burgers equations field. !< !< It is a FOODiE integrand class concrete extension. !< !<### Burgers PDE equation !<The Burgers PDE equation is a non linear PDE widely used as numerical benchmark that can be applied to describe !<a wide range of different problems, from fluid dynamics to traffic flows, see [1]. !< !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = [u]\\;\\;\\; !<F(U) = [-\\frac{1}{2}u&#94;2+\\nu u_x] !<\\end{matrix} !< !< !<This is the viscous Burgers' equation, \\nu being the viscosity. This equation is of paramount relevance because it retains !<complex aspects such as the hyperbolic nature of the convection term (allowing discontinuous solutions) and the diffusive nature !<of the viscous term. !< !<#### Bibliography !< !<[1] *The partial differential equation ut + uux = nuxx*, Hopf, Eberhard, Communications on Pure and Applied Mathematics, !< vol 3, issue 3, doi 10.1002/cpa.3160030302, pp. 201--230, 1950. !< !<#### State variables organization !< State variable is organized as an array (rank 1) for whole physical domain. private integer ( I_P ) :: Ni = 0 !< Number of grid nodes. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ) :: h = 0._R_P !< Space step discretization. real ( R_P ) :: nu = 0._R_P !< Viscosity. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, whole physical domain, [1:Ni]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:Ni,1:steps]. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Burgers field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dBurgers_dt !< Time derivative, residuals func. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => burgers_multiply_burgers !< Burgers * burgers operator. procedure , pass ( lhs ), public :: integrand_multiply_real => burgers_multiply_real !< Burgers * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_burgers !< Real * Burgers operator. procedure , pass ( lhs ), public :: add => add_burgers !< Burgers + Burgers operator. procedure , pass ( lhs ), public :: sub => sub_burgers !< Burgers - Burgers operator. procedure , pass ( lhs ), public :: assign_integrand => burgers_assign_burgers !< Burgers = Burgers. procedure , pass ( lhs ), public :: assign_real => burgers_assign_real !< Burgers = real. ! private methods procedure , pass ( self ), private :: x => dBurgers_dx !< 1st derivative. procedure , pass ( self ), private :: xx => d2Burgers_dx2 !< 2nd derivative. endtype burgers","tags":"","loc":"type/burgers.html","title":"burgers – FOODiE "},{"text":"type, public, extends(integrand) :: euler_1D_openmp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D (OpenMP enabled) PDEs system field. It is a FOODiE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type(euler_1D_openmp), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class(euler_1D_openmp), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private subroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D_openmp !< Euler 1D (OpenMP enabled) PDEs system field. !< !< It is a FOODiE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D_openmp","tags":"","loc":"type/euler_1d_openmp.html","title":"euler_1D_openmp – FOODiE "},{"text":"type, public, extends(integrand) :: euler_1D Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Euler 1D PDEs system field. It is a FOODiE integrand class concrete extension. 1D Euler PDEs system The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas\n dynamics, that reads as\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\n\\end{matrix}\n\n where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H\n the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal\n (thermally and calorically perfect) gas is considered\n\n\\begin{matrix}\nR = c_p - c_v \\\\\n\\gamma = \\frac{c_p}{c_v}\\\\\ne = c_v T \\\\\nh = c_p T\n\\end{matrix}\n\n where R is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), e is the\n internal energy, h is the internal enthalpy and T is the temperature. The following addition equations of state hold:\n\n\\begin{matrix}\nT = \\frac{p}{\\rho R} \\\\\nE = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\\nH = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\\na = \\sqrt{\\frac{\\gamma p}{\\rho}}\n\\end{matrix}\n Multi-fluid Euler PDEs system An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with\n different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the\n density with the density fraction of each specie composing the mixture. This led to the following system:\n\n\\begin{matrix}\nU_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\\nU = \\begin{bmatrix}\n\\rho_s \\\\\n\\rho u \\\\\n\\rho E\n\\end{bmatrix}\\;\\;\\;\nF(U) = \\begin{bmatrix}\n\\rho_s u \\\\\n\\rho u&#94;2 + p \\\\\n\\rho u H\n\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\\n\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\\nc_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s}\n\\end{matrix}\n\n where N_s is the number of initial species composing the gas mixture. Primitive variables organization Primitive variables are organized as an array of reals which the first index means: 1    : density of species 1    (r1) 2    : density of species 2    (r2) …  : s    : density of species s-th (rs) …  : Ns   : density of species Ns   (rNs) Ns+1 : velocity                (u) Ns+2 : pressure                (p) Ns+3 : density                 (r=sum(rs)) Ns+4 : specific heats ratio    (g) Conservative variables organization Conservative variables are organized as an array (rank 2) of reals which the first index means: 1    : mass conservation of species 1    (r1) 2    : mass conservation of species 2    (r2) …  : s    : mass conservation of species s-th (rs) …  : Ns   : mass conservation of species Ns   (rNs) Ns+1 : momentum conservation             (r*u) Ns+2 : energy conservation               (r*E)\n Finalize field. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalization Procedures final :: finalize private subroutine finalize (self) Arguments Type Intent Optional Attributes Name type(euler_1D), intent(inout) :: self Euler field. Description Destroy field. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. procedure, public, pass(self) :: destroy Destroy field. private puresubroutine destroy (self) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. Description Destroy field. procedure, public, pass(self) :: output Extract Euler field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. private purefunction compute_dt (self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. procedure, public, pass(self) :: t => dEuler_dt Time derivative, residuals function. private function dEuler_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. procedure, public, pass(lhs) :: integrand_multiply_integrand => euler_multiply_euler Euler * Euler operator. private function euler_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => euler_multiply_real Euler * real operator. private function euler_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_euler Real * Euler operator. private function real_multiply_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class(euler_1D), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. procedure, public, pass(lhs) :: add => add_euler Euler + Euler operator. private function add_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. procedure, public, pass(lhs) :: sub => sub_euler Euler - Euler. private function sub_euler (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. procedure, public, pass(lhs) :: assign_integrand => euler_assign_euler Euler = Euler. private subroutine euler_assign_euler (lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. procedure, public, pass(lhs) :: assign_real => euler_assign_real Euler = real. private subroutine euler_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. procedure, private, pass(self) :: primitive2conservative Convert primitive variables to conservative ones. private purefunction primitive2conservative (self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. procedure, private, pass(self) :: conservative2primitive Convert conservative variables to primitive ones. private purefunction conservative2primitive (self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. procedure, private, pass(self) :: impose_boundary_conditions Impose boundary conditions. private puresubroutine impose_boundary_conditions (self, primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. procedure, private, pass(self) :: reconstruct_interfaces_states Reconstruct interfaces states. private puresubroutine reconstruct_interfaces_states (self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. procedure, private, pass(self) :: riemann_solver Solve the Riemann Problem at cell interfaces. private puresubroutine riemann_solver (self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Source Code type , extends ( integrand ) :: euler_1D !< Euler 1D PDEs system field. !< !< It is a FOODiE integrand class concrete extension. !< !<### 1D Euler PDEs system !< The 1D Euler PDEs system considered is a non linear, hyperbolic (inviscid) system of conservation laws for compressible gas !< dynamics, that reads as !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix} !<\\end{matrix} !< !< where \\rho is the density, u is the velocity, p the pressure, E the total internal specific energy and H !< the total specific enthalpy. The PDEs system must completed with the proper initial and boundary conditions. Moreover, an ideal !< (thermally and calorically perfect) gas is considered !< !<\\begin{matrix} !<R = c_p - c_v \\\\ !<\\gamma = \\frac{c_p}{c_v}\\\\ !<e = c_v T \\\\ !<h = c_p T !<\\end{matrix} !< !< where *R* is the gas constant, c_p\\,c_v are the specific heats at constant pressure and volume (respectively), *e* is the !< internal energy, *h* is the internal enthalpy and *T* is the temperature. The following addition equations of state hold: !< !<\\begin{matrix} !<T = \\frac{p}{\\rho R} \\\\ !<E = \\rho e + \\frac{1}{2} \\rho u&#94;2 \\\\ !<H = \\rho h + \\frac{1}{2} \\rho u&#94;2 \\\\ !<a = \\sqrt{\\frac{\\gamma p}{\\rho}} !<\\end{matrix} !< !< !<### Multi-fluid Euler PDEs system !< An extension of the above Euler system is considered allowing the modelling of a multi-fluid mixture of different gas (with !< different physical characteristics). The well known Standard Thermodynamic Model is used to model the gas mixture replacing the !< density with the density fraction of each specie composing the mixture. This led to the following system: !< !<\\begin{matrix} !<U_t = R(U)  \\Leftrightarrow U_t = F(U)_x \\\\ !<U = \\begin{bmatrix} !<\\rho_s \\\\ !<\\rho u \\\\ !<\\rho E !<\\end{bmatrix}\\;\\;\\; !<F(U) = \\begin{bmatrix} !<\\rho_s u \\\\ !<\\rho u&#94;2 + p \\\\ !<\\rho u H !<\\end{bmatrix}\\;\\;\\; for\\; s=1,2,...N_s \\\\ !<\\rho = \\sum_{s=1}&#94;{N_s}\\rho_s \\\\ !<c_p = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{p,s} \\quad  c_v = \\sum_{s=1}&#94;{N_S} \\frac{\\rho_s}{\\rho} c_{v,s} !<\\end{matrix} !< !< where N_s is the number of initial species composing the gas mixture. !< !<#### Primitive variables organization !< Primitive variables are organized as an array of reals which the first index means: !< !< + 1    : density of species 1    (r1) !< + 2    : density of species 2    (r2) !< + ...  : !< + s    : density of species s-th (rs) !< + ...  : !< + Ns   : density of species Ns   (rNs) !< + Ns+1 : velocity                (u) !< + Ns+2 : pressure                (p) !< + Ns+3 : density                 (r=sum(rs)) !< + Ns+4 : specific heats ratio    (g) !< !<#### Conservative variables organization !< Conservative variables are organized as an array (rank 2) of reals which the first index means: !< !< + 1    : mass conservation of species 1    (r1) !< + 2    : mass conservation of species 2    (r2) !< + ...  : !< + s    : mass conservation of species s-th (rs) !< + ...  : !< + Ns   : mass conservation of species Ns   (rNs) !< + Ns+1 : momentum conservation             (r*u) !< + Ns+2 : energy conservation               (r*E) private integer ( I_P ) :: steps = 0 !< Number of time steps stored. integer ( I_P ) :: ord = 0 !< Space accuracy formal order. integer ( I_P ) :: Ni = 0 !< Space dimension. integer ( I_P ) :: Ng = 0 !< Number of ghost cells for boundary conditions handling. integer ( I_P ) :: Ns = 0 !< Number of initial species. integer ( I_P ) :: Nc = 0 !< Number of conservative variables, Ns+2. integer ( I_P ) :: Np = 0 !< Number of primitive variables, Ns+4. real ( R_P ) :: Dx = 0._R_P !< Space step. type ( weno_interpolator_upwind ) :: weno !< WENO interpolator. real ( R_P ), allocatable :: U (:,:) !< Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real ( R_P ), allocatable :: previous (:,:,:) !< Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real ( R_P ), allocatable :: cp0 (:) !< Specific heat cp of initial species [1:Ns]. real ( R_P ), allocatable :: cv0 (:) !< Specific heat cv of initial species [1:Ns]. character (:), allocatable :: BC_L !< Left boundary condition type. character (:), allocatable :: BC_R !< Right boundary condition type. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: destroy !< Destroy field. procedure , pass ( self ), public :: output !< Extract Euler field. procedure , pass ( self ), public :: dt => compute_dt !< Compute the current time step, by means of CFL condition. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dEuler_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => euler_multiply_euler !< Euler * Euler operator. procedure , pass ( lhs ), public :: integrand_multiply_real => euler_multiply_real !< Euler * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_euler !< Real * Euler operator. procedure , pass ( lhs ), public :: add => add_euler !< Euler + Euler operator. procedure , pass ( lhs ), public :: sub => sub_euler !< Euler - Euler. procedure , pass ( lhs ), public :: assign_integrand => euler_assign_euler !< Euler = Euler. procedure , pass ( lhs ), public :: assign_real => euler_assign_real !< Euler = real. ! private methods procedure , pass ( self ), private :: primitive2conservative !< Convert primitive variables to conservative ones. procedure , pass ( self ), private :: conservative2primitive !< Convert conservative variables to primitive ones. procedure , pass ( self ), private :: impose_boundary_conditions !< Impose boundary conditions. procedure , pass ( self ), private :: reconstruct_interfaces_states !< Reconstruct interfaces states. procedure , pass ( self ), private :: riemann_solver !< Solve the Riemann Problem at cell interfaces. final :: finalize !< Finalize field. endtype euler_1D","tags":"","loc":"type/euler_1d.html","title":"euler_1D – FOODiE "},{"text":"type, public, extends(integrand) :: lorenz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Lorenz equations field. It is a FOODiE integrand class concrete extension. Lorenz ODEs system The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a\nsystem, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODiE solvers. The Lorenz' ODEs system can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2 \\\\\n v_3\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n \\sigma (v_2-v_1) \\\\\n v_1(\\rho - v_3) -v_2 \\\\\n v_1 v_2 - \\beta v_3\n \\end{bmatrix}\n\\end{matrix} The parameters set is constant and it is here selected as: \\begin{matrix}\n \\sigma = 10 \\\\\n \\rho = 28 \\\\\n \\beta = \\frac{8}{3}\n\\end{matrix} These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODiE solvers, see [2]. Bibliography [1] Deterministic Nonperiodic Flow , Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130–141,\ndoi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 [2] Scientific software design: the object-oriented way , Rouson, Damian, Jim Xia, and Xiaofeng Xu,\nCambridge University Press, 2011 State variables organization State variables are organized as an array (rank 1) of reals of dims elements, in this case 3 elements. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. procedure, public, pass(self) :: output Extract Lorenz field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. private function dLorenz_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. private function lorenz_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. private function real_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. private function add_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. private function sub_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. private subroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. private subroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class concrete extension. !< !<### Lorenz ODEs system !<The Lorenz' equations system [1] is a non linear system of pure ODEs that retains a reasonable-complex behaviour: such a !<system, for a certain parameters-region exhibits a chaotic dynamics useful for testing FOODiE solvers. !< !<The Lorenz' ODEs system can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 \\\\ !< v_3 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< \\sigma (v_2-v_1) \\\\ !< v_1(\\rho - v_3) -v_2 \\\\ !< v_1 v_2 - \\beta v_3 !< \\end{bmatrix} !<\\end{matrix} !< !<The parameters set is constant and it is here selected as: !< !<\\begin{matrix} !< \\sigma = 10 \\\\ !< \\rho = 28 \\\\ !< \\beta = \\frac{8}{3} !<\\end{matrix} !< !<These values are chaos-inducing thus they magnify the eventual numerical inaccuracies of FOODiE solvers, see [2]. !< !<#### Bibliography !< !<[1] *Deterministic Nonperiodic Flow*, Lorenz E.N., Journal of the Atmospheric Sciences, 1963, vol. 20, pp. 130--141, !<doi: http://dx.doi.org/10.1175/1520-0469(1963)020<0130:DNF>2.0.CO;2 !< !<[2] *Scientific software design: the object-oriented way*, Rouson, Damian, Jim Xia, and Xiaofeng Xu, !<Cambridge University Press, 2011 !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 3 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Lorenz field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivative, residuals function. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => lorenz_multiply_lorenz !< Lorenz * Lorenz operator. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< Lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz operator. procedure , pass ( lhs ), public :: sub => sub_lorenz !< Lorenz - Lorenz. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. endtype lorenz","tags":"","loc":"type/lorenz.html","title":"lorenz – FOODiE "},{"text":"type, public, extends(integrand) :: oscillation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Oscillation equations field. It is a FOODiE integrand class concrete extension. Oscillation ODEs system The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: \\begin{matrix}\n U_t = R(U)  \\\\\n U = \\begin{bmatrix}\n v_1 \\\\\n v_2\n \\end{bmatrix}\\;\\;\\;\n R(U) = \\begin{bmatrix}\n -f v_2 \\\\\n f v_1\n \\end{bmatrix}\n\\end{matrix} The frequency f is constant and it is here selected as f=10&#94;-4 . In the space v1-v2 the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not\nstable leading to a wrong path, see [1]. Bibliography [1] Numerical Methods for Fluid Dynamics With Applications to Geophysics , Dale R. Durran, Springer, 2010. State variables organization State variables are organized as an array (rank 1) of reals of dims elements, in this case 2 elements. Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). Type-Bound Procedures procedure, public, pass(self) :: init Init field. private subroutine init (self, initial_state, f, steps) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Oscillation field. procedure, public, pass(self) :: output Extract Oscillation field. private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. private function dOscillation_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. procedure, public, pass(self) :: update_previous_steps Update previous time steps. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of oscillation field. Description Extract previous time solution of oscillation field. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. private function oscillation_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. private function oscillation_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. private function real_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. private function add_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. procedure, public, pass(lhs) :: sub => sub_oscillation Oscillation - Oscillation. private function sub_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. private subroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. procedure, public, pass(lhs) :: assign_real => oscillation_assign_real Oscillation = real. private subroutine oscillation_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Oscillation field. Source Code type , extends ( integrand ) :: oscillation !< Oscillation equations field. !< !< It is a FOODiE integrand class concrete extension. !< !<### Oscillation ODEs system !<The (inertial) Oscillation equations system is a non linear system of pure ODEs and it can be written as: !< !<\\begin{matrix} !< U_t = R(U)  \\\\ !< U = \\begin{bmatrix} !< v_1 \\\\ !< v_2 !< \\end{bmatrix}\\;\\;\\; !< R(U) = \\begin{bmatrix} !< -f v_2 \\\\ !< f v_1 !< \\end{bmatrix} !<\\end{matrix} !< !<The frequency *f* is constant and it is here selected as *f=10&#94;-4*. !< !<In the space *v1-v2* the path of the oscillation must be a circle, but for the frequency selected some ODE solvers are not !<stable leading to a wrong path, see [1]. !< !<#### Bibliography !< !<[1] *Numerical Methods for Fluid Dynamics With Applications to Geophysics*, Dale R. Durran, Springer, 2010. !< !<#### State variables organization !< State variables are organized as an array (rank 1) of reals of *dims* elements, in this case 2 elements. private integer ( I_P ) :: dims = 0 !< Space dimensions. integer ( I_P ) :: steps = 0 !< Number of time steps stored. real ( R_P ), dimension (:), allocatable :: U !< Integrand (state) variables, [1:dims]. real ( R_P ), dimension (:,:), allocatable :: previous !< Previous time steps states, [1:dims,1:steps]. real ( R_P ) :: f = 0._R_P !< Oscillation frequency (Hz). contains ! auxiliary methods procedure , pass ( self ), public :: init !< Init field. procedure , pass ( self ), public :: output !< Extract Oscillation field. ! type_integrand deferred methods procedure , pass ( self ), public :: t => dOscillation_dt !< Time derivative, residuals. procedure , pass ( self ), public :: update_previous_steps !< Update previous time steps. procedure , pass ( self ), public :: previous_step !< Get a previous time step. procedure , pass ( lhs ), public :: integrand_multiply_integrand => oscillation_multiply_oscillation !< Oscillation * oscillation. procedure , pass ( lhs ), public :: integrand_multiply_real => oscillation_multiply_real !< Oscillation * real. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_oscillation !< Real * Oscillation. procedure , pass ( lhs ), public :: add => add_oscillation !< Oscillation + Oscillation. procedure , pass ( lhs ), public :: sub => sub_oscillation !< Oscillation - Oscillation. procedure , pass ( lhs ), public :: assign_integrand => oscillation_assign_oscillation !< Oscillation = Oscillation. procedure , pass ( lhs ), public :: assign_real => oscillation_assign_real !< Oscillation = real. endtype oscillation","tags":"","loc":"type/oscillation.html","title":"oscillation – FOODiE "},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: self Integrand field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update the previous time steps (of integrand field) for multi-step(level) ODE solvers.","tags":"","loc":"interface/update_previous_steps.html","title":"update_previous_steps – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_integrand(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand.","tags":"","loc":"interface/assignment_integrand.html","title":"assignment_integrand – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real.","tags":"","loc":"interface/assignment_real.html","title":"assignment_real – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative(self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function.","tags":"","loc":"interface/time_derivative.html","title":"time_derivative – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Selected previous time integrand field. Description Get a previous time steps (of integrand field) for multi-step(level) ODE solvers.","tags":"","loc":"interface/previous_step.html","title":"previous_step – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real.","tags":"","loc":"interface/integrand_op_real.html","title":"integrand_op_real – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand.","tags":"","loc":"interface/real_op_integrand.html","title":"real_op_integrand – FOODiE"},{"text":"abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator(lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand.","tags":"","loc":"interface/symmetric_operator.html","title":"symmetric_operator – FOODiE"},{"text":"private elementalsubroutine init(self, steps) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. integer(kind=I_P), intent(in) :: steps Number of time steps used. Description Create the actual Adams-Bashforth integrator: initialize the b coefficients. Source Code elemental subroutine init ( self , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual Adams-Bashforth integrator: initialize the *b* coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. integer ( I_P ), intent ( IN ) :: steps !< Number of time steps used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = steps if ( allocated ( self % b )) deallocate ( self % b ) ; allocate ( self % b ( 1 : steps )) ; self % b = 0._R_P select case ( steps ) case ( 1 ) ! AB(1) Forward-Euler self % b ( 1 ) = 1._R_P case ( 2 ) ! AB(2) self % b ( 1 ) = - 0.5_R_P self % b ( 2 ) = 1.5_R_P case ( 3 ) ! AB(3) self % b ( 1 ) = 5._R_P / 1 2._R_P self % b ( 2 ) = - 4._R_P / 3._R_P self % b ( 3 ) = 2 3._R_P / 1 2._R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init.html","title":"init – FOODiE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Destoy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 if ( allocated ( self % b )) deallocate ( self % b ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FOODiE"},{"text":"private subroutine integrate(self, field, Dt, t) Arguments Type Intent Optional Attributes Name class( adams_bashforth_integrator ), intent(in) :: self Actual AB integrator. class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: Dt Time steps. real(kind=R_P), intent(in) :: t (:) Times. Description Integrate field with Adams-Bashforth class scheme. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Steps counter. Source Code subroutine integrate ( self , field , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with Adams-Bashforth class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( adams_bashforth_integrator ), intent ( IN ) :: self !< Actual AB integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time steps. real ( R_P ), intent ( IN ) :: t (:) !< Times. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do s = 1 , self % steps field = field + field % t ( n = s , t = t ( s )) * ( Dt * self % b ( s )) enddo call field % update_previous_steps return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate.html","title":"integrate – FOODiE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( adams_bashforth_integrator ), intent(inout) :: self AB integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( adams_bashforth_integrator ), intent ( INOUT ) :: self !< AB integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize.html","title":"finalize – FOODiE"},{"text":"private subroutine integrate(field, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit Euler scheme, 1st order. Source Code subroutine integrate ( field , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit Euler scheme, 1st order. !--------------------------------------------------------------------------------------------------------------------------------- class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field + field % t ( t = t ) * Dt return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~2.html","title":"integrate – FOODiE"},{"text":"private elementalsubroutine init(self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. Source Code elemental subroutine init ( self , nu , alpha ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual leapfrog integrator: initialize the filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( INOUT ) :: self !< LF integrator. real ( R_P ), optional , intent ( IN ) :: nu !< Williams-Robert-Asselin filter coefficient. real ( R_P ), optional , intent ( IN ) :: alpha !< Robert-Asselin filter coefficient. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % nu = 0.01_R_P self % alpha = 0.5_R_P if ( present ( nu )) self % nu = nu if ( present ( alpha )) self % alpha = alpha return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~2.html","title":"init – FOODiE"},{"text":"private subroutine integrate(self, field, filter, Dt, t) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout), optional :: filter Filter field displacement. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with leapfrog class scheme. Source Code subroutine integrate ( self , field , filter , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with leapfrog class scheme. !--------------------------------------------------------------------------------------------------------------------------------- class ( leapfrog_integrator ), intent ( IN ) :: self !< LF integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), optional , intent ( INOUT ) :: filter !< Filter field displacement. real ( R_P ), intent ( in ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- field = field % previous_step ( n = 1 ) + field % t ( n = 2 , t = t ) * ( Dt * 2._R_P ) if ( present ( filter )) then filter = ( field % previous_step ( n = 1 ) - field % previous_step ( n = 2 ) * 2._R_P + field ) * self % nu * 0.5_R_P endif call field % update_previous_steps ( filter = filter , weights = [ self % alpha , self % alpha - 1._R_P ]) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~3.html","title":"integrate – FOODiE"},{"text":"private elementalsubroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' low storage table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' low storage table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % A )) deallocate ( self % A ) ; allocate ( self % A ( 1 : stages )) ; self % A = 0._R_P if ( allocated ( self % B )) deallocate ( self % B ) ; allocate ( self % B ( 1 : stages )) ; self % B = 0._R_P if ( allocated ( self % C )) deallocate ( self % C ) ; allocate ( self % C ( 1 : stages )) ; self % C = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % B ( 1 ) = 1._R_P case ( 5 ) ! LSRK(5,4) self % A ( 1 ) = 0._R_P self % A ( 2 ) = - real ( 567301805773_I8P , kind = R_P ) / real ( 1357537059087_I8P , kind = R_P ) self % A ( 3 ) = - real ( 2404267990393_I8P , kind = R_P ) / real ( 2016746695238_I8P , kind = R_P ) self % A ( 4 ) = - real ( 3550918686646_I8P , kind = R_P ) / real ( 2091501179385_I8P , kind = R_P ) self % A ( 5 ) = - real ( 1275806237668_I8P , kind = R_P ) / real ( 842570457699_I8P , kind = R_P ) self % B ( 1 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % B ( 2 ) = real ( 5161836677717_I8P , kind = R_P ) / real ( 13612068292357_I8P , kind = R_P ) self % B ( 3 ) = real ( 1720146321549_I8P , kind = R_P ) / real ( 2090206949498_I8P , kind = R_P ) self % B ( 4 ) = real ( 3134564353537_I8P , kind = R_P ) / real ( 4481467310338_I8P , kind = R_P ) self % B ( 5 ) = real ( 2277821191437_I8P , kind = R_P ) / real ( 14882151754819_I8P , kind = R_P ) self % C ( 1 ) = 0._R_P self % C ( 2 ) = real ( 1432997174477_I8P , kind = R_P ) / real ( 9575080441755_I8P , kind = R_P ) self % C ( 3 ) = real ( 2526269341429_I8P , kind = R_P ) / real ( 6820363962896_I8P , kind = R_P ) self % C ( 4 ) = real ( 2006345519317_I8P , kind = R_P ) / real ( 3224310063776_I8P , kind = R_P ) self % C ( 5 ) = real ( 2802321613138_I8P , kind = R_P ) / real ( 2924317926251_I8P , kind = R_P ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~3.html","title":"init – FOODiE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % A )) deallocate ( self % A ) if ( allocated ( self % B )) deallocate ( self % B ) if ( allocated ( self % C )) deallocate ( self % C ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FOODiE"},{"text":"private subroutine integrate(self, field, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( ls_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:2) Runge-Kutta registers [1:2]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit low storage Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. Source Code subroutine integrate ( self , field , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit low storage Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( ls_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 : 2 ) !< Runge-Kutta registers [1:2]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages stage ( 1 ) = field stage ( 2 ) = field * 0._R_P do s = 1 , self % stages stage ( 2 ) = stage ( 2 ) * self % A ( s ) + stage ( 1 )% t ( t = t + self % C ( s ) * Dt ) * Dt stage ( 1 ) = stage ( 1 ) + stage ( 2 ) * self % B ( s ) enddo field = stage ( 1 ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~4.html","title":"integrate – FOODiE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( ls_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~2.html","title":"finalize – FOODiE"},{"text":"private elementalsubroutine init(self, stages) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self RK integrator. integer(kind=I_P), intent(in) :: stages Number of stages used. Description Create the actual RK integrator: initialize the Butcher' table coefficients. Source Code elemental subroutine init ( self , stages ) !--------------------------------------------------------------------------------------------------------------------------------- !< Create the actual RK integrator: initialize the Butcher' table coefficients. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< RK integrator. integer ( I_P ), intent ( IN ) :: stages !< Number of stages used. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( stages < 1 ) return ! error print should be added self % stages = stages if ( allocated ( self % beta )) deallocate ( self % beta ) ; allocate ( self % beta ( 1 : stages )) ; self % beta = 0._R_P if ( allocated ( self % alph )) deallocate ( self % alph ) ; allocate ( self % alph ( 1 : stages , 1 : stages )) ; self % alph = 0._R_P if ( allocated ( self % gamm )) deallocate ( self % gamm ) ; allocate ( self % gamm ( 1 : stages )) ; self % gamm = 0._R_P select case ( stages ) case ( 1 ) ! RK(1,1) Forward-Euler self % beta ( 1 ) = 1._R_P case ( 2 ) ! SSPRK(2,2) self % beta ( 1 ) = 0.5_R_P self % beta ( 2 ) = 0.5_R_P self % alph ( 2 , 1 ) = 1._R_P self % gamm ( 2 ) = 1._R_P case ( 3 ) ! SSPRK(3,3) self % beta ( 1 ) = 1._R_P / 6._R_P self % beta ( 2 ) = 1._R_P / 6._R_P self % beta ( 3 ) = 2._R_P / 3._R_P self % alph ( 2 , 1 ) = 1._R_P self % alph ( 3 , 1 ) = 0.25_R_P ; self % alph ( 3 , 2 ) = 0.25_R_P self % gamm ( 2 ) = 1._R_P self % gamm ( 3 ) = 0.5_R_P case ( 5 ) ! SSPRK(5,4) self % beta ( 1 ) = 0.14681187618661_R_P self % beta ( 2 ) = 0.24848290924556_R_P self % beta ( 3 ) = 0.10425883036650_R_P self % beta ( 4 ) = 0.27443890091960_R_P self % beta ( 5 ) = 0.22600748319395_R_P self % alph ( 2 , 1 ) = 0.39175222700392_R_P self % alph ( 3 , 1 ) = 0.21766909633821_R_P ; self % alph ( 3 , 2 ) = 0.36841059262959_R_P self % alph ( 4 , 1 ) = 0.08269208670950_R_P ; self % alph ( 4 , 2 ) = 0.13995850206999_R_P ; self % alph ( 4 , 3 ) = 0.25189177424738_R_P self % alph ( 5 , 1 ) = 0.06796628370320_R_P ; self % alph ( 5 , 2 ) = 0.11503469844438_R_P ; self % alph ( 5 , 3 ) = 0.20703489864929_R_P self % alph ( 5 , 4 ) = 0.54497475021237_R_P self % gamm ( 2 ) = 0.39175222700392_R_P self % gamm ( 3 ) = 0.58607968896780_R_P self % gamm ( 4 ) = 0.47454236302687_R_P self % gamm ( 5 ) = 0.93501063100924_R_P endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~4.html","title":"init – FOODiE"},{"text":"private elementalsubroutine destroy(self) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Destoy the integrator. Source Code elemental subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destoy the integrator. !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % stages = 0 if ( allocated ( self % alph )) deallocate ( self % alph ) if ( allocated ( self % beta )) deallocate ( self % beta ) if ( allocated ( self % gamm )) deallocate ( self % gamm ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FOODiE"},{"text":"private subroutine integrate(self, field, stage, Dt, t) Arguments Type Intent Optional Attributes Name class( tvd_runge_kutta_integrator ), intent(in) :: self Actual RK integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout) :: stage (1:) Runge-Kutta stages [1:stages]. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. Note This method can be used after the integrator is created (i.e. the RK coeficients are initialized). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s First stages counter. integer(kind=I_P), public :: ss Second stages counter. Source Code subroutine integrate ( self , field , stage , Dt , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Integrate field with explicit TVD (or SSP) Runge-Kutta scheme. !< !< @note This method can be used **after** the integrator is created (i.e. the RK coeficients are initialized). !--------------------------------------------------------------------------------------------------------------------------------- class ( tvd_runge_kutta_integrator ), intent ( IN ) :: self !< Actual RK integrator. class ( integrand ), intent ( INOUT ) :: field !< Field to be integrated. class ( integrand ), intent ( INOUT ) :: stage ( 1 :) !< Runge-Kutta stages [1:stages]. real ( R_P ), intent ( IN ) :: Dt !< Time step. real ( R_P ), intent ( IN ) :: t !< Time. integer ( I_P ) :: s !< First stages counter. integer ( I_P ) :: ss !< Second stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( stage ) class is ( integrand ) ! computing stages do s = 1 , self % stages stage ( s ) = field do ss = 1 , s - 1 stage ( s ) = stage ( s ) + stage ( ss ) * ( Dt * self % alph ( s , ss )) enddo stage ( s ) = stage ( s )% t ( t = t + self % gamm ( s ) * Dt ) enddo ! computing new time step do s = 1 , self % stages field = field + stage ( s ) * ( Dt * self % beta ( s )) enddo endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine integrate","tags":"","loc":"proc/integrate~5.html","title":"integrate – FOODiE"},{"text":"private elementalsubroutine finalize(self) Arguments Type Intent Optional Attributes Name type( tvd_runge_kutta_integrator ), intent(inout) :: self Integrator. Description Finalize object. Source Code elemental subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Finalize object. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ), intent ( INOUT ) :: self !< Integrator. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~3.html","title":"finalize – FOODiE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, parameter :: pi = 4._R_P*atan(1._R_P) Pi greek. integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~5.html","title":"init – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results.html","title":"save_results – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t (1:ab_steps) Times. integer(kind=I_P), public :: s AB steps counter. integer(kind=I_P), public :: ss AB substeps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ( s )) if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( field = domain , dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab.html","title":"test_ab – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( field = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler.html","title":"test_euler – FOODiE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( burgers ), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer, public :: step Time steps counter. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) else call lf_integrator % integrate ( field = domain , filter = filter , dt = dt , t = t ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog.html","title":"test_leapfrog – FOODiE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:registers) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk.html","title":"test_ls_rk – FOODiE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( burgers ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk.html","title":"test_tvd_rk – FOODiE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Burgers field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), dimension (:), allocatable :: state !< Burgers state variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output.html","title":"output – FOODiE"},{"text":"private purefunction compute_dt(self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. Source Code pure function compute_dt ( self , CFL ) result ( dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step, by means of CFL condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. real ( R_P ), intent ( IN ) :: CFL !< Courant-Friedricks-Lewi stability coefficient. real ( R_P ) :: dt !< Current time step. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dt = CFL * self % h ** 2 / self % nu return !--------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt.html","title":"compute_dt – FOODiE"},{"text":"private function dBurgers_dt(self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. Source Code function dBurgers_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Burgers field, residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Burgers field time derivative. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: dState_dt ) select type ( dState_dt ) class is ( burgers ) dState_dt = self dState_dt = self % xx ( n = n ) * self % nu dState_dt = dState_dt - self * self % x ( n = n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dBurgers_dt","tags":"","loc":"proc/dburgers_dt.html","title":"dBurgers_dt – FOODiE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: previous ) select type ( previous ) class is ( burgers ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step.html","title":"previous_step – FOODiE"},{"text":"private function burgers_multiply_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. Source Code function burgers_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_burgers","tags":"","loc":"proc/burgers_multiply_burgers.html","title":"burgers_multiply_burgers – FOODiE"},{"text":"private function burgers_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. Source Code function burgers_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Burgers field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction burgers_multiply_real","tags":"","loc":"proc/burgers_multiply_real.html","title":"burgers_multiply_real – FOODiE"},{"text":"private function real_multiply_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. Source Code function real_multiply_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( burgers ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_burgers","tags":"","loc":"proc/real_multiply_burgers.html","title":"real_multiply_burgers – FOODiE"},{"text":"private function add_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. Source Code function add_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_burgers","tags":"","loc":"proc/add_burgers.html","title":"add_burgers – FOODiE"},{"text":"private function sub_burgers(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. Source Code function sub_burgers ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Burgers fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( burgers :: opr ) select type ( opr ) class is ( burgers ) opr = lhs select type ( rhs ) class is ( burgers ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_burgers","tags":"","loc":"proc/sub_burgers.html","title":"sub_burgers – FOODiE"},{"text":"private function dBurgers_dx(self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. integer, public :: dn Time level, dummy variable.","tags":"","loc":"proc/dburgers_dx.html","title":"dBurgers_dx – FOODiE"},{"text":"private function d2Burgers_dx2(self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. integer, public :: dn Time level, dummy variable.","tags":"","loc":"proc/d2burgers_dx2.html","title":"d2Burgers_dx2 – FOODiE"},{"text":"private subroutine init(self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , Ni , h , nu , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. integer ( I_P ), intent ( IN ) :: Ni !< Number of grid nodes. real ( R_P ), dimension ( 1 : Ni ), intent ( IN ) :: initial_state !< Initial state of Burgers field domain. real ( R_P ), intent ( IN ) :: h !< Space step discretization. real ( R_P ), intent ( IN ) :: nu !< Viscosity. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : Ni , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % Ni = Ni self % h = h self % nu = nu return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~6.html","title":"init – FOODiE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: self !< Burgers field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( burgers ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps.html","title":"update_previous_steps – FOODiE"},{"text":"private subroutine burgers_assign_burgers(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. Source Code subroutine burgers_assign_burgers ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Burgers field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( burgers ) lhs % Ni = rhs % Ni lhs % steps = rhs % steps lhs % h = rhs % h lhs % nu = rhs % nu if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_burgers","tags":"","loc":"proc/burgers_assign_burgers.html","title":"burgers_assign_burgers – FOODiE"},{"text":"private subroutine burgers_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field. Source Code subroutine burgers_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Burgers field. !--------------------------------------------------------------------------------------------------------------------------------- class ( burgers ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine burgers_assign_real","tags":"","loc":"proc/burgers_assign_real.html","title":"burgers_assign_real – FOODiE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~7.html","title":"init – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~2.html","title":"save_results – FOODiE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie.html","title":"save_time_serie – FOODiE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~2.html","title":"output – FOODiE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~2.html","title":"compute_dt – FOODiE"},{"text":"private function dEuler_dt(self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: dn Time level, dummy variable. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: dn !< Time level, dummy variable. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( F ( 1 : self % Nc , 0 : self % Ni )) ; F = 0._R_P allocate ( P ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng )) ; P = 0._R_P allocate ( PR ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 )) ; PR = 0._R_P !$OMP PARALLEL DEFAULT(NONE) & !$OMP PRIVATE(i, dn, n) & !$OMP SHARED(self, P) ! compute primitive variables if ( self % steps >= 2 ) then ! self%previous should be used, multi-step time integration dn = self % steps ; if ( present ( n )) dn = n !$OMP DO do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % previous (:, i , dn )) enddo else ! self%U should be used, single-step time integration !$OMP DO do i = 1 , self % Ni P (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo endif !$OMP END PARALLEL call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface !$OMP PARALLEL DEFAULT(NONE) & !$OMP PRIVATE(i) & !$OMP SHARED(self, F, PR) !$OMP DO do i = 0 , self % Ni call self % riemann_solver ( r1 = PR ( self % Ns + 3 , 2 , i ), & u1 = PR ( self % Ns + 1 , 2 , i ), & p1 = PR ( self % Ns + 2 , 2 , i ), & g1 = PR ( self % Ns + 4 , 2 , i ), & r4 = PR ( self % Ns + 3 , 1 , i + 1 ), & u4 = PR ( self % Ns + 1 , 1 , i + 1 ), & p4 = PR ( self % Ns + 2 , 1 , i + 1 ), & g4 = PR ( self % Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( self % Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 2 , i ) / PR ( self % Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : self % Ns , 1 , i + 1 ) / PR ( self % Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo !$OMP END PARALLEL ! compute residuals allocate ( euler_1D_openmp :: dState_dt ) select type ( dState_dt ) class is ( euler_1D_openmp ) dState_dt = self !!$OMP PARALLEL DEFAULT(PRIVATE) & !!$OMP SHARED(self, dState_dt, F) !!$OMP DO do i = 1 , self % Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo !!$OMP END PARALLEL endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt.html","title":"dEuler_dt – FOODiE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: previous ) select type ( previous ) class is ( euler_1D_openmp ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~2.html","title":"previous_step – FOODiE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs select type ( rhs ) class is ( euler_1D_openmp ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler.html","title":"euler_multiply_euler – FOODiE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real.html","title":"euler_multiply_real – FOODiE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class(euler_1D_openmp), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D_openmp ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler.html","title":"real_multiply_euler – FOODiE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs select type ( rhs ) class is ( euler_1D_openmp ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler.html","title":"add_euler – FOODiE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D_openmp :: opr ) select type ( opr ) class is ( euler_1D_openmp ) opr = lhs select type ( rhs ) class is ( euler_1D_openmp ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler.html","title":"sub_euler – FOODiE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative.html","title":"primitive2conservative – FOODiE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive.html","title":"conservative2primitive – FOODiE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p.html","title":"p – FOODiE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r.html","title":"r – FOODiE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a.html","title":"a – FOODiE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e.html","title":"E – FOODiE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h.html","title":"H – FOODiE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: s Steps counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~8.html","title":"init – FOODiE"},{"text":"private puresubroutine destroy(self) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~4.html","title":"destroy – FOODiE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D_openmp ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~2.html","title":"update_previous_steps – FOODiE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D_openmp ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler.html","title":"euler_assign_euler – FOODiE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real.html","title":"euler_assign_real – FOODiE"},{"text":"private puresubroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions.html","title":"impose_boundary_conditions – FOODiE"},{"text":"private subroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( self % ord ) case ( 1 ) ! 1st order piecewise constant reconstruction !$OMP PARALLEL DEFAULT(NONE) & !$OMP PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) & !$OMP SHARED(self, primitive, r_primitive) !$OMP DO do i = 0 , self % Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo !$OMP END PARALLEL case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction !$OMP PARALLEL PRIVATE(i, j, f, v, Pm, LPm, RPm, C, CR) SHARED(self, primitive, r_primitive) !$OMP DO do i = 0 , self % Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = self % Ns , Np = self % Np , primitive = Pm (:, f )) enddo do j = i + 1 - self % Ng , i - 1 + self % Ng do f = 1 , 2 do v = 1 , self % Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : self % Ns + 2 , f ), primitive ( 1 : self % Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , self % Ns + 2 call self % weno % interpolate ( S = self % Ng , & stencil = C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , self % Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : self % Ns + 2 , f ), CR ( 1 : self % Ns + 2 , f )) enddo r_primitive ( self % Ns + 3 , f , i ) = sum ( r_primitive ( 1 : self % Ns , f , i )) r_primitive ( self % Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cp0 ) / & dot_product ( r_primitive ( 1 : self % Ns , f , i ) / r_primitive ( self % Ns + 3 , f , i ), self % cv0 ) enddo enddo !$OMP END PARALLEL endselect return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states.html","title":"reconstruct_interfaces_states – FOODiE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class(euler_1D_openmp), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D_openmp ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver.html","title":"riemann_solver – FOODiE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type(euler_1D_openmp), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D_openmp ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~4.html","title":"finalize – FOODiE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states.html","title":"compute_inter_states – FOODiE"},{"text":"subroutine init() Arguments None Description Initialize the field. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~9.html","title":"init – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~3.html","title":"save_results – FOODiE"},{"text":"subroutine save_time_serie(title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public, save :: tsfile File unit for saving time serie results. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: v Counter. Source Code subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie","tags":"","loc":"proc/save_time_serie~2.html","title":"save_time_serie – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t (1:ab_steps) Times. integer(kind=I_P), public :: s AB steps counter. integer(kind=I_P), public :: ss AB substeps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ( s )) if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( field = domain , dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~2.html","title":"test_ab – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( field = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~2.html","title":"test_euler – FOODiE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type(euler_1D), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. integer, public :: step Time steps counter. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit leapfrog, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-lf-RAW-filter-time_serie.dat' , & t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) else call lf_integrator % integrate ( field = domain , filter = filter , dt = dt , t = t ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit leapfrog, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~2.html","title":"test_leapfrog – FOODiE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:registers) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit low storage Runge-Kutta, t=' // & str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-lsrk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~2.html","title":"test_ls_rk – FOODiE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D), public :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P), public :: dt Time step. real(kind=R_P), public :: t Time. integer(kind=I_P), public :: s RK stages counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-tvdrk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~2.html","title":"test_tvd_rk – FOODiE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. Return Value real(kind=R_P),\n  dimension(:,:),allocatable Euler state vector. Description Output the Euler field state (primitive variables). Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Counter. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Euler field state (primitive variables). !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), dimension (:,:), allocatable :: state !< Euler state vector. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( state ( 1 : self % Np , 1 : self % Ni )) do i = 1 , self % Ni state (:, i ) = self % conservative2primitive ( self % U (:, i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~3.html","title":"output – FOODiE"},{"text":"private purefunction compute_dt(self, Nmax, Tmax, t, CFL) result(Dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: Nmax Maximun number of iterates. real(kind=R_P), intent(in) :: Tmax Maximum time (ignored if Nmax>0). real(kind=R_P), intent(in) :: t Time. real(kind=R_P), intent(in) :: CFL CFL value. Return Value real(kind=R_P) Time step. Description Compute the current time step by means of CFL condition. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: P (:) Primitive variables. real(kind=R_P), public :: vmax Maximum propagation speed of signals. integer(kind=I_P), public :: i Counter. Source Code pure function compute_dt ( self , Nmax , Tmax , t , CFL ) result ( Dt ) !-------------------------------------------------------------------------------------------------------------------------------- !< Compute the current time step by means of CFL condition. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Nmax !< Maximun number of iterates. real ( R_P ), intent ( IN ) :: Tmax !< Maximum time (ignored if Nmax>0). real ( R_P ), intent ( IN ) :: t !< Time. real ( R_P ), intent ( IN ) :: CFL !< CFL value. real ( R_P ) :: Dt !< Time step. real ( R_P ), allocatable :: P (:) !< Primitive variables. real ( R_P ) :: vmax !< Maximum propagation speed of signals. integer ( I_P ) :: i !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ns => self % Ns , Dx => self % Dx ) vmax = 0._R_P do i = 1 , Ni P = self % conservative2primitive ( self % U (:, i )) vmax = max ( abs ( P ( Ns + 1 )) + a ( p = P ( Ns + 2 ), r = P ( Ns + 3 ), g = P ( Ns + 4 )), vmax ) enddo Dt = Dx * CFL / vmax if ( Nmax <= 0 ) then if (( t + Dt ) > Tmax ) Dt = Tmax - t endif return endassociate !-------------------------------------------------------------------------------------------------------------------------------- endfunction compute_dt","tags":"","loc":"proc/compute_dt~3.html","title":"compute_dt – FOODiE"},{"text":"private function dEuler_dt(self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Euler field time derivative. Description Time derivative of Euler field, the residuals function. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: F (:,:) Fluxes of conservative variables. real(kind=R_P), public, allocatable :: P (:,:) Primitive variables. real(kind=R_P), public, allocatable :: PR (:,:,:) Left (1) and right (2) (reconstructed) interface values of primitive variables. integer(kind=I_P), public :: dn Time level, dummy variable. integer(kind=I_P), public :: i Counter. Source Code function dEuler_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Euler field, the residuals function. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Euler field time derivative. real ( R_P ), allocatable :: F (:,:) !< Fluxes of conservative variables. real ( R_P ), allocatable :: P (:,:) !< Primitive variables. real ( R_P ), allocatable :: PR (:,:,:) !< Left (1) and right (2) (reconstructed) interface values of primitive variables. integer ( I_P ) :: dn !< Time level, dummy variable. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Nc => self % Nc , Np => self % Np , Ns => self % Ns , U => self % U , previous => self % previous ) ! allocate temporary arrays allocate ( F ( 1 : Nc , 0 : Ni )) ; F = 0._R_P allocate ( P ( 1 : Np , 1 - Ng : Ni + Ng )) ; P = 0._R_P allocate ( PR ( 1 : Np , 1 : 2 , 0 : Ni + 1 )) ; PR = 0._R_P ! compute primitive variables if ( self % steps >= 2 ) then ! self%previous should be used, multi-step time integration dn = self % steps ; if ( present ( n )) dn = n do i = 1 , Ni P (:, i ) = self % conservative2primitive ( previous (:, i , dn )) enddo else ! self%U should be used, single-step time integration do i = 1 , Ni P (:, i ) = self % conservative2primitive ( U (:, i )) enddo endif call self % impose_boundary_conditions ( primitive = P ) call self % reconstruct_interfaces_states ( primitive = P , r_primitive = PR ) ! compute fluxes by solving Rimeann Problems at each interface do i = 0 , Ni call self % riemann_solver ( r1 = PR ( Ns + 3 , 2 , i ), u1 = PR ( Ns + 1 , 2 , i ), p1 = PR ( Ns + 2 , 2 , i ), g1 = PR ( Ns + 4 , 2 , i ), & r4 = PR ( Ns + 3 , 1 , i + 1 ), u4 = PR ( Ns + 1 , 1 , i + 1 ), p4 = PR ( Ns + 2 , 1 , i + 1 ), g4 = PR ( Ns + 4 , 1 , i + 1 ), & F = F (:, i )) if ( Ns > 1 ) then if ( F ( 1 , i ) > 0._R_P ) then F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 2 , i ) / PR ( Ns + 3 , 2 , i ) * F ( 1 , i ) else F ( 1 : self % Ns , i ) = PR ( 1 : Ns , 1 , i + 1 ) / PR ( Ns + 3 , 1 , i + 1 ) * F ( 1 , i ) endif endif enddo ! compute residuals allocate ( euler_1D :: dState_dt ) select type ( dState_dt ) class is ( euler_1D ) dState_dt = self do i = 1 , Ni dState_dt % U (:, i ) = ( F (:, i - 1 ) - F (:, i )) / self % Dx enddo endselect endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dEuler_dt","tags":"","loc":"proc/deuler_dt~2.html","title":"dEuler_dt – FOODiE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Euler field. Description Extract previous time solution of Euler field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: previous ) select type ( previous ) class is ( euler_1D ) previous = self previous % U = self % previous (:, :, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~3.html","title":"previous_step – FOODiE"},{"text":"private function euler_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by another one. Source Code function euler_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_euler","tags":"","loc":"proc/euler_multiply_euler~2.html","title":"euler_multiply_euler – FOODiE"},{"text":"private function euler_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply an Euler field by a real scalar. Source Code function euler_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply an Euler field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction euler_multiply_real","tags":"","loc":"proc/euler_multiply_real~2.html","title":"euler_multiply_real – FOODiE"},{"text":"private function real_multiply_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class(euler_1D), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by an Euler field. Source Code function real_multiply_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( euler_1D ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_euler","tags":"","loc":"proc/real_multiply_euler~2.html","title":"real_multiply_euler – FOODiE"},{"text":"private function add_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Euler fields. Source Code function add_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_euler","tags":"","loc":"proc/add_euler~2.html","title":"add_euler – FOODiE"},{"text":"private function sub_euler(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Euler fields. Source Code function sub_euler ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Euler fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( euler_1D :: opr ) select type ( opr ) class is ( euler_1D ) opr = lhs select type ( rhs ) class is ( euler_1D ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_euler","tags":"","loc":"proc/sub_euler~2.html","title":"sub_euler – FOODiE"},{"text":"private purefunction primitive2conservative(self, primitive) result(conservative) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (:) Primitive variables. Return Value real(kind=R_P)\n  (1:self%Nc) Conservative variables. Description Convert primitive variables to conservative variables. Source Code pure function primitive2conservative ( self , primitive ) result ( conservative ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert primitive variables to conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive (:) !< Primitive variables. real ( R_P ) :: conservative ( 1 : self % Nc ) !< Conservative variables. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns ) conservative ( 1 : Ns ) = primitive ( 1 : Ns ) conservative ( Ns + 1 ) = primitive ( Ns + 3 ) * primitive ( Ns + 1 ) conservative ( Ns + 2 ) = primitive ( Ns + 2 ) / ( primitive ( Ns + 4 ) - 1._R_P ) + & 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 ) endassociate return !--------------------------------------------------------------------------------------------------------------------------------- endfunction primitive2conservative","tags":"","loc":"proc/primitive2conservative~2.html","title":"primitive2conservative – FOODiE"},{"text":"private purefunction conservative2primitive(self, conservative) result(primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: conservative (:) Conservative variables. Return Value real(kind=R_P)\n  (1:self%Np) Primitive variables. Description Convert conservative variables to primitive variables. Variables Type Visibility Attributes Name Initial real(kind=R_P), public, allocatable :: c (:) Species concentration. Source Code pure function conservative2primitive ( self , conservative ) result ( primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Convert conservative variables to primitive variables. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: conservative (:) !< Conservative variables. real ( R_P ) :: primitive ( 1 : self % Np ) !< Primitive variables. real ( R_P ), allocatable :: c (:) !< Species concentration. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ns => self % Ns , cp0 => self % cp0 , cv0 => self % cv0 ) primitive ( 1 : Ns ) = conservative ( 1 : Ns ) primitive ( Ns + 3 ) = sum ( conservative ( 1 : Ns )) c = primitive ( 1 : Ns ) / primitive ( Ns + 3 ) primitive ( Ns + 4 ) = dot_product ( c , cp0 ) / dot_product ( c , cv0 ) primitive ( Ns + 1 ) = conservative ( Ns + 1 ) / primitive ( Ns + 3 ) primitive ( Ns + 2 ) = ( conservative ( Ns + 2 ) - 0.5_R_P * primitive ( Ns + 3 ) * primitive ( Ns + 1 ) * primitive ( Ns + 1 )) * & ( primitive ( Ns + 4 ) - 1._R_P ) endassociate return !-------------------------------------------------------------------------------------------------------------------------------- endfunction conservative2primitive","tags":"","loc":"proc/conservative2primitive~2.html","title":"conservative2primitive – FOODiE"},{"text":"private elementalfunction p(r, a, g) result(pressure) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Pressure. Description Compute the pressure for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p","tags":"","loc":"proc/p~2.html","title":"p – FOODiE"},{"text":"private elementalfunction r(p, a, g) result(density) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: a Speed of sound. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Density. Description Compute the density for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize ! non type-bound procedures pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r","tags":"","loc":"proc/r~2.html","title":"r – FOODiE"},{"text":"private elementalfunction a(p, r, g) result(ss) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Speed of sound. Description Compute the speed of sound for an ideal calorically perfect gas. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function p ( r , a , g ) result ( pressure ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the pressure for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: pressure !< Pressure. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pressure = r * a * a / g return !--------------------------------------------------------------------------------------------------------------------------------- endfunction p elemental function r ( p , a , g ) result ( density ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the density for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: a !< Speed of sound. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: density !< Density. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- density = g * p / ( a * a ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction r elemental function a ( p , r , g ) result ( ss ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the speed of sound for an ideal calorically perfect gas. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: ss !< Speed of sound. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ss = sqrt ( g * p / r ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction a","tags":"","loc":"proc/a~2.html","title":"a – FOODiE"},{"text":"private elementalfunction E(p, r, u, g) result(energy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific energy (per unit of mass). Description Compute total specific energy (per unit of mass).\n\n  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function E ( p , r , u , g ) result ( energy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific energy (per unit of mass). !< !<  E = \\frac{p}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ) :: energy !< Total specific energy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- energy = p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction E","tags":"","loc":"proc/e~2.html","title":"E – FOODiE"},{"text":"private elementalfunction H(p, r, u, g) result(entalpy) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Module of velocity vector. real(kind=R_P), intent(in) :: g Specific heats ratio \\frac{{c_p}}{{c_v}}. Return Value real(kind=R_P) Total specific entalpy (per unit of mass). Description Compute total specific entalpy (per unit of mass).\n\n  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2}\n Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function H ( p , r , u , g ) result ( entalpy ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute total specific entalpy (per unit of mass). !< !<  H = \\frac{{\\g p}}{{\\left( {\\g  - 1} \\right)\\r }} + \\frac{{u&#94;2 }}{2} !< !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: g !< Specific heats ratio \\frac{{c_p}}{{c_v}}. real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Module of velocity vector. real ( R_P ) :: entalpy !< Total specific entalpy (per unit of mass). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- entalpy = g * p / (( g - 1._R_P ) * r ) + 0.5_R_P * u * u return !--------------------------------------------------------------------------------------------------------------------------------- endfunction H","tags":"","loc":"proc/h~2.html","title":"H – FOODiE"},{"text":"private subroutine init(self, Ni, Ns, Dx, BC_L, BC_R, initial_state, cp0, cv0, steps, ord) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. integer(kind=I_P), intent(in) :: Ni Space dimension. integer(kind=I_P), intent(in) :: Ns Number of initial species. real(kind=R_P), intent(in) :: Dx Space step. character(len=*), intent(in) :: BC_L Left boundary condition type. character(len=*), intent(in) :: BC_R Right boundary condition type. real(kind=R_P), intent(in) :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), intent(in) :: cp0 (:) Initial specific heat, constant pressure. real(kind=R_P), intent(in) :: cv0 (:) Initial specific heat, constant volume. integer(kind=I_P), intent(in), optional :: steps Time steps stored. integer(kind=I_P), intent(in), optional :: ord Space accuracy formal order. Description Init field. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type(weno_factory), public :: factory WENO factory. class(weno_interpolator), public, allocatable :: weno WENO interpolator. integer(kind=I_P), public :: i Space counter. integer(kind=I_P), public :: s Steps counter. Source Code subroutine init ( self , Ni , Ns , Dx , BC_L , BC_R , initial_state , cp0 , cv0 , steps , ord ) !--------------------------------------------------------------------------------------------------------------------------------- !< Init field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. integer ( I_P ), intent ( IN ) :: Ni !< Space dimension. integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. real ( R_P ), intent ( IN ) :: Dx !< Space step. character ( * ), intent ( IN ) :: BC_L !< Left boundary condition type. character ( * ), intent ( IN ) :: BC_R !< Right boundary condition type. real ( R_P ), intent ( IN ) :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), intent ( IN ) :: cp0 (:) !< Initial specific heat, constant pressure. real ( R_P ), intent ( IN ) :: cv0 (:) !< Initial specific heat, constant volume. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ), optional , intent ( IN ) :: ord !< Space accuracy formal order. type ( weno_factory ) :: factory !< WENO factory. class ( weno_interpolator ), allocatable :: weno !< WENO interpolator. integer ( I_P ) :: i !< Space counter. integer ( I_P ) :: s !< Steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 ; if ( present ( steps )) self % steps = steps self % ord = 1 ; if ( present ( ord )) self % ord = ord self % Ng = ( self % ord + 1 ) / 2 if ( self % ord > 1 ) then call factory % create ( constructor = weno_constructor_upwind ( S = self % Ng , eps = 1 0._R_P ** ( - 40 )), interpolator = weno ) self % weno = weno endif self % Ni = Ni self % Ns = Ns self % Nc = Ns + 2 self % Np = Ns + 4 self % Dx = Dx if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % Nc , 1 : Ni )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % Nc , 1 : Ni , 1 : self % steps )) endif self % cp0 = cp0 self % cv0 = cv0 self % BC_L = BC_L self % BC_R = BC_R do i = 1 , Ni self % U (:, i ) = self % primitive2conservative ( initial_state (:, i )) enddo if ( self % steps > 0 ) then do s = 1 , self % steps do i = 1 , Ni self % previous (:, i , s ) = self % primitive2conservative ( initial_state (:, i )) enddo enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~10.html","title":"init – FOODiE"},{"text":"private puresubroutine destroy(self) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. Description Destroy field. Source Code pure subroutine destroy ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % steps = 0 self % ord = 0 self % Ni = 0 self % Ng = 0 self % Ns = 0 self % Nc = 0 self % Np = 0 self % Dx = 0._R_P if ( allocated ( self % U )) deallocate ( self % U ) if ( allocated ( self % previous )) deallocate ( self % previous ) if ( allocated ( self % cp0 )) deallocate ( self % cp0 ) if ( allocated ( self % cv0 )) deallocate ( self % cv0 ) if ( allocated ( self % BC_L )) deallocate ( self % BC_L ) if ( allocated ( self % BC_R )) deallocate ( self % BC_R ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine destroy","tags":"","loc":"proc/destroy~5.html","title":"destroy – FOODiE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: self Euler field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: self !< Euler field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, :, s ) = self % previous (:, :, s + 1 ) enddo self % previous (:, :, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( euler_1D ) do s = 1 , self % steps self % previous (:, :, s ) = self % previous (:, :, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~3.html","title":"update_previous_steps – FOODiE"},{"text":"private subroutine euler_assign_euler(lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Euler field to another. Source Code subroutine euler_assign_euler ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Euler field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( euler_1D ) lhs % steps = rhs % steps lhs % ord = rhs % ord lhs % Ni = rhs % Ni lhs % Ng = rhs % Ng lhs % Ns = rhs % Ns lhs % Nc = rhs % Nc lhs % Np = rhs % Np lhs % Dx = rhs % Dx lhs % weno = rhs % weno if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous if ( allocated ( rhs % cp0 )) lhs % cp0 = rhs % cp0 if ( allocated ( rhs % cv0 )) lhs % cv0 = rhs % cv0 if ( allocated ( rhs % BC_L )) lhs % BC_L = rhs % BC_L if ( allocated ( rhs % BC_R )) lhs % BC_R = rhs % BC_R endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_euler","tags":"","loc":"proc/euler_assign_euler~2.html","title":"euler_assign_euler – FOODiE"},{"text":"private subroutine euler_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to an Euler field. Source Code subroutine euler_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to an Euler field. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine euler_assign_real","tags":"","loc":"proc/euler_assign_real~2.html","title":"euler_assign_real – FOODiE"},{"text":"private puresubroutine impose_boundary_conditions(self, primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(inout) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables [1:Np,1-Ng:Ni+Ng]. Description Impose boundary conditions. The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: i Space counter. Source Code pure subroutine impose_boundary_conditions ( self , primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Impose boundary conditions. !< !< The boundary conditions are imposed on the primitive variables by means of the ghost cells approach. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( INOUT ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables [1:Np,1-Ng:Ni+Ng]. integer ( I_P ) :: i !< Space counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( self % BC_L ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) enddo case ( 'REF' ) ! reflective BC do i = 1 - self % Ng , 0 primitive (:, i ) = primitive (:, - i + 1 ) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , - i + 1 ) ! only velocity enddo endselect select case ( trim ( adjustl ( self % BC_R ))) case ( 'TRA' ) ! trasmissive (non reflective) BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) enddo case ( 'REF' ) ! reflective BC do i = self % Ni + 1 , self % Ni + self % Ng primitive (:, i ) = primitive (:, self % Ni - ( i - self % Ni - 1 )) ! all variables primitive ( self % Ns + 1 , i ) = - primitive ( self % Ns + 1 , self % Ni - ( i - self % Ni - 1 )) ! only velocity enddo endselect return !-------------------------------------------------------------------------------------------------------------------------------- endsubroutine impose_boundary_conditions","tags":"","loc":"proc/impose_boundary_conditions~2.html","title":"impose_boundary_conditions – FOODiE"},{"text":"private puresubroutine reconstruct_interfaces_states(self, primitive, r_primitive) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: primitive (1:self%Np,1-self%Ng:self%Ni+self%Ng) Primitive variables. real(kind=R_P), intent(inout) :: r_primitive (1:self%Np,1:2,0:self%Ni+1) Reconstructed primitive variables. Description Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: C (1:2,1-self%Ng:-1+self%Ng,1:self%Ns+2) Pseudo characteristic variables. real(kind=R_P), public :: CR (1:self%Ns+2,1:2) Pseudo characteristic reconst. vars. real(kind=R_P), public :: Pm (1:self%Np,1:2) Mean of primitive variables. real(kind=R_P), public :: LPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean left eigenvectors matrix. real(kind=R_P), public :: RPm (1:self%Ns+2,1:self%Ns+2,1:2) Mean right eigenvectors matrix. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: j Counter. integer(kind=I_P), public :: f Counter. integer(kind=I_P), public :: v Counter. Functions purefunction eigen_vect_L(Ns, Np, primitive) result(L) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Left eigenvectors matrix. Description Compute left eigenvectors from primitive variables. purefunction eigen_vect_R(Ns, Np, primitive) result(R) Arguments Type Intent Optional Attributes Name integer(kind=I_P), intent(in) :: Ns Number of initial species. integer(kind=I_P), intent(in) :: Np Number of primitive variables. real(kind=R_P), intent(in) :: primitive (1:Np) Primitive variables. Return Value real(kind=R_P)\n  (1:Ns+2,1:Ns+2) Right eigenvectors matrix. Description Compute right eigenvectors from primitive variables. Source Code pure subroutine reconstruct_interfaces_states ( self , primitive , r_primitive ) !-------------------------------------------------------------------------------------------------------------------------------- !< Reconstruct the interfaces states (into primitive variables formulation) by the requested order of accuracy. !-------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: primitive ( 1 : self % Np , 1 - self % Ng : self % Ni + self % Ng ) !< Primitive variables. real ( R_P ), intent ( INOUT ) :: r_primitive ( 1 : self % Np , 1 : 2 , 0 : self % Ni + 1 ) !< Reconstructed primitive variables. real ( R_P ) :: C ( 1 : 2 , 1 - self % Ng : - 1 + self % Ng , 1 : self % Ns + 2 ) !< Pseudo characteristic variables. real ( R_P ) :: CR ( 1 : self % Ns + 2 , 1 : 2 ) !< Pseudo characteristic reconst. vars. real ( R_P ) :: Pm ( 1 : self % Np , 1 : 2 ) !< Mean of primitive variables. real ( R_P ) :: LPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean left eigenvectors matrix. real ( R_P ) :: RPm ( 1 : self % Ns + 2 , 1 : self % Ns + 2 , 1 : 2 ) !< Mean right eigenvectors matrix. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: j !< Counter. integer ( I_P ) :: f !< Counter. integer ( I_P ) :: v !< Counter. !-------------------------------------------------------------------------------------------------------------------------------- !-------------------------------------------------------------------------------------------------------------------------------- associate ( Ni => self % Ni , Ng => self % Ng , Ns => self % Ns , Np => self % Np , ord => self % ord , cv0 => self % cv0 , cp0 => self % cp0 , weno => self % weno ) select case ( ord ) case ( 1 ) ! 1st order piecewise constant reconstruction do i = 0 , Ni + 1 r_primitive (:, 1 , i ) = primitive (:, i ) r_primitive (:, 2 , i ) = r_primitive (:, 1 , i ) enddo case ( 3 , 5 , 7 ) ! 3rd, 5th or 7th order WENO reconstruction do i = 0 , Ni + 1 ! trasform primitive variables to pseudo charteristic ones do f = 1 , 2 Pm (:, f ) = 0.5_R_P * ( primitive (:, i + f - 2 ) + primitive (:, i + f - 1 )) enddo do f = 1 , 2 LPm (:, :, f ) = eigen_vect_L ( Ns = Ns , Np = Np , primitive = Pm (:, f )) RPm (:, :, f ) = eigen_vect_R ( Ns = Ns , Np = Np , primitive = Pm (:, f )) enddo do j = i + 1 - Ng , i - 1 + Ng do f = 1 , 2 do v = 1 , Ns + 2 C ( f , j - i , v ) = dot_product ( LPm ( v , 1 : Ns + 2 , f ), primitive ( 1 : Ns + 2 , j )) enddo enddo enddo ! compute WENO reconstruction of pseudo charteristic variables do v = 1 , Ns + 2 call weno % interpolate ( S = Ng , & stencil = C ( 1 : 2 , 1 - Ng : - 1 + Ng , v ), & location = 'both' , & interpolation = CR ( v , 1 : 2 )) enddo ! trasform back reconstructed pseudo charteristic variables to primitive ones do f = 1 , 2 do v = 1 , Ns + 2 r_primitive ( v , f , i ) = dot_product ( RPm ( v , 1 : Ns + 2 , f ), CR ( 1 : Ns + 2 , f )) enddo r_primitive ( Ns + 3 , f , i ) = sum ( r_primitive ( 1 : Ns , f , i )) r_primitive ( Ns + 4 , f , i ) = dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cp0 ) / & dot_product ( r_primitive ( 1 : Ns , f , i ) / r_primitive ( Ns + 3 , f , i ), cv0 ) enddo enddo endselect endassociate return !-------------------------------------------------------------------------------------------------------------------------------- contains pure function eigen_vect_L ( Ns , Np , primitive ) result ( L ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute left eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: L ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Left eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: gp_a !< g*p/a. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) gp_a = gp / a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) L = 0._R_P L ( 1 , Ns + 1 ) = - gp_a ; L ( 1 , Ns + 2 ) = 1._R_P do s = 2 , Ns + 1 if ( primitive ( s - 1 ) > 0 ) L ( s , s - 1 ) = gp / primitive ( s - 1 ) ; L ( s , Ns + 2 ) = - 1._R_P enddo L ( Ns + 2 , Ns + 1 ) = gp_a ; L ( Ns + 2 , Ns + 2 ) = 1._R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_L pure function eigen_vect_R ( Ns , Np , primitive ) result ( R ) !------------------------------------------------------------------------------------------------------------------------------- !< Compute right eigenvectors from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ), intent ( IN ) :: Ns !< Number of initial species. integer ( I_P ), intent ( IN ) :: Np !< Number of primitive variables. real ( R_P ), intent ( IN ) :: primitive ( 1 : Np ) !< Primitive variables. real ( R_P ) :: R ( 1 : Ns + 2 , 1 : Ns + 2 ) !< Right eigenvectors matrix. real ( R_P ) :: gp !< g*p. real ( R_P ) :: ss !< Speed of sound, sqrt(g*p/r). real ( R_P ) :: gp_inv !< 1/(g*p). integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- gp = primitive ( Ns + 4 ) * primitive ( Ns + 2 ) ss = a ( p = primitive ( Ns + 2 ), r = primitive ( Ns + 3 ), g = primitive ( Ns + 4 )) gp_inv = 1._R_P / gp R = 0._R_P do s = 1 , Ns R ( s , 1 ) = 0.5_R_P * primitive ( s ) * gp_inv ; R ( s , s + 1 ) = primitive ( s ) * gp_inv ; R ( s , Ns + 2 ) = R ( s , 1 ) enddo R ( Ns + 1 , 1 ) = - 0.5_R_P * ss * gp_inv ; R ( Ns + 1 , Ns + 2 ) = 0.5_R_P * ss * gp_inv R ( Ns + 2 , 1 ) = 0.5_R_P ; R ( Ns + 2 , Ns + 2 ) = 0.5_R_P return !------------------------------------------------------------------------------------------------------------------------------- endfunction eigen_vect_R endsubroutine reconstruct_interfaces_states","tags":"","loc":"proc/reconstruct_interfaces_states~2.html","title":"reconstruct_interfaces_states – FOODiE"},{"text":"private puresubroutine riemann_solver(self, p1, r1, u1, g1, p4, r4, u4, g4, F) Arguments Type Intent Optional Attributes Name class(euler_1D), intent(in) :: self Euler field. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heats ratio of state 1. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heats ratio of state 4. real(kind=R_P), intent(out) :: F (1:self%Nc) Resulting fluxes. Description Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: F1 (1:3) State 1 fluxes. real(kind=R_P), public :: F4 (1:3) State 4 fluxes. real(kind=R_P), public :: u Velocity of the intermediate states. real(kind=R_P), public :: p Pressure of the intermediate states. real(kind=R_P), public :: S1 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: S4 Maximum wave speed of state 1 and 4. real(kind=R_P), public :: lmax Maximum wave speed estimation. Functions purefunction fluxes(p, r, u, g) result(Fc) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: p Pressure. real(kind=R_P), intent(in) :: r Density. real(kind=R_P), intent(in) :: u Velocity. real(kind=R_P), intent(in) :: g Specific heats ratio. Return Value real(kind=R_P)\n  (1:3) State fluxes. Description 1D Euler fluxes from primitive variables. Source Code pure subroutine riemann_solver ( self , p1 , r1 , u1 , g1 , p4 , r4 , u4 , g4 , F ) !--------------------------------------------------------------------------------------------------------------------------------- !< Solve the Riemann problem between the state $1$ and $4$ using the (local) Lax Friedrichs (Rusanov) solver. !--------------------------------------------------------------------------------------------------------------------------------- class ( euler_1D ), intent ( IN ) :: self !< Euler field. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heats ratio of state 1. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heats ratio of state 4. real ( R_P ), intent ( OUT ) :: F ( 1 : self % Nc ) !< Resulting fluxes. real ( R_P ) :: F1 ( 1 : 3 ) !< State 1 fluxes. real ( R_P ) :: F4 ( 1 : 3 ) !< State 4 fluxes. real ( R_P ) :: u !< Velocity of the intermediate states. real ( R_P ) :: p !< Pressure of the intermediate states. real ( R_P ) :: S1 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: S4 !< Maximum wave speed of state 1 and 4. real ( R_P ) :: lmax !< Maximum wave speed estimation. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! evaluating the intermediates states 2 and 3 from the known states U1,U4 using the PVRS approximation call compute_inter_states ( p1 = p1 , r1 = r1 , u1 = u1 , g1 = g1 , p4 = p4 , r4 = r4 , u4 = u4 , g4 = g4 , p = p , S = u , S1 = S1 , S4 = S4 ) ! evalutaing the maximum waves speed lmax = max ( abs ( S1 ), abs ( u ), abs ( S4 )) ! computing the fluxes of state 1 and 4 F1 = fluxes ( p = p1 , r = r1 , u = u1 , g = g1 ) F4 = fluxes ( p = p4 , r = r4 , u = u4 , g = g4 ) ! computing the Lax-Friedrichs fluxes approximation F ( 1 ) = 0.5_R_P * ( F1 ( 1 ) + F4 ( 1 ) - lmax * ( r4 - r1 )) F ( self % Ns + 1 ) = 0.5_R_P * ( F1 ( 2 ) + F4 ( 2 ) - lmax * ( r4 * u4 - r1 * u1 )) F ( self % Ns + 2 ) = 0.5_R_P * ( F1 ( 3 ) + F4 ( 3 ) - lmax * ( r4 * E ( p = p4 , r = r4 , u = u4 , g = g4 ) - r1 * E ( p = p1 , r = r1 , u = u1 , g = g1 ))) return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function fluxes ( p , r , u , g ) result ( Fc ) !------------------------------------------------------------------------------------------------------------------------------- !< 1D Euler fluxes from primitive variables. !------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: p !< Pressure. real ( R_P ), intent ( IN ) :: r !< Density. real ( R_P ), intent ( IN ) :: u !< Velocity. real ( R_P ), intent ( IN ) :: g !< Specific heats ratio. real ( R_P ) :: Fc ( 1 : 3 ) !< State fluxes. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- Fc ( 1 ) = r * u Fc ( 2 ) = Fc ( 1 ) * u + p Fc ( 3 ) = Fc ( 1 ) * H ( p = p , r = r , u = u , g = g ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction fluxes endsubroutine riemann_solver","tags":"","loc":"proc/riemann_solver~2.html","title":"riemann_solver – FOODiE"},{"text":"private subroutine finalize(self) Arguments Type Intent Optional Attributes Name type(euler_1D), intent(inout) :: self Euler field. Description Destroy field. Source Code subroutine finalize ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Destroy field. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_1D ), intent ( INOUT ) :: self !< Euler field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call self % destroy return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine finalize","tags":"","loc":"proc/finalize~5.html","title":"finalize – FOODiE"},{"text":"private puresubroutine compute_inter_states(r1, p1, u1, g1, r4, p4, u4, g4, p, S, S1, S4) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: r1 Density of state 1. real(kind=R_P), intent(in) :: p1 Pressure of state 1. real(kind=R_P), intent(in) :: u1 Velocity of state 1. real(kind=R_P), intent(in) :: g1 Specific heat ratio of state 1. real(kind=R_P), intent(in) :: r4 Density of state 4. real(kind=R_P), intent(in) :: p4 Pressure of state 4. real(kind=R_P), intent(in) :: u4 Velocity of state 4. real(kind=R_P), intent(in) :: g4 Specific heat ratio of state 4. real(kind=R_P), intent(out) :: p Pressure of the intermediate states. real(kind=R_P), intent(out) :: S Contact discontinuity signal velocity. real(kind=R_P), intent(out) :: S1 Left fastest signal velocity. real(kind=R_P), intent(out) :: S4 Right fastest signal velocity. Description Compute inter states (23*-states) from state1 and state4. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=R_P), public :: a1 Speed of sound of state 1. real(kind=R_P), public :: a4 Speed of sound of state 4. real(kind=R_P), public :: ram Mean value of rho*a. real(kind=R_P), public, parameter :: toll = 1e-10_R_P Tollerance. Source Code pure subroutine compute_inter_states ( r1 , p1 , u1 , g1 , r4 , p4 , u4 , g4 , p , S , S1 , S4 ) !------------------------------------------------------------------------------------------------------------------------------ !< Compute inter states (23*-states) from state1 and state4. !------------------------------------------------------------------------------------------------------------------------------ real ( R_P ), intent ( IN ) :: r1 !< Density of state 1. real ( R_P ), intent ( IN ) :: p1 !< Pressure of state 1. real ( R_P ), intent ( IN ) :: u1 !< Velocity of state 1. real ( R_P ), intent ( IN ) :: g1 !< Specific heat ratio of state 1. real ( R_P ), intent ( IN ) :: r4 !< Density of state 4. real ( R_P ), intent ( IN ) :: p4 !< Pressure of state 4. real ( R_P ), intent ( IN ) :: u4 !< Velocity of state 4. real ( R_P ), intent ( IN ) :: g4 !< Specific heat ratio of state 4. real ( R_P ), intent ( OUT ) :: p !< Pressure of the intermediate states. real ( R_P ), intent ( OUT ) :: S !< Contact discontinuity signal velocity. real ( R_P ), intent ( OUT ) :: S1 !< Left fastest signal velocity. real ( R_P ), intent ( OUT ) :: S4 !< Right fastest signal velocity. real ( R_P ) :: a1 !< Speed of sound of state 1. real ( R_P ) :: a4 !< Speed of sound of state 4. real ( R_P ) :: ram !< Mean value of rho*a. real ( R_P ), parameter :: toll = 1 e - 10_R_P !< Tollerance. !------------------------------------------------------------------------------------------------------------------------------ !------------------------------------------------------------------------------------------------------------------------------ ! evaluation of the intermediate states pressure and velocity a1 = sqrt ( g1 * p1 / r1 ) ! left speed of sound a4 = sqrt ( g4 * p4 / r4 ) ! right speed of sound ram = 0.5_R_P * ( r1 + r4 ) * 0.5_R_P * ( a1 + a4 ) ! product of mean density for mean speed of sound S = 0.5_R_P * ( u1 + u4 ) - 0.5_R_P * ( p4 - p1 ) / ram ! evaluation of the contact wave speed (velocity of intermediate states) p = 0.5_R_P * ( p1 + p4 ) - 0.5_R_P * ( u4 - u1 ) * ram ! evaluation of the pressure of the intermediate states ! evaluation of the left wave speeds if ( p <= p1 * ( 1._R_P + toll )) then ! rarefaction S1 = u1 - a1 else ! shock S1 = u1 - a1 * sqrt ( 1._R_P + ( g1 + 1._R_P ) / ( 2._R_P * g1 ) * ( p / p1 - 1._R_P )) endif ! evaluation of the right wave speeds if ( p <= p4 * ( 1._R_P + toll )) then ! rarefaction S4 = u4 + a4 else ! shock S4 = u4 + a4 * sqrt ( 1._R_P + ( g4 + 1._R_P ) / ( 2._R_P * g4 ) * ( p / p4 - 1._R_P )) endif return !------------------------------------------------------------------------------------------------------------------------------ endsubroutine compute_inter_states","tags":"","loc":"proc/compute_inter_states~2.html","title":"compute_inter_states – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: s Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~4.html","title":"save_results – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer(kind=I_P), public :: s AB steps counter. integer, public :: step Time steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) else call ab_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~3.html","title":"test_ab – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~3.html","title":"test_euler – FOODiE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( lorenz ), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. integer, public :: step Time steps counter. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) else call lf_integrator % integrate ( field = attractor , filter = filter , dt = dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~3.html","title":"test_leapfrog – FOODiE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:registers) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~3.html","title":"test_ls_rk – FOODiE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( lorenz ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~3.html","title":"test_tvd_rk – FOODiE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Lorenz field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. real ( R_P ), dimension (:), allocatable :: state !< Lorenz state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~4.html","title":"output – FOODiE"},{"text":"private function dLorenz_dt(self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: dn Time level, dummy variable. Source Code function dLorenz_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Lorenz field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: dState_dt ) select type ( dState_dt ) class is ( lorenz ) dState_dt = self if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n dState_dt % U ( 1 ) = self % sigma * ( self % previous ( 2 , dn ) - self % previous ( 1 , dn )) dState_dt % U ( 2 ) = self % previous ( 1 , dn ) * ( self % rho - self % previous ( 3 , dn )) - self % previous ( 2 , dn ) dState_dt % U ( 3 ) = self % previous ( 1 , dn ) * self % previous ( 2 , dn ) - self % beta * self % previous ( 3 , dn ) else ! self%previous should not be used, use directly self%U dState_dt % U ( 1 ) = self % sigma * ( self % U ( 2 ) - self % U ( 1 )) dState_dt % U ( 2 ) = self % U ( 1 ) * ( self % rho - self % U ( 3 )) - self % U ( 2 ) dState_dt % U ( 3 ) = self % U ( 1 ) * self % U ( 2 ) - self % beta * self % U ( 3 ) endif endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dLorenz_dt","tags":"","loc":"proc/dlorenz_dt.html","title":"dLorenz_dt – FOODiE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: self !< Lorenz field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: previous ) select type ( previous ) class is ( lorenz ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~4.html","title":"previous_step – FOODiE"},{"text":"private function lorenz_multiply_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. Source Code function lorenz_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a lorenz field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_lorenz","tags":"","loc":"proc/lorenz_multiply_lorenz.html","title":"lorenz_multiply_lorenz – FOODiE"},{"text":"private function lorenz_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. Source Code function lorenz_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Lorenz field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lorenz_multiply_real","tags":"","loc":"proc/lorenz_multiply_real.html","title":"lorenz_multiply_real – FOODiE"},{"text":"private function real_multiply_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. Source Code function real_multiply_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( lorenz ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_lorenz","tags":"","loc":"proc/real_multiply_lorenz.html","title":"real_multiply_lorenz – FOODiE"},{"text":"private function add_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. Source Code function add_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Lorenz","tags":"","loc":"proc/add_lorenz.html","title":"add_lorenz – FOODiE"},{"text":"private function sub_lorenz(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. Source Code function sub_lorenz ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Lorenz fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( lorenz :: opr ) select type ( opr ) class is ( lorenz ) opr = lhs select type ( rhs ) class is ( lorenz ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_lorenz","tags":"","loc":"proc/sub_lorenz.html","title":"sub_lorenz – FOODiE"},{"text":"private subroutine init(self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , sigma , rho , beta , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of Lorenz field vector. real ( R_P ), intent ( IN ) :: sigma !< Lorenz  \\sigma. real ( R_P ), intent ( IN ) :: rho !< Lorenz  \\rho. real ( R_P ), intent ( IN ) :: beta !< Lorenz  \\beta. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % sigma = sigma self % rho = rho self % beta = beta return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~11.html","title":"init – FOODiE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: self !< Lorenz field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( lorenz ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~4.html","title":"update_previous_steps – FOODiE"},{"text":"private subroutine lorenz_assign_lorenz(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. Source Code subroutine lorenz_assign_lorenz ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Lorenz field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( lorenz ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % sigma = rhs % sigma lhs % rho = rhs % rho lhs % beta = rhs % beta endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_lorenz","tags":"","loc":"proc/lorenz_assign_lorenz.html","title":"lorenz_assign_lorenz – FOODiE"},{"text":"private subroutine lorenz_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field. Source Code subroutine lorenz_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Lorenz field. !--------------------------------------------------------------------------------------------------------------------------------- class ( lorenz ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine lorenz_assign_real","tags":"","loc":"proc/lorenz_assign_real.html","title":"lorenz_assign_real – FOODiE"},{"text":"subroutine save_results(title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: rawfile Raw file unit for saving results. type(pyplot), public :: plt Plot file handler. integer(kind=I_P), public :: i Counter. integer(kind=I_P), public :: s Counter. Source Code subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 2 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results","tags":"","loc":"proc/save_results~5.html","title":"save_results – FOODiE"},{"text":"subroutine test_ab() Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 3 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( adams_bashforth_integrator ), public :: ab_integrator Adams-Bashforth integrator. integer, public, parameter :: ab_steps = 3 Adams-Bashforth steps number. integer, public :: step Time steps counter. integer(kind=I_P), public :: s AB steps counter. Source Code subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 3 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) else call ab_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit ' // 'Adams-Bashforth ' // & trim ( str (. true ., s )) // ' steps' , & filename = 'oscillation_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab","tags":"","loc":"proc/test_ab~4.html","title":"test_ab – FOODiE"},{"text":"subroutine test_euler() Arguments None Description Test explicit forward Euler ODE solver. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( euler_explicit_integrator ), public :: euler_integrator Euler integrator. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integrations, explicit Euler' , & filename = 'oscillation_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler","tags":"","loc":"proc/test_euler~4.html","title":"test_euler – FOODiE"},{"text":"subroutine test_leapfrog() Arguments None Description Test explicit leapfrog class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. type( oscillation ), public :: filter Filter displacement. type( leapfrog_integrator ), public :: lf_integrator Leapfrog integrator. integer, public :: step Time steps counter. Source Code subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( oscillation ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init () call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , f = f , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) else call lf_integrator % integrate ( field = attractor , filter = filter , dt = dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit leapfrog scheme' ,& filename = 'oscillation_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog","tags":"","loc":"proc/test_leapfrog~4.html","title":"test_leapfrog – FOODiE"},{"text":"subroutine test_ls_rk() Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( ls_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. integer, public, parameter :: registers = 2 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:registers) Runge-Kutta registers. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : registers ) !< Runge-Kutta registers. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , filename = 'oscillation_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk","tags":"","loc":"proc/test_ls_rk~4.html","title":"test_ls_rk – FOODiE"},{"text":"subroutine test_tvd_rk() Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( tvd_runge_kutta_integrator ), public :: rk_integrator Runge-Kutta integrator. integer, public, parameter :: rk_stages = 5 Runge-Kutta stages number. type( oscillation ), public :: rk_stage (1:rk_stages) Runge-Kutta stages. integer(kind=I_P), public :: s RK stages counter. integer(kind=I_P), public :: step Time steps counter. Source Code subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'oscillation_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk","tags":"","loc":"proc/test_tvd_rk~4.html","title":"test_tvd_rk – FOODiE"},{"text":"private purefunction output(self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. Source Code pure function output ( self ) result ( state ) !--------------------------------------------------------------------------------------------------------------------------------- !< Output the Oscillation field state. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. real ( R_P ), dimension (:), allocatable :: state !< Oscillation state vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- state = self % U return !--------------------------------------------------------------------------------------------------------------------------------- endfunction output","tags":"","loc":"proc/output~5.html","title":"output – FOODiE"},{"text":"private function dOscillation_dt(self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: dn Time level, dummy variable. Source Code function dOscillation_dt ( self , n , t ) result ( dState_dt ) !--------------------------------------------------------------------------------------------------------------------------------- !< Time derivative of Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. integer ( I_P ), optional , intent ( IN ) :: n !< Time level. real ( R_P ), optional , intent ( IN ) :: t !< Time. class ( integrand ), allocatable :: dState_dt !< Oscillation field time derivative. integer ( I_P ) :: dn !< Time level, dummy variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: dState_dt ) select type ( dState_dt ) class is ( oscillation ) dState_dt = self if ( self % steps >= 2 ) then ! self%previous should be used dn = self % steps ; if ( present ( n )) dn = n dState_dt % U ( 1 ) = - self % f * self % previous ( 2 , dn ) dState_dt % U ( 2 ) = self % f * self % previous ( 1 , dn ) else ! self%previous should not be used, use directly self%U dState_dt % U ( 1 ) = - self % f * self % U ( 2 ) dState_dt % U ( 2 ) = self % f * self % U ( 1 ) endif endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dOscillation_dt","tags":"","loc":"proc/doscillation_dt.html","title":"dOscillation_dt – FOODiE"},{"text":"private function previous_step(self, n) result(previous) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of oscillation field. Description Extract previous time solution of oscillation field. Source Code function previous_step ( self , n ) result ( previous ) !--------------------------------------------------------------------------------------------------------------------------------- !< Extract previous time solution of oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: self !< Oscillation field. integer ( I_P ), intent ( IN ) :: n !< Time level. class ( integrand ), allocatable :: previous !< Previous time solution of oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: previous ) select type ( previous ) class is ( oscillation ) previous = self previous % U = self % previous (:, n ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction previous_step","tags":"","loc":"proc/previous_step~5.html","title":"previous_step – FOODiE"},{"text":"private function oscillation_multiply_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. Source Code function oscillation_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a oscillation field by another one. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U * rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_oscillation","tags":"","loc":"proc/oscillation_multiply_oscillation.html","title":"oscillation_multiply_oscillation – FOODiE"},{"text":"private function oscillation_multiply_real(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. Source Code function oscillation_multiply_real ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a Oscillation field by a real scalar. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs opr % U = lhs % U * rhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction oscillation_multiply_real","tags":"","loc":"proc/oscillation_multiply_real.html","title":"oscillation_multiply_real – FOODiE"},{"text":"private function real_multiply_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. Source Code function real_multiply_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply a real scalar by a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), intent ( IN ) :: lhs !< Left hand side. class ( oscillation ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = rhs opr % U = rhs % U * lhs endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction real_multiply_oscillation","tags":"","loc":"proc/real_multiply_oscillation.html","title":"real_multiply_oscillation – FOODiE"},{"text":"private function add_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. Source Code function add_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Add two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U + rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction add_Oscillation","tags":"","loc":"proc/add_oscillation.html","title":"add_oscillation – FOODiE"},{"text":"private function sub_oscillation(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. Source Code function sub_oscillation ( lhs , rhs ) result ( opr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract two Oscillation fields. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( IN ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. class ( integrand ), allocatable :: opr !< Operator result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( oscillation :: opr ) select type ( opr ) class is ( oscillation ) opr = lhs select type ( rhs ) class is ( oscillation ) opr % U = lhs % U - rhs % U endselect endselect return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sub_Oscillation","tags":"","loc":"proc/sub_oscillation.html","title":"sub_oscillation – FOODiE"},{"text":"private subroutine init(self, initial_state, f, steps) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Oscillation field. Variables Type Visibility Attributes Name Initial integer(kind=I_P), public :: s Time steps counter. Source Code subroutine init ( self , initial_state , f , steps ) !--------------------------------------------------------------------------------------------------------------------------------- !< Construct an initialized Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. real ( R_P ), dimension (:), intent ( IN ) :: initial_state !< Initial state of the Oscillation field vector. real ( R_P ), intent ( IN ) :: f !< Frequency. integer ( I_P ), optional , intent ( IN ) :: steps !< Time steps stored. integer ( I_P ) :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % dims = size ( initial_state ) self % steps = 0 ; if ( present ( steps )) self % steps = steps if ( allocated ( self % U )) deallocate ( self % U ) ; allocate ( self % U ( 1 : self % dims )) if ( self % steps > 0 ) then if ( allocated ( self % previous )) deallocate ( self % previous ) ; allocate ( self % previous ( 1 : self % dims , 1 : self % steps )) endif self % U = initial_state if ( self % steps > 0 ) then do s = 1 , self % steps self % previous (:, s ) = initial_state enddo endif self % f = f return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init","tags":"","loc":"proc/init~12.html","title":"init – FOODiE"},{"text":"private subroutine update_previous_steps(self, filter, weights) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. Variables Type Visibility Attributes Name Initial integer, public :: s Time steps counter. Source Code subroutine update_previous_steps ( self , filter , weights ) !--------------------------------------------------------------------------------------------------------------------------------- !< Update previous time steps. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: self !< Oscillation field. class ( integrand ), optional , intent ( IN ) :: filter !< Filter field displacement. real ( R_P ), optional , intent ( IN ) :: weights (:) !< Weights for filtering the steps. integer :: s !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( self % steps > 0 ) then do s = 1 , self % steps - 1 self % previous (:, s ) = self % previous (:, s + 1 ) enddo self % previous (:, self % steps ) = self % U endif if ( present ( filter ). and . present ( weights )) then select type ( filter ) class is ( oscillation ) do s = 1 , self % steps self % previous (:, s ) = self % previous (:, s ) + filter % U * weights ( s ) enddo endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine update_previous_steps","tags":"","loc":"proc/update_previous_steps~5.html","title":"update_previous_steps – FOODiE"},{"text":"private subroutine oscillation_assign_oscillation(lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. Source Code subroutine oscillation_assign_oscillation ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one Oscillation field to another. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. class ( integrand ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( rhs ) class is ( oscillation ) lhs % dims = rhs % dims lhs % steps = rhs % steps if ( allocated ( rhs % U )) lhs % U = rhs % U if ( allocated ( rhs % previous )) lhs % previous = rhs % previous lhs % f = rhs % f endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_oscillation","tags":"","loc":"proc/oscillation_assign_oscillation.html","title":"oscillation_assign_oscillation – FOODiE"},{"text":"private subroutine oscillation_assign_real(lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Oscillation field. Source Code subroutine oscillation_assign_real ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assign one real to a Oscillation field. !--------------------------------------------------------------------------------------------------------------------------------- class ( oscillation ), intent ( INOUT ) :: lhs !< Left hand side. real ( R_P ), intent ( IN ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % U )) lhs % U = rhs if ( allocated ( lhs % previous )) lhs % previous = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine oscillation_assign_real","tags":"","loc":"proc/oscillation_assign_real.html","title":"oscillation_assign_real – FOODiE"},{"text":"Uses: type_integrand foodie_integrator_adams_bashforth foodie_integrator_euler_explicit foodie_integrator_leapfrog foodie_integrator_low_storage_runge_kutta foodie_integrator_tvd_runge_kutta Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE, Fortran Object oriented Ordinary Differential Equations integration library. FOODiE is a KISS library for solving systems of Ordinary Differential Equation (ODE) into the Initial Values Problems (IVP)\n contest. The mathematical formulation of the problem is: U_t = R(t,U)\n U_0 = F(0) where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function and F is the (vectorial) initial conditions function. FOODiE is aimed to the time-like integration of the above system of ODE. To this aim, different numerical schemes are provided: explicit Adams-Bashforth class of schemes: 1 step, namely the forward explicit Euler scheme, 1st order accurate; 2 steps, 2nd accurate; 3 steps, 3rd accurate; forward explicit Euler scheme, a 1st order accurate; explicit Leapfrog : Unfiltered, 2st order accurate, (mostly) unstable; Robert-Asselin filtered, 1st order accurate; Robert-Asselin-Williams filter, 3rd order accurate; explicit low storage Runge-Kutta 2N class schemes: LS(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; LS(5,4): 5 stages, 4th order accurate; explicit TVD or SSP Runge-Kutta class schemes: TVD(1,1): 1 stage, 1st order accurate, namely the forward explicit Euler one; SSP(2,2): 2 stages, 2nd order accurate; SSP(3,3): 3 stages, 3rd order accurate; SSP(5,4): 5 stages, 4th order accurate; Usage FOODiE schemes must be applied to only subclass extensions of the abstract class type_integrand . To use FOODiE you must: extend type_integrand abstract class provided by FOODiE implementing your concrete integrand field For example for the Lorenz' ODE system type , extends ( integrand ) :: lorenz !< Lorenz equations field. !< !< It is a FOODiE integrand class. private real ( R_P ), dimension (:), allocatable :: state !< Solution vector. real ( R_P ) :: sigma = 0._R_P !< Lorenz \\sigma. real ( R_P ) :: rho = 0._R_P !< Lorenz \\rho. real ( R_P ) :: beta = 0._R_P !< Lorenz \\beta. contains procedure , pass ( self ), public :: t => dLorenz_dt !< Time derivate, resiuduals function. procedure , pass ( lhs ), public :: integrand_multiply_real => lorenz_multiply_real !< lorenz * real operator. procedure , pass ( rhs ), public :: real_multiply_integrand => real_multiply_lorenz !< Real * Lorenz operator. procedure , pass ( lhs ), public :: add => add_lorenz !< Lorenz + Lorenz oprator. procedure , pass ( lhs ), public :: assign_integrand => lorenz_assign_lorenz !< Lorenz = Lorenz. procedure , pass ( lhs ), public :: assign_real => lorenz_assign_real !< Lorenz = real. ... endtype lorenz use one of the provided FOODiE integrator For example using the forward explicit Euler scheme to the above Lorenz' ODE system use foodie , only : euler_explicit_integrator use type_lorenz , only : lorenz type ( euler_explicit_integrator ) :: euler_integrator type ( lorenz ) :: attractor real :: dt = 0.01 do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt ) enddo Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"module/foodie.html","title":"foodie – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit class of Adams-Bashforth multi-step schemes, from 1st to 3rd order accutate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Adams-Bashforth class scheme implemented is:  U&#94;{n+s} = U&#94;{n+s-1} +\\Delta t \\left[ \\sum_{i=1}&#94;{n+s}{ b_i \\cdot R(t&#94;{n+i-1}, U&#94;{n+i-1}) } \\right]  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The coefficients \\b define the actual scheme, that is selected accordingly to the number of steps used. Currently the following schemes are available: 1 step, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order.\n The b coefficient is:\n b = \\left[1\\right]\n The scheme is:\n  U&#94;{n+1} = U&#94;n + \\Delta t R(t&#94;n,U&#94;n)  2 steps This scheme is 2nd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} -\\frac{1}{2} & \\frac{3}{2} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+2} = U&#94;{n+1} +\\Delta t \\left[ \\frac{3}{2} R(t&#94;{n+1}, U&#94;{n+1})-\\frac{1}{2} R(t&#94;{n}, U&#94;{n})  \\right]  3 steps This scheme is 3rd order.\n The b coefficients are:\n b = \\left[ {\\begin{array}{*{20}{c}} b_1 & b_2 & b_3 \\end{array}} \\right] =\n       \\left[ {\\begin{array}{*{20}{c}} \\frac{5}{12} & -\\frac{4}{3} & \\frac{23}{12} \\end{array}} \\right]\n The scheme is:\n  U&#94;{n+3} = U&#94;{n+2} +\\Delta t \\left[ \\frac{23}{12}R(t&#94;{n+2}, U&#94;{n+2}) - \\frac{4}{3}R(t&#94;{n+1}, U&#94;{n+1})\n +\\frac{5}{12} R(t&#94;{n}, U&#94;{n})  \\right]  Bibliography Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: adams_bashforth_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps. real(kind=R_P), private, allocatable :: b (:) b coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_adams_bashforth.html","title":"foodie_integrator_adams_bashforth – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the Forward Explicit Euler scheme implemented is:  U&#94;{n+1} = U&#94;n +\\Delta t R(t, U&#94;n)  Note The value of \\Delta t must be provided, it not being computed by the integrator. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: euler_explicit_integrator Type-Bound Procedures procedure, public, nopass :: integrate Integrate integrand field. Description FOODiE integrator: provide an explicit Euler scheme, it being 1st order accurate. Subroutines private subroutine integrate (field, Dt, t) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: field Field to be integrated. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with explicit Euler scheme, 1st order.","tags":"","loc":"module/foodie_integrator_euler_explicit.html","title":"foodie_integrator_euler_explicit – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the leapfrog class scheme implemented (see [3]) is:  U&#94;{n+2} = U&#94;{n} + 2\\Delta t \\cdot R(t&#94;{n+1}, U&#94;{n+1})  Optionally, the Robert-Asselin-Williams (RAW) filter (see [3]) is applied to the computed integration steps:\n  \\Delta = \\frac{\\nu}{2}(U&#94;{n} - 2 U&#94;{n+1} + U&#94;{n+2}) \n  U&#94;{n+1} = U&#94;{n+1} + \\Delta * \\alpha \n  U&#94;{n+2} = U&#94;{n+2} + \\Delta * (\\alpha-1) \n Note that for \\alpha=1 the filter reverts back to the standard Robert-Asselin scheme.\n The filter coefficients should be taken as \\nu \\in [0,1] and \\alpha \\in [0.5,1]. The default values are\n+ \\nu=0.01)\n+ \\alpha=0.5) Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit. The filter coefficients \\nu,\\,\\alpha  define the actual scheme. Bibliography [1] The integration of a low order spectral form of the primitive meteorological equations , Robert, A. J., J. Meteor. Soc.\n Japan,vol. 44, pages 237–245, 1966. [2] Frequency filter for time integrations , Asselin, R., Monthly Weather Review, vol. 100, pages 487–490, 1972. [3] The RAW filter: An improvement to the Robert–Asselin filter in semi-implicit integrations , Williams, P.D., Monthly\n Weather Review, vol. 139(6), pages 1996–2007, June 2011. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: leapfrog_integrator Components Type Visibility Attributes Name Initial real(kind=R_P), private :: nu = 0.01_R_P Robert-Asselin filter coefficient. real(kind=R_P), private :: alpha = 0.5_R_P Robert-Asselin-Williams filter coefficient. Type-Bound Procedures procedure, public, pass(self) :: init Initialize (create) the integrator. procedure, public, pass(self) :: integrate Integrate integrand field. Description FOODiE integrator: provide an explicit class of leapfrog multi-step schemes, 2nd order accutate. Subroutines private elementalsubroutine init (self, nu, alpha) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(inout) :: self LF integrator. real(kind=R_P), intent(in), optional :: nu Williams-Robert-Asselin filter coefficient. real(kind=R_P), intent(in), optional :: alpha Robert-Asselin filter coefficient. Description Create the actual leapfrog integrator: initialize the filter coefficient. private subroutine integrate (self, field, filter, Dt, t) Arguments Type Intent Optional Attributes Name class( leapfrog_integrator ), intent(in) :: self LF integrator. class( integrand ), intent(inout) :: field Field to be integrated. class( integrand ), intent(inout), optional :: filter Filter field displacement. real(kind=R_P), intent(in) :: Dt Time step. real(kind=R_P), intent(in) :: t Time. Description Integrate field with leapfrog class scheme.","tags":"","loc":"module/foodie_integrator_leapfrog.html","title":"foodie_integrator_leapfrog – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit class of low storage Runge-Kutta schemes, from 1st to 4th order accurate. The class of integrators provided have the low storage property allowing for an efficient use of the memory.\n Following Williamson approach [1], the LSRK(5,4)2N (solution 3) scheme of Carpenter et al. [2] is implemented. Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form: \\begin{matrix}\n K_1 = U&#94;n \\\\\n K_2 = 0 \\\\\n\\left.\\begin{matrix}\n K_2 = A_s K_2 + \\Delta t R(t&#94;n + C_s \\Delta t, K_1) \\\\\n K_1 = K_1 + B_s K_2\n\\end{matrix}\\right\\} s=1,2,...N_s\\\\\nU&#94;{n+1} = K_1\n\\end{matrix} where Ns is the number of stages used and K_1, K_2 are the 2 registers used for stages computation. Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus A_1=C_1=0. The coefficients A_s, B_s, C_s are given in the Williamson low storage table\n form. The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order. It is not a real low storage scheme, this being\n meaningless for a first order scheme. However it is added for safety reason.\n A = \\left[ 0 \\right]\n B = \\left[ 1 \\right]\n C = \\left[ 0 \\right] 5 stages, SSP, 4th order This scheme is a low storage RK(5, 4), based on the solution 3 proposed in [2].\nA = \\left[ {\\begin{matrix}\n 0                                   \\\\\n-\\frac{567301805773 }{1357537059087} \\\\\n-\\frac{2404267990393}{2016746695238} \\\\\n-\\frac{3550918686646}{2091501179385} \\\\\n-\\frac{1275806237668}{842570457699 }\n\\end{matrix}} \\right]\nB = \\left[ {\\begin{matrix}\n\\frac{1432997174477}{9575080441755 } \\\\\n\\frac{5161836677717}{13612068292357} \\\\\n\\frac{1720146321549}{2090206949498 } \\\\\n\\frac{3134564353537}{4481467310338 } \\\\\n\\frac{2277821191437}{14882151754819}\n\\end{matrix}} \\right]\nC = \\left[ {\\begin{matrix}\n 0                                  \\\\\n\\frac{1432997174477}{9575080441755} \\\\\n\\frac{2526269341429}{6820363962896} \\\\\n\\frac{2006345519317}{3224310063776} \\\\\n\\frac{2802321613138}{2924317926251}\n\\end{matrix}} \\right] Bibliography [1] Low-Storage Runge-Kutta Schemes , J. H. Williamson, Journal of Computational Physics, vol. 35, 1980, pp. 48–56. [2] Fourth-Order 2N-Storage Runge-Kutta Schemes , Mark H. Carpenter, Christopher A. Kennedy, NASA Technical Memorandum 109112,\n June 1994. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: ls_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: A (:) Low storage A coefficients. real(kind=R_P), public, allocatable :: B (:) Low storage B coefficients. real(kind=R_P), public, allocatable :: C (:) Low storage C coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_low_storage_runge_kutta.html","title":"foodie_integrator_low_storage_runge_kutta – FOODiE"},{"text":"Uses: IR_Precision type_integrand Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. FOODiE integrator: provide an explicit class of TVD or SSP Runge-Kutta schemes, from 1st to 4th order accutate. The class of integrators provided have the Total Variation Diminishing (TVD) property or the Strong Stability Preserving (SSP)\n one. The schemes are explicit and defined through the Butcher's table syntax, see[1] . Considering the following ODE system:  U_t = R(t,U)  where U_t = \\frac{dU}{dt}, U is the vector of state variables being a function of the time-like independent variable t , R is the (vectorial) residual function, the class of schemes implemented are written in the form:  U&#94;{n+1} = U&#94;n +\\Delta t \\sum_{s=1}&#94;{Ns}\\beta&#94;s K&#94;s  where Ns is the number of stages used and K&#94;s is the s&#94;{th} stage computed as:  K&#94;s = R\\left( t&#94;n+\\gamma&#94;s \\Delta t, U&#94;n +\\Delta t \\sum_{i=1}&#94;{s-1}\\alpha&#94;{s,i} K&#94;i \\right)  Note The value of \\Delta t must be provided, it not being computed by the integrator. The schemes are explicit thus the above summation is up to s-1. The coefficients \\beta, \\alpha and \\gamma are\n given in the Butcher table form: \\gamma&#94;1 \\alpha&#94;{1,1} \\alpha&#94;{1,2} \\cdots \\alpha&#94;{1,Ns} \\gamma&#94;2 \\alpha&#94;{2,1} \\alpha&#94;{2,2} \\cdots \\alpha&#94;{2,Ns} \\vdots \\vdots \\vdots \\ddots \\vdots \\gamma&#94;{Ns} \\alpha&#94;{Ns,1} \\alpha&#94;{Ns,2} \\cdots \\alpha&#94;{Ns,Ns} \\beta&#94;1 \\beta&#94;2 \\cdots \\beta&#94;{Ns} Because only explicit schemes are considered the Butcher table reduces to diagonal matrix: \\gamma&#94;1       0            0      \\cdots         0     \\gamma&#94;2 \\alpha&#94;{2,1} \\alpha&#94;{2,2} \\cdots \\alpha&#94;{2,Ns} \\vdots \\vdots \\vdots \\ddots \\vdots \\gamma&#94;{Ns} \\alpha&#94;{Ns,1} \\alpha&#94;{Ns,2} \\cdots         0      \\beta&#94;1 \\beta&#94;2 \\cdots \\beta&#94;{Ns} Moreover the following relation always holds:\n  \\gamma&#94;s = \\sum_{i=1}&#94;{Ns}\\alpha&#94;{s,i}  The different schemes are selected accordingly to the number of stages used. Currently the following schemes are available: 1 stage, Explicit Forward Euler, 1st order This scheme is TVD and reverts to Explicit Forward Euler, it being 1st order.\n \\beta = \\left[1\\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0 \\end{array}} \\right]\n \\gamma = \\left[0\\right] 2 stages, SSP, 2nd order This scheme is an optmial SSP(2, 2) without low-storage algorithm, see [2].\n \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{2}&\\frac{1}{2} \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0\\\\ 1&0 \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\end{array}} \\right] 3 stages, SSP, 3rd order This scheme is an optmial SSP(3, 3) without low-storage algorithm, see [2].\n \\beta = \\left[ {\\begin{array}{*{20}{c}} \\frac{1}{6}&\\frac{1}{6}&\\frac{1}{3}  \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}} 0&0&0\\\\ 1&0&0\\\\ \\frac{1}{4}&\\frac{1}{4}&0 \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0 \\\\ 1 \\\\ \\frac{1}{2} \\end{array}} \\right] 5 stages, SSP, 4th order This scheme is an optmial SSP(5, 4) without low-storage algorithm, see [2].\n \\beta = \\left[ {\\begin{array}{*{20}{c}} 0.14681187618661&0.24848290924556&0.10425883036650&0.27443890091960&\n 0.22600748319395 \\end{array}} \\right]\n \\alpha = \\left[ {\\begin{array}{*{20}{c}}\n 0&0&0&0&0 \\\\ 0.39175222700392&0&0&0&0 \\\\ 0.21766909633821&0.36841059262959&0&0&0 \\\\ 0.08269208670950&\n 0.13995850206999&0.25189177424738&0&0 \\\\ 0.06796628370320&0.11503469844438&0.20703489864929&0.54497475021237&0\n \\end{array}} \\right]\n \\gamma = \\left[ {\\begin{array}{*{20}{c}} 0\\\\0.39175222700392\\\\0.58607968896780\\\\0.47454236302687\\\\0.93501063100924\n           \\end{array}} \\right] Bibliography [1] Coefficients for the study of Runge-Kutta integration processes , Butcher, J.C., J. Austral. Math. Soc., Vol. 3,\n pages: 185–201, 1963. [2] High Order Strong Stability Preserving Time Discretizations , Gottlieb, S., Ketcheson, D. I., Shu, C.W., Journal of\n Scientific Computing, vol. 38, N. 3, 2009, pp. 251-289. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: tvd_runge_kutta_integrator Components Type Visibility Attributes Name Initial integer(kind=I_P), public :: stages = 0 Number of stages. real(kind=R_P), public, allocatable :: alph (:,:) \\alpha Butcher's coefficients. real(kind=R_P), public, allocatable :: beta (:) \\beta Butcher's coefficients. real(kind=R_P), public, allocatable :: gamm (:) \\gamma Butcher's coefficients. Finalizations Procedures final :: finalize","tags":"","loc":"module/foodie_integrator_tvd_runge_kutta.html","title":"foodie_integrator_tvd_runge_kutta – FOODiE"},{"text":"Uses: IR_Precision Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define the abstract type integrand for building FOODiE ODE integrators. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: self Integrand field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update the previous time steps (of integrand field) for multi-step(level) ODE solvers. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_integrand (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Symmetric assignment integrand = integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private subroutine assignment_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( integrand ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Asymmetric assignment integrand = real. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function time_derivative (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Result of the time derivative function of integrand field. Description Time derivative function of integrand class, i.e. the residuals function. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: self Integrand field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Selected previous time integrand field. Description Get a previous time steps (of integrand field) for multi-step(level) ODE solvers. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function integrand_op_real (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator integrand.op.real. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function real_op_integrand (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Asymmetric type operator real.op.integrand. abstract interface Abstract type bound procedures necessary for implementing a concrete extension of the class(integrand). private function symmetric_operator (lhs, rhs) result(operator_result) Arguments Type Intent Optional Attributes Name class( integrand ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Symmetric type operator integrand.op.integrand. Derived Types type, public, abstract :: integrand Type-Bound Procedures procedure(time_derivative), public, pass(self), deferred :: t Time derivative, residuals. procedure(update_previous_steps), public, pass(self), deferred :: update_previous_steps Update the previous time steps. procedure(previous_step), public, pass(self), deferred :: previous_step Get a previous time step. procedure(symmetric_operator), public, pass(lhs), deferred :: integrand_multiply_integrand Integrand * integrand operator. procedure(integrand_op_real), public, pass(lhs), deferred :: integrand_multiply_real Integrand * real operator. procedure(real_op_integrand), public, pass(rhs), deferred :: real_multiply_integrand Real * integrand operator. procedure(symmetric_operator), public, pass(lhs), deferred :: add Integrand + integrand oprator. procedure(symmetric_operator), public, pass(lhs), deferred :: sub Integrand - integrand oprator. procedure(assignment_integrand), public, pass(lhs), deferred :: assign_integrand Integrand = integrand. procedure(assignment_real), public, pass(lhs), deferred :: assign_real Integrand = real. generic, public :: operator(+) => add Overloading + operator. generic, public :: operator(-) => sub Overloading - operator. generic, public :: operator(*) => integrand_multiply_integrand, real_multiply_integrand, integrand_multiply_real Overloading * operator. generic, public :: assignment(=) => assign_integrand, assign_real Overloading = assignament. Description Abstract type for building FOODiE ODE integrators.","tags":"","loc":"module/type_integrand.html","title":"type_integrand – FOODiE"},{"text":"Uses: IR_Precision foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Burgers field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: burgers Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: Ni = 0 Number of grid nodes. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private :: h = 0._R_P Space step discretization. real(kind=R_P), private :: nu = 0._R_P Viscosity. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, whole physical domain, [1:Ni]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:Ni,1:steps]. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Burgers field. procedure, public, pass(self) :: dt => compute_dt Compute the current time step, by means of CFL condition. procedure, public, pass(self) :: t => dBurgers_dt Time derivative, residuals func. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(lhs) :: integrand_multiply_integrand => burgers_multiply_burgers Burgers * burgers operator. procedure, public, pass(lhs) :: integrand_multiply_real => burgers_multiply_real Burgers * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_burgers Real * Burgers operator. procedure, public, pass(lhs) :: add => add_burgers Burgers + Burgers operator. procedure, public, pass(lhs) :: sub => sub_burgers Burgers - Burgers operator. procedure, public, pass(lhs) :: assign_integrand => burgers_assign_burgers Burgers = Burgers. procedure, public, pass(lhs) :: assign_real => burgers_assign_real Burgers = real. procedure, private, pass(self) :: x => dBurgers_dx 1st derivative. procedure, private, pass(self) :: xx => d2Burgers_dx2 2nd derivative. Description Burgers equations field. Functions private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. Return Value real(kind=R_P),\n  dimension(:),allocatable Burgers state variable. Description Output the Burgers field state. private purefunction compute_dt (self, CFL) result(dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. real(kind=R_P), intent(in) :: CFL Courant-Friedricks-Lewi stability coefficient. Return Value real(kind=R_P) Current time step. Description Compute the current time step, by means of CFL condition. private function dBurgers_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Burgers field time derivative. Description Time derivative of Burgers field, residuals function. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Burgers field. Description Extract previous time solution of Burgers field. private function burgers_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by another one. private function burgers_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Burgers field by a real scalar. private function real_multiply_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( burgers ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Burgers field. private function add_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Burgers fields. private function sub_burgers (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Burgers fields. private function dBurgers_dx (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ) Burgers field derivative. Description Compute the first order spatial derivative of Burgers field. private function d2Burgers_dx2 (self, n) result(derivative) Arguments Type Intent Optional Attributes Name class( burgers ), intent(in) :: self Burgers field. integer, intent(in), optional :: n Time level. Return Value type( burgers ) Burgers field derivative. Description Compute the second order spatial derivative of Burgers field. Subroutines private subroutine init (self, initial_state, Ni, h, nu, steps) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. real(kind=R_P), intent(in), dimension(1:Ni) :: initial_state Initial state of Burgers field domain. integer(kind=I_P), intent(in) :: Ni Number of grid nodes. real(kind=R_P), intent(in) :: h Space step discretization. real(kind=R_P), intent(in) :: nu Viscosity. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Burgers field. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: self Burgers field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. private subroutine burgers_assign_burgers (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Burgers field to another. private subroutine burgers_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( burgers ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Burgers field.","tags":"","loc":"module/type_burgers.html","title":"type_burgers – FOODiE"},{"text":"Uses: IR_Precision foodie wenoof Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D (OpenMP enabled) field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D_openmp Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d_openmp.html","title":"type_euler_1D_openmp – FOODiE"},{"text":"Uses: IR_Precision foodie wenoof Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Euler 1D field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: euler_1D Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: steps = 0 Number of time steps stored. integer(kind=I_P), private :: ord = 0 Space accuracy formal order. integer(kind=I_P), private :: Ni = 0 Space dimension. integer(kind=I_P), private :: Ng = 0 Number of ghost cells for boundary conditions handling. integer(kind=I_P), private :: Ns = 0 Number of initial species. integer(kind=I_P), private :: Nc = 0 Number of conservative variables, Ns+2. integer(kind=I_P), private :: Np = 0 Number of primitive variables, Ns+4. real(kind=R_P), private :: Dx = 0._R_P Space step. type(weno_interpolator_upwind), private :: weno WENO interpolator. real(kind=R_P), private, allocatable :: U (:,:) Integrand (state) variables, whole physical domain [1:Nc,1-Ng:Ni+Ng]. real(kind=R_P), private, allocatable :: previous (:,:,:) Previous time steps states [1:Nc,1-Ng:Ni+Ng,1:steps]. real(kind=R_P), private, allocatable :: cp0 (:) Specific heat cp of initial species [1:Ns]. real(kind=R_P), private, allocatable :: cv0 (:) Specific heat cv of initial species [1:Ns]. character(len=:), private, allocatable :: BC_L Left boundary condition type. character(len=:), private, allocatable :: BC_R Right boundary condition type. Finalizations Procedures final :: finalize","tags":"","loc":"module/type_euler_1d.html","title":"type_euler_1D – FOODiE"},{"text":"Uses: IR_Precision foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Lorenz field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: lorenz Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: sigma = 0._R_P Lorenz \\sigma. real(kind=R_P), private :: rho = 0._R_P Lorenz \\rho. real(kind=R_P), private :: beta = 0._R_P Lorenz \\beta. Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Lorenz field. procedure, public, pass(self) :: t => dLorenz_dt Time derivative, residuals function. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(lhs) :: integrand_multiply_integrand => lorenz_multiply_lorenz Lorenz * Lorenz operator. procedure, public, pass(lhs) :: integrand_multiply_real => lorenz_multiply_real Lorenz * real operator. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_lorenz Real * Lorenz operator. procedure, public, pass(lhs) :: add => add_lorenz Lorenz + Lorenz operator. procedure, public, pass(lhs) :: sub => sub_lorenz Lorenz - Lorenz. procedure, public, pass(lhs) :: assign_integrand => lorenz_assign_lorenz Lorenz = Lorenz. procedure, public, pass(lhs) :: assign_real => lorenz_assign_real Lorenz = real. Description Lorenz equations field. Functions private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. Return Value real(kind=R_P),\n  dimension(:),allocatable Lorenz state vector. Description Output the Lorenz field state. private function dLorenz_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Lorenz field time derivative. Description Time derivative of Lorenz field. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: self Lorenz field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of Lorenz field. Description Extract previous time solution of Lorenz field. private function lorenz_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a lorenz field by another one. private function lorenz_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Lorenz field by a real scalar. private function real_multiply_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( lorenz ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Lorenz field. private function add_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Lorenz fields. private function sub_lorenz (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Lorenz fields. Subroutines private subroutine init (self, initial_state, sigma, rho, beta, steps) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of Lorenz field vector. real(kind=R_P), intent(in) :: sigma Lorenz  \\sigma. real(kind=R_P), intent(in) :: rho Lorenz  \\rho. real(kind=R_P), intent(in) :: beta Lorenz  \\beta. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Lorenz field. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: self Lorenz field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. private subroutine lorenz_assign_lorenz (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Lorenz field to another. private subroutine lorenz_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( lorenz ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Lorenz field.","tags":"","loc":"module/type_lorenz.html","title":"type_lorenz – FOODiE"},{"text":"Uses: IR_Precision foodie Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Define Oscillation field that is a concrete extension of the abstract integrand type. Used By Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends(integrand) :: oscillation Components Type Visibility Attributes Name Initial integer(kind=I_P), private :: dims = 0 Space dimensions. integer(kind=I_P), private :: steps = 0 Number of time steps stored. real(kind=R_P), private, dimension(:), allocatable :: U Integrand (state) variables, [1:dims]. real(kind=R_P), private, dimension(:,:), allocatable :: previous Previous time steps states, [1:dims,1:steps]. real(kind=R_P), private :: f = 0._R_P Oscillation frequency (Hz). Type-Bound Procedures procedure, public, pass(self) :: init Init field. procedure, public, pass(self) :: output Extract Oscillation field. procedure, public, pass(self) :: t => dOscillation_dt Time derivative, residuals. procedure, public, pass(self) :: update_previous_steps Update previous time steps. procedure, public, pass(self) :: previous_step Get a previous time step. procedure, public, pass(lhs) :: integrand_multiply_integrand => oscillation_multiply_oscillation Oscillation * oscillation. procedure, public, pass(lhs) :: integrand_multiply_real => oscillation_multiply_real Oscillation * real. procedure, public, pass(rhs) :: real_multiply_integrand => real_multiply_oscillation Real * Oscillation. procedure, public, pass(lhs) :: add => add_oscillation Oscillation + Oscillation. procedure, public, pass(lhs) :: sub => sub_oscillation Oscillation - Oscillation. procedure, public, pass(lhs) :: assign_integrand => oscillation_assign_oscillation Oscillation = Oscillation. procedure, public, pass(lhs) :: assign_real => oscillation_assign_real Oscillation = real. Description Oscillation equations field. Functions private purefunction output (self) result(state) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. Return Value real(kind=R_P),\n  dimension(:),allocatable Oscillation state vector. Description Output the Oscillation field state. private function dOscillation_dt (self, n, t) result(dState_dt) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in), optional :: n Time level. real(kind=R_P), intent(in), optional :: t Time. Return Value class( integrand ),\n  allocatable Oscillation field time derivative. Description Time derivative of Oscillation field. private function previous_step (self, n) result(previous) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: self Oscillation field. integer(kind=I_P), intent(in) :: n Time level. Return Value class( integrand ),\n  allocatable Previous time solution of oscillation field. Description Extract previous time solution of oscillation field. private function oscillation_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a oscillation field by another one. private function oscillation_multiply_real (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a Oscillation field by a real scalar. private function real_multiply_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R_P), intent(in) :: lhs Left hand side. class( oscillation ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Multiply a real scalar by a Oscillation field. private function add_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Add two Oscillation fields. private function sub_oscillation (lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(in) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Return Value class( integrand ),\n  allocatable Operator result. Description Subtract two Oscillation fields. Subroutines private subroutine init (self, initial_state, f, steps) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. real(kind=R_P), intent(in), dimension(:) :: initial_state Initial state of the Oscillation field vector. real(kind=R_P), intent(in) :: f Frequency. integer(kind=I_P), intent(in), optional :: steps Time steps stored. Description Construct an initialized Oscillation field. private subroutine update_previous_steps (self, filter, weights) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: self Oscillation field. class( integrand ), intent(in), optional :: filter Filter field displacement. real(kind=R_P), intent(in), optional :: weights (:) Weights for filtering the steps. Description Update previous time steps. private subroutine oscillation_assign_oscillation (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. class( integrand ), intent(in) :: rhs Right hand side. Description Assign one Oscillation field to another. private subroutine oscillation_assign_real (lhs, rhs) Arguments Type Intent Optional Attributes Name class( oscillation ), intent(inout) :: lhs Left hand side. real(kind=R_P), intent(in) :: rhs Right hand side. Description Assign one real to a Oscillation field.","tags":"","loc":"module/type_oscillation.html","title":"type_oscillation – FOODiE"},{"text":"Uses: IR_Precision type_burgers Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Burgers equation. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( burgers ) :: domain Burgers field domain. real(kind=R_P), parameter :: CFL = 0.1_R_P CFL value. real(kind=R_P), parameter :: t_final = 0.6_R_P Final time. real(kind=R_P), parameter :: nu = 1._R_P Viscosity. integer(kind=I_P), parameter :: Ni = 100 Number of grid nodes. real(kind=R_P) :: h Space step discretization. real(kind=R_P) :: initial_state (1:Ni) Initial state. real(kind=R_P) :: x (1:Ni) Nodes values. real(kind=R_P), allocatable :: final_state (:) Final state. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_burgers !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Burgers equation. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_burgers , only : burgers use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( burgers ) :: domain !< Burgers field domain. real ( R_P ), parameter :: CFL = 0.1_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.6_R_P !< Final time. real ( R_P ), parameter :: nu = 1._R_P !< Viscosity. integer ( I_P ), parameter :: Ni = 100 !< Number of grid nodes. real ( R_P ) :: h !< Space step discretization. real ( R_P ) :: initial_state ( 1 : Ni ) !< Initial state. real ( R_P ) :: x ( 1 : Ni ) !< Nodes values. real ( R_P ), allocatable :: final_state (:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'burgers' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Burgers equation integration' , & examples = [ \"burgers --solver euler --results\" , & \"burgers --solver runge-kutta -r \" , & \"burgers --solver adams-bashforth\" , & \"burgers --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! create Burgers field initial state call init () ! integrate Burgers equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- real ( R_P ), parameter :: pi = 4._R_P * atan ( 1._R_P ) !< Pi greek. integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- h = 2._R_P * pi / Ni do i = 1 , Ni x ( i ) = h * ( i - 1 ) initial_state ( i ) = 1 0._R_P * sin ( x ( i )) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"U\"' do i = 1 , Ni write ( rawfile , '(2(' // FR_P // ',1X))' ) x ( i ), final_state ( i ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) call plt % add_plot ( x = x , y = final_state , label = 'U' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = s ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t ( s ) < t_final ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ( s )) if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( field = domain , dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit ' // & 'Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'burgers_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of explicit Euler solver' call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call euler_integrator % integrate ( field = domain , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit Euler' , & filename = 'burgers_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( burgers ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu , steps = 2 ) dt = domain % dt ( CFL = CFL ) t = 0._R_P step = 1 do while ( t < t_final ) if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) else call lf_integrator % integrate ( field = domain , filter = filter , dt = dt , t = t ) endif t = t + dt step = step + 1 enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit leapfrog scheme' ,& filename = 'burgers_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( burgers ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Burgers equation by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call domain % init ( initial_state = initial_state , Ni = Ni , h = h , nu = nu ) dt = domain % dt ( CFL = CFL ) t = 0._R_P do while ( t < t_final ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt enddo final_state = domain % output () call save_results ( title = 'FOODiE test: Burgers equation integration, t=' // str ( n = t_final ) // ' explicit TVD Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , & filename = 'burgers_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_burgers","tags":"","loc":"program/integrate_burgers.html","title":"integrate_burgers – FOODiE"},{"text":"Uses: IR_Precision type_euler_1D_openmp Data_Type_Command_Line_Interface foodie pyplot_module omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Euler 1D PDEs system. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( tvd_runge_kutta_integrator ) :: rk_integrator Runge-Kutta integrator. integer, parameter :: rk_stages = 5 Runge-Kutta stages number. type(euler_1D_openmp) :: rk_stage (1:rk_stages) Runge-Kutta stages. real(kind=R_P) :: dt Time step. real(kind=R_P) :: t Time. type(euler_1D_openmp) :: domain Domain of Euler equations. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. real(kind=R_P), parameter :: t_final = 0.15_R_P Final time. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. integer(kind=I_P) :: Ni Number of grid cells. real(kind=R_P) :: Dx Space step discretization. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P), allocatable :: initial_state (:,:) Initial state of primitive variables. real(kind=R_P), allocatable :: x (:) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. integer(kind=I_P) :: omp_threads Number of OpenMP threads. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. integer(kind=I_P) :: profiling (1:2) Tic-toc profiling counters. integer(kind=I_P) :: count_rate Counting rate of system clock. real(kind=R_P) :: system_clocks Profiling result. integer(kind=I_P) :: steps Time steps counter. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. Source Code program integrate_euler_1D_openmp !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D_openmp , only : euler_1D_openmp use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot #ifdef OPENMP use OMP_LIB #endif !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D_openmp ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. type ( euler_1D_openmp ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.15_R_P !< Final time. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. integer ( I_P ) :: Ni !< Number of grid cells. real ( R_P ) :: Dx !< Space step discretization. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ), allocatable :: initial_state (:,:) !< Initial state of primitive variables. real ( R_P ), allocatable :: x (:) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. integer ( I_P ) :: omp_threads !< Number of OpenMP threads. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. integer ( I_P ) :: profiling ( 1 : 2 ) !< Tic-toc profiling counters. integer ( I_P ) :: count_rate !< Counting rate of system clock. real ( R_P ) :: system_clocks !< Profiling result. integer ( I_P ) :: steps !< Time steps counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D-openmp' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on 1D Euler equations integration, OpenMP enabled' , & examples = [ \"euler-1D --results  \" , & \"euler-1D -r -t -v -p\" , & \"euler-1D            \" , & \"euler-1D --plots -r \" ]) call cli % add ( switch = '--Ni' , help = 'Number finite volumes used' , required = . false ., act = 'store' , def = '100' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) call cli % add ( switch = '--omp_threads' , help = 'Number of OpenMP threads used' , required = . false ., act = 'store' , def = '1' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--omp_threads' , val = omp_threads , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--Ni' , val = Ni , error = error ) ; if ( error /= 0 ) stop #ifdef OPENMP call omp_set_dynamic (. false .) call omp_set_num_threads ( omp_threads ) ! check OpenMP parallel environment correctness !$OMP PARALLEL      & !$OMP DEFAULT(none) & !$OMP SHARED(omp_threads) omp_threads = omp_get_num_threads () !$OMP END PARALLEL print \"(A)\" , 'Testing FOODiE with ' // trim ( str (. true ., omp_threads )) // ' OpenMP threads for Ni: ' // trim ( str (. true ., Ni )) // ' cells' #endif ! create Euler field initial state call init () print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) t = 0._R_P steps = 0 call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages )) // '-time_serie.dat' , & t = t ) system_clocks = 0._R_P do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call system_clock ( profiling ( 1 ), count_rate ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) call system_clock ( profiling ( 2 ), count_rate ) system_clocks = system_clocks + real ( profiling ( 2 ) - profiling ( 1 ), kind = R_P ) / count_rate t = t + dt steps = steps + 1 call save_time_serie ( t = t ) enddo system_clocks = system_clocks / steps if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., rk_stages )) // ' stages' , & filename = 'euler_1D_openmp_integration-tvdrk-' // trim ( str (. true ., rk_stages ))) print \"(A)\" , 'Finish! Average system seconds spent for 1 step integration: ' // trim ( str (. true ., system_clocks )) stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( x ( 1 : Ni )) allocate ( initial_state ( 1 : Np , 1 : Ni )) Dx = 1._R_P / Ni ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie endprogram integrate_euler_1D_openmp","tags":"","loc":"program/integrate_euler_1d_openmp.html","title":"integrate_euler_1D_openmp – FOODiE"},{"text":"Uses: IR_Precision type_euler_1D Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Euler 1D PDEs system. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type(euler_1D) :: domain Domain of Euler equations. real(kind=R_P), parameter :: CFL = 0.7_R_P CFL value. real(kind=R_P), parameter :: t_final = 0.15_R_P Final time. integer(kind=I_P), parameter :: Ni = 100 Number of grid cells. integer(kind=I_P), parameter :: Ns = 1 Number of differnt initial gas species. integer(kind=I_P), parameter :: Nc = Ns+2 Number of conservative variables. integer(kind=I_P), parameter :: Np = Ns+4 Number of primitive variables. real(kind=R_P) :: Dx = 1._R_P/Ni Space step discretization. character(len=3) :: BC_L Left boundary condition type. character(len=3) :: BC_R Right boundary condition type. real(kind=R_P) :: cp0 (1:Ns) Specific heat at constant pressure. real(kind=R_P) :: cv0 (1:Ns) Specific heat at constant volume. real(kind=R_P) :: initial_state (1:Np,1:Ni) Initial state of primitive variables. real(kind=R_P) :: x (1:Ni) Cell center x-abscissa values. real(kind=R_P), allocatable :: final_state (:,:) Final state. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. logical :: time_serie Flag for activating time serie-results saving. logical :: verbose Flag for activating more verbose output. Subroutines subroutine init () Arguments None Description Initialize the field. subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save results. subroutine save_time_serie (title, filename, finish, t) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: title Plot title. character(len=*), intent(in), optional :: filename Output filename. logical, intent(in), optional :: finish Flag for triggering the file closing. real(kind=R_P), intent(in) :: t Current integration time. Description Save time-serie results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_euler_1D !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Euler 1D PDEs system. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_euler_1D , only : euler_1D use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( euler_1D ) :: domain !< Domain of Euler equations. real ( R_P ), parameter :: CFL = 0.7_R_P !< CFL value. real ( R_P ), parameter :: t_final = 0.15_R_P !< Final time. integer ( I_P ), parameter :: Ni = 100 !< Number of grid cells. integer ( I_P ), parameter :: Ns = 1 !< Number of differnt initial gas species. integer ( I_P ), parameter :: Nc = Ns + 2 !< Number of conservative variables. integer ( I_P ), parameter :: Np = Ns + 4 !< Number of primitive variables. real ( R_P ) :: Dx = 1._R_P / Ni !< Space step discretization. character ( 3 ) :: BC_L !< Left boundary condition type. character ( 3 ) :: BC_R !< Right boundary condition type. real ( R_P ) :: cp0 ( 1 : Ns ) !< Specific heat at constant pressure. real ( R_P ) :: cv0 ( 1 : Ns ) !< Specific heat at constant volume. real ( R_P ) :: initial_state ( 1 : Np , 1 : Ni ) !< Initial state of primitive variables. real ( R_P ) :: x ( 1 : Ni ) !< Cell center x-abscissa values. real ( R_P ), allocatable :: final_state (:,:) !< Final state. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. logical :: time_serie !< Flag for activating time serie-results saving. logical :: verbose !< Flag for activating more verbose output. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'euler-1D' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on 1D Euler equations integration' , & examples = [ \"euler-1D --solver euler --results\" , & \"euler-1D --solver runge-kutta -r \" , & \"euler-1D --solver adams-bashforth\" , & \"euler-1D --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--tserie' , switch_ab = '-t' , help = 'Save time-serie-results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--verbose' , help = 'Verbose output' , required = . false ., act = 'store_true' , def = '.false.' , error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-t' , val = time_serie , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '--verbose' , val = verbose , error = error ) ; if ( error /= 0 ) stop ! create Euler field initial state call init () ! integrate Euler equation select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the field. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I_P ) :: i !< Space counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! Sod's problem BC_L = 'TRA' BC_R = 'TRA' cp0 ( 1 ) = 104 0._R_P cv0 ( 1 ) = 74 3._R_P do i = 1 , Ni / 2 x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 1._R_P , & ! rho(s) 0._R_P , & ! u 1._R_P , & ! p 1._R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo do i = Ni / 2 + 1 , Ni x ( i ) = Dx * i - 0.5_R_P * Dx initial_state (:, i ) = [ 0.125_R_P , & ! rho(s) 0._R_P , & ! u 0.1_R_P , & ! p 0.125_R_P , & ! sum(rho(s)) cp0 / cv0 ] ! gamma = cp/cv enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results . or . plots ) final_state = domain % output () if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' do i = 1 , Ni write ( rawfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'x' , title = title ) do v = 1 , Ns call plt % add_plot ( x = x , y = final_state ( v , :), label = 'rho(' // trim ( str (. true ., v )) // ')' , linestyle = 'b-' , linewidth = 1 ) enddo call plt % add_plot ( x = x , y = final_state ( Ns + 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 2 , :), label = 'p' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 3 , :), label = 'rho' , linestyle = 'o-' , linewidth = 1 ) call plt % add_plot ( x = x , y = final_state ( Ns + 4 , :), label = 'gamma' , linestyle = 'c-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine save_time_serie ( title , filename , finish , t ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save time-serie results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ), optional :: title !< Plot title. character ( * ), intent ( IN ), optional :: filename !< Output filename. logical , intent ( IN ), optional :: finish !< Flag for triggering the file closing. real ( R_P ), intent ( IN ) :: t !< Current integration time. integer ( I_P ), save :: tsfile !< File unit for saving time serie results. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: v !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( time_serie ) then final_state = domain % output () if ( present ( filename ). and . present ( title )) then open ( newunit = tsfile , file = filename ) write ( tsfile , '(A)' ) '# ' // title endif write ( tsfile , '(A)' ) '# VARIABLES: \"x\" \"rho(1)\" \"rho(2)\"... \"rho(Ns)\" \"u\" \"p\" \"rho\" \"gamma\"' write ( tsfile , '(A)' ) '# Time: ' // str ( n = t ) do i = 1 , Ni write ( tsfile , '(' // trim ( str (. true ., Np + 1 )) // '(' // FR_P // ',1X))' ) x ( i ), ( final_state ( v , i ), v = 1 , Np ) enddo if ( present ( finish )) then if ( finish ) close ( tsfile ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_time_serie subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t ( 1 : ab_steps ) !< Times. integer ( I_P ) :: s !< AB steps counter. integer ( I_P ) :: ss !< AB substeps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = s , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ( s )) step = 1 do while ( t ( s ) < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t ( s ), CFL = 0.1_R_P * CFL ) if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ( s )) if ( step > 1 ) then t ( step ) = t ( step - 1 ) + dt else t ( step ) = dt endif else call ab_integrator % integrate ( field = domain , dt = dt , t = t ) do ss = 1 , s - 1 t ( ss ) = t ( ss + 1 ) enddo t ( s ) = t ( s ) + dt endif step = step + 1 call save_time_serie ( t = t ( s )) enddo call save_time_serie ( t = t ( s ), finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Adams-Bashforth, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' steps' , & filename = 'euler_1D_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of explicit Euler solver' call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '  Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call euler_integrator % integrate ( field = domain , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit Euler, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( euler_1D ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , steps = 2 , ord = 3 ) t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit leapfrog, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-lf-RAW-filter-time_serie.dat' , & t = t ) step = 1 do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = 0.1_R_P * CFL ) if ( 2 >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) else call lf_integrator % integrate ( field = domain , filter = filter , dt = dt , t = t ) endif t = t + dt step = step + 1 call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit leapfrog, t=' // str ( n = t_final ), & filename = 'euler_1D_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit low storage Runge-Kutta, t=' // & str ( n = t_final ) // trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-lsrk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage , dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit low storage Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( euler_1D ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. real ( R_P ) :: dt !< Time step. real ( R_P ) :: t !< Time. integer ( I_P ) :: s !< RK stages counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating 1D Euler equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) select case ( s ) case ( 1 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 1 ) case ( 2 , 3 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 3 ) case ( 5 ) call domain % init ( Ni = Ni , Ns = Ns , Dx = Dx , BC_L = BC_L , BC_R = BC_R , initial_state = initial_state , cp0 = cp0 , cv0 = cv0 , ord = 7 ) endselect t = 0._R_P call save_time_serie ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-tvdrk-' // trim ( str (. true ., s )) // '-time_serie.dat' , & t = t ) do while ( t < t_final ) if ( verbose ) print \"(A)\" , '    Time step: ' // str ( n = dt ) // ', Time: ' // str ( n = t ) dt = domain % dt ( Nmax = 0 , Tmax = t_final , t = t , CFL = CFL ) call rk_integrator % integrate ( field = domain , stage = rk_stage ( 1 : s ), dt = dt , t = t ) t = t + dt call save_time_serie ( t = t ) enddo call save_time_serie ( t = t , finish = . true .) call save_results ( title = 'FOODiE test: 1D Euler equations integration, explicit TVD Runge-Kutta, t=' // str ( n = t_final ) // & trim ( str (. true ., s )) // ' stages' , & filename = 'euler_1D_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_euler_1D","tags":"","loc":"program/integrate_euler_1d.html","title":"integrate_euler_1D – FOODiE"},{"text":"Uses: IR_Precision type_lorenz Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Lorenz equations. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( lorenz ) :: attractor Lorenz field. integer, parameter :: num_steps = 2000 Maximum time steps. integer, parameter :: space_dimension = 3 Space dimensions. real(kind=R_P), parameter :: sigma = 10._R_P Lorenz' \\sigma. real(kind=R_P), parameter :: rho = 28._R_P Lorenz' \\rho. real(kind=R_P), parameter :: beta = 8._R_P/3._R_P Lorenz' \\beta. real(kind=R_P), parameter :: dt = 0.01_R_P Time step. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [1.,1.,1.] Initial state. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_lorenz !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Lorenz equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_lorenz , only : lorenz use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( lorenz ) :: attractor !< Lorenz field. integer , parameter :: num_steps = 2000 !< Maximum time steps. integer , parameter :: space_dimension = 3 !< Space dimensions. real ( R_P ), parameter :: sigma = 1 0._R_P !< Lorenz' \\sigma. real ( R_P ), parameter :: rho = 2 8._R_P !< Lorenz' \\rho. real ( R_P ), parameter :: beta = 8._R_P / 3._R_P !< Lorenz' \\beta. real ( R_P ), parameter :: dt = 0.01_R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 1. , 1. , 1. ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'lorenz' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Lorenz equations integration' , & examples = [ \"lorenz --solver euler --results\" , & \"lorenz --solver runge-kutta -r \" , & \"lorenz --solver adams-bashforth\" , & \"lorenz --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Lorenz equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\" \"z\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 3 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'x' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'y' , linestyle = 'b-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 3 , :), label = 'z' , linestyle = 'g-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'x-y path' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 3 , :), label = 'x-z path' , linestyle = 'g-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 2 , :), y = solution ( 3 , :), label = 'y-z path' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer ( I_P ) :: s !< AB steps counter. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) else call ab_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Adams-Bashforth ' // trim ( str (. true ., s )) // ' steps' , & filename = 'lorenz_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit Euler' , & filename = 'lorenz_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( lorenz ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init ( nu = 1.0_R_P , alpha = 0._R_P ) call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) else call lf_integrator % integrate ( field = attractor , filter = filter , dt = dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit leapfrog scheme' ,& filename = 'lorenz_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : registers ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit low storage Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'lorenz_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( lorenz ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Lorenz equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , sigma = sigma , rho = rho , beta = beta ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Lorenz equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // ' stages' ,& filename = 'lorenz_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_lorenz","tags":"","loc":"program/integrate_lorenz.html","title":"integrate_lorenz – FOODiE"},{"text":"Uses: IR_Precision type_oscillation Data_Type_Command_Line_Interface foodie pyplot_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Test FOODiE with the integration of Oscillation equations. Calls Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type(Type_Command_Line_Interface) :: cli Command line interface handler. type( oscillation ) :: attractor Oscillation field. integer, parameter :: num_steps = 1e4 Maximum time steps. integer, parameter :: space_dimension = 2 Space dimensions. real(kind=R_P), parameter :: f = 1e-4_R_P Frequency. real(kind=R_P), parameter :: dt = 100._R_P Time step. real(kind=R_P), parameter :: initial_state (1:space_dimension) = [0._R_P,1._R_P] Initial state. real(kind=R_P) :: solution (0:space_dimension,0:num_steps) Solution at each time step. integer(kind=I_P) :: error Error handler. character(len=99) :: solver Solver used. logical :: plots Flag for activating plots saving. logical :: results Flag for activating results saving. Subroutines subroutine save_results (title, filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: title Plot title. character(len=*), intent(in) :: filename Output filename. Description Save plots of results. subroutine test_ab () Arguments None Description Test explicit Adams-Bashforth class of ODE solvers. subroutine test_euler () Arguments None Description Test explicit forward Euler ODE solver. subroutine test_leapfrog () Arguments None Description Test explicit leapfrog class of ODE solvers. subroutine test_ls_rk () Arguments None Description Test explicit low storage Runge-Kutta class of ODE solvers. subroutine test_tvd_rk () Arguments None Description Test explicit TVD/SSP Runge-Kutta class of ODE solvers. Source Code program integrate_oscillation !----------------------------------------------------------------------------------------------------------------------------------- !< Test FOODiE with the integration of Oscillation equations. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- use IR_Precision , only : R_P , I_P , FR_P , str use type_oscillation , only : oscillation use Data_Type_Command_Line_Interface , only : Type_Command_Line_Interface use foodie , only : adams_bashforth_integrator , & euler_explicit_integrator , & leapfrog_integrator , & ls_runge_kutta_integrator , & tvd_runge_kutta_integrator use pyplot_module , only : pyplot !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( Type_Command_Line_Interface ) :: cli !< Command line interface handler. type ( oscillation ) :: attractor !< Oscillation field. integer , parameter :: num_steps = 1 e4 !< Maximum time steps. integer , parameter :: space_dimension = 2 !< Space dimensions. real ( R_P ), parameter :: f = 1 e - 4_R_P !< Frequency. real ( R_P ), parameter :: dt = 10 0._R_P !< Time step. real ( R_P ), parameter :: initial_state ( 1 : space_dimension ) = [ 0._R_P , 1._R_P ] !< Initial state. real ( R_P ) :: solution ( 0 : space_dimension , 0 : num_steps ) !< Solution at each time step. integer ( I_P ) :: error !< Error handler. character ( 99 ) :: solver !< Solver used. logical :: plots !< Flag for activating plots saving. logical :: results !< Flag for activating results saving. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! setting Command Line Interface call cli % init ( progname = 'oscillation' , & authors = 'Fortran-FOSS-Programmers' , & license = 'GNU GPLv3' , & description = 'Test FOODiE library on Oscillation equations integration' , & examples = [ \"oscillation --solver euler --results\" , & \"oscillation --solver runge-kutta -r \" , & \"oscillation --solver adams-bashforth\" , & \"oscillation --solver all --plots -r \" ]) call cli % add ( switch = '--solver' , switch_ab = '-s' , help = 'ODE solver used' , required = . true ., act = 'store' , error = error ) call cli % add ( switch = '--results' , switch_ab = '-r' , help = 'Save results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) call cli % add ( switch = '--plots' , switch_ab = '-p' , help = 'Save plots of results' , required = . false ., act = 'store_true' , def = '.false.' , & error = error ) ! parsing Command Line Interface call cli % parse ( error = error ) call cli % get ( switch = '-s' , val = solver , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-r' , val = results , error = error ) ; if ( error /= 0 ) stop call cli % get ( switch = '-p' , val = plots , error = error ) ; if ( error /= 0 ) stop ! integrate Oscillation equations select case ( trim ( adjustl ( solver ))) case ( 'adams-bashforth' ) call test_ab () case ( 'euler' ) call test_euler () case ( 'leapfrog' ) call test_leapfrog () case ( 'ls-runge-kutta' ) call test_ls_rk () case ( 'tvd-runge-kutta' ) call test_tvd_rk () case ( 'all' ) call test_ab () call test_euler () call test_leapfrog () call test_ls_rk () call test_tvd_rk () case default print \"(A)\" , 'Error: unknown solver \"' // trim ( adjustl ( solver )) // '\"' print \"(A)\" , 'Valid solver names are:' print \"(A)\" , '  + adams-bashforth' print \"(A)\" , '  + euler' print \"(A)\" , '  + leapfrog' print \"(A)\" , '  + ls-runge-kutta' print \"(A)\" , '  + tvd-runge-kutta' print \"(A)\" , '  + all' endselect stop !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine save_results ( title , filename ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save plots of results. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: title !< Plot title. character ( * ), intent ( IN ) :: filename !< Output filename. integer ( I_P ) :: rawfile !< Raw file unit for saving results. type ( pyplot ) :: plt !< Plot file handler. integer ( I_P ) :: i !< Counter. integer ( I_P ) :: s !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( results ) then open ( newunit = rawfile , file = filename // '.dat' ) write ( rawfile , '(A)' ) '# ' // title write ( rawfile , '(A)' ) '# VARIABLES: \"t\" \"x\" \"y\"' do s = 1 , num_steps write ( rawfile , '(4(' // FR_P // ',1X))' )( solution ( i , s ), i = 0 , 2 ) enddo close ( rawfile ) endif if ( plots ) then call plt % initialize ( grid = . true ., xlabel = 'time' , title = title , legend = . true .) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 1 , :), label = 'u' , linestyle = 'r-' , linewidth = 1 ) call plt % add_plot ( x = solution ( 0 , :), y = solution ( 2 , :), label = 'v' , linestyle = 'b-' , linewidth = 1 ) call plt % savefig ( filename // '.png' ) call plt % initialize ( grid = . true ., xlabel = 'v1' , ylabel = 'v2' , title = title // '-path' , legend = . true .) call plt % add_plot ( x = solution ( 1 , :), y = solution ( 2 , :), label = 'path' , linestyle = 'r-' , linewidth = 1 ) call plt % savefig ( 'path-' // filename // '.png' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_results subroutine test_ab () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit Adams-Bashforth class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 3 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( adams_bashforth_integrator ) :: ab_integrator !< Adams-Bashforth integrator. integer , parameter :: ab_steps = 3 !< Adams-Bashforth steps number. integer :: step !< Time steps counter. integer ( I_P ) :: s !< AB steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of Adams-Bashforth class of solvers' do s = 1 , ab_steps print \"(A)\" , ' AB-' // trim ( str (. true ., s )) call ab_integrator % init ( steps = s ) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f , steps = s ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( s >= step ) then ! the time steps from 1 to s - 1 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) else call ab_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step - s : step - 1 )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit ' // 'Adams-Bashforth ' // & trim ( str (. true ., s )) // ' steps' , & filename = 'oscillation_integration-ab-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ab subroutine test_euler () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit forward Euler ODE solver. !--------------------------------------------------------------------------------------------------------------------------------- type ( euler_explicit_integrator ) :: euler_integrator !< Euler integrator. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of explicit Euler solver' call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call euler_integrator % integrate ( field = attractor , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integrations, explicit Euler' , & filename = 'oscillation_integration-euler' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_euler subroutine test_leapfrog () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit leapfrog class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. type ( oscillation ) :: filter !< Filter displacement. type ( leapfrog_integrator ) :: lf_integrator !< Leapfrog integrator. integer :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of leapfrog (RAW filtered) class of solvers' call lf_integrator % init () call rk_integrator % init ( stages = rk_stages ) call attractor % init ( initial_state = initial_state , f = f , steps = 2 ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps if ( 2 >= step ) then ! the time steps from 1 to 2 must be computed with other scheme... call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) else call lf_integrator % integrate ( field = attractor , filter = filter , dt = dt , t = solution ( 0 , step )) endif solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit leapfrog scheme' ,& filename = 'oscillation_integration-lf-RAW-filter' ) print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_leapfrog subroutine test_ls_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit low storage Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( ls_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. integer , parameter :: registers = 2 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : registers ) !< Runge-Kutta registers. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of low storage (2N) Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 2 ) cycle ! 2 stages not yet implemented if ( s == 3 ) cycle ! 3 stages not yet implemented if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage , dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit low storage Runge-Kutta ' // & trim ( str (. true ., s )) // ' stages' , filename = 'oscillation_integration-lsrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_ls_rk subroutine test_tvd_rk () !--------------------------------------------------------------------------------------------------------------------------------- !< Test explicit TVD/SSP Runge-Kutta class of ODE solvers. !--------------------------------------------------------------------------------------------------------------------------------- type ( tvd_runge_kutta_integrator ) :: rk_integrator !< Runge-Kutta integrator. integer , parameter :: rk_stages = 5 !< Runge-Kutta stages number. type ( oscillation ) :: rk_stage ( 1 : rk_stages ) !< Runge-Kutta stages. integer ( I_P ) :: s !< RK stages counter. integer ( I_P ) :: step !< Time steps counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Integrating Oscillation equations by means of TVD/SSP Runge-Kutta class of solvers' do s = 1 , rk_stages if ( s == 4 ) cycle ! 4 stages not yet implemented print \"(A)\" , ' RK-' // trim ( str (. true ., s )) call rk_integrator % init ( stages = s ) call attractor % init ( initial_state = initial_state , f = f ) solution ( 0 , 0 ) = 0._R_P solution ( 1 : space_dimension , 0 ) = attractor % output () do step = 1 , num_steps call rk_integrator % integrate ( field = attractor , stage = rk_stage ( 1 : s ), dt = dt , t = solution ( 0 , step )) solution ( 0 , step ) = step * dt solution ( 1 : space_dimension , step ) = attractor % output () enddo call save_results ( title = 'FOODiE test: Oscillation equation integration, explicit TVD Runge-Kutta ' // trim ( str (. true ., s )) // & ' stages' , filename = 'oscillation_integration-tvdrk-' // trim ( str (. true ., s ))) enddo print \"(A)\" , 'Finish!' return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine test_tvd_rk endprogram integrate_oscillation","tags":"","loc":"program/integrate_oscillation.html","title":"integrate_oscillation – FOODiE"}]}